\hypertarget{catch_8hpp_source}{}\doxysection{catch.\+hpp}

\begin{DoxyCode}{0}
\DoxyCodeLine{1 \textcolor{comment}{/*}}
\DoxyCodeLine{2 \textcolor{comment}{ *  Catch v2.13.10}}
\DoxyCodeLine{3 \textcolor{comment}{ *  Generated: 2022-\/10-\/16 11:01:23.452308}}
\DoxyCodeLine{4 \textcolor{comment}{ *  -\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/}}
\DoxyCodeLine{5 \textcolor{comment}{ *  This file has been merged from multiple headers. Please don't edit it directly}}
\DoxyCodeLine{6 \textcolor{comment}{ *  Copyright (c) 2022 Two Blue Cubes Ltd. All rights reserved.}}
\DoxyCodeLine{7 \textcolor{comment}{ *}}
\DoxyCodeLine{8 \textcolor{comment}{ *  Distributed under the Boost Software License, Version 1.0. (See accompanying}}
\DoxyCodeLine{9 \textcolor{comment}{ *  file LICENSE\_1\_0.txt or copy at http://www.boost.org/LICENSE\_1\_0.txt)}}
\DoxyCodeLine{10 \textcolor{comment}{ */}}
\DoxyCodeLine{11 \textcolor{preprocessor}{\#ifndef TWOBLUECUBES\_SINGLE\_INCLUDE\_CATCH\_HPP\_INCLUDED}}
\DoxyCodeLine{12 \textcolor{preprocessor}{\#define TWOBLUECUBES\_SINGLE\_INCLUDE\_CATCH\_HPP\_INCLUDED}}
\DoxyCodeLine{13 \textcolor{comment}{// start catch.hpp}}
\DoxyCodeLine{14 }
\DoxyCodeLine{15 }
\DoxyCodeLine{16 \textcolor{preprocessor}{\#define CATCH\_VERSION\_MAJOR 2}}
\DoxyCodeLine{17 \textcolor{preprocessor}{\#define CATCH\_VERSION\_MINOR 13}}
\DoxyCodeLine{18 \textcolor{preprocessor}{\#define CATCH\_VERSION\_PATCH 10}}
\DoxyCodeLine{19 }
\DoxyCodeLine{20 \textcolor{preprocessor}{\#ifdef \_\_clang\_\_}}
\DoxyCodeLine{21 \textcolor{preprocessor}{\#    pragma clang system\_header}}
\DoxyCodeLine{22 \textcolor{preprocessor}{\#elif defined \_\_GNUC\_\_}}
\DoxyCodeLine{23 \textcolor{preprocessor}{\#    pragma GCC system\_header}}
\DoxyCodeLine{24 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{25 }
\DoxyCodeLine{26 \textcolor{comment}{// start catch\_suppress\_warnings.h}}
\DoxyCodeLine{27 }
\DoxyCodeLine{28 \textcolor{preprocessor}{\#ifdef \_\_clang\_\_}}
\DoxyCodeLine{29 \textcolor{preprocessor}{\#   ifdef \_\_ICC }\textcolor{comment}{// icpc defines the \_\_clang\_\_ macro}}
\DoxyCodeLine{30 \textcolor{preprocessor}{\#       pragma warning(push)}}
\DoxyCodeLine{31 \textcolor{preprocessor}{\#       pragma warning(disable: 161 1682)}}
\DoxyCodeLine{32 \textcolor{preprocessor}{\#   else }\textcolor{comment}{// \_\_ICC}}
\DoxyCodeLine{33 \textcolor{preprocessor}{\#       pragma clang diagnostic push}}
\DoxyCodeLine{34 \textcolor{preprocessor}{\#       pragma clang diagnostic ignored "{}-\/Wpadded"{}}}
\DoxyCodeLine{35 \textcolor{preprocessor}{\#       pragma clang diagnostic ignored "{}-\/Wswitch-\/enum"{}}}
\DoxyCodeLine{36 \textcolor{preprocessor}{\#       pragma clang diagnostic ignored "{}-\/Wcovered-\/switch-\/default"{}}}
\DoxyCodeLine{37 \textcolor{preprocessor}{\#    endif}}
\DoxyCodeLine{38 \textcolor{preprocessor}{\#elif defined \_\_GNUC\_\_}}
\DoxyCodeLine{39      \textcolor{comment}{// Because REQUIREs trigger GCC's -\/Wparentheses, and because still}}
\DoxyCodeLine{40      \textcolor{comment}{// supported version of g++ have only buggy support for \_Pragmas,}}
\DoxyCodeLine{41      \textcolor{comment}{// Wparentheses have to be suppressed globally.}}
\DoxyCodeLine{42 \textcolor{preprocessor}{\#    pragma GCC diagnostic ignored "{}-\/Wparentheses"{}} \textcolor{comment}{// See \#674 for details}}
\DoxyCodeLine{43 }
\DoxyCodeLine{44 \textcolor{preprocessor}{\#    pragma GCC diagnostic push}}
\DoxyCodeLine{45 \textcolor{preprocessor}{\#    pragma GCC diagnostic ignored "{}-\/Wunused-\/variable"{}}}
\DoxyCodeLine{46 \textcolor{preprocessor}{\#    pragma GCC diagnostic ignored "{}-\/Wpadded"{}}}
\DoxyCodeLine{47 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{48 \textcolor{comment}{// end catch\_suppress\_warnings.h}}
\DoxyCodeLine{49 \textcolor{preprocessor}{\#if defined(CATCH\_CONFIG\_MAIN) || defined(CATCH\_CONFIG\_RUNNER)}}
\DoxyCodeLine{50 \textcolor{preprocessor}{\#  define CATCH\_IMPL}}
\DoxyCodeLine{51 \textcolor{preprocessor}{\#  define CATCH\_CONFIG\_ALL\_PARTS}}
\DoxyCodeLine{52 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{53 }
\DoxyCodeLine{54 \textcolor{comment}{// In the impl file, we want to have access to all parts of the headers}}
\DoxyCodeLine{55 \textcolor{comment}{// Can also be used to sanely support PCHs}}
\DoxyCodeLine{56 \textcolor{preprocessor}{\#if defined(CATCH\_CONFIG\_ALL\_PARTS)}}
\DoxyCodeLine{57 \textcolor{preprocessor}{\#  define CATCH\_CONFIG\_EXTERNAL\_INTERFACES}}
\DoxyCodeLine{58 \textcolor{preprocessor}{\#  if defined(CATCH\_CONFIG\_DISABLE\_MATCHERS)}}
\DoxyCodeLine{59 \textcolor{preprocessor}{\#    undef CATCH\_CONFIG\_DISABLE\_MATCHERS}}
\DoxyCodeLine{60 \textcolor{preprocessor}{\#  endif}}
\DoxyCodeLine{61 \textcolor{preprocessor}{\#  if !defined(CATCH\_CONFIG\_ENABLE\_CHRONO\_STRINGMAKER)}}
\DoxyCodeLine{62 \textcolor{preprocessor}{\#    define CATCH\_CONFIG\_ENABLE\_CHRONO\_STRINGMAKER}}
\DoxyCodeLine{63 \textcolor{preprocessor}{\#  endif}}
\DoxyCodeLine{64 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{65 }
\DoxyCodeLine{66 \textcolor{preprocessor}{\#if !defined(CATCH\_CONFIG\_IMPL\_ONLY)}}
\DoxyCodeLine{67 \textcolor{comment}{// start catch\_platform.h}}
\DoxyCodeLine{68 }
\DoxyCodeLine{69 \textcolor{comment}{// See e.g.:}}
\DoxyCodeLine{70 \textcolor{comment}{// https://opensource.apple.com/source/CarbonHeaders/CarbonHeaders-\/18.1/TargetConditionals.h.auto.html}}
\DoxyCodeLine{71 \textcolor{preprocessor}{\#ifdef \_\_APPLE\_\_}}
\DoxyCodeLine{72 \textcolor{preprocessor}{\#  include <TargetConditionals.h>}}
\DoxyCodeLine{73 \textcolor{preprocessor}{\#  if (defined(TARGET\_OS\_OSX) \&\& TARGET\_OS\_OSX == 1) || \(\backslash\)}}
\DoxyCodeLine{74 \textcolor{preprocessor}{      (defined(TARGET\_OS\_MAC) \&\& TARGET\_OS\_MAC == 1)}}
\DoxyCodeLine{75 \textcolor{preprocessor}{\#    define CATCH\_PLATFORM\_MAC}}
\DoxyCodeLine{76 \textcolor{preprocessor}{\#  elif (defined(TARGET\_OS\_IPHONE) \&\& TARGET\_OS\_IPHONE == 1)}}
\DoxyCodeLine{77 \textcolor{preprocessor}{\#    define CATCH\_PLATFORM\_IPHONE}}
\DoxyCodeLine{78 \textcolor{preprocessor}{\#  endif}}
\DoxyCodeLine{79 }
\DoxyCodeLine{80 \textcolor{preprocessor}{\#elif defined(linux) || defined(\_\_linux) || defined(\_\_linux\_\_)}}
\DoxyCodeLine{81 \textcolor{preprocessor}{\#  define CATCH\_PLATFORM\_LINUX}}
\DoxyCodeLine{82 }
\DoxyCodeLine{83 \textcolor{preprocessor}{\#elif defined(WIN32) || defined(\_\_WIN32\_\_) || defined(\_WIN32) || defined(\_MSC\_VER) || defined(\_\_MINGW32\_\_)}}
\DoxyCodeLine{84 \textcolor{preprocessor}{\#  define CATCH\_PLATFORM\_WINDOWS}}
\DoxyCodeLine{85 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{86 }
\DoxyCodeLine{87 \textcolor{comment}{// end catch\_platform.h}}
\DoxyCodeLine{88 }
\DoxyCodeLine{89 \textcolor{preprocessor}{\#ifdef CATCH\_IMPL}}
\DoxyCodeLine{90 \textcolor{preprocessor}{\#  ifndef CLARA\_CONFIG\_MAIN}}
\DoxyCodeLine{91 \textcolor{preprocessor}{\#    define CLARA\_CONFIG\_MAIN\_NOT\_DEFINED}}
\DoxyCodeLine{92 \textcolor{preprocessor}{\#    define CLARA\_CONFIG\_MAIN}}
\DoxyCodeLine{93 \textcolor{preprocessor}{\#  endif}}
\DoxyCodeLine{94 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{95 }
\DoxyCodeLine{96 \textcolor{comment}{// start catch\_user\_interfaces.h}}
\DoxyCodeLine{97 }
\DoxyCodeLine{98 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{99     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} rngSeed();}
\DoxyCodeLine{100 \}}
\DoxyCodeLine{101 }
\DoxyCodeLine{102 \textcolor{comment}{// end catch\_user\_interfaces.h}}
\DoxyCodeLine{103 \textcolor{comment}{// start catch\_tag\_alias\_autoregistrar.h}}
\DoxyCodeLine{104 }
\DoxyCodeLine{105 \textcolor{comment}{// start catch\_common.h}}
\DoxyCodeLine{106 }
\DoxyCodeLine{107 \textcolor{comment}{// start catch\_compiler\_capabilities.h}}
\DoxyCodeLine{108 }
\DoxyCodeLine{109 \textcolor{comment}{// Detect a number of compiler features -\/ by compiler}}
\DoxyCodeLine{110 \textcolor{comment}{// The following features are defined:}}
\DoxyCodeLine{111 \textcolor{comment}{//}}
\DoxyCodeLine{112 \textcolor{comment}{// CATCH\_CONFIG\_COUNTER : is the \_\_COUNTER\_\_ macro supported?}}
\DoxyCodeLine{113 \textcolor{comment}{// CATCH\_CONFIG\_WINDOWS\_SEH : is Windows SEH supported?}}
\DoxyCodeLine{114 \textcolor{comment}{// CATCH\_CONFIG\_POSIX\_SIGNALS : are POSIX signals supported?}}
\DoxyCodeLine{115 \textcolor{comment}{// CATCH\_CONFIG\_DISABLE\_EXCEPTIONS : Are exceptions enabled?}}
\DoxyCodeLine{116 \textcolor{comment}{// ****************}}
\DoxyCodeLine{117 \textcolor{comment}{// Note to maintainers: if new toggles are added please document them}}
\DoxyCodeLine{118 \textcolor{comment}{// in configuration.md, too}}
\DoxyCodeLine{119 \textcolor{comment}{// ****************}}
\DoxyCodeLine{120 }
\DoxyCodeLine{121 \textcolor{comment}{// In general each macro has a \_NO\_<feature name> form}}
\DoxyCodeLine{122 \textcolor{comment}{// (e.g. CATCH\_CONFIG\_NO\_POSIX\_SIGNALS) which disables the feature.}}
\DoxyCodeLine{123 \textcolor{comment}{// Many features, at point of detection, define an \_INTERNAL\_ macro, so they}}
\DoxyCodeLine{124 \textcolor{comment}{// can be combined, en-\/mass, with the \_NO\_ forms later.}}
\DoxyCodeLine{125 }
\DoxyCodeLine{126 \textcolor{preprocessor}{\#ifdef \_\_cplusplus}}
\DoxyCodeLine{127 }
\DoxyCodeLine{128 \textcolor{preprocessor}{\#  if (\_\_cplusplus >= 201402L) || (defined(\_MSVC\_LANG) \&\& \_MSVC\_LANG >= 201402L)}}
\DoxyCodeLine{129 \textcolor{preprocessor}{\#    define CATCH\_CPP14\_OR\_GREATER}}
\DoxyCodeLine{130 \textcolor{preprocessor}{\#  endif}}
\DoxyCodeLine{131 }
\DoxyCodeLine{132 \textcolor{preprocessor}{\#  if (\_\_cplusplus >= 201703L) || (defined(\_MSVC\_LANG) \&\& \_MSVC\_LANG >= 201703L)}}
\DoxyCodeLine{133 \textcolor{preprocessor}{\#    define CATCH\_CPP17\_OR\_GREATER}}
\DoxyCodeLine{134 \textcolor{preprocessor}{\#  endif}}
\DoxyCodeLine{135 }
\DoxyCodeLine{136 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{137 }
\DoxyCodeLine{138 \textcolor{comment}{// Only GCC compiler should be used in this block, so other compilers trying to}}
\DoxyCodeLine{139 \textcolor{comment}{// mask themselves as GCC should be ignored.}}
\DoxyCodeLine{140 \textcolor{preprocessor}{\#if defined(\_\_GNUC\_\_) \&\& !defined(\_\_clang\_\_) \&\& !defined(\_\_ICC) \&\& !defined(\_\_CUDACC\_\_) \&\& !defined(\_\_LCC\_\_)}}
\DoxyCodeLine{141 \textcolor{preprocessor}{\#    define CATCH\_INTERNAL\_START\_WARNINGS\_SUPPRESSION \_Pragma( "{}GCC diagnostic push"{}} )}
\DoxyCodeLine{142 \textcolor{preprocessor}{\#    define CATCH\_INTERNAL\_STOP\_WARNINGS\_SUPPRESSION  \_Pragma( "{}GCC diagnostic pop"{}} )}
\DoxyCodeLine{143 }
\DoxyCodeLine{144 \textcolor{preprocessor}{\#    define CATCH\_INTERNAL\_IGNORE\_BUT\_WARN(...) (void)\_\_builtin\_constant\_p(\_\_VA\_ARGS\_\_)}}
\DoxyCodeLine{145 }
\DoxyCodeLine{146 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{147 }
\DoxyCodeLine{148 \textcolor{preprocessor}{\#if defined(\_\_clang\_\_)}}
\DoxyCodeLine{149 }
\DoxyCodeLine{150 \textcolor{preprocessor}{\#    define CATCH\_INTERNAL\_START\_WARNINGS\_SUPPRESSION \_Pragma( "{}clang diagnostic push"{}} )}
\DoxyCodeLine{151 \textcolor{preprocessor}{\#    define CATCH\_INTERNAL\_STOP\_WARNINGS\_SUPPRESSION  \_Pragma( "{}clang diagnostic pop"{}} )}
\DoxyCodeLine{152 }
\DoxyCodeLine{153 \textcolor{comment}{// As of this writing, IBM XL's implementation of \_\_builtin\_constant\_p has a bug}}
\DoxyCodeLine{154 \textcolor{comment}{// which results in calls to destructors being emitted for each temporary,}}
\DoxyCodeLine{155 \textcolor{comment}{// without a matching initialization. In practice, this can result in something}}
\DoxyCodeLine{156 \textcolor{comment}{// like `std::string::\string~string` being called on an uninitialized value.}}
\DoxyCodeLine{157 \textcolor{comment}{//}}
\DoxyCodeLine{158 \textcolor{comment}{// For example, this code will likely segfault under IBM XL:}}
\DoxyCodeLine{159 \textcolor{comment}{// ```}}
\DoxyCodeLine{160 \textcolor{comment}{// REQUIRE(std::string("{}12"{}) + "{}34"{} == "{}1234"{})}}
\DoxyCodeLine{161 \textcolor{comment}{// ```}}
\DoxyCodeLine{162 \textcolor{comment}{//}}
\DoxyCodeLine{163 \textcolor{comment}{// Therefore, `CATCH\_INTERNAL\_IGNORE\_BUT\_WARN` is not implemented.}}
\DoxyCodeLine{164 \textcolor{preprocessor}{\#  if !defined(\_\_ibmxl\_\_) \&\& !defined(\_\_CUDACC\_\_)}}
\DoxyCodeLine{165 \textcolor{preprocessor}{\#    define CATCH\_INTERNAL\_IGNORE\_BUT\_WARN(...) (void)\_\_builtin\_constant\_p(\_\_VA\_ARGS\_\_) }\textcolor{comment}{/* NOLINT(cppcoreguidelines-\/pro-\/type-\/vararg, hicpp-\/vararg) */}\textcolor{preprocessor}{}}
\DoxyCodeLine{166 \textcolor{preprocessor}{\#  endif}}
\DoxyCodeLine{167 }
\DoxyCodeLine{168 \textcolor{preprocessor}{\#    define CATCH\_INTERNAL\_SUPPRESS\_GLOBALS\_WARNINGS \(\backslash\)}}
\DoxyCodeLine{169 \textcolor{preprocessor}{         \_Pragma( "{}clang diagnostic ignored \(\backslash\)"{}-\/Wexit-\/time-\/destructors\(\backslash\)"{}"{}} ) \(\backslash\)}
\DoxyCodeLine{170          \_Pragma( "{}clang diagnostic ignored \(\backslash\)"{}-\/Wglobal-\/constructors\(\backslash\)"{}"{})}
\DoxyCodeLine{171 }
\DoxyCodeLine{172 \textcolor{preprocessor}{\#    define CATCH\_INTERNAL\_SUPPRESS\_PARENTHESES\_WARNINGS \(\backslash\)}}
\DoxyCodeLine{173 \textcolor{preprocessor}{         \_Pragma( "{}clang diagnostic ignored \(\backslash\)"{}-\/Wparentheses\(\backslash\)"{}"{}} )}
\DoxyCodeLine{174 }
\DoxyCodeLine{175 \textcolor{preprocessor}{\#    define CATCH\_INTERNAL\_SUPPRESS\_UNUSED\_WARNINGS \(\backslash\)}}
\DoxyCodeLine{176 \textcolor{preprocessor}{         \_Pragma( "{}clang diagnostic ignored \(\backslash\)"{}-\/Wunused-\/variable\(\backslash\)"{}"{}} )}
\DoxyCodeLine{177 }
\DoxyCodeLine{178 \textcolor{preprocessor}{\#    define CATCH\_INTERNAL\_SUPPRESS\_ZERO\_VARIADIC\_WARNINGS \(\backslash\)}}
\DoxyCodeLine{179 \textcolor{preprocessor}{         \_Pragma( "{}clang diagnostic ignored \(\backslash\)"{}-\/Wgnu-\/zero-\/variadic-\/macro-\/arguments\(\backslash\)"{}"{}} )}
\DoxyCodeLine{180 }
\DoxyCodeLine{181 \textcolor{preprocessor}{\#    define CATCH\_INTERNAL\_SUPPRESS\_UNUSED\_TEMPLATE\_WARNINGS \(\backslash\)}}
\DoxyCodeLine{182 \textcolor{preprocessor}{         \_Pragma( "{}clang diagnostic ignored \(\backslash\)"{}-\/Wunused-\/template\(\backslash\)"{}"{}} )}
\DoxyCodeLine{183 }
\DoxyCodeLine{184 \textcolor{preprocessor}{\#endif }\textcolor{comment}{// \_\_clang\_\_}}
\DoxyCodeLine{185 }
\DoxyCodeLine{187 \textcolor{comment}{// Assume that non-\/Windows platforms support posix signals by default}}
\DoxyCodeLine{188 \textcolor{preprocessor}{\#if !defined(CATCH\_PLATFORM\_WINDOWS)}}
\DoxyCodeLine{189 \textcolor{preprocessor}{    \#define CATCH\_INTERNAL\_CONFIG\_POSIX\_SIGNALS}}
\DoxyCodeLine{190 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{191 }
\DoxyCodeLine{193 \textcolor{comment}{// We know some environments not to support full POSIX signals}}
\DoxyCodeLine{194 \textcolor{preprocessor}{\#if defined(\_\_CYGWIN\_\_) || defined(\_\_QNX\_\_) || defined(\_\_EMSCRIPTEN\_\_) || defined(\_\_DJGPP\_\_)}}
\DoxyCodeLine{195 \textcolor{preprocessor}{    \#define CATCH\_INTERNAL\_CONFIG\_NO\_POSIX\_SIGNALS}}
\DoxyCodeLine{196 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{197 }
\DoxyCodeLine{198 \textcolor{preprocessor}{\#ifdef \_\_OS400\_\_}}
\DoxyCodeLine{199 \textcolor{preprocessor}{\#       define CATCH\_INTERNAL\_CONFIG\_NO\_POSIX\_SIGNALS}}
\DoxyCodeLine{200 \textcolor{preprocessor}{\#       define CATCH\_CONFIG\_COLOUR\_NONE}}
\DoxyCodeLine{201 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{202 }
\DoxyCodeLine{204 \textcolor{comment}{// Android somehow still does not support std::to\_string}}
\DoxyCodeLine{205 \textcolor{preprocessor}{\#if defined(\_\_ANDROID\_\_)}}
\DoxyCodeLine{206 \textcolor{preprocessor}{\#    define CATCH\_INTERNAL\_CONFIG\_NO\_CPP11\_TO\_STRING}}
\DoxyCodeLine{207 \textcolor{preprocessor}{\#    define CATCH\_INTERNAL\_CONFIG\_ANDROID\_LOGWRITE}}
\DoxyCodeLine{208 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{209 }
\DoxyCodeLine{211 \textcolor{comment}{// Not all Windows environments support SEH properly}}
\DoxyCodeLine{212 \textcolor{preprocessor}{\#if defined(\_\_MINGW32\_\_)}}
\DoxyCodeLine{213 \textcolor{preprocessor}{\#    define CATCH\_INTERNAL\_CONFIG\_NO\_WINDOWS\_SEH}}
\DoxyCodeLine{214 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{215 }
\DoxyCodeLine{217 \textcolor{comment}{// PS4}}
\DoxyCodeLine{218 \textcolor{preprocessor}{\#if defined(\_\_ORBIS\_\_)}}
\DoxyCodeLine{219 \textcolor{preprocessor}{\#    define CATCH\_INTERNAL\_CONFIG\_NO\_NEW\_CAPTURE}}
\DoxyCodeLine{220 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{221 }
\DoxyCodeLine{223 \textcolor{comment}{// Cygwin}}
\DoxyCodeLine{224 \textcolor{preprocessor}{\#ifdef \_\_CYGWIN\_\_}}
\DoxyCodeLine{225 }
\DoxyCodeLine{226 \textcolor{comment}{// Required for some versions of Cygwin to declare gettimeofday}}
\DoxyCodeLine{227 \textcolor{comment}{// see: http://stackoverflow.com/questions/36901803/gettimeofday-\/not-\/declared-\/in-\/this-\/scope-\/cygwin}}
\DoxyCodeLine{228 \textcolor{preprocessor}{\#   define \_BSD\_SOURCE}}
\DoxyCodeLine{229 \textcolor{comment}{// some versions of cygwin (most) do not support std::to\_string. Use the libstd check.}}
\DoxyCodeLine{230 \textcolor{comment}{// https://gcc.gnu.org/onlinedocs/gcc-\/4.8.2/libstdc++/api/a01053\_source.html line 2812-\/2813}}
\DoxyCodeLine{231 \textcolor{preprocessor}{\# if !((\_\_cplusplus >= 201103L) \&\& defined(\_GLIBCXX\_USE\_C99) \(\backslash\)}}
\DoxyCodeLine{232 \textcolor{preprocessor}{           \&\& !defined(\_GLIBCXX\_HAVE\_BROKEN\_VSWPRINTF))}}
\DoxyCodeLine{233 }
\DoxyCodeLine{234 \textcolor{preprocessor}{\#    define CATCH\_INTERNAL\_CONFIG\_NO\_CPP11\_TO\_STRING}}
\DoxyCodeLine{235 }
\DoxyCodeLine{236 \textcolor{preprocessor}{\# endif}}
\DoxyCodeLine{237 \textcolor{preprocessor}{\#endif }\textcolor{comment}{// \_\_CYGWIN\_\_}}
\DoxyCodeLine{238 }
\DoxyCodeLine{240 \textcolor{comment}{// Visual C++}}
\DoxyCodeLine{241 \textcolor{preprocessor}{\#if defined(\_MSC\_VER)}}
\DoxyCodeLine{242 }
\DoxyCodeLine{243 \textcolor{comment}{// Universal Windows platform does not support SEH}}
\DoxyCodeLine{244 \textcolor{comment}{// Or console colours (or console at all...)}}
\DoxyCodeLine{245 \textcolor{preprocessor}{\#  if defined(WINAPI\_FAMILY) \&\& (WINAPI\_FAMILY == WINAPI\_FAMILY\_APP)}}
\DoxyCodeLine{246 \textcolor{preprocessor}{\#    define CATCH\_CONFIG\_COLOUR\_NONE}}
\DoxyCodeLine{247 \textcolor{preprocessor}{\#  else}}
\DoxyCodeLine{248 \textcolor{preprocessor}{\#    define CATCH\_INTERNAL\_CONFIG\_WINDOWS\_SEH}}
\DoxyCodeLine{249 \textcolor{preprocessor}{\#  endif}}
\DoxyCodeLine{250 }
\DoxyCodeLine{251 \textcolor{preprocessor}{\#  if !defined(\_\_clang\_\_) }\textcolor{comment}{// Handle Clang masquerading for msvc}}
\DoxyCodeLine{252 }
\DoxyCodeLine{253 \textcolor{comment}{// MSVC traditional preprocessor needs some workaround for \_\_VA\_ARGS\_\_}}
\DoxyCodeLine{254 \textcolor{comment}{// \_MSVC\_TRADITIONAL == 0 means new conformant preprocessor}}
\DoxyCodeLine{255 \textcolor{comment}{// \_MSVC\_TRADITIONAL == 1 means old traditional non-\/conformant preprocessor}}
\DoxyCodeLine{256 \textcolor{preprocessor}{\#    if !defined(\_MSVC\_TRADITIONAL) || (defined(\_MSVC\_TRADITIONAL) \&\& \_MSVC\_TRADITIONAL)}}
\DoxyCodeLine{257 \textcolor{preprocessor}{\#      define CATCH\_INTERNAL\_CONFIG\_TRADITIONAL\_MSVC\_PREPROCESSOR}}
\DoxyCodeLine{258 \textcolor{preprocessor}{\#    endif }\textcolor{comment}{// MSVC\_TRADITIONAL}}
\DoxyCodeLine{259 }
\DoxyCodeLine{260 \textcolor{comment}{// Only do this if we're not using clang on Windows, which uses `diagnostic push` \& `diagnostic pop`}}
\DoxyCodeLine{261 \textcolor{preprocessor}{\#    define CATCH\_INTERNAL\_START\_WARNINGS\_SUPPRESSION \_\_pragma( warning(push) )}}
\DoxyCodeLine{262 \textcolor{preprocessor}{\#    define CATCH\_INTERNAL\_STOP\_WARNINGS\_SUPPRESSION  \_\_pragma( warning(pop) )}}
\DoxyCodeLine{263 \textcolor{preprocessor}{\#  endif }\textcolor{comment}{// \_\_clang\_\_}}
\DoxyCodeLine{264 }
\DoxyCodeLine{265 \textcolor{preprocessor}{\#endif }\textcolor{comment}{// \_MSC\_VER}}
\DoxyCodeLine{266 }
\DoxyCodeLine{267 \textcolor{preprocessor}{\#if defined(\_REENTRANT) || defined(\_MSC\_VER)}}
\DoxyCodeLine{268 \textcolor{comment}{// Enable async processing, as -\/pthread is specified or no additional linking is required}}
\DoxyCodeLine{269 \textcolor{preprocessor}{\# define CATCH\_INTERNAL\_CONFIG\_USE\_ASYNC}}
\DoxyCodeLine{270 \textcolor{preprocessor}{\#endif }\textcolor{comment}{// \_MSC\_VER}}
\DoxyCodeLine{271 }
\DoxyCodeLine{273 \textcolor{comment}{// Check if we are compiled with -\/fno-\/exceptions or equivalent}}
\DoxyCodeLine{274 \textcolor{preprocessor}{\#if defined(\_\_EXCEPTIONS) || defined(\_\_cpp\_exceptions) || defined(\_CPPUNWIND)}}
\DoxyCodeLine{275 \textcolor{preprocessor}{\#  define CATCH\_INTERNAL\_CONFIG\_EXCEPTIONS\_ENABLED}}
\DoxyCodeLine{276 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{277 }
\DoxyCodeLine{279 \textcolor{comment}{// DJGPP}}
\DoxyCodeLine{280 \textcolor{preprocessor}{\#ifdef \_\_DJGPP\_\_}}
\DoxyCodeLine{281 \textcolor{preprocessor}{\#  define CATCH\_INTERNAL\_CONFIG\_NO\_WCHAR}}
\DoxyCodeLine{282 \textcolor{preprocessor}{\#endif }\textcolor{comment}{// \_\_DJGPP\_\_}}
\DoxyCodeLine{283 }
\DoxyCodeLine{285 \textcolor{comment}{// Embarcadero C++Build}}
\DoxyCodeLine{286 \textcolor{preprocessor}{\#if defined(\_\_BORLANDC\_\_)}}
\DoxyCodeLine{287 \textcolor{preprocessor}{    \#define CATCH\_INTERNAL\_CONFIG\_POLYFILL\_ISNAN}}
\DoxyCodeLine{288 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{289 }
\DoxyCodeLine{291 }
\DoxyCodeLine{292 \textcolor{comment}{// Use of \_\_COUNTER\_\_ is suppressed during code analysis in}}
\DoxyCodeLine{293 \textcolor{comment}{// CLion/AppCode 2017.2.x and former, because \_\_COUNTER\_\_ is not properly}}
\DoxyCodeLine{294 \textcolor{comment}{// handled by it.}}
\DoxyCodeLine{295 \textcolor{comment}{// Otherwise all supported compilers support COUNTER macro,}}
\DoxyCodeLine{296 \textcolor{comment}{// but user still might want to turn it off}}
\DoxyCodeLine{297 \textcolor{preprocessor}{\#if ( !defined(\_\_JETBRAINS\_IDE\_\_) || \_\_JETBRAINS\_IDE\_\_ >= 20170300L )}}
\DoxyCodeLine{298 \textcolor{preprocessor}{    \#define CATCH\_INTERNAL\_CONFIG\_COUNTER}}
\DoxyCodeLine{299 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{300 }
\DoxyCodeLine{302 }
\DoxyCodeLine{303 \textcolor{comment}{// RTX is a special version of Windows that is real time.}}
\DoxyCodeLine{304 \textcolor{comment}{// This means that it is detected as Windows, but does not provide}}
\DoxyCodeLine{305 \textcolor{comment}{// the same set of capabilities as real Windows does.}}
\DoxyCodeLine{306 \textcolor{preprocessor}{\#if defined(UNDER\_RTSS) || defined(RTX64\_BUILD)}}
\DoxyCodeLine{307 \textcolor{preprocessor}{    \#define CATCH\_INTERNAL\_CONFIG\_NO\_WINDOWS\_SEH}}
\DoxyCodeLine{308 \textcolor{preprocessor}{    \#define CATCH\_INTERNAL\_CONFIG\_NO\_ASYNC}}
\DoxyCodeLine{309 \textcolor{preprocessor}{    \#define CATCH\_CONFIG\_COLOUR\_NONE}}
\DoxyCodeLine{310 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{311 }
\DoxyCodeLine{312 \textcolor{preprocessor}{\#if !defined(\_GLIBCXX\_USE\_C99\_MATH\_TR1)}}
\DoxyCodeLine{313 \textcolor{preprocessor}{\#define CATCH\_INTERNAL\_CONFIG\_GLOBAL\_NEXTAFTER}}
\DoxyCodeLine{314 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{315 }
\DoxyCodeLine{316 \textcolor{comment}{// Various stdlib support checks that require \_\_has\_include}}
\DoxyCodeLine{317 \textcolor{preprocessor}{\#if defined(\_\_has\_include)}}
\DoxyCodeLine{318   \textcolor{comment}{// Check if string\_view is available and usable}}
\DoxyCodeLine{319 \textcolor{preprocessor}{  \#if \_\_has\_include(<string\_view>) \&\& defined(CATCH\_CPP17\_OR\_GREATER)}}
\DoxyCodeLine{320 \textcolor{preprocessor}{  \#    define CATCH\_INTERNAL\_CONFIG\_CPP17\_STRING\_VIEW}}
\DoxyCodeLine{321 \textcolor{preprocessor}{  \#endif}}
\DoxyCodeLine{322 }
\DoxyCodeLine{323   \textcolor{comment}{// Check if optional is available and usable}}
\DoxyCodeLine{324 \textcolor{preprocessor}{  \#  if \_\_has\_include(<optional>) \&\& defined(CATCH\_CPP17\_OR\_GREATER)}}
\DoxyCodeLine{325 \textcolor{preprocessor}{  \#    define CATCH\_INTERNAL\_CONFIG\_CPP17\_OPTIONAL}}
\DoxyCodeLine{326 \textcolor{preprocessor}{  \#  endif }\textcolor{comment}{// \_\_has\_include(<optional>) \&\& defined(CATCH\_CPP17\_OR\_GREATER)}}
\DoxyCodeLine{327 }
\DoxyCodeLine{328   \textcolor{comment}{// Check if byte is available and usable}}
\DoxyCodeLine{329 \textcolor{preprocessor}{  \#  if \_\_has\_include(<cstddef>) \&\& defined(CATCH\_CPP17\_OR\_GREATER)}}
\DoxyCodeLine{330 \textcolor{preprocessor}{  \#    include <cstddef>}}
\DoxyCodeLine{331 \textcolor{preprocessor}{  \#    if defined(\_\_cpp\_lib\_byte) \&\& (\_\_cpp\_lib\_byte > 0)}}
\DoxyCodeLine{332 \textcolor{preprocessor}{  \#      define CATCH\_INTERNAL\_CONFIG\_CPP17\_BYTE}}
\DoxyCodeLine{333 \textcolor{preprocessor}{  \#    endif}}
\DoxyCodeLine{334 \textcolor{preprocessor}{  \#  endif }\textcolor{comment}{// \_\_has\_include(<cstddef>) \&\& defined(CATCH\_CPP17\_OR\_GREATER)}}
\DoxyCodeLine{335 }
\DoxyCodeLine{336   \textcolor{comment}{// Check if variant is available and usable}}
\DoxyCodeLine{337 \textcolor{preprocessor}{  \#  if \_\_has\_include(<variant>) \&\& defined(CATCH\_CPP17\_OR\_GREATER)}}
\DoxyCodeLine{338 \textcolor{preprocessor}{  \#    if defined(\_\_clang\_\_) \&\& (\_\_clang\_major\_\_ < 8)}}
\DoxyCodeLine{339          \textcolor{comment}{// work around clang bug with libstdc++ https://bugs.llvm.org/show\_bug.cgi?id=31852}}
\DoxyCodeLine{340          \textcolor{comment}{// fix should be in clang 8, workaround in libstdc++ 8.2}}
\DoxyCodeLine{341 \textcolor{preprocessor}{  \#      include <ciso646>}}
\DoxyCodeLine{342 \textcolor{preprocessor}{  \#      if defined(\_\_GLIBCXX\_\_) \&\& defined(\_GLIBCXX\_RELEASE) \&\& (\_GLIBCXX\_RELEASE < 9)}}
\DoxyCodeLine{343 \textcolor{preprocessor}{  \#        define CATCH\_CONFIG\_NO\_CPP17\_VARIANT}}
\DoxyCodeLine{344 \textcolor{preprocessor}{  \#      else}}
\DoxyCodeLine{345 \textcolor{preprocessor}{  \#        define CATCH\_INTERNAL\_CONFIG\_CPP17\_VARIANT}}
\DoxyCodeLine{346 \textcolor{preprocessor}{  \#      endif }\textcolor{comment}{// defined(\_\_GLIBCXX\_\_) \&\& defined(\_GLIBCXX\_RELEASE) \&\& (\_GLIBCXX\_RELEASE < 9)}}
\DoxyCodeLine{347 \textcolor{preprocessor}{  \#    else}}
\DoxyCodeLine{348 \textcolor{preprocessor}{  \#      define CATCH\_INTERNAL\_CONFIG\_CPP17\_VARIANT}}
\DoxyCodeLine{349 \textcolor{preprocessor}{  \#    endif }\textcolor{comment}{// defined(\_\_clang\_\_) \&\& (\_\_clang\_major\_\_ < 8)}}
\DoxyCodeLine{350 \textcolor{preprocessor}{  \#  endif }\textcolor{comment}{// \_\_has\_include(<variant>) \&\& defined(CATCH\_CPP17\_OR\_GREATER)}}
\DoxyCodeLine{351 \textcolor{preprocessor}{\#endif }\textcolor{comment}{// defined(\_\_has\_include)}}
\DoxyCodeLine{352 }
\DoxyCodeLine{353 \textcolor{preprocessor}{\#if defined(CATCH\_INTERNAL\_CONFIG\_COUNTER) \&\& !defined(CATCH\_CONFIG\_NO\_COUNTER) \&\& !defined(CATCH\_CONFIG\_COUNTER)}}
\DoxyCodeLine{354 \textcolor{preprocessor}{\#   define CATCH\_CONFIG\_COUNTER}}
\DoxyCodeLine{355 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{356 \textcolor{preprocessor}{\#if defined(CATCH\_INTERNAL\_CONFIG\_WINDOWS\_SEH) \&\& !defined(CATCH\_CONFIG\_NO\_WINDOWS\_SEH) \&\& !defined(CATCH\_CONFIG\_WINDOWS\_SEH) \&\& !defined(CATCH\_INTERNAL\_CONFIG\_NO\_WINDOWS\_SEH)}}
\DoxyCodeLine{357 \textcolor{preprocessor}{\#   define CATCH\_CONFIG\_WINDOWS\_SEH}}
\DoxyCodeLine{358 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{359 \textcolor{comment}{// This is set by default, because we assume that unix compilers are posix-\/signal-\/compatible by default.}}
\DoxyCodeLine{360 \textcolor{preprocessor}{\#if defined(CATCH\_INTERNAL\_CONFIG\_POSIX\_SIGNALS) \&\& !defined(CATCH\_INTERNAL\_CONFIG\_NO\_POSIX\_SIGNALS) \&\& !defined(CATCH\_CONFIG\_NO\_POSIX\_SIGNALS) \&\& !defined(CATCH\_CONFIG\_POSIX\_SIGNALS)}}
\DoxyCodeLine{361 \textcolor{preprocessor}{\#   define CATCH\_CONFIG\_POSIX\_SIGNALS}}
\DoxyCodeLine{362 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{363 \textcolor{comment}{// This is set by default, because we assume that compilers with no wchar\_t support are just rare exceptions.}}
\DoxyCodeLine{364 \textcolor{preprocessor}{\#if !defined(CATCH\_INTERNAL\_CONFIG\_NO\_WCHAR) \&\& !defined(CATCH\_CONFIG\_NO\_WCHAR) \&\& !defined(CATCH\_CONFIG\_WCHAR)}}
\DoxyCodeLine{365 \textcolor{preprocessor}{\#   define CATCH\_CONFIG\_WCHAR}}
\DoxyCodeLine{366 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{367 }
\DoxyCodeLine{368 \textcolor{preprocessor}{\#if !defined(CATCH\_INTERNAL\_CONFIG\_NO\_CPP11\_TO\_STRING) \&\& !defined(CATCH\_CONFIG\_NO\_CPP11\_TO\_STRING) \&\& !defined(CATCH\_CONFIG\_CPP11\_TO\_STRING)}}
\DoxyCodeLine{369 \textcolor{preprocessor}{\#    define CATCH\_CONFIG\_CPP11\_TO\_STRING}}
\DoxyCodeLine{370 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{371 }
\DoxyCodeLine{372 \textcolor{preprocessor}{\#if defined(CATCH\_INTERNAL\_CONFIG\_CPP17\_OPTIONAL) \&\& !defined(CATCH\_CONFIG\_NO\_CPP17\_OPTIONAL) \&\& !defined(CATCH\_CONFIG\_CPP17\_OPTIONAL)}}
\DoxyCodeLine{373 \textcolor{preprocessor}{\#  define CATCH\_CONFIG\_CPP17\_OPTIONAL}}
\DoxyCodeLine{374 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{375 }
\DoxyCodeLine{376 \textcolor{preprocessor}{\#if defined(CATCH\_INTERNAL\_CONFIG\_CPP17\_STRING\_VIEW) \&\& !defined(CATCH\_CONFIG\_NO\_CPP17\_STRING\_VIEW) \&\& !defined(CATCH\_CONFIG\_CPP17\_STRING\_VIEW)}}
\DoxyCodeLine{377 \textcolor{preprocessor}{\#  define CATCH\_CONFIG\_CPP17\_STRING\_VIEW}}
\DoxyCodeLine{378 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{379 }
\DoxyCodeLine{380 \textcolor{preprocessor}{\#if defined(CATCH\_INTERNAL\_CONFIG\_CPP17\_VARIANT) \&\& !defined(CATCH\_CONFIG\_NO\_CPP17\_VARIANT) \&\& !defined(CATCH\_CONFIG\_CPP17\_VARIANT)}}
\DoxyCodeLine{381 \textcolor{preprocessor}{\#  define CATCH\_CONFIG\_CPP17\_VARIANT}}
\DoxyCodeLine{382 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{383 }
\DoxyCodeLine{384 \textcolor{preprocessor}{\#if defined(CATCH\_INTERNAL\_CONFIG\_CPP17\_BYTE) \&\& !defined(CATCH\_CONFIG\_NO\_CPP17\_BYTE) \&\& !defined(CATCH\_CONFIG\_CPP17\_BYTE)}}
\DoxyCodeLine{385 \textcolor{preprocessor}{\#  define CATCH\_CONFIG\_CPP17\_BYTE}}
\DoxyCodeLine{386 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{387 }
\DoxyCodeLine{388 \textcolor{preprocessor}{\#if defined(CATCH\_CONFIG\_EXPERIMENTAL\_REDIRECT)}}
\DoxyCodeLine{389 \textcolor{preprocessor}{\#  define CATCH\_INTERNAL\_CONFIG\_NEW\_CAPTURE}}
\DoxyCodeLine{390 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{391 }
\DoxyCodeLine{392 \textcolor{preprocessor}{\#if defined(CATCH\_INTERNAL\_CONFIG\_NEW\_CAPTURE) \&\& !defined(CATCH\_INTERNAL\_CONFIG\_NO\_NEW\_CAPTURE) \&\& !defined(CATCH\_CONFIG\_NO\_NEW\_CAPTURE) \&\& !defined(CATCH\_CONFIG\_NEW\_CAPTURE)}}
\DoxyCodeLine{393 \textcolor{preprocessor}{\#  define CATCH\_CONFIG\_NEW\_CAPTURE}}
\DoxyCodeLine{394 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{395 }
\DoxyCodeLine{396 \textcolor{preprocessor}{\#if !defined(CATCH\_INTERNAL\_CONFIG\_EXCEPTIONS\_ENABLED) \&\& !defined(CATCH\_CONFIG\_DISABLE\_EXCEPTIONS)}}
\DoxyCodeLine{397 \textcolor{preprocessor}{\#  define CATCH\_CONFIG\_DISABLE\_EXCEPTIONS}}
\DoxyCodeLine{398 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{399 }
\DoxyCodeLine{400 \textcolor{preprocessor}{\#if defined(CATCH\_INTERNAL\_CONFIG\_POLYFILL\_ISNAN) \&\& !defined(CATCH\_CONFIG\_NO\_POLYFILL\_ISNAN) \&\& !defined(CATCH\_CONFIG\_POLYFILL\_ISNAN)}}
\DoxyCodeLine{401 \textcolor{preprocessor}{\#  define CATCH\_CONFIG\_POLYFILL\_ISNAN}}
\DoxyCodeLine{402 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{403 }
\DoxyCodeLine{404 \textcolor{preprocessor}{\#if defined(CATCH\_INTERNAL\_CONFIG\_USE\_ASYNC)  \&\& !defined(CATCH\_INTERNAL\_CONFIG\_NO\_ASYNC) \&\& !defined(CATCH\_CONFIG\_NO\_USE\_ASYNC) \&\& !defined(CATCH\_CONFIG\_USE\_ASYNC)}}
\DoxyCodeLine{405 \textcolor{preprocessor}{\#  define CATCH\_CONFIG\_USE\_ASYNC}}
\DoxyCodeLine{406 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{407 }
\DoxyCodeLine{408 \textcolor{preprocessor}{\#if defined(CATCH\_INTERNAL\_CONFIG\_ANDROID\_LOGWRITE) \&\& !defined(CATCH\_CONFIG\_NO\_ANDROID\_LOGWRITE) \&\& !defined(CATCH\_CONFIG\_ANDROID\_LOGWRITE)}}
\DoxyCodeLine{409 \textcolor{preprocessor}{\#  define CATCH\_CONFIG\_ANDROID\_LOGWRITE}}
\DoxyCodeLine{410 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{411 }
\DoxyCodeLine{412 \textcolor{preprocessor}{\#if defined(CATCH\_INTERNAL\_CONFIG\_GLOBAL\_NEXTAFTER) \&\& !defined(CATCH\_CONFIG\_NO\_GLOBAL\_NEXTAFTER) \&\& !defined(CATCH\_CONFIG\_GLOBAL\_NEXTAFTER)}}
\DoxyCodeLine{413 \textcolor{preprocessor}{\#  define CATCH\_CONFIG\_GLOBAL\_NEXTAFTER}}
\DoxyCodeLine{414 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{415 }
\DoxyCodeLine{416 \textcolor{comment}{// Even if we do not think the compiler has that warning, we still have}}
\DoxyCodeLine{417 \textcolor{comment}{// to provide a macro that can be used by the code.}}
\DoxyCodeLine{418 \textcolor{preprocessor}{\#if !defined(CATCH\_INTERNAL\_START\_WARNINGS\_SUPPRESSION)}}
\DoxyCodeLine{419 \textcolor{preprocessor}{\#   define CATCH\_INTERNAL\_START\_WARNINGS\_SUPPRESSION}}
\DoxyCodeLine{420 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{421 \textcolor{preprocessor}{\#if !defined(CATCH\_INTERNAL\_STOP\_WARNINGS\_SUPPRESSION)}}
\DoxyCodeLine{422 \textcolor{preprocessor}{\#   define CATCH\_INTERNAL\_STOP\_WARNINGS\_SUPPRESSION}}
\DoxyCodeLine{423 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{424 \textcolor{preprocessor}{\#if !defined(CATCH\_INTERNAL\_SUPPRESS\_PARENTHESES\_WARNINGS)}}
\DoxyCodeLine{425 \textcolor{preprocessor}{\#   define CATCH\_INTERNAL\_SUPPRESS\_PARENTHESES\_WARNINGS}}
\DoxyCodeLine{426 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{427 \textcolor{preprocessor}{\#if !defined(CATCH\_INTERNAL\_SUPPRESS\_GLOBALS\_WARNINGS)}}
\DoxyCodeLine{428 \textcolor{preprocessor}{\#   define CATCH\_INTERNAL\_SUPPRESS\_GLOBALS\_WARNINGS}}
\DoxyCodeLine{429 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{430 \textcolor{preprocessor}{\#if !defined(CATCH\_INTERNAL\_SUPPRESS\_UNUSED\_WARNINGS)}}
\DoxyCodeLine{431 \textcolor{preprocessor}{\#   define CATCH\_INTERNAL\_SUPPRESS\_UNUSED\_WARNINGS}}
\DoxyCodeLine{432 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{433 \textcolor{preprocessor}{\#if !defined(CATCH\_INTERNAL\_SUPPRESS\_ZERO\_VARIADIC\_WARNINGS)}}
\DoxyCodeLine{434 \textcolor{preprocessor}{\#   define CATCH\_INTERNAL\_SUPPRESS\_ZERO\_VARIADIC\_WARNINGS}}
\DoxyCodeLine{435 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{436 }
\DoxyCodeLine{437 \textcolor{comment}{// The goal of this macro is to avoid evaluation of the arguments, but}}
\DoxyCodeLine{438 \textcolor{comment}{// still have the compiler warn on problems inside...}}
\DoxyCodeLine{439 \textcolor{preprocessor}{\#if !defined(CATCH\_INTERNAL\_IGNORE\_BUT\_WARN)}}
\DoxyCodeLine{440 \textcolor{preprocessor}{\#   define CATCH\_INTERNAL\_IGNORE\_BUT\_WARN(...)}}
\DoxyCodeLine{441 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{442 }
\DoxyCodeLine{443 \textcolor{preprocessor}{\#if defined(\_\_APPLE\_\_) \&\& defined(\_\_apple\_build\_version\_\_) \&\& (\_\_clang\_major\_\_ < 10)}}
\DoxyCodeLine{444 \textcolor{preprocessor}{\#   undef CATCH\_INTERNAL\_SUPPRESS\_UNUSED\_TEMPLATE\_WARNINGS}}
\DoxyCodeLine{445 \textcolor{preprocessor}{\#elif defined(\_\_clang\_\_) \&\& (\_\_clang\_major\_\_ < 5)}}
\DoxyCodeLine{446 \textcolor{preprocessor}{\#   undef CATCH\_INTERNAL\_SUPPRESS\_UNUSED\_TEMPLATE\_WARNINGS}}
\DoxyCodeLine{447 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{448 }
\DoxyCodeLine{449 \textcolor{preprocessor}{\#if !defined(CATCH\_INTERNAL\_SUPPRESS\_UNUSED\_TEMPLATE\_WARNINGS)}}
\DoxyCodeLine{450 \textcolor{preprocessor}{\#   define CATCH\_INTERNAL\_SUPPRESS\_UNUSED\_TEMPLATE\_WARNINGS}}
\DoxyCodeLine{451 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{452 }
\DoxyCodeLine{453 \textcolor{preprocessor}{\#if defined(CATCH\_CONFIG\_DISABLE\_EXCEPTIONS)}}
\DoxyCodeLine{454 \textcolor{preprocessor}{\#define CATCH\_TRY if ((true))}}
\DoxyCodeLine{455 \textcolor{preprocessor}{\#define CATCH\_CATCH\_ALL if ((false))}}
\DoxyCodeLine{456 \textcolor{preprocessor}{\#define CATCH\_CATCH\_ANON(type) if ((false))}}
\DoxyCodeLine{457 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{458 \textcolor{preprocessor}{\#define CATCH\_TRY try}}
\DoxyCodeLine{459 \textcolor{preprocessor}{\#define CATCH\_CATCH\_ALL catch (...)}}
\DoxyCodeLine{460 \textcolor{preprocessor}{\#define CATCH\_CATCH\_ANON(type) catch (type)}}
\DoxyCodeLine{461 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{462 }
\DoxyCodeLine{463 \textcolor{preprocessor}{\#if defined(CATCH\_INTERNAL\_CONFIG\_TRADITIONAL\_MSVC\_PREPROCESSOR) \&\& !defined(CATCH\_CONFIG\_NO\_TRADITIONAL\_MSVC\_PREPROCESSOR) \&\& !defined(CATCH\_CONFIG\_TRADITIONAL\_MSVC\_PREPROCESSOR)}}
\DoxyCodeLine{464 \textcolor{preprocessor}{\#define CATCH\_CONFIG\_TRADITIONAL\_MSVC\_PREPROCESSOR}}
\DoxyCodeLine{465 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{466 }
\DoxyCodeLine{467 \textcolor{comment}{// end catch\_compiler\_capabilities.h}}
\DoxyCodeLine{468 \textcolor{preprocessor}{\#define INTERNAL\_CATCH\_UNIQUE\_NAME\_LINE2( name, line ) name\#\#line}}
\DoxyCodeLine{469 \textcolor{preprocessor}{\#define INTERNAL\_CATCH\_UNIQUE\_NAME\_LINE( name, line ) INTERNAL\_CATCH\_UNIQUE\_NAME\_LINE2( name, line )}}
\DoxyCodeLine{470 \textcolor{preprocessor}{\#ifdef CATCH\_CONFIG\_COUNTER}}
\DoxyCodeLine{471 \textcolor{preprocessor}{\#  define INTERNAL\_CATCH\_UNIQUE\_NAME( name ) INTERNAL\_CATCH\_UNIQUE\_NAME\_LINE( name, \_\_COUNTER\_\_ )}}
\DoxyCodeLine{472 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{473 \textcolor{preprocessor}{\#  define INTERNAL\_CATCH\_UNIQUE\_NAME( name ) INTERNAL\_CATCH\_UNIQUE\_NAME\_LINE( name, \_\_LINE\_\_ )}}
\DoxyCodeLine{474 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{475 }
\DoxyCodeLine{476 \textcolor{preprocessor}{\#include <iosfwd>}}
\DoxyCodeLine{477 \textcolor{preprocessor}{\#include <string>}}
\DoxyCodeLine{478 \textcolor{preprocessor}{\#include <cstdint>}}
\DoxyCodeLine{479 }
\DoxyCodeLine{480 \textcolor{comment}{// We need a dummy global operator<< so we can bring it into Catch namespace later}}
\DoxyCodeLine{481 \textcolor{keyword}{struct }\mbox{\hyperlink{structCatch__global__namespace__dummy}{Catch\_global\_namespace\_dummy}} \{\};}
\DoxyCodeLine{482 std::ostream\& operator<<(std::ostream\&, \mbox{\hyperlink{structCatch__global__namespace__dummy}{Catch\_global\_namespace\_dummy}});}
\DoxyCodeLine{483 }
\DoxyCodeLine{484 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{485 }
\DoxyCodeLine{486     \textcolor{keyword}{struct }\mbox{\hyperlink{structCatch_1_1CaseSensitive}{CaseSensitive}} \{ \textcolor{keyword}{enum} Choice \{}
\DoxyCodeLine{487         Yes,}
\DoxyCodeLine{488         No}
\DoxyCodeLine{489     \}; \};}
\DoxyCodeLine{490 }
\DoxyCodeLine{491     \textcolor{keyword}{class }\mbox{\hyperlink{classCatch_1_1NonCopyable}{NonCopyable}} \{}
\DoxyCodeLine{492         \mbox{\hyperlink{classCatch_1_1NonCopyable}{NonCopyable}}( \mbox{\hyperlink{classCatch_1_1NonCopyable}{NonCopyable}} \textcolor{keyword}{const}\& )              = \textcolor{keyword}{delete};}
\DoxyCodeLine{493         \mbox{\hyperlink{classCatch_1_1NonCopyable}{NonCopyable}}( \mbox{\hyperlink{classCatch_1_1NonCopyable}{NonCopyable}} \&\& )                  = \textcolor{keyword}{delete};}
\DoxyCodeLine{494         \mbox{\hyperlink{classCatch_1_1NonCopyable}{NonCopyable}}\& operator = ( \mbox{\hyperlink{classCatch_1_1NonCopyable}{NonCopyable}} \textcolor{keyword}{const}\& ) = \textcolor{keyword}{delete};}
\DoxyCodeLine{495         \mbox{\hyperlink{classCatch_1_1NonCopyable}{NonCopyable}}\& operator = ( \mbox{\hyperlink{classCatch_1_1NonCopyable}{NonCopyable}} \&\& )     = \textcolor{keyword}{delete};}
\DoxyCodeLine{496 }
\DoxyCodeLine{497     \textcolor{keyword}{protected}:}
\DoxyCodeLine{498         \mbox{\hyperlink{classCatch_1_1NonCopyable}{NonCopyable}}();}
\DoxyCodeLine{499         \textcolor{keyword}{virtual} \mbox{\hyperlink{classCatch_1_1NonCopyable}{\string~NonCopyable}}();}
\DoxyCodeLine{500     \};}
\DoxyCodeLine{501 }
\DoxyCodeLine{502     \textcolor{keyword}{struct }\mbox{\hyperlink{structCatch_1_1SourceLineInfo}{SourceLineInfo}} \{}
\DoxyCodeLine{503 }
\DoxyCodeLine{504         \mbox{\hyperlink{structCatch_1_1SourceLineInfo}{SourceLineInfo}}() = \textcolor{keyword}{delete};}
\DoxyCodeLine{505         \mbox{\hyperlink{structCatch_1_1SourceLineInfo}{SourceLineInfo}}( \textcolor{keywordtype}{char} \textcolor{keyword}{const}* \_file, std::size\_t \_line ) noexcept}
\DoxyCodeLine{506         :   file( \_file ),}
\DoxyCodeLine{507             line( \_line )}
\DoxyCodeLine{508         \{\}}
\DoxyCodeLine{509 }
\DoxyCodeLine{510         \mbox{\hyperlink{structCatch_1_1SourceLineInfo}{SourceLineInfo}}( \mbox{\hyperlink{structCatch_1_1SourceLineInfo}{SourceLineInfo}} \textcolor{keyword}{const}\& other )            = \textcolor{keywordflow}{default};}
\DoxyCodeLine{511         \mbox{\hyperlink{structCatch_1_1SourceLineInfo}{SourceLineInfo}}\& operator = ( \mbox{\hyperlink{structCatch_1_1SourceLineInfo}{SourceLineInfo}} \textcolor{keyword}{const}\& )     = \textcolor{keywordflow}{default};}
\DoxyCodeLine{512         \mbox{\hyperlink{structCatch_1_1SourceLineInfo}{SourceLineInfo}}( \mbox{\hyperlink{structCatch_1_1SourceLineInfo}{SourceLineInfo}}\&\& )              \textcolor{keyword}{noexcept} = \textcolor{keywordflow}{default};}
\DoxyCodeLine{513         \mbox{\hyperlink{structCatch_1_1SourceLineInfo}{SourceLineInfo}}\& operator = ( \mbox{\hyperlink{structCatch_1_1SourceLineInfo}{SourceLineInfo}}\&\& ) \textcolor{keyword}{noexcept} = \textcolor{keywordflow}{default};}
\DoxyCodeLine{514 }
\DoxyCodeLine{515         \textcolor{keywordtype}{bool} empty() \textcolor{keyword}{const} \textcolor{keyword}{noexcept} \{ \textcolor{keywordflow}{return} file[0] == \textcolor{charliteral}{'\(\backslash\)0'}; \}}
\DoxyCodeLine{516         \textcolor{keywordtype}{bool} operator == ( \mbox{\hyperlink{structCatch_1_1SourceLineInfo}{SourceLineInfo}} \textcolor{keyword}{const}\& other ) \textcolor{keyword}{const} \textcolor{keyword}{noexcept};}
\DoxyCodeLine{517         \textcolor{keywordtype}{bool} operator < ( \mbox{\hyperlink{structCatch_1_1SourceLineInfo}{SourceLineInfo}} \textcolor{keyword}{const}\& other ) \textcolor{keyword}{const} \textcolor{keyword}{noexcept};}
\DoxyCodeLine{518 }
\DoxyCodeLine{519         \textcolor{keywordtype}{char} \textcolor{keyword}{const}* file;}
\DoxyCodeLine{520         std::size\_t line;}
\DoxyCodeLine{521     \};}
\DoxyCodeLine{522 }
\DoxyCodeLine{523     std::ostream\& operator << ( std::ostream\& os, \mbox{\hyperlink{structCatch_1_1SourceLineInfo}{SourceLineInfo}} \textcolor{keyword}{const}\& info );}
\DoxyCodeLine{524 }
\DoxyCodeLine{525     \textcolor{comment}{// Bring in operator<< from global namespace into Catch namespace}}
\DoxyCodeLine{526     \textcolor{comment}{// This is necessary because the overload of operator<< above makes}}
\DoxyCodeLine{527     \textcolor{comment}{// lookup stop at namespace Catch}}
\DoxyCodeLine{528     using ::operator<<;}
\DoxyCodeLine{529 }
\DoxyCodeLine{530     \textcolor{comment}{// Use this in variadic streaming macros to allow}}
\DoxyCodeLine{531     \textcolor{comment}{//    >> +StreamEndStop}}
\DoxyCodeLine{532     \textcolor{comment}{// as well as}}
\DoxyCodeLine{533     \textcolor{comment}{//    >> stuff +StreamEndStop}}
\DoxyCodeLine{534     \textcolor{keyword}{struct }\mbox{\hyperlink{structCatch_1_1StreamEndStop}{StreamEndStop}} \{}
\DoxyCodeLine{535         std::string operator+() \textcolor{keyword}{const};}
\DoxyCodeLine{536     \};}
\DoxyCodeLine{537     \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{538     T \textcolor{keyword}{const}\& operator + ( T \textcolor{keyword}{const}\& value, \mbox{\hyperlink{structCatch_1_1StreamEndStop}{StreamEndStop}} ) \{}
\DoxyCodeLine{539         \textcolor{keywordflow}{return} value;}
\DoxyCodeLine{540     \}}
\DoxyCodeLine{541 \}}
\DoxyCodeLine{542 }
\DoxyCodeLine{543 \textcolor{preprocessor}{\#define CATCH\_INTERNAL\_LINEINFO \(\backslash\)}}
\DoxyCodeLine{544 \textcolor{preprocessor}{    ::Catch::SourceLineInfo( \_\_FILE\_\_, static\_cast<std::size\_t>( \_\_LINE\_\_ ) )}}
\DoxyCodeLine{545 }
\DoxyCodeLine{546 \textcolor{comment}{// end catch\_common.h}}
\DoxyCodeLine{547 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{548 }
\DoxyCodeLine{549     \textcolor{keyword}{struct }\mbox{\hyperlink{structCatch_1_1RegistrarForTagAliases}{RegistrarForTagAliases}} \{}
\DoxyCodeLine{550         \mbox{\hyperlink{structCatch_1_1RegistrarForTagAliases}{RegistrarForTagAliases}}( \textcolor{keywordtype}{char} \textcolor{keyword}{const}* alias, \textcolor{keywordtype}{char} \textcolor{keyword}{const}* tag, \mbox{\hyperlink{structCatch_1_1SourceLineInfo}{SourceLineInfo}} \textcolor{keyword}{const}\& lineInfo );}
\DoxyCodeLine{551     \};}
\DoxyCodeLine{552 }
\DoxyCodeLine{553 \} \textcolor{comment}{// end namespace Catch}}
\DoxyCodeLine{554 }
\DoxyCodeLine{555 \textcolor{preprocessor}{\#define CATCH\_REGISTER\_TAG\_ALIAS( alias, spec ) \(\backslash\)}}
\DoxyCodeLine{556 \textcolor{preprocessor}{    CATCH\_INTERNAL\_START\_WARNINGS\_SUPPRESSION \(\backslash\)}}
\DoxyCodeLine{557 \textcolor{preprocessor}{    CATCH\_INTERNAL\_SUPPRESS\_GLOBALS\_WARNINGS \(\backslash\)}}
\DoxyCodeLine{558 \textcolor{preprocessor}{    namespace\{ Catch::RegistrarForTagAliases INTERNAL\_CATCH\_UNIQUE\_NAME( AutoRegisterTagAlias )( alias, spec, CATCH\_INTERNAL\_LINEINFO ); \} \(\backslash\)}}
\DoxyCodeLine{559 \textcolor{preprocessor}{    CATCH\_INTERNAL\_STOP\_WARNINGS\_SUPPRESSION}}
\DoxyCodeLine{560 }
\DoxyCodeLine{561 \textcolor{comment}{// end catch\_tag\_alias\_autoregistrar.h}}
\DoxyCodeLine{562 \textcolor{comment}{// start catch\_test\_registry.h}}
\DoxyCodeLine{563 }
\DoxyCodeLine{564 \textcolor{comment}{// start catch\_interfaces\_testcase.h}}
\DoxyCodeLine{565 }
\DoxyCodeLine{566 \textcolor{preprocessor}{\#include <vector>}}
\DoxyCodeLine{567 }
\DoxyCodeLine{568 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{569 }
\DoxyCodeLine{570     \textcolor{keyword}{class }TestSpec;}
\DoxyCodeLine{571 }
\DoxyCodeLine{572     \textcolor{keyword}{struct }\mbox{\hyperlink{structCatch_1_1ITestInvoker}{ITestInvoker}} \{}
\DoxyCodeLine{573         \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} invoke () \textcolor{keyword}{const} = 0;}
\DoxyCodeLine{574         \textcolor{keyword}{virtual} \mbox{\hyperlink{structCatch_1_1ITestInvoker}{\string~ITestInvoker}}();}
\DoxyCodeLine{575     \};}
\DoxyCodeLine{576 }
\DoxyCodeLine{577     \textcolor{keyword}{class }\mbox{\hyperlink{classCatch_1_1TestCase}{TestCase}};}
\DoxyCodeLine{578     \textcolor{keyword}{struct }\mbox{\hyperlink{structCatch_1_1IConfig}{IConfig}};}
\DoxyCodeLine{579 }
\DoxyCodeLine{580     \textcolor{keyword}{struct }\mbox{\hyperlink{structCatch_1_1ITestCaseRegistry}{ITestCaseRegistry}} \{}
\DoxyCodeLine{581         \textcolor{keyword}{virtual} \mbox{\hyperlink{structCatch_1_1ITestCaseRegistry}{\string~ITestCaseRegistry}}();}
\DoxyCodeLine{582         \textcolor{keyword}{virtual} std::vector<TestCase> \textcolor{keyword}{const}\& getAllTests() \textcolor{keyword}{const} = 0;}
\DoxyCodeLine{583         \textcolor{keyword}{virtual} std::vector<TestCase> \textcolor{keyword}{const}\& getAllTestsSorted( \mbox{\hyperlink{structCatch_1_1IConfig}{IConfig}} \textcolor{keyword}{const}\& config ) \textcolor{keyword}{const} = 0;}
\DoxyCodeLine{584     \};}
\DoxyCodeLine{585 }
\DoxyCodeLine{586     \textcolor{keywordtype}{bool} isThrowSafe( \mbox{\hyperlink{classCatch_1_1TestCase}{TestCase}} \textcolor{keyword}{const}\& testCase, \mbox{\hyperlink{structCatch_1_1IConfig}{IConfig}} \textcolor{keyword}{const}\& config );}
\DoxyCodeLine{587     \textcolor{keywordtype}{bool} matchTest( \mbox{\hyperlink{classCatch_1_1TestCase}{TestCase}} \textcolor{keyword}{const}\& testCase, TestSpec \textcolor{keyword}{const}\& testSpec, \mbox{\hyperlink{structCatch_1_1IConfig}{IConfig}} \textcolor{keyword}{const}\& config );}
\DoxyCodeLine{588     std::vector<TestCase> filterTests( std::vector<TestCase> \textcolor{keyword}{const}\& testCases, TestSpec \textcolor{keyword}{const}\& testSpec, \mbox{\hyperlink{structCatch_1_1IConfig}{IConfig}} \textcolor{keyword}{const}\& config );}
\DoxyCodeLine{589     std::vector<TestCase> \textcolor{keyword}{const}\& getAllTestCasesSorted( \mbox{\hyperlink{structCatch_1_1IConfig}{IConfig}} \textcolor{keyword}{const}\& config );}
\DoxyCodeLine{590 }
\DoxyCodeLine{591 \}}
\DoxyCodeLine{592 }
\DoxyCodeLine{593 \textcolor{comment}{// end catch\_interfaces\_testcase.h}}
\DoxyCodeLine{594 \textcolor{comment}{// start catch\_stringref.h}}
\DoxyCodeLine{595 }
\DoxyCodeLine{596 \textcolor{preprocessor}{\#include <cstddef>}}
\DoxyCodeLine{597 \textcolor{preprocessor}{\#include <string>}}
\DoxyCodeLine{598 \textcolor{preprocessor}{\#include <iosfwd>}}
\DoxyCodeLine{599 \textcolor{preprocessor}{\#include <cassert>}}
\DoxyCodeLine{600 }
\DoxyCodeLine{601 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{602 }
\DoxyCodeLine{606     \textcolor{keyword}{class }\mbox{\hyperlink{classCatch_1_1StringRef}{StringRef}} \{}
\DoxyCodeLine{607     \textcolor{keyword}{public}:}
\DoxyCodeLine{608         \textcolor{keyword}{using }size\_type = std::size\_t;}
\DoxyCodeLine{609         \textcolor{keyword}{using }const\_iterator = \textcolor{keyword}{const} \textcolor{keywordtype}{char}*;}
\DoxyCodeLine{610 }
\DoxyCodeLine{611     \textcolor{keyword}{private}:}
\DoxyCodeLine{612         \textcolor{keyword}{static} \textcolor{keyword}{constexpr} \textcolor{keywordtype}{char} \textcolor{keyword}{const}* \textcolor{keyword}{const} s\_empty = \textcolor{stringliteral}{"{}"{}};}
\DoxyCodeLine{613 }
\DoxyCodeLine{614         \textcolor{keywordtype}{char} \textcolor{keyword}{const}* m\_start = s\_empty;}
\DoxyCodeLine{615         size\_type m\_size = 0;}
\DoxyCodeLine{616 }
\DoxyCodeLine{617     \textcolor{keyword}{public}: \textcolor{comment}{// construction}}
\DoxyCodeLine{618         \textcolor{keyword}{constexpr} \mbox{\hyperlink{classCatch_1_1StringRef}{StringRef}}() \textcolor{keyword}{noexcept} = \textcolor{keywordflow}{default};}
\DoxyCodeLine{619 }
\DoxyCodeLine{620         \mbox{\hyperlink{classCatch_1_1StringRef}{StringRef}}( \textcolor{keywordtype}{char} \textcolor{keyword}{const}* rawChars ) \textcolor{keyword}{noexcept};}
\DoxyCodeLine{621 }
\DoxyCodeLine{622         \textcolor{keyword}{constexpr} \mbox{\hyperlink{classCatch_1_1StringRef}{StringRef}}( \textcolor{keywordtype}{char} \textcolor{keyword}{const}* rawChars, size\_type size ) noexcept}
\DoxyCodeLine{623         :   m\_start( rawChars ),}
\DoxyCodeLine{624             m\_size( size )}
\DoxyCodeLine{625         \{\}}
\DoxyCodeLine{626 }
\DoxyCodeLine{627         \mbox{\hyperlink{classCatch_1_1StringRef}{StringRef}}( std::string \textcolor{keyword}{const}\& stdString ) noexcept}
\DoxyCodeLine{628         :   m\_start( stdString.c\_str() ),}
\DoxyCodeLine{629             m\_size( stdString.size() )}
\DoxyCodeLine{630         \{\}}
\DoxyCodeLine{631 }
\DoxyCodeLine{632         \textcolor{keyword}{explicit} \textcolor{keyword}{operator} std::string()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{633             \textcolor{keywordflow}{return} std::string(m\_start, m\_size);}
\DoxyCodeLine{634         \}}
\DoxyCodeLine{635 }
\DoxyCodeLine{636     \textcolor{keyword}{public}: \textcolor{comment}{// operators}}
\DoxyCodeLine{637         \textcolor{keyword}{auto} operator == ( \mbox{\hyperlink{classCatch_1_1StringRef}{StringRef}} \textcolor{keyword}{const}\& other ) \textcolor{keyword}{const} \textcolor{keyword}{noexcept} -\/> bool;}
\DoxyCodeLine{638         \textcolor{keyword}{auto} operator != (\mbox{\hyperlink{classCatch_1_1StringRef}{StringRef}} \textcolor{keyword}{const}\& other) \textcolor{keyword}{const} \textcolor{keyword}{noexcept} -\/> \textcolor{keywordtype}{bool} \{}
\DoxyCodeLine{639             \textcolor{keywordflow}{return} !(*\textcolor{keyword}{this} == other);}
\DoxyCodeLine{640         \}}
\DoxyCodeLine{641 }
\DoxyCodeLine{642         \textcolor{keyword}{auto} operator[] ( size\_type index ) \textcolor{keyword}{const} \textcolor{keyword}{noexcept} -\/> \textcolor{keywordtype}{char} \{}
\DoxyCodeLine{643             assert(index < m\_size);}
\DoxyCodeLine{644             \textcolor{keywordflow}{return} m\_start[index];}
\DoxyCodeLine{645         \}}
\DoxyCodeLine{646 }
\DoxyCodeLine{647     \textcolor{keyword}{public}: \textcolor{comment}{// named queries}}
\DoxyCodeLine{648         \textcolor{keyword}{constexpr} \textcolor{keyword}{auto} empty() \textcolor{keyword}{const} \textcolor{keyword}{noexcept} -\/> \textcolor{keywordtype}{bool} \{}
\DoxyCodeLine{649             \textcolor{keywordflow}{return} m\_size == 0;}
\DoxyCodeLine{650         \}}
\DoxyCodeLine{651         \textcolor{keyword}{constexpr} \textcolor{keyword}{auto} size() \textcolor{keyword}{const} \textcolor{keyword}{noexcept} -\/> size\_type \{}
\DoxyCodeLine{652             \textcolor{keywordflow}{return} m\_size;}
\DoxyCodeLine{653         \}}
\DoxyCodeLine{654 }
\DoxyCodeLine{655         \textcolor{comment}{// Returns the current start pointer. If the StringRef is not}}
\DoxyCodeLine{656         \textcolor{comment}{// null-\/terminated, throws std::domain\_exception}}
\DoxyCodeLine{657         \textcolor{keyword}{auto} c\_str() \textcolor{keyword}{const} -\/> \textcolor{keywordtype}{char} \textcolor{keyword}{const}*;}
\DoxyCodeLine{658 }
\DoxyCodeLine{659     \textcolor{keyword}{public}: \textcolor{comment}{// substrings and searches}}
\DoxyCodeLine{660         \textcolor{comment}{// Returns a substring of [start, start + length).}}
\DoxyCodeLine{661         \textcolor{comment}{// If start + length > size(), then the substring is [start, size()).}}
\DoxyCodeLine{662         \textcolor{comment}{// If start > size(), then the substring is empty.}}
\DoxyCodeLine{663         \textcolor{keyword}{auto} substr( size\_type start, size\_type length ) \textcolor{keyword}{const} \textcolor{keyword}{noexcept} -\/> \mbox{\hyperlink{classCatch_1_1StringRef}{StringRef}};}
\DoxyCodeLine{664 }
\DoxyCodeLine{665         \textcolor{comment}{// Returns the current start pointer. May not be null-\/terminated.}}
\DoxyCodeLine{666         \textcolor{keyword}{auto} data() \textcolor{keyword}{const} \textcolor{keyword}{noexcept} -\/> \textcolor{keywordtype}{char} \textcolor{keyword}{const}*;}
\DoxyCodeLine{667 }
\DoxyCodeLine{668         \textcolor{keyword}{constexpr} \textcolor{keyword}{auto} isNullTerminated() \textcolor{keyword}{const} \textcolor{keyword}{noexcept} -\/> \textcolor{keywordtype}{bool} \{}
\DoxyCodeLine{669             \textcolor{keywordflow}{return} m\_start[m\_size] == \textcolor{charliteral}{'\(\backslash\)0'};}
\DoxyCodeLine{670         \}}
\DoxyCodeLine{671 }
\DoxyCodeLine{672     \textcolor{keyword}{public}: \textcolor{comment}{// iterators}}
\DoxyCodeLine{673         \textcolor{keyword}{constexpr} const\_iterator begin()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} m\_start; \}}
\DoxyCodeLine{674         \textcolor{keyword}{constexpr} const\_iterator end()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} m\_start + m\_size; \}}
\DoxyCodeLine{675     \};}
\DoxyCodeLine{676 }
\DoxyCodeLine{677     \textcolor{keyword}{auto} operator += ( std::string\& lhs, \mbox{\hyperlink{classCatch_1_1StringRef}{StringRef}} \textcolor{keyword}{const}\& sr ) -\/> std::string\&;}
\DoxyCodeLine{678     \textcolor{keyword}{auto} operator << ( std::ostream\& os, \mbox{\hyperlink{classCatch_1_1StringRef}{StringRef}} \textcolor{keyword}{const}\& sr ) -\/> std::ostream\&;}
\DoxyCodeLine{679 }
\DoxyCodeLine{680     \textcolor{keyword}{constexpr} \textcolor{keyword}{auto} \textcolor{keyword}{operator} \textcolor{stringliteral}{"{}"{}} \_sr( \textcolor{keywordtype}{char} \textcolor{keyword}{const}* rawChars, std::size\_t size ) \textcolor{keyword}{noexcept} -\/> \mbox{\hyperlink{classCatch_1_1StringRef}{StringRef}} \{}
\DoxyCodeLine{681         \textcolor{keywordflow}{return} \mbox{\hyperlink{classCatch_1_1StringRef}{StringRef}}( rawChars, size );}
\DoxyCodeLine{682     \}}
\DoxyCodeLine{683 \} \textcolor{comment}{// namespace Catch}}
\DoxyCodeLine{684 }
\DoxyCodeLine{685 \textcolor{keyword}{constexpr} \textcolor{keyword}{auto} \textcolor{keyword}{operator} \textcolor{stringliteral}{"{}"{}} \_catch\_sr( \textcolor{keywordtype}{char} \textcolor{keyword}{const}* rawChars, std::size\_t size ) \textcolor{keyword}{noexcept} -\/> \mbox{\hyperlink{classCatch_1_1StringRef}{Catch::StringRef}} \{}
\DoxyCodeLine{686     \textcolor{keywordflow}{return} \mbox{\hyperlink{classCatch_1_1StringRef}{Catch::StringRef}}( rawChars, size );}
\DoxyCodeLine{687 \}}
\DoxyCodeLine{688 }
\DoxyCodeLine{689 \textcolor{comment}{// end catch\_stringref.h}}
\DoxyCodeLine{690 \textcolor{comment}{// start catch\_preprocessor.hpp}}
\DoxyCodeLine{691 }
\DoxyCodeLine{692 }
\DoxyCodeLine{693 \textcolor{preprocessor}{\#define CATCH\_RECURSION\_LEVEL0(...) \_\_VA\_ARGS\_\_}}
\DoxyCodeLine{694 \textcolor{preprocessor}{\#define CATCH\_RECURSION\_LEVEL1(...) CATCH\_RECURSION\_LEVEL0(CATCH\_RECURSION\_LEVEL0(CATCH\_RECURSION\_LEVEL0(\_\_VA\_ARGS\_\_)))}}
\DoxyCodeLine{695 \textcolor{preprocessor}{\#define CATCH\_RECURSION\_LEVEL2(...) CATCH\_RECURSION\_LEVEL1(CATCH\_RECURSION\_LEVEL1(CATCH\_RECURSION\_LEVEL1(\_\_VA\_ARGS\_\_)))}}
\DoxyCodeLine{696 \textcolor{preprocessor}{\#define CATCH\_RECURSION\_LEVEL3(...) CATCH\_RECURSION\_LEVEL2(CATCH\_RECURSION\_LEVEL2(CATCH\_RECURSION\_LEVEL2(\_\_VA\_ARGS\_\_)))}}
\DoxyCodeLine{697 \textcolor{preprocessor}{\#define CATCH\_RECURSION\_LEVEL4(...) CATCH\_RECURSION\_LEVEL3(CATCH\_RECURSION\_LEVEL3(CATCH\_RECURSION\_LEVEL3(\_\_VA\_ARGS\_\_)))}}
\DoxyCodeLine{698 \textcolor{preprocessor}{\#define CATCH\_RECURSION\_LEVEL5(...) CATCH\_RECURSION\_LEVEL4(CATCH\_RECURSION\_LEVEL4(CATCH\_RECURSION\_LEVEL4(\_\_VA\_ARGS\_\_)))}}
\DoxyCodeLine{699 }
\DoxyCodeLine{700 \textcolor{preprocessor}{\#ifdef CATCH\_CONFIG\_TRADITIONAL\_MSVC\_PREPROCESSOR}}
\DoxyCodeLine{701 \textcolor{preprocessor}{\#define INTERNAL\_CATCH\_EXPAND\_VARGS(...) \_\_VA\_ARGS\_\_}}
\DoxyCodeLine{702 \textcolor{comment}{// MSVC needs more evaluations}}
\DoxyCodeLine{703 \textcolor{preprocessor}{\#define CATCH\_RECURSION\_LEVEL6(...) CATCH\_RECURSION\_LEVEL5(CATCH\_RECURSION\_LEVEL5(CATCH\_RECURSION\_LEVEL5(\_\_VA\_ARGS\_\_)))}}
\DoxyCodeLine{704 \textcolor{preprocessor}{\#define CATCH\_RECURSE(...)  CATCH\_RECURSION\_LEVEL6(CATCH\_RECURSION\_LEVEL6(\_\_VA\_ARGS\_\_))}}
\DoxyCodeLine{705 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{706 \textcolor{preprocessor}{\#define CATCH\_RECURSE(...)  CATCH\_RECURSION\_LEVEL5(\_\_VA\_ARGS\_\_)}}
\DoxyCodeLine{707 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{708 }
\DoxyCodeLine{709 \textcolor{preprocessor}{\#define CATCH\_REC\_END(...)}}
\DoxyCodeLine{710 \textcolor{preprocessor}{\#define CATCH\_REC\_OUT}}
\DoxyCodeLine{711 }
\DoxyCodeLine{712 \textcolor{preprocessor}{\#define CATCH\_EMPTY()}}
\DoxyCodeLine{713 \textcolor{preprocessor}{\#define CATCH\_DEFER(id) id CATCH\_EMPTY()}}
\DoxyCodeLine{714 }
\DoxyCodeLine{715 \textcolor{preprocessor}{\#define CATCH\_REC\_GET\_END2() 0, CATCH\_REC\_END}}
\DoxyCodeLine{716 \textcolor{preprocessor}{\#define CATCH\_REC\_GET\_END1(...) CATCH\_REC\_GET\_END2}}
\DoxyCodeLine{717 \textcolor{preprocessor}{\#define CATCH\_REC\_GET\_END(...) CATCH\_REC\_GET\_END1}}
\DoxyCodeLine{718 \textcolor{preprocessor}{\#define CATCH\_REC\_NEXT0(test, next, ...) next CATCH\_REC\_OUT}}
\DoxyCodeLine{719 \textcolor{preprocessor}{\#define CATCH\_REC\_NEXT1(test, next) CATCH\_DEFER ( CATCH\_REC\_NEXT0 ) ( test, next, 0)}}
\DoxyCodeLine{720 \textcolor{preprocessor}{\#define CATCH\_REC\_NEXT(test, next)  CATCH\_REC\_NEXT1(CATCH\_REC\_GET\_END test, next)}}
\DoxyCodeLine{721 }
\DoxyCodeLine{722 \textcolor{preprocessor}{\#define CATCH\_REC\_LIST0(f, x, peek, ...) , f(x) CATCH\_DEFER ( CATCH\_REC\_NEXT(peek, CATCH\_REC\_LIST1) ) ( f, peek, \_\_VA\_ARGS\_\_ )}}
\DoxyCodeLine{723 \textcolor{preprocessor}{\#define CATCH\_REC\_LIST1(f, x, peek, ...) , f(x) CATCH\_DEFER ( CATCH\_REC\_NEXT(peek, CATCH\_REC\_LIST0) ) ( f, peek, \_\_VA\_ARGS\_\_ )}}
\DoxyCodeLine{724 \textcolor{preprocessor}{\#define CATCH\_REC\_LIST2(f, x, peek, ...)   f(x) CATCH\_DEFER ( CATCH\_REC\_NEXT(peek, CATCH\_REC\_LIST1) ) ( f, peek, \_\_VA\_ARGS\_\_ )}}
\DoxyCodeLine{725 }
\DoxyCodeLine{726 \textcolor{preprocessor}{\#define CATCH\_REC\_LIST0\_UD(f, userdata, x, peek, ...) , f(userdata, x) CATCH\_DEFER ( CATCH\_REC\_NEXT(peek, CATCH\_REC\_LIST1\_UD) ) ( f, userdata, peek, \_\_VA\_ARGS\_\_ )}}
\DoxyCodeLine{727 \textcolor{preprocessor}{\#define CATCH\_REC\_LIST1\_UD(f, userdata, x, peek, ...) , f(userdata, x) CATCH\_DEFER ( CATCH\_REC\_NEXT(peek, CATCH\_REC\_LIST0\_UD) ) ( f, userdata, peek, \_\_VA\_ARGS\_\_ )}}
\DoxyCodeLine{728 \textcolor{preprocessor}{\#define CATCH\_REC\_LIST2\_UD(f, userdata, x, peek, ...)   f(userdata, x) CATCH\_DEFER ( CATCH\_REC\_NEXT(peek, CATCH\_REC\_LIST1\_UD) ) ( f, userdata, peek, \_\_VA\_ARGS\_\_ )}}
\DoxyCodeLine{729 }
\DoxyCodeLine{730 \textcolor{comment}{// Applies the function macro `f` to each of the remaining parameters, inserts commas between the results,}}
\DoxyCodeLine{731 \textcolor{comment}{// and passes userdata as the first parameter to each invocation,}}
\DoxyCodeLine{732 \textcolor{comment}{// e.g. CATCH\_REC\_LIST\_UD(f, x, a, b, c) evaluates to f(x, a), f(x, b), f(x, c)}}
\DoxyCodeLine{733 \textcolor{preprocessor}{\#define CATCH\_REC\_LIST\_UD(f, userdata, ...) CATCH\_RECURSE(CATCH\_REC\_LIST2\_UD(f, userdata, \_\_VA\_ARGS\_\_, ()()(), ()()(), ()()(), 0))}}
\DoxyCodeLine{734 }
\DoxyCodeLine{735 \textcolor{preprocessor}{\#define CATCH\_REC\_LIST(f, ...) CATCH\_RECURSE(CATCH\_REC\_LIST2(f, \_\_VA\_ARGS\_\_, ()()(), ()()(), ()()(), 0))}}
\DoxyCodeLine{736 }
\DoxyCodeLine{737 \textcolor{preprocessor}{\#define INTERNAL\_CATCH\_EXPAND1(param) INTERNAL\_CATCH\_EXPAND2(param)}}
\DoxyCodeLine{738 \textcolor{preprocessor}{\#define INTERNAL\_CATCH\_EXPAND2(...) INTERNAL\_CATCH\_NO\#\# \_\_VA\_ARGS\_\_}}
\DoxyCodeLine{739 \textcolor{preprocessor}{\#define INTERNAL\_CATCH\_DEF(...) INTERNAL\_CATCH\_DEF \_\_VA\_ARGS\_\_}}
\DoxyCodeLine{740 \textcolor{preprocessor}{\#define INTERNAL\_CATCH\_NOINTERNAL\_CATCH\_DEF}}
\DoxyCodeLine{741 \textcolor{preprocessor}{\#define INTERNAL\_CATCH\_STRINGIZE(...) INTERNAL\_CATCH\_STRINGIZE2(\_\_VA\_ARGS\_\_)}}
\DoxyCodeLine{742 \textcolor{preprocessor}{\#ifndef CATCH\_CONFIG\_TRADITIONAL\_MSVC\_PREPROCESSOR}}
\DoxyCodeLine{743 \textcolor{preprocessor}{\#define INTERNAL\_CATCH\_STRINGIZE2(...) \#\_\_VA\_ARGS\_\_}}
\DoxyCodeLine{744 \textcolor{preprocessor}{\#define INTERNAL\_CATCH\_STRINGIZE\_WITHOUT\_PARENS(param) INTERNAL\_CATCH\_STRINGIZE(INTERNAL\_CATCH\_REMOVE\_PARENS(param))}}
\DoxyCodeLine{745 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{746 \textcolor{comment}{// MSVC is adding extra space and needs another indirection to expand INTERNAL\_CATCH\_NOINTERNAL\_CATCH\_DEF}}
\DoxyCodeLine{747 \textcolor{preprocessor}{\#define INTERNAL\_CATCH\_STRINGIZE2(...) INTERNAL\_CATCH\_STRINGIZE3(\_\_VA\_ARGS\_\_)}}
\DoxyCodeLine{748 \textcolor{preprocessor}{\#define INTERNAL\_CATCH\_STRINGIZE3(...) \#\_\_VA\_ARGS\_\_}}
\DoxyCodeLine{749 \textcolor{preprocessor}{\#define INTERNAL\_CATCH\_STRINGIZE\_WITHOUT\_PARENS(param) (INTERNAL\_CATCH\_STRINGIZE(INTERNAL\_CATCH\_REMOVE\_PARENS(param)) + 1)}}
\DoxyCodeLine{750 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{751 }
\DoxyCodeLine{752 \textcolor{preprocessor}{\#define INTERNAL\_CATCH\_MAKE\_NAMESPACE2(...) ns\_\#\#\_\_VA\_ARGS\_\_}}
\DoxyCodeLine{753 \textcolor{preprocessor}{\#define INTERNAL\_CATCH\_MAKE\_NAMESPACE(name) INTERNAL\_CATCH\_MAKE\_NAMESPACE2(name)}}
\DoxyCodeLine{754 }
\DoxyCodeLine{755 \textcolor{preprocessor}{\#define INTERNAL\_CATCH\_REMOVE\_PARENS(...) INTERNAL\_CATCH\_EXPAND1(INTERNAL\_CATCH\_DEF \_\_VA\_ARGS\_\_)}}
\DoxyCodeLine{756 }
\DoxyCodeLine{757 \textcolor{preprocessor}{\#ifndef CATCH\_CONFIG\_TRADITIONAL\_MSVC\_PREPROCESSOR}}
\DoxyCodeLine{758 \textcolor{preprocessor}{\#define INTERNAL\_CATCH\_MAKE\_TYPE\_LIST2(...) decltype(get\_wrapper<INTERNAL\_CATCH\_REMOVE\_PARENS\_GEN(\_\_VA\_ARGS\_\_)>())}}
\DoxyCodeLine{759 \textcolor{preprocessor}{\#define INTERNAL\_CATCH\_MAKE\_TYPE\_LIST(...) INTERNAL\_CATCH\_MAKE\_TYPE\_LIST2(INTERNAL\_CATCH\_REMOVE\_PARENS(\_\_VA\_ARGS\_\_))}}
\DoxyCodeLine{760 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{761 \textcolor{preprocessor}{\#define INTERNAL\_CATCH\_MAKE\_TYPE\_LIST2(...) INTERNAL\_CATCH\_EXPAND\_VARGS(decltype(get\_wrapper<INTERNAL\_CATCH\_REMOVE\_PARENS\_GEN(\_\_VA\_ARGS\_\_)>()))}}
\DoxyCodeLine{762 \textcolor{preprocessor}{\#define INTERNAL\_CATCH\_MAKE\_TYPE\_LIST(...) INTERNAL\_CATCH\_EXPAND\_VARGS(INTERNAL\_CATCH\_MAKE\_TYPE\_LIST2(INTERNAL\_CATCH\_REMOVE\_PARENS(\_\_VA\_ARGS\_\_)))}}
\DoxyCodeLine{763 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{764 }
\DoxyCodeLine{765 \textcolor{preprocessor}{\#define INTERNAL\_CATCH\_MAKE\_TYPE\_LISTS\_FROM\_TYPES(...)\(\backslash\)}}
\DoxyCodeLine{766 \textcolor{preprocessor}{    CATCH\_REC\_LIST(INTERNAL\_CATCH\_MAKE\_TYPE\_LIST,\_\_VA\_ARGS\_\_)}}
\DoxyCodeLine{767 }
\DoxyCodeLine{768 \textcolor{preprocessor}{\#define INTERNAL\_CATCH\_REMOVE\_PARENS\_1\_ARG(\_0) INTERNAL\_CATCH\_REMOVE\_PARENS(\_0)}}
\DoxyCodeLine{769 \textcolor{preprocessor}{\#define INTERNAL\_CATCH\_REMOVE\_PARENS\_2\_ARG(\_0, \_1) INTERNAL\_CATCH\_REMOVE\_PARENS(\_0), INTERNAL\_CATCH\_REMOVE\_PARENS\_1\_ARG(\_1)}}
\DoxyCodeLine{770 \textcolor{preprocessor}{\#define INTERNAL\_CATCH\_REMOVE\_PARENS\_3\_ARG(\_0, \_1, \_2) INTERNAL\_CATCH\_REMOVE\_PARENS(\_0), INTERNAL\_CATCH\_REMOVE\_PARENS\_2\_ARG(\_1, \_2)}}
\DoxyCodeLine{771 \textcolor{preprocessor}{\#define INTERNAL\_CATCH\_REMOVE\_PARENS\_4\_ARG(\_0, \_1, \_2, \_3) INTERNAL\_CATCH\_REMOVE\_PARENS(\_0), INTERNAL\_CATCH\_REMOVE\_PARENS\_3\_ARG(\_1, \_2, \_3)}}
\DoxyCodeLine{772 \textcolor{preprocessor}{\#define INTERNAL\_CATCH\_REMOVE\_PARENS\_5\_ARG(\_0, \_1, \_2, \_3, \_4) INTERNAL\_CATCH\_REMOVE\_PARENS(\_0), INTERNAL\_CATCH\_REMOVE\_PARENS\_4\_ARG(\_1, \_2, \_3, \_4)}}
\DoxyCodeLine{773 \textcolor{preprocessor}{\#define INTERNAL\_CATCH\_REMOVE\_PARENS\_6\_ARG(\_0, \_1, \_2, \_3, \_4, \_5) INTERNAL\_CATCH\_REMOVE\_PARENS(\_0), INTERNAL\_CATCH\_REMOVE\_PARENS\_5\_ARG(\_1, \_2, \_3, \_4, \_5)}}
\DoxyCodeLine{774 \textcolor{preprocessor}{\#define INTERNAL\_CATCH\_REMOVE\_PARENS\_7\_ARG(\_0, \_1, \_2, \_3, \_4, \_5, \_6) INTERNAL\_CATCH\_REMOVE\_PARENS(\_0), INTERNAL\_CATCH\_REMOVE\_PARENS\_6\_ARG(\_1, \_2, \_3, \_4, \_5, \_6)}}
\DoxyCodeLine{775 \textcolor{preprocessor}{\#define INTERNAL\_CATCH\_REMOVE\_PARENS\_8\_ARG(\_0, \_1, \_2, \_3, \_4, \_5, \_6, \_7) INTERNAL\_CATCH\_REMOVE\_PARENS(\_0), INTERNAL\_CATCH\_REMOVE\_PARENS\_7\_ARG(\_1, \_2, \_3, \_4, \_5, \_6, \_7)}}
\DoxyCodeLine{776 \textcolor{preprocessor}{\#define INTERNAL\_CATCH\_REMOVE\_PARENS\_9\_ARG(\_0, \_1, \_2, \_3, \_4, \_5, \_6, \_7, \_8) INTERNAL\_CATCH\_REMOVE\_PARENS(\_0), INTERNAL\_CATCH\_REMOVE\_PARENS\_8\_ARG(\_1, \_2, \_3, \_4, \_5, \_6, \_7, \_8)}}
\DoxyCodeLine{777 \textcolor{preprocessor}{\#define INTERNAL\_CATCH\_REMOVE\_PARENS\_10\_ARG(\_0, \_1, \_2, \_3, \_4, \_5, \_6, \_7, \_8, \_9) INTERNAL\_CATCH\_REMOVE\_PARENS(\_0), INTERNAL\_CATCH\_REMOVE\_PARENS\_9\_ARG(\_1, \_2, \_3, \_4, \_5, \_6, \_7, \_8, \_9)}}
\DoxyCodeLine{778 \textcolor{preprocessor}{\#define INTERNAL\_CATCH\_REMOVE\_PARENS\_11\_ARG(\_0, \_1, \_2, \_3, \_4, \_5, \_6, \_7, \_8, \_9, \_10) INTERNAL\_CATCH\_REMOVE\_PARENS(\_0), INTERNAL\_CATCH\_REMOVE\_PARENS\_10\_ARG(\_1, \_2, \_3, \_4, \_5, \_6, \_7, \_8, \_9, \_10)}}
\DoxyCodeLine{779 }
\DoxyCodeLine{780 \textcolor{preprocessor}{\#define INTERNAL\_CATCH\_VA\_NARGS\_IMPL(\_0, \_1, \_2, \_3, \_4, \_5, \_6, \_7, \_8, \_9, \_10, N, ...) N}}
\DoxyCodeLine{781 }
\DoxyCodeLine{782 \textcolor{preprocessor}{\#define INTERNAL\_CATCH\_TYPE\_GEN\(\backslash\)}}
\DoxyCodeLine{783 \textcolor{preprocessor}{    template<typename...> struct TypeList \{\};\(\backslash\)}}
\DoxyCodeLine{784 \textcolor{preprocessor}{    template<typename...Ts>\(\backslash\)}}
\DoxyCodeLine{785 \textcolor{preprocessor}{    constexpr auto get\_wrapper() noexcept -\/> TypeList<Ts...> \{ return \{\}; \}\(\backslash\)}}
\DoxyCodeLine{786 \textcolor{preprocessor}{    template<template<typename...> class...> struct TemplateTypeList\{\};\(\backslash\)}}
\DoxyCodeLine{787 \textcolor{preprocessor}{    template<template<typename...> class...Cs>\(\backslash\)}}
\DoxyCodeLine{788 \textcolor{preprocessor}{    constexpr auto get\_wrapper() noexcept -\/> TemplateTypeList<Cs...> \{ return \{\}; \}\(\backslash\)}}
\DoxyCodeLine{789 \textcolor{preprocessor}{    template<typename...>\(\backslash\)}}
\DoxyCodeLine{790 \textcolor{preprocessor}{    struct append;\(\backslash\)}}
\DoxyCodeLine{791 \textcolor{preprocessor}{    template<typename...>\(\backslash\)}}
\DoxyCodeLine{792 \textcolor{preprocessor}{    struct rewrap;\(\backslash\)}}
\DoxyCodeLine{793 \textcolor{preprocessor}{    template<template<typename...> class, typename...>\(\backslash\)}}
\DoxyCodeLine{794 \textcolor{preprocessor}{    struct create;\(\backslash\)}}
\DoxyCodeLine{795 \textcolor{preprocessor}{    template<template<typename...> class, typename>\(\backslash\)}}
\DoxyCodeLine{796 \textcolor{preprocessor}{    struct convert;\(\backslash\)}}
\DoxyCodeLine{797 \textcolor{preprocessor}{    \(\backslash\)}}
\DoxyCodeLine{798 \textcolor{preprocessor}{    template<typename T> \(\backslash\)}}
\DoxyCodeLine{799 \textcolor{preprocessor}{    struct append<T> \{ using type = T; \};\(\backslash\)}}
\DoxyCodeLine{800 \textcolor{preprocessor}{    template< template<typename...> class L1, typename...E1, template<typename...> class L2, typename...E2, typename...Rest>\(\backslash\)}}
\DoxyCodeLine{801 \textcolor{preprocessor}{    struct append<L1<E1...>, L2<E2...>, Rest...> \{ using type = typename append<L1<E1...,E2...>, Rest...>::type; \};\(\backslash\)}}
\DoxyCodeLine{802 \textcolor{preprocessor}{    template< template<typename...> class L1, typename...E1, typename...Rest>\(\backslash\)}}
\DoxyCodeLine{803 \textcolor{preprocessor}{    struct append<L1<E1...>, TypeList<mpl\_::na>, Rest...> \{ using type = L1<E1...>; \};\(\backslash\)}}
\DoxyCodeLine{804 \textcolor{preprocessor}{    \(\backslash\)}}
\DoxyCodeLine{805 \textcolor{preprocessor}{    template< template<typename...> class Container, template<typename...> class List, typename...elems>\(\backslash\)}}
\DoxyCodeLine{806 \textcolor{preprocessor}{    struct rewrap<TemplateTypeList<Container>, List<elems...>> \{ using type = TypeList<Container<elems...>>; \};\(\backslash\)}}
\DoxyCodeLine{807 \textcolor{preprocessor}{    template< template<typename...> class Container, template<typename...> class List, class...Elems, typename...Elements>\(\backslash\)}}
\DoxyCodeLine{808 \textcolor{preprocessor}{    struct rewrap<TemplateTypeList<Container>, List<Elems...>, Elements...> \{ using type = typename append<TypeList<Container<Elems...>>, typename rewrap<TemplateTypeList<Container>, Elements...>::type>::type; \};\(\backslash\)}}
\DoxyCodeLine{809 \textcolor{preprocessor}{    \(\backslash\)}}
\DoxyCodeLine{810 \textcolor{preprocessor}{    template<template <typename...> class Final, template< typename...> class...Containers, typename...Types>\(\backslash\)}}
\DoxyCodeLine{811 \textcolor{preprocessor}{    struct create<Final, TemplateTypeList<Containers...>, TypeList<Types...>> \{ using type = typename append<Final<>, typename rewrap<TemplateTypeList<Containers>, Types...>::type...>::type; \};\(\backslash\)}}
\DoxyCodeLine{812 \textcolor{preprocessor}{    template<template <typename...> class Final, template <typename...> class List, typename...Ts>\(\backslash\)}}
\DoxyCodeLine{813 \textcolor{preprocessor}{    struct convert<Final, List<Ts...>> \{ using type = typename append<Final<>,TypeList<Ts>...>::type; \};}}
\DoxyCodeLine{814 }
\DoxyCodeLine{815 \textcolor{preprocessor}{\#define INTERNAL\_CATCH\_NTTP\_1(signature, ...)\(\backslash\)}}
\DoxyCodeLine{816 \textcolor{preprocessor}{    template<INTERNAL\_CATCH\_REMOVE\_PARENS(signature)> struct Nttp\{\};\(\backslash\)}}
\DoxyCodeLine{817 \textcolor{preprocessor}{    template<INTERNAL\_CATCH\_REMOVE\_PARENS(signature)>\(\backslash\)}}
\DoxyCodeLine{818 \textcolor{preprocessor}{    constexpr auto get\_wrapper() noexcept -\/> Nttp<\_\_VA\_ARGS\_\_> \{ return \{\}; \} \(\backslash\)}}
\DoxyCodeLine{819 \textcolor{preprocessor}{    template<template<INTERNAL\_CATCH\_REMOVE\_PARENS(signature)> class...> struct NttpTemplateTypeList\{\};\(\backslash\)}}
\DoxyCodeLine{820 \textcolor{preprocessor}{    template<template<INTERNAL\_CATCH\_REMOVE\_PARENS(signature)> class...Cs>\(\backslash\)}}
\DoxyCodeLine{821 \textcolor{preprocessor}{    constexpr auto get\_wrapper() noexcept -\/> NttpTemplateTypeList<Cs...> \{ return \{\}; \} \(\backslash\)}}
\DoxyCodeLine{822 \textcolor{preprocessor}{    \(\backslash\)}}
\DoxyCodeLine{823 \textcolor{preprocessor}{    template< template<INTERNAL\_CATCH\_REMOVE\_PARENS(signature)> class Container, template<INTERNAL\_CATCH\_REMOVE\_PARENS(signature)> class List, INTERNAL\_CATCH\_REMOVE\_PARENS(signature)>\(\backslash\)}}
\DoxyCodeLine{824 \textcolor{preprocessor}{    struct rewrap<NttpTemplateTypeList<Container>, List<\_\_VA\_ARGS\_\_>> \{ using type = TypeList<Container<\_\_VA\_ARGS\_\_>>; \};\(\backslash\)}}
\DoxyCodeLine{825 \textcolor{preprocessor}{    template< template<INTERNAL\_CATCH\_REMOVE\_PARENS(signature)> class Container, template<INTERNAL\_CATCH\_REMOVE\_PARENS(signature)> class List, INTERNAL\_CATCH\_REMOVE\_PARENS(signature), typename...Elements>\(\backslash\)}}
\DoxyCodeLine{826 \textcolor{preprocessor}{    struct rewrap<NttpTemplateTypeList<Container>, List<\_\_VA\_ARGS\_\_>, Elements...> \{ using type = typename append<TypeList<Container<\_\_VA\_ARGS\_\_>>, typename rewrap<NttpTemplateTypeList<Container>, Elements...>::type>::type; \};\(\backslash\)}}
\DoxyCodeLine{827 \textcolor{preprocessor}{    template<template <typename...> class Final, template<INTERNAL\_CATCH\_REMOVE\_PARENS(signature)> class...Containers, typename...Types>\(\backslash\)}}
\DoxyCodeLine{828 \textcolor{preprocessor}{    struct create<Final, NttpTemplateTypeList<Containers...>, TypeList<Types...>> \{ using type = typename append<Final<>, typename rewrap<NttpTemplateTypeList<Containers>, Types...>::type...>::type; \};}}
\DoxyCodeLine{829 }
\DoxyCodeLine{830 \textcolor{preprocessor}{\#define INTERNAL\_CATCH\_DECLARE\_SIG\_TEST0(TestName)}}
\DoxyCodeLine{831 \textcolor{preprocessor}{\#define INTERNAL\_CATCH\_DECLARE\_SIG\_TEST1(TestName, signature)\(\backslash\)}}
\DoxyCodeLine{832 \textcolor{preprocessor}{    template<INTERNAL\_CATCH\_REMOVE\_PARENS(signature)>\(\backslash\)}}
\DoxyCodeLine{833 \textcolor{preprocessor}{    static void TestName()}}
\DoxyCodeLine{834 \textcolor{preprocessor}{\#define INTERNAL\_CATCH\_DECLARE\_SIG\_TEST\_X(TestName, signature, ...)\(\backslash\)}}
\DoxyCodeLine{835 \textcolor{preprocessor}{    template<INTERNAL\_CATCH\_REMOVE\_PARENS(signature)>\(\backslash\)}}
\DoxyCodeLine{836 \textcolor{preprocessor}{    static void TestName()}}
\DoxyCodeLine{837 }
\DoxyCodeLine{838 \textcolor{preprocessor}{\#define INTERNAL\_CATCH\_DEFINE\_SIG\_TEST0(TestName)}}
\DoxyCodeLine{839 \textcolor{preprocessor}{\#define INTERNAL\_CATCH\_DEFINE\_SIG\_TEST1(TestName, signature)\(\backslash\)}}
\DoxyCodeLine{840 \textcolor{preprocessor}{    template<INTERNAL\_CATCH\_REMOVE\_PARENS(signature)>\(\backslash\)}}
\DoxyCodeLine{841 \textcolor{preprocessor}{    static void TestName()}}
\DoxyCodeLine{842 \textcolor{preprocessor}{\#define INTERNAL\_CATCH\_DEFINE\_SIG\_TEST\_X(TestName, signature,...)\(\backslash\)}}
\DoxyCodeLine{843 \textcolor{preprocessor}{    template<INTERNAL\_CATCH\_REMOVE\_PARENS(signature)>\(\backslash\)}}
\DoxyCodeLine{844 \textcolor{preprocessor}{    static void TestName()}}
\DoxyCodeLine{845 }
\DoxyCodeLine{846 \textcolor{preprocessor}{\#define INTERNAL\_CATCH\_NTTP\_REGISTER0(TestFunc, signature)\(\backslash\)}}
\DoxyCodeLine{847 \textcolor{preprocessor}{    template<typename Type>\(\backslash\)}}
\DoxyCodeLine{848 \textcolor{preprocessor}{    void reg\_test(TypeList<Type>, Catch::NameAndTags nameAndTags)\(\backslash\)}}
\DoxyCodeLine{849 \textcolor{preprocessor}{    \{\(\backslash\)}}
\DoxyCodeLine{850 \textcolor{preprocessor}{        Catch::AutoReg( Catch::makeTestInvoker(\&TestFunc<Type>), CATCH\_INTERNAL\_LINEINFO, Catch::StringRef(), nameAndTags);\(\backslash\)}}
\DoxyCodeLine{851 \textcolor{preprocessor}{    \}}}
\DoxyCodeLine{852 }
\DoxyCodeLine{853 \textcolor{preprocessor}{\#define INTERNAL\_CATCH\_NTTP\_REGISTER(TestFunc, signature, ...)\(\backslash\)}}
\DoxyCodeLine{854 \textcolor{preprocessor}{    template<INTERNAL\_CATCH\_REMOVE\_PARENS(signature)>\(\backslash\)}}
\DoxyCodeLine{855 \textcolor{preprocessor}{    void reg\_test(Nttp<\_\_VA\_ARGS\_\_>, Catch::NameAndTags nameAndTags)\(\backslash\)}}
\DoxyCodeLine{856 \textcolor{preprocessor}{    \{\(\backslash\)}}
\DoxyCodeLine{857 \textcolor{preprocessor}{        Catch::AutoReg( Catch::makeTestInvoker(\&TestFunc<\_\_VA\_ARGS\_\_>), CATCH\_INTERNAL\_LINEINFO, Catch::StringRef(), nameAndTags);\(\backslash\)}}
\DoxyCodeLine{858 \textcolor{preprocessor}{    \}}}
\DoxyCodeLine{859 }
\DoxyCodeLine{860 \textcolor{preprocessor}{\#define INTERNAL\_CATCH\_NTTP\_REGISTER\_METHOD0(TestName, signature, ...)\(\backslash\)}}
\DoxyCodeLine{861 \textcolor{preprocessor}{    template<typename Type>\(\backslash\)}}
\DoxyCodeLine{862 \textcolor{preprocessor}{    void reg\_test(TypeList<Type>, Catch::StringRef className, Catch::NameAndTags nameAndTags)\(\backslash\)}}
\DoxyCodeLine{863 \textcolor{preprocessor}{    \{\(\backslash\)}}
\DoxyCodeLine{864 \textcolor{preprocessor}{        Catch::AutoReg( Catch::makeTestInvoker(\&TestName<Type>::test), CATCH\_INTERNAL\_LINEINFO, className, nameAndTags);\(\backslash\)}}
\DoxyCodeLine{865 \textcolor{preprocessor}{    \}}}
\DoxyCodeLine{866 }
\DoxyCodeLine{867 \textcolor{preprocessor}{\#define INTERNAL\_CATCH\_NTTP\_REGISTER\_METHOD(TestName, signature, ...)\(\backslash\)}}
\DoxyCodeLine{868 \textcolor{preprocessor}{    template<INTERNAL\_CATCH\_REMOVE\_PARENS(signature)>\(\backslash\)}}
\DoxyCodeLine{869 \textcolor{preprocessor}{    void reg\_test(Nttp<\_\_VA\_ARGS\_\_>, Catch::StringRef className, Catch::NameAndTags nameAndTags)\(\backslash\)}}
\DoxyCodeLine{870 \textcolor{preprocessor}{    \{\(\backslash\)}}
\DoxyCodeLine{871 \textcolor{preprocessor}{        Catch::AutoReg( Catch::makeTestInvoker(\&TestName<\_\_VA\_ARGS\_\_>::test), CATCH\_INTERNAL\_LINEINFO, className, nameAndTags);\(\backslash\)}}
\DoxyCodeLine{872 \textcolor{preprocessor}{    \}}}
\DoxyCodeLine{873 }
\DoxyCodeLine{874 \textcolor{preprocessor}{\#define INTERNAL\_CATCH\_DECLARE\_SIG\_TEST\_METHOD0(TestName, ClassName)}}
\DoxyCodeLine{875 \textcolor{preprocessor}{\#define INTERNAL\_CATCH\_DECLARE\_SIG\_TEST\_METHOD1(TestName, ClassName, signature)\(\backslash\)}}
\DoxyCodeLine{876 \textcolor{preprocessor}{    template<typename TestType> \(\backslash\)}}
\DoxyCodeLine{877 \textcolor{preprocessor}{    struct TestName : INTERNAL\_CATCH\_REMOVE\_PARENS(ClassName)<TestType> \{ \(\backslash\)}}
\DoxyCodeLine{878 \textcolor{preprocessor}{        void test();\(\backslash\)}}
\DoxyCodeLine{879 \textcolor{preprocessor}{    \}}}
\DoxyCodeLine{880 }
\DoxyCodeLine{881 \textcolor{preprocessor}{\#define INTERNAL\_CATCH\_DECLARE\_SIG\_TEST\_METHOD\_X(TestName, ClassName, signature, ...)\(\backslash\)}}
\DoxyCodeLine{882 \textcolor{preprocessor}{    template<INTERNAL\_CATCH\_REMOVE\_PARENS(signature)> \(\backslash\)}}
\DoxyCodeLine{883 \textcolor{preprocessor}{    struct TestName : INTERNAL\_CATCH\_REMOVE\_PARENS(ClassName)<\_\_VA\_ARGS\_\_> \{ \(\backslash\)}}
\DoxyCodeLine{884 \textcolor{preprocessor}{        void test();\(\backslash\)}}
\DoxyCodeLine{885 \textcolor{preprocessor}{    \}}}
\DoxyCodeLine{886 }
\DoxyCodeLine{887 \textcolor{preprocessor}{\#define INTERNAL\_CATCH\_DEFINE\_SIG\_TEST\_METHOD0(TestName)}}
\DoxyCodeLine{888 \textcolor{preprocessor}{\#define INTERNAL\_CATCH\_DEFINE\_SIG\_TEST\_METHOD1(TestName, signature)\(\backslash\)}}
\DoxyCodeLine{889 \textcolor{preprocessor}{    template<typename TestType> \(\backslash\)}}
\DoxyCodeLine{890 \textcolor{preprocessor}{    void INTERNAL\_CATCH\_MAKE\_NAMESPACE(TestName)::TestName<TestType>::test()}}
\DoxyCodeLine{891 \textcolor{preprocessor}{\#define INTERNAL\_CATCH\_DEFINE\_SIG\_TEST\_METHOD\_X(TestName, signature, ...)\(\backslash\)}}
\DoxyCodeLine{892 \textcolor{preprocessor}{    template<INTERNAL\_CATCH\_REMOVE\_PARENS(signature)> \(\backslash\)}}
\DoxyCodeLine{893 \textcolor{preprocessor}{    void INTERNAL\_CATCH\_MAKE\_NAMESPACE(TestName)::TestName<\_\_VA\_ARGS\_\_>::test()}}
\DoxyCodeLine{894 }
\DoxyCodeLine{895 \textcolor{preprocessor}{\#ifndef CATCH\_CONFIG\_TRADITIONAL\_MSVC\_PREPROCESSOR}}
\DoxyCodeLine{896 \textcolor{preprocessor}{\#define INTERNAL\_CATCH\_NTTP\_0}}
\DoxyCodeLine{897 \textcolor{preprocessor}{\#define INTERNAL\_CATCH\_NTTP\_GEN(...) INTERNAL\_CATCH\_VA\_NARGS\_IMPL(\_\_VA\_ARGS\_\_, INTERNAL\_CATCH\_NTTP\_1(\_\_VA\_ARGS\_\_), INTERNAL\_CATCH\_NTTP\_1(\_\_VA\_ARGS\_\_), INTERNAL\_CATCH\_NTTP\_1(\_\_VA\_ARGS\_\_), INTERNAL\_CATCH\_NTTP\_1(\_\_VA\_ARGS\_\_), INTERNAL\_CATCH\_NTTP\_1(\_\_VA\_ARGS\_\_), INTERNAL\_CATCH\_NTTP\_1( \_\_VA\_ARGS\_\_), INTERNAL\_CATCH\_NTTP\_1( \_\_VA\_ARGS\_\_), INTERNAL\_CATCH\_NTTP\_1( \_\_VA\_ARGS\_\_), INTERNAL\_CATCH\_NTTP\_1( \_\_VA\_ARGS\_\_),INTERNAL\_CATCH\_NTTP\_1( \_\_VA\_ARGS\_\_), INTERNAL\_CATCH\_NTTP\_0)}}
\DoxyCodeLine{898 \textcolor{preprocessor}{\#define INTERNAL\_CATCH\_DEFINE\_SIG\_TEST\_METHOD(TestName, ...) INTERNAL\_CATCH\_VA\_NARGS\_IMPL( "{}dummy"{}}, \_\_VA\_ARGS\_\_, INTERNAL\_CATCH\_DEFINE\_SIG\_TEST\_METHOD\_X,INTERNAL\_CATCH\_DEFINE\_SIG\_TEST\_METHOD\_X, INTERNAL\_CATCH\_DEFINE\_SIG\_TEST\_METHOD\_X, INTERNAL\_CATCH\_DEFINE\_SIG\_TEST\_METHOD\_X, INTERNAL\_CATCH\_DEFINE\_SIG\_TEST\_METHOD\_X, INTERNAL\_CATCH\_DEFINE\_SIG\_TEST\_METHOD\_X, INTERNAL\_CATCH\_DEFINE\_SIG\_TEST\_METHOD\_X,INTERNAL\_CATCH\_DEFINE\_SIG\_TEST\_METHOD\_X,INTERNAL\_CATCH\_DEFINE\_SIG\_TEST\_METHOD\_X, INTERNAL\_CATCH\_DEFINE\_SIG\_TEST\_METHOD1, INTERNAL\_CATCH\_DEFINE\_SIG\_TEST\_METHOD0)(TestName, \_\_VA\_ARGS\_\_)}
\DoxyCodeLine{899 \textcolor{preprocessor}{\#define INTERNAL\_CATCH\_DECLARE\_SIG\_TEST\_METHOD(TestName, ClassName, ...) INTERNAL\_CATCH\_VA\_NARGS\_IMPL( "{}dummy"{}}, \_\_VA\_ARGS\_\_, INTERNAL\_CATCH\_DECLARE\_SIG\_TEST\_METHOD\_X,INTERNAL\_CATCH\_DECLARE\_SIG\_TEST\_METHOD\_X, INTERNAL\_CATCH\_DECLARE\_SIG\_TEST\_METHOD\_X, INTERNAL\_CATCH\_DECLARE\_SIG\_TEST\_METHOD\_X, INTERNAL\_CATCH\_DECLARE\_SIG\_TEST\_METHOD\_X, INTERNAL\_CATCH\_DECLARE\_SIG\_TEST\_METHOD\_X, INTERNAL\_CATCH\_DECLARE\_SIG\_TEST\_METHOD\_X,INTERNAL\_CATCH\_DECLARE\_SIG\_TEST\_METHOD\_X,INTERNAL\_CATCH\_DECLARE\_SIG\_TEST\_METHOD\_X, INTERNAL\_CATCH\_DECLARE\_SIG\_TEST\_METHOD1, INTERNAL\_CATCH\_DECLARE\_SIG\_TEST\_METHOD0)(TestName, ClassName, \_\_VA\_ARGS\_\_)}
\DoxyCodeLine{900 \textcolor{preprocessor}{\#define INTERNAL\_CATCH\_NTTP\_REG\_METHOD\_GEN(TestName, ...) INTERNAL\_CATCH\_VA\_NARGS\_IMPL( "{}dummy"{}}, \_\_VA\_ARGS\_\_, INTERNAL\_CATCH\_NTTP\_REGISTER\_METHOD, INTERNAL\_CATCH\_NTTP\_REGISTER\_METHOD, INTERNAL\_CATCH\_NTTP\_REGISTER\_METHOD, INTERNAL\_CATCH\_NTTP\_REGISTER\_METHOD, INTERNAL\_CATCH\_NTTP\_REGISTER\_METHOD, INTERNAL\_CATCH\_NTTP\_REGISTER\_METHOD, INTERNAL\_CATCH\_NTTP\_REGISTER\_METHOD, INTERNAL\_CATCH\_NTTP\_REGISTER\_METHOD, INTERNAL\_CATCH\_NTTP\_REGISTER\_METHOD, INTERNAL\_CATCH\_NTTP\_REGISTER\_METHOD0, INTERNAL\_CATCH\_NTTP\_REGISTER\_METHOD0)(TestName, \_\_VA\_ARGS\_\_)}
\DoxyCodeLine{901 \textcolor{preprocessor}{\#define INTERNAL\_CATCH\_NTTP\_REG\_GEN(TestFunc, ...) INTERNAL\_CATCH\_VA\_NARGS\_IMPL( "{}dummy"{}}, \_\_VA\_ARGS\_\_, INTERNAL\_CATCH\_NTTP\_REGISTER, INTERNAL\_CATCH\_NTTP\_REGISTER, INTERNAL\_CATCH\_NTTP\_REGISTER, INTERNAL\_CATCH\_NTTP\_REGISTER, INTERNAL\_CATCH\_NTTP\_REGISTER, INTERNAL\_CATCH\_NTTP\_REGISTER, INTERNAL\_CATCH\_NTTP\_REGISTER, INTERNAL\_CATCH\_NTTP\_REGISTER, INTERNAL\_CATCH\_NTTP\_REGISTER, INTERNAL\_CATCH\_NTTP\_REGISTER0, INTERNAL\_CATCH\_NTTP\_REGISTER0)(TestFunc, \_\_VA\_ARGS\_\_)}
\DoxyCodeLine{902 \textcolor{preprocessor}{\#define INTERNAL\_CATCH\_DEFINE\_SIG\_TEST(TestName, ...) INTERNAL\_CATCH\_VA\_NARGS\_IMPL( "{}dummy"{}}, \_\_VA\_ARGS\_\_, INTERNAL\_CATCH\_DEFINE\_SIG\_TEST\_X, INTERNAL\_CATCH\_DEFINE\_SIG\_TEST\_X, INTERNAL\_CATCH\_DEFINE\_SIG\_TEST\_X, INTERNAL\_CATCH\_DEFINE\_SIG\_TEST\_X, INTERNAL\_CATCH\_DEFINE\_SIG\_TEST\_X, INTERNAL\_CATCH\_DEFINE\_SIG\_TEST\_X, INTERNAL\_CATCH\_DEFINE\_SIG\_TEST\_X, INTERNAL\_CATCH\_DEFINE\_SIG\_TEST\_X,INTERNAL\_CATCH\_DEFINE\_SIG\_TEST\_X,INTERNAL\_CATCH\_DEFINE\_SIG\_TEST1, INTERNAL\_CATCH\_DEFINE\_SIG\_TEST0)(TestName, \_\_VA\_ARGS\_\_)}
\DoxyCodeLine{903 \textcolor{preprocessor}{\#define INTERNAL\_CATCH\_DECLARE\_SIG\_TEST(TestName, ...) INTERNAL\_CATCH\_VA\_NARGS\_IMPL( "{}dummy"{}}, \_\_VA\_ARGS\_\_, INTERNAL\_CATCH\_DECLARE\_SIG\_TEST\_X,INTERNAL\_CATCH\_DECLARE\_SIG\_TEST\_X, INTERNAL\_CATCH\_DECLARE\_SIG\_TEST\_X, INTERNAL\_CATCH\_DECLARE\_SIG\_TEST\_X, INTERNAL\_CATCH\_DECLARE\_SIG\_TEST\_X, INTERNAL\_CATCH\_DECLARE\_SIG\_TEST\_X, INTERNAL\_CATCH\_DEFINE\_SIG\_TEST\_X,INTERNAL\_CATCH\_DECLARE\_SIG\_TEST\_X,INTERNAL\_CATCH\_DECLARE\_SIG\_TEST\_X, INTERNAL\_CATCH\_DECLARE\_SIG\_TEST1, INTERNAL\_CATCH\_DECLARE\_SIG\_TEST0)(TestName, \_\_VA\_ARGS\_\_)}
\DoxyCodeLine{904 \textcolor{preprocessor}{\#define INTERNAL\_CATCH\_REMOVE\_PARENS\_GEN(...) INTERNAL\_CATCH\_VA\_NARGS\_IMPL(\_\_VA\_ARGS\_\_, INTERNAL\_CATCH\_REMOVE\_PARENS\_11\_ARG,INTERNAL\_CATCH\_REMOVE\_PARENS\_10\_ARG,INTERNAL\_CATCH\_REMOVE\_PARENS\_9\_ARG,INTERNAL\_CATCH\_REMOVE\_PARENS\_8\_ARG,INTERNAL\_CATCH\_REMOVE\_PARENS\_7\_ARG,INTERNAL\_CATCH\_REMOVE\_PARENS\_6\_ARG,INTERNAL\_CATCH\_REMOVE\_PARENS\_5\_ARG,INTERNAL\_CATCH\_REMOVE\_PARENS\_4\_ARG,INTERNAL\_CATCH\_REMOVE\_PARENS\_3\_ARG,INTERNAL\_CATCH\_REMOVE\_PARENS\_2\_ARG,INTERNAL\_CATCH\_REMOVE\_PARENS\_1\_ARG)(\_\_VA\_ARGS\_\_)}}
\DoxyCodeLine{905 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{906 \textcolor{preprocessor}{\#define INTERNAL\_CATCH\_NTTP\_0(signature)}}
\DoxyCodeLine{907 \textcolor{preprocessor}{\#define INTERNAL\_CATCH\_NTTP\_GEN(...) INTERNAL\_CATCH\_EXPAND\_VARGS(INTERNAL\_CATCH\_VA\_NARGS\_IMPL(\_\_VA\_ARGS\_\_, INTERNAL\_CATCH\_NTTP\_1, INTERNAL\_CATCH\_NTTP\_1, INTERNAL\_CATCH\_NTTP\_1, INTERNAL\_CATCH\_NTTP\_1, INTERNAL\_CATCH\_NTTP\_1, INTERNAL\_CATCH\_NTTP\_1, INTERNAL\_CATCH\_NTTP\_1, INTERNAL\_CATCH\_NTTP\_1, INTERNAL\_CATCH\_NTTP\_1,INTERNAL\_CATCH\_NTTP\_1, INTERNAL\_CATCH\_NTTP\_0)( \_\_VA\_ARGS\_\_))}}
\DoxyCodeLine{908 \textcolor{preprocessor}{\#define INTERNAL\_CATCH\_DEFINE\_SIG\_TEST\_METHOD(TestName, ...) INTERNAL\_CATCH\_EXPAND\_VARGS(INTERNAL\_CATCH\_VA\_NARGS\_IMPL( "{}dummy"{}}, \_\_VA\_ARGS\_\_, INTERNAL\_CATCH\_DEFINE\_SIG\_TEST\_METHOD\_X,INTERNAL\_CATCH\_DEFINE\_SIG\_TEST\_METHOD\_X, INTERNAL\_CATCH\_DEFINE\_SIG\_TEST\_METHOD\_X, INTERNAL\_CATCH\_DEFINE\_SIG\_TEST\_METHOD\_X, INTERNAL\_CATCH\_DEFINE\_SIG\_TEST\_METHOD\_X, INTERNAL\_CATCH\_DEFINE\_SIG\_TEST\_METHOD\_X, INTERNAL\_CATCH\_DEFINE\_SIG\_TEST\_METHOD\_X,INTERNAL\_CATCH\_DEFINE\_SIG\_TEST\_METHOD\_X,INTERNAL\_CATCH\_DEFINE\_SIG\_TEST\_METHOD\_X, INTERNAL\_CATCH\_DEFINE\_SIG\_TEST\_METHOD1, INTERNAL\_CATCH\_DEFINE\_SIG\_TEST\_METHOD0)(TestName, \_\_VA\_ARGS\_\_))}
\DoxyCodeLine{909 \textcolor{preprocessor}{\#define INTERNAL\_CATCH\_DECLARE\_SIG\_TEST\_METHOD(TestName, ClassName, ...) INTERNAL\_CATCH\_EXPAND\_VARGS(INTERNAL\_CATCH\_VA\_NARGS\_IMPL( "{}dummy"{}}, \_\_VA\_ARGS\_\_, INTERNAL\_CATCH\_DECLARE\_SIG\_TEST\_METHOD\_X,INTERNAL\_CATCH\_DECLARE\_SIG\_TEST\_METHOD\_X, INTERNAL\_CATCH\_DECLARE\_SIG\_TEST\_METHOD\_X, INTERNAL\_CATCH\_DECLARE\_SIG\_TEST\_METHOD\_X, INTERNAL\_CATCH\_DECLARE\_SIG\_TEST\_METHOD\_X, INTERNAL\_CATCH\_DECLARE\_SIG\_TEST\_METHOD\_X, INTERNAL\_CATCH\_DECLARE\_SIG\_TEST\_METHOD\_X,INTERNAL\_CATCH\_DECLARE\_SIG\_TEST\_METHOD\_X,INTERNAL\_CATCH\_DECLARE\_SIG\_TEST\_METHOD\_X, INTERNAL\_CATCH\_DECLARE\_SIG\_TEST\_METHOD1, INTERNAL\_CATCH\_DECLARE\_SIG\_TEST\_METHOD0)(TestName, ClassName, \_\_VA\_ARGS\_\_))}
\DoxyCodeLine{910 \textcolor{preprocessor}{\#define INTERNAL\_CATCH\_NTTP\_REG\_METHOD\_GEN(TestName, ...) INTERNAL\_CATCH\_EXPAND\_VARGS(INTERNAL\_CATCH\_VA\_NARGS\_IMPL( "{}dummy"{}}, \_\_VA\_ARGS\_\_, INTERNAL\_CATCH\_NTTP\_REGISTER\_METHOD, INTERNAL\_CATCH\_NTTP\_REGISTER\_METHOD, INTERNAL\_CATCH\_NTTP\_REGISTER\_METHOD, INTERNAL\_CATCH\_NTTP\_REGISTER\_METHOD, INTERNAL\_CATCH\_NTTP\_REGISTER\_METHOD, INTERNAL\_CATCH\_NTTP\_REGISTER\_METHOD, INTERNAL\_CATCH\_NTTP\_REGISTER\_METHOD, INTERNAL\_CATCH\_NTTP\_REGISTER\_METHOD, INTERNAL\_CATCH\_NTTP\_REGISTER\_METHOD, INTERNAL\_CATCH\_NTTP\_REGISTER\_METHOD0, INTERNAL\_CATCH\_NTTP\_REGISTER\_METHOD0)(TestName, \_\_VA\_ARGS\_\_))}
\DoxyCodeLine{911 \textcolor{preprocessor}{\#define INTERNAL\_CATCH\_NTTP\_REG\_GEN(TestFunc, ...) INTERNAL\_CATCH\_EXPAND\_VARGS(INTERNAL\_CATCH\_VA\_NARGS\_IMPL( "{}dummy"{}}, \_\_VA\_ARGS\_\_, INTERNAL\_CATCH\_NTTP\_REGISTER, INTERNAL\_CATCH\_NTTP\_REGISTER, INTERNAL\_CATCH\_NTTP\_REGISTER, INTERNAL\_CATCH\_NTTP\_REGISTER, INTERNAL\_CATCH\_NTTP\_REGISTER, INTERNAL\_CATCH\_NTTP\_REGISTER, INTERNAL\_CATCH\_NTTP\_REGISTER, INTERNAL\_CATCH\_NTTP\_REGISTER, INTERNAL\_CATCH\_NTTP\_REGISTER, INTERNAL\_CATCH\_NTTP\_REGISTER0, INTERNAL\_CATCH\_NTTP\_REGISTER0)(TestFunc, \_\_VA\_ARGS\_\_))}
\DoxyCodeLine{912 \textcolor{preprocessor}{\#define INTERNAL\_CATCH\_DEFINE\_SIG\_TEST(TestName, ...) INTERNAL\_CATCH\_EXPAND\_VARGS(INTERNAL\_CATCH\_VA\_NARGS\_IMPL( "{}dummy"{}}, \_\_VA\_ARGS\_\_, INTERNAL\_CATCH\_DEFINE\_SIG\_TEST\_X, INTERNAL\_CATCH\_DEFINE\_SIG\_TEST\_X, INTERNAL\_CATCH\_DEFINE\_SIG\_TEST\_X, INTERNAL\_CATCH\_DEFINE\_SIG\_TEST\_X, INTERNAL\_CATCH\_DEFINE\_SIG\_TEST\_X, INTERNAL\_CATCH\_DEFINE\_SIG\_TEST\_X, INTERNAL\_CATCH\_DEFINE\_SIG\_TEST\_X, INTERNAL\_CATCH\_DEFINE\_SIG\_TEST\_X,INTERNAL\_CATCH\_DEFINE\_SIG\_TEST\_X,INTERNAL\_CATCH\_DEFINE\_SIG\_TEST1, INTERNAL\_CATCH\_DEFINE\_SIG\_TEST0)(TestName, \_\_VA\_ARGS\_\_))}
\DoxyCodeLine{913 \textcolor{preprocessor}{\#define INTERNAL\_CATCH\_DECLARE\_SIG\_TEST(TestName, ...) INTERNAL\_CATCH\_EXPAND\_VARGS(INTERNAL\_CATCH\_VA\_NARGS\_IMPL( "{}dummy"{}}, \_\_VA\_ARGS\_\_, INTERNAL\_CATCH\_DECLARE\_SIG\_TEST\_X,INTERNAL\_CATCH\_DECLARE\_SIG\_TEST\_X, INTERNAL\_CATCH\_DECLARE\_SIG\_TEST\_X, INTERNAL\_CATCH\_DECLARE\_SIG\_TEST\_X, INTERNAL\_CATCH\_DECLARE\_SIG\_TEST\_X, INTERNAL\_CATCH\_DECLARE\_SIG\_TEST\_X, INTERNAL\_CATCH\_DEFINE\_SIG\_TEST\_X,INTERNAL\_CATCH\_DECLARE\_SIG\_TEST\_X,INTERNAL\_CATCH\_DECLARE\_SIG\_TEST\_X, INTERNAL\_CATCH\_DECLARE\_SIG\_TEST1, INTERNAL\_CATCH\_DECLARE\_SIG\_TEST0)(TestName, \_\_VA\_ARGS\_\_))}
\DoxyCodeLine{914 \textcolor{preprocessor}{\#define INTERNAL\_CATCH\_REMOVE\_PARENS\_GEN(...) INTERNAL\_CATCH\_EXPAND\_VARGS(INTERNAL\_CATCH\_VA\_NARGS\_IMPL(\_\_VA\_ARGS\_\_, INTERNAL\_CATCH\_REMOVE\_PARENS\_11\_ARG,INTERNAL\_CATCH\_REMOVE\_PARENS\_10\_ARG,INTERNAL\_CATCH\_REMOVE\_PARENS\_9\_ARG,INTERNAL\_CATCH\_REMOVE\_PARENS\_8\_ARG,INTERNAL\_CATCH\_REMOVE\_PARENS\_7\_ARG,INTERNAL\_CATCH\_REMOVE\_PARENS\_6\_ARG,INTERNAL\_CATCH\_REMOVE\_PARENS\_5\_ARG,INTERNAL\_CATCH\_REMOVE\_PARENS\_4\_ARG,INTERNAL\_CATCH\_REMOVE\_PARENS\_3\_ARG,INTERNAL\_CATCH\_REMOVE\_PARENS\_2\_ARG,INTERNAL\_CATCH\_REMOVE\_PARENS\_1\_ARG)(\_\_VA\_ARGS\_\_))}}
\DoxyCodeLine{915 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{916 }
\DoxyCodeLine{917 \textcolor{comment}{// end catch\_preprocessor.hpp}}
\DoxyCodeLine{918 \textcolor{comment}{// start catch\_meta.hpp}}
\DoxyCodeLine{919 }
\DoxyCodeLine{920 }
\DoxyCodeLine{921 \textcolor{preprocessor}{\#include <type\_traits>}}
\DoxyCodeLine{922 }
\DoxyCodeLine{923 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{924     \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{925     \textcolor{keyword}{struct }\mbox{\hyperlink{structCatch_1_1always__false}{always\_false}} : std::false\_type \{\};}
\DoxyCodeLine{926 }
\DoxyCodeLine{927     \textcolor{keyword}{template} <\textcolor{keyword}{typename}> \textcolor{keyword}{struct }\mbox{\hyperlink{structCatch_1_1true__given}{true\_given}} : std::true\_type \{\};}
\DoxyCodeLine{928     \textcolor{keyword}{struct }\mbox{\hyperlink{structCatch_1_1is__callable__tester}{is\_callable\_tester}} \{}
\DoxyCodeLine{929         \textcolor{keyword}{template} <\textcolor{keyword}{typename} Fun, \textcolor{keyword}{typename}... Args>}
\DoxyCodeLine{930         \mbox{\hyperlink{structCatch_1_1true__given}{true\_given<decltype(std::declval<Fun>}}()(std::declval<Args>()...))> \textcolor{keyword}{static} test(\textcolor{keywordtype}{int});}
\DoxyCodeLine{931         \textcolor{keyword}{template} <\textcolor{keyword}{typename}...>}
\DoxyCodeLine{932         std::false\_type \textcolor{keyword}{static} test(...);}
\DoxyCodeLine{933     \};}
\DoxyCodeLine{934 }
\DoxyCodeLine{935     \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{936     \textcolor{keyword}{struct }\mbox{\hyperlink{structCatch_1_1is__callable}{is\_callable}};}
\DoxyCodeLine{937 }
\DoxyCodeLine{938     \textcolor{keyword}{template} <\textcolor{keyword}{typename} Fun, \textcolor{keyword}{typename}... Args>}
\DoxyCodeLine{939     \textcolor{keyword}{struct }\mbox{\hyperlink{structCatch_1_1is__callable}{is\_callable}}<Fun(Args...)> : decltype(is\_callable\_tester::test<Fun, Args...>(0)) \{\};}
\DoxyCodeLine{940 }
\DoxyCodeLine{941 \textcolor{preprocessor}{\#if defined(\_\_cpp\_lib\_is\_invocable) \&\& \_\_cpp\_lib\_is\_invocable >= 201703}}
\DoxyCodeLine{942     \textcolor{comment}{// std::result\_of is deprecated in C++17 and removed in C++20. Hence, it is}}
\DoxyCodeLine{943     \textcolor{comment}{// replaced with std::invoke\_result here.}}
\DoxyCodeLine{944     \textcolor{keyword}{template} <\textcolor{keyword}{typename} Func, \textcolor{keyword}{typename}... U>}
\DoxyCodeLine{945     \textcolor{keyword}{using }FunctionReturnType = std::remove\_reference\_t<std::remove\_cv\_t<std::invoke\_result\_t<Func, U...>>>;}
\DoxyCodeLine{946 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{947     \textcolor{comment}{// Keep ::type here because we still support C++11}}
\DoxyCodeLine{948     \textcolor{keyword}{template} <\textcolor{keyword}{typename} Func, \textcolor{keyword}{typename}... U>}
\DoxyCodeLine{949     \textcolor{keyword}{using }FunctionReturnType = \textcolor{keyword}{typename} std::remove\_reference<\textcolor{keyword}{typename} std::remove\_cv<\textcolor{keyword}{typename} std::result\_of<Func(U...)>::type>::type>::type;}
\DoxyCodeLine{950 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{951 }
\DoxyCodeLine{952 \} \textcolor{comment}{// namespace Catch}}
\DoxyCodeLine{953 }
\DoxyCodeLine{954 \textcolor{keyword}{namespace }mpl\_\{}
\DoxyCodeLine{955     \textcolor{keyword}{struct }na;}
\DoxyCodeLine{956 \}}
\DoxyCodeLine{957 }
\DoxyCodeLine{958 \textcolor{comment}{// end catch\_meta.hpp}}
\DoxyCodeLine{959 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{960 }
\DoxyCodeLine{961 \textcolor{keyword}{template}<\textcolor{keyword}{typename} C>}
\DoxyCodeLine{962 \textcolor{keyword}{class }\mbox{\hyperlink{classCatch_1_1TestInvokerAsMethod}{TestInvokerAsMethod}} : \textcolor{keyword}{public} \mbox{\hyperlink{structCatch_1_1ITestInvoker}{ITestInvoker}} \{}
\DoxyCodeLine{963     void (C::*m\_testAsMethod)();}
\DoxyCodeLine{964 \textcolor{keyword}{public}:}
\DoxyCodeLine{965     \mbox{\hyperlink{classCatch_1_1TestInvokerAsMethod}{TestInvokerAsMethod}}( \textcolor{keywordtype}{void} (C::*testAsMethod)() ) noexcept : m\_testAsMethod( testAsMethod ) \{\}}
\DoxyCodeLine{966 }
\DoxyCodeLine{967     \textcolor{keywordtype}{void} invoke()\textcolor{keyword}{ const override }\{}
\DoxyCodeLine{968         C obj;}
\DoxyCodeLine{969         (obj.*m\_testAsMethod)();}
\DoxyCodeLine{970     \}}
\DoxyCodeLine{971 \};}
\DoxyCodeLine{972 }
\DoxyCodeLine{973 \textcolor{keyword}{auto} makeTestInvoker( \textcolor{keywordtype}{void}(*testAsFunction)() ) noexcept -\/> \mbox{\hyperlink{structCatch_1_1ITestInvoker}{ITestInvoker}}*;}
\DoxyCodeLine{974 }
\DoxyCodeLine{975 template<typename C>}
\DoxyCodeLine{976 auto makeTestInvoker( \textcolor{keywordtype}{void} (C::*testAsMethod)() ) noexcept -\/> \mbox{\hyperlink{structCatch_1_1ITestInvoker}{ITestInvoker}}* \{}
\DoxyCodeLine{977     \textcolor{keywordflow}{return} \textcolor{keyword}{new}(std::nothrow) \mbox{\hyperlink{classCatch_1_1TestInvokerAsMethod}{TestInvokerAsMethod<C>}}( testAsMethod );}
\DoxyCodeLine{978 \}}
\DoxyCodeLine{979 }
\DoxyCodeLine{980 \textcolor{keyword}{struct }\mbox{\hyperlink{structCatch_1_1NameAndTags}{NameAndTags}} \{}
\DoxyCodeLine{981     \mbox{\hyperlink{structCatch_1_1NameAndTags}{NameAndTags}}( \mbox{\hyperlink{classCatch_1_1StringRef}{StringRef}} \textcolor{keyword}{const}\& name\_ = \mbox{\hyperlink{classCatch_1_1StringRef}{StringRef}}(), \mbox{\hyperlink{classCatch_1_1StringRef}{StringRef}} \textcolor{keyword}{const}\& tags\_ = \mbox{\hyperlink{classCatch_1_1StringRef}{StringRef}}() ) \textcolor{keyword}{noexcept};}
\DoxyCodeLine{982     \mbox{\hyperlink{classCatch_1_1StringRef}{StringRef}} name;}
\DoxyCodeLine{983     \mbox{\hyperlink{classCatch_1_1StringRef}{StringRef}} tags;}
\DoxyCodeLine{984 \};}
\DoxyCodeLine{985 }
\DoxyCodeLine{986 \textcolor{keyword}{struct }\mbox{\hyperlink{structCatch_1_1AutoReg}{AutoReg}} : \mbox{\hyperlink{classCatch_1_1NonCopyable}{NonCopyable}} \{}
\DoxyCodeLine{987     \mbox{\hyperlink{structCatch_1_1AutoReg}{AutoReg}}( \mbox{\hyperlink{structCatch_1_1ITestInvoker}{ITestInvoker}}* invoker, \mbox{\hyperlink{structCatch_1_1SourceLineInfo}{SourceLineInfo}} \textcolor{keyword}{const}\& lineInfo, \mbox{\hyperlink{classCatch_1_1StringRef}{StringRef}} \textcolor{keyword}{const}\& classOrMethod, \mbox{\hyperlink{structCatch_1_1NameAndTags}{NameAndTags}} \textcolor{keyword}{const}\& nameAndTags ) \textcolor{keyword}{noexcept};}
\DoxyCodeLine{988     \mbox{\hyperlink{structCatch_1_1AutoReg}{\string~AutoReg}}();}
\DoxyCodeLine{989 \};}
\DoxyCodeLine{990 }
\DoxyCodeLine{991 \} \textcolor{comment}{// end namespace Catch}}
\DoxyCodeLine{992 }
\DoxyCodeLine{993 \textcolor{preprocessor}{\#if defined(CATCH\_CONFIG\_DISABLE)}}
\DoxyCodeLine{994 \textcolor{preprocessor}{    \#define INTERNAL\_CATCH\_TESTCASE\_NO\_REGISTRATION( TestName, ... ) \(\backslash\)}}
\DoxyCodeLine{995 \textcolor{preprocessor}{        static void TestName()}}
\DoxyCodeLine{996 \textcolor{preprocessor}{    \#define INTERNAL\_CATCH\_TESTCASE\_METHOD\_NO\_REGISTRATION( TestName, ClassName, ... ) \(\backslash\)}}
\DoxyCodeLine{997 \textcolor{preprocessor}{        namespace\{                        \(\backslash\)}}
\DoxyCodeLine{998 \textcolor{preprocessor}{            struct TestName : INTERNAL\_CATCH\_REMOVE\_PARENS(ClassName) \{ \(\backslash\)}}
\DoxyCodeLine{999 \textcolor{preprocessor}{                void test();              \(\backslash\)}}
\DoxyCodeLine{1000 \textcolor{preprocessor}{            \};                            \(\backslash\)}}
\DoxyCodeLine{1001 \textcolor{preprocessor}{        \}                                 \(\backslash\)}}
\DoxyCodeLine{1002 \textcolor{preprocessor}{        void TestName::test()}}
\DoxyCodeLine{1003 \textcolor{preprocessor}{    \#define INTERNAL\_CATCH\_TEMPLATE\_TEST\_CASE\_NO\_REGISTRATION\_2( TestName, TestFunc, Name, Tags, Signature, ... )  \(\backslash\)}}
\DoxyCodeLine{1004 \textcolor{preprocessor}{        INTERNAL\_CATCH\_DEFINE\_SIG\_TEST(TestFunc, INTERNAL\_CATCH\_REMOVE\_PARENS(Signature))}}
\DoxyCodeLine{1005 \textcolor{preprocessor}{    \#define INTERNAL\_CATCH\_TEMPLATE\_TEST\_CASE\_METHOD\_NO\_REGISTRATION\_2( TestNameClass, TestName, ClassName, Name, Tags, Signature, ... )    \(\backslash\)}}
\DoxyCodeLine{1006 \textcolor{preprocessor}{        namespace\{                                                                                  \(\backslash\)}}
\DoxyCodeLine{1007 \textcolor{preprocessor}{            namespace INTERNAL\_CATCH\_MAKE\_NAMESPACE(TestName) \{                                      \(\backslash\)}}
\DoxyCodeLine{1008 \textcolor{preprocessor}{            INTERNAL\_CATCH\_DECLARE\_SIG\_TEST\_METHOD(TestName, ClassName, INTERNAL\_CATCH\_REMOVE\_PARENS(Signature));\(\backslash\)}}
\DoxyCodeLine{1009 \textcolor{preprocessor}{        \}                                                                                           \(\backslash\)}}
\DoxyCodeLine{1010 \textcolor{preprocessor}{        \}                                                                                           \(\backslash\)}}
\DoxyCodeLine{1011 \textcolor{preprocessor}{        INTERNAL\_CATCH\_DEFINE\_SIG\_TEST\_METHOD(TestName, INTERNAL\_CATCH\_REMOVE\_PARENS(Signature))}}
\DoxyCodeLine{1012 }
\DoxyCodeLine{1013 \textcolor{preprocessor}{    \#ifndef CATCH\_CONFIG\_TRADITIONAL\_MSVC\_PREPROCESSOR}}
\DoxyCodeLine{1014 \textcolor{preprocessor}{        \#define INTERNAL\_CATCH\_TEMPLATE\_TEST\_CASE\_NO\_REGISTRATION(Name, Tags, ...) \(\backslash\)}}
\DoxyCodeLine{1015 \textcolor{preprocessor}{            INTERNAL\_CATCH\_TEMPLATE\_TEST\_CASE\_NO\_REGISTRATION\_2( INTERNAL\_CATCH\_UNIQUE\_NAME( C\_A\_T\_C\_H\_T\_E\_M\_P\_L\_A\_T\_E\_T\_E\_S\_T\_ ), INTERNAL\_CATCH\_UNIQUE\_NAME( C\_A\_T\_C\_H\_T\_E\_M\_P\_L\_A\_T\_E\_T\_E\_S\_T\_F\_U\_N\_C\_ ), Name, Tags, typename TestType, \_\_VA\_ARGS\_\_ )}}
\DoxyCodeLine{1016 \textcolor{preprocessor}{    \#else}}
\DoxyCodeLine{1017 \textcolor{preprocessor}{        \#define INTERNAL\_CATCH\_TEMPLATE\_TEST\_CASE\_NO\_REGISTRATION(Name, Tags, ...) \(\backslash\)}}
\DoxyCodeLine{1018 \textcolor{preprocessor}{            INTERNAL\_CATCH\_EXPAND\_VARGS( INTERNAL\_CATCH\_TEMPLATE\_TEST\_CASE\_NO\_REGISTRATION\_2( INTERNAL\_CATCH\_UNIQUE\_NAME( C\_A\_T\_C\_H\_T\_E\_M\_P\_L\_A\_T\_E\_T\_E\_S\_T\_ ), INTERNAL\_CATCH\_UNIQUE\_NAME( C\_A\_T\_C\_H\_T\_E\_M\_P\_L\_A\_T\_E\_T\_E\_S\_T\_F\_U\_N\_C\_ ), Name, Tags, typename TestType, \_\_VA\_ARGS\_\_ ) )}}
\DoxyCodeLine{1019 \textcolor{preprocessor}{    \#endif}}
\DoxyCodeLine{1020 }
\DoxyCodeLine{1021 \textcolor{preprocessor}{    \#ifndef CATCH\_CONFIG\_TRADITIONAL\_MSVC\_PREPROCESSOR}}
\DoxyCodeLine{1022 \textcolor{preprocessor}{        \#define INTERNAL\_CATCH\_TEMPLATE\_TEST\_CASE\_SIG\_NO\_REGISTRATION(Name, Tags, Signature, ...) \(\backslash\)}}
\DoxyCodeLine{1023 \textcolor{preprocessor}{            INTERNAL\_CATCH\_TEMPLATE\_TEST\_CASE\_NO\_REGISTRATION\_2( INTERNAL\_CATCH\_UNIQUE\_NAME( C\_A\_T\_C\_H\_T\_E\_M\_P\_L\_A\_T\_E\_T\_E\_S\_T\_ ), INTERNAL\_CATCH\_UNIQUE\_NAME( C\_A\_T\_C\_H\_T\_E\_M\_P\_L\_A\_T\_E\_T\_E\_S\_T\_F\_U\_N\_C\_ ), Name, Tags, Signature, \_\_VA\_ARGS\_\_ )}}
\DoxyCodeLine{1024 \textcolor{preprocessor}{    \#else}}
\DoxyCodeLine{1025 \textcolor{preprocessor}{        \#define INTERNAL\_CATCH\_TEMPLATE\_TEST\_CASE\_SIG\_NO\_REGISTRATION(Name, Tags, Signature, ...) \(\backslash\)}}
\DoxyCodeLine{1026 \textcolor{preprocessor}{            INTERNAL\_CATCH\_EXPAND\_VARGS( INTERNAL\_CATCH\_TEMPLATE\_TEST\_CASE\_NO\_REGISTRATION\_2( INTERNAL\_CATCH\_UNIQUE\_NAME( C\_A\_T\_C\_H\_T\_E\_M\_P\_L\_A\_T\_E\_T\_E\_S\_T\_ ), INTERNAL\_CATCH\_UNIQUE\_NAME( C\_A\_T\_C\_H\_T\_E\_M\_P\_L\_A\_T\_E\_T\_E\_S\_T\_F\_U\_N\_C\_ ), Name, Tags, Signature, \_\_VA\_ARGS\_\_ ) )}}
\DoxyCodeLine{1027 \textcolor{preprocessor}{    \#endif}}
\DoxyCodeLine{1028 }
\DoxyCodeLine{1029 \textcolor{preprocessor}{    \#ifndef CATCH\_CONFIG\_TRADITIONAL\_MSVC\_PREPROCESSOR}}
\DoxyCodeLine{1030 \textcolor{preprocessor}{        \#define INTERNAL\_CATCH\_TEMPLATE\_TEST\_CASE\_METHOD\_NO\_REGISTRATION( ClassName, Name, Tags,... ) \(\backslash\)}}
\DoxyCodeLine{1031 \textcolor{preprocessor}{            INTERNAL\_CATCH\_TEMPLATE\_TEST\_CASE\_METHOD\_NO\_REGISTRATION\_2( INTERNAL\_CATCH\_UNIQUE\_NAME( C\_A\_T\_C\_H\_T\_E\_M\_P\_L\_A\_T\_E\_T\_E\_S\_T\_C\_L\_A\_S\_S\_ ), INTERNAL\_CATCH\_UNIQUE\_NAME( C\_A\_T\_C\_H\_T\_E\_M\_P\_L\_A\_T\_E\_T\_E\_S\_T\_ ) , ClassName, Name, Tags, typename T, \_\_VA\_ARGS\_\_ )}}
\DoxyCodeLine{1032 \textcolor{preprocessor}{    \#else}}
\DoxyCodeLine{1033 \textcolor{preprocessor}{        \#define INTERNAL\_CATCH\_TEMPLATE\_TEST\_CASE\_METHOD\_NO\_REGISTRATION( ClassName, Name, Tags,... ) \(\backslash\)}}
\DoxyCodeLine{1034 \textcolor{preprocessor}{            INTERNAL\_CATCH\_EXPAND\_VARGS( INTERNAL\_CATCH\_TEMPLATE\_TEST\_CASE\_METHOD\_NO\_REGISTRATION\_2( INTERNAL\_CATCH\_UNIQUE\_NAME( C\_A\_T\_C\_H\_T\_E\_M\_P\_L\_A\_T\_E\_T\_E\_S\_T\_C\_L\_A\_S\_S\_ ), INTERNAL\_CATCH\_UNIQUE\_NAME( C\_A\_T\_C\_H\_T\_E\_M\_P\_L\_A\_T\_E\_T\_E\_S\_T\_ ) , ClassName, Name, Tags, typename T, \_\_VA\_ARGS\_\_ ) )}}
\DoxyCodeLine{1035 \textcolor{preprocessor}{    \#endif}}
\DoxyCodeLine{1036 }
\DoxyCodeLine{1037 \textcolor{preprocessor}{    \#ifndef CATCH\_CONFIG\_TRADITIONAL\_MSVC\_PREPROCESSOR}}
\DoxyCodeLine{1038 \textcolor{preprocessor}{        \#define INTERNAL\_CATCH\_TEMPLATE\_TEST\_CASE\_METHOD\_SIG\_NO\_REGISTRATION( ClassName, Name, Tags, Signature, ... ) \(\backslash\)}}
\DoxyCodeLine{1039 \textcolor{preprocessor}{            INTERNAL\_CATCH\_TEMPLATE\_TEST\_CASE\_METHOD\_NO\_REGISTRATION\_2( INTERNAL\_CATCH\_UNIQUE\_NAME( C\_A\_T\_C\_H\_T\_E\_M\_P\_L\_A\_T\_E\_T\_E\_S\_T\_C\_L\_A\_S\_S\_ ), INTERNAL\_CATCH\_UNIQUE\_NAME( C\_A\_T\_C\_H\_T\_E\_M\_P\_L\_A\_T\_E\_T\_E\_S\_T\_ ) , ClassName, Name, Tags, Signature, \_\_VA\_ARGS\_\_ )}}
\DoxyCodeLine{1040 \textcolor{preprocessor}{    \#else}}
\DoxyCodeLine{1041 \textcolor{preprocessor}{        \#define INTERNAL\_CATCH\_TEMPLATE\_TEST\_CASE\_METHOD\_SIG\_NO\_REGISTRATION( ClassName, Name, Tags, Signature, ... ) \(\backslash\)}}
\DoxyCodeLine{1042 \textcolor{preprocessor}{            INTERNAL\_CATCH\_EXPAND\_VARGS( INTERNAL\_CATCH\_TEMPLATE\_TEST\_CASE\_METHOD\_NO\_REGISTRATION\_2( INTERNAL\_CATCH\_UNIQUE\_NAME( C\_A\_T\_C\_H\_T\_E\_M\_P\_L\_A\_T\_E\_T\_E\_S\_T\_C\_L\_A\_S\_S\_ ), INTERNAL\_CATCH\_UNIQUE\_NAME( C\_A\_T\_C\_H\_T\_E\_M\_P\_L\_A\_T\_E\_T\_E\_S\_T\_ ) , ClassName, Name, Tags, Signature, \_\_VA\_ARGS\_\_ ) )}}
\DoxyCodeLine{1043 \textcolor{preprocessor}{    \#endif}}
\DoxyCodeLine{1044 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{1045 }
\DoxyCodeLine{1047 \textcolor{preprocessor}{    \#define INTERNAL\_CATCH\_TESTCASE2( TestName, ... ) \(\backslash\)}}
\DoxyCodeLine{1048 \textcolor{preprocessor}{        static void TestName(); \(\backslash\)}}
\DoxyCodeLine{1049 \textcolor{preprocessor}{        CATCH\_INTERNAL\_START\_WARNINGS\_SUPPRESSION \(\backslash\)}}
\DoxyCodeLine{1050 \textcolor{preprocessor}{        CATCH\_INTERNAL\_SUPPRESS\_GLOBALS\_WARNINGS \(\backslash\)}}
\DoxyCodeLine{1051 \textcolor{preprocessor}{        namespace\{ Catch::AutoReg INTERNAL\_CATCH\_UNIQUE\_NAME( autoRegistrar )( Catch::makeTestInvoker( \&TestName ), CATCH\_INTERNAL\_LINEINFO, Catch::StringRef(), Catch::NameAndTags\{ \_\_VA\_ARGS\_\_ \} ); \} }\textcolor{comment}{/* NOLINT */}\textcolor{preprocessor}{ \(\backslash\)}}
\DoxyCodeLine{1052 \textcolor{preprocessor}{        CATCH\_INTERNAL\_STOP\_WARNINGS\_SUPPRESSION \(\backslash\)}}
\DoxyCodeLine{1053 \textcolor{preprocessor}{        static void TestName()}}
\DoxyCodeLine{1054 \textcolor{preprocessor}{    \#define INTERNAL\_CATCH\_TESTCASE( ... ) \(\backslash\)}}
\DoxyCodeLine{1055 \textcolor{preprocessor}{        INTERNAL\_CATCH\_TESTCASE2( INTERNAL\_CATCH\_UNIQUE\_NAME( C\_A\_T\_C\_H\_T\_E\_S\_T\_ ), \_\_VA\_ARGS\_\_ )}}
\DoxyCodeLine{1056 }
\DoxyCodeLine{1058 \textcolor{preprocessor}{    \#define INTERNAL\_CATCH\_METHOD\_AS\_TEST\_CASE( QualifiedMethod, ... ) \(\backslash\)}}
\DoxyCodeLine{1059 \textcolor{preprocessor}{        CATCH\_INTERNAL\_START\_WARNINGS\_SUPPRESSION \(\backslash\)}}
\DoxyCodeLine{1060 \textcolor{preprocessor}{        CATCH\_INTERNAL\_SUPPRESS\_GLOBALS\_WARNINGS \(\backslash\)}}
\DoxyCodeLine{1061 \textcolor{preprocessor}{        namespace\{ Catch::AutoReg INTERNAL\_CATCH\_UNIQUE\_NAME( autoRegistrar )( Catch::makeTestInvoker( \&QualifiedMethod ), CATCH\_INTERNAL\_LINEINFO, "{}\&"{}} \#QualifiedMethod, Catch::NameAndTags\{ \_\_VA\_ARGS\_\_ \} ); \} \textcolor{comment}{/* NOLINT */}\textcolor{preprocessor}{ \(\backslash\)}}
\DoxyCodeLine{1062 \textcolor{preprocessor}{        CATCH\_INTERNAL\_STOP\_WARNINGS\_SUPPRESSION}}
\DoxyCodeLine{1063 }
\DoxyCodeLine{1065 \textcolor{preprocessor}{    \#define INTERNAL\_CATCH\_TEST\_CASE\_METHOD2( TestName, ClassName, ... )\(\backslash\)}}
\DoxyCodeLine{1066 \textcolor{preprocessor}{        CATCH\_INTERNAL\_START\_WARNINGS\_SUPPRESSION \(\backslash\)}}
\DoxyCodeLine{1067 \textcolor{preprocessor}{        CATCH\_INTERNAL\_SUPPRESS\_GLOBALS\_WARNINGS \(\backslash\)}}
\DoxyCodeLine{1068 \textcolor{preprocessor}{        namespace\{ \(\backslash\)}}
\DoxyCodeLine{1069 \textcolor{preprocessor}{            struct TestName : INTERNAL\_CATCH\_REMOVE\_PARENS(ClassName) \{ \(\backslash\)}}
\DoxyCodeLine{1070 \textcolor{preprocessor}{                void test(); \(\backslash\)}}
\DoxyCodeLine{1071 \textcolor{preprocessor}{            \}; \(\backslash\)}}
\DoxyCodeLine{1072 \textcolor{preprocessor}{            Catch::AutoReg INTERNAL\_CATCH\_UNIQUE\_NAME( autoRegistrar ) ( Catch::makeTestInvoker( \&TestName::test ), CATCH\_INTERNAL\_LINEINFO, \#ClassName, Catch::NameAndTags\{ \_\_VA\_ARGS\_\_ \} ); }\textcolor{comment}{/* NOLINT */}\textcolor{preprocessor}{ \(\backslash\)}}
\DoxyCodeLine{1073 \textcolor{preprocessor}{        \} \(\backslash\)}}
\DoxyCodeLine{1074 \textcolor{preprocessor}{        CATCH\_INTERNAL\_STOP\_WARNINGS\_SUPPRESSION \(\backslash\)}}
\DoxyCodeLine{1075 \textcolor{preprocessor}{        void TestName::test()}}
\DoxyCodeLine{1076 \textcolor{preprocessor}{    \#define INTERNAL\_CATCH\_TEST\_CASE\_METHOD( ClassName, ... ) \(\backslash\)}}
\DoxyCodeLine{1077 \textcolor{preprocessor}{        INTERNAL\_CATCH\_TEST\_CASE\_METHOD2( INTERNAL\_CATCH\_UNIQUE\_NAME( C\_A\_T\_C\_H\_T\_E\_S\_T\_ ), ClassName, \_\_VA\_ARGS\_\_ )}}
\DoxyCodeLine{1078 }
\DoxyCodeLine{1080 \textcolor{preprocessor}{    \#define INTERNAL\_CATCH\_REGISTER\_TESTCASE( Function, ... ) \(\backslash\)}}
\DoxyCodeLine{1081 \textcolor{preprocessor}{        CATCH\_INTERNAL\_START\_WARNINGS\_SUPPRESSION \(\backslash\)}}
\DoxyCodeLine{1082 \textcolor{preprocessor}{        CATCH\_INTERNAL\_SUPPRESS\_GLOBALS\_WARNINGS \(\backslash\)}}
\DoxyCodeLine{1083 \textcolor{preprocessor}{        Catch::AutoReg INTERNAL\_CATCH\_UNIQUE\_NAME( autoRegistrar )( Catch::makeTestInvoker( Function ), CATCH\_INTERNAL\_LINEINFO, Catch::StringRef(), Catch::NameAndTags\{ \_\_VA\_ARGS\_\_ \} ); }\textcolor{comment}{/* NOLINT */}\textcolor{preprocessor}{ \(\backslash\)}}
\DoxyCodeLine{1084 \textcolor{preprocessor}{        CATCH\_INTERNAL\_STOP\_WARNINGS\_SUPPRESSION}}
\DoxyCodeLine{1085 }
\DoxyCodeLine{1087 \textcolor{preprocessor}{    \#define INTERNAL\_CATCH\_TEMPLATE\_TEST\_CASE\_2(TestName, TestFunc, Name, Tags, Signature, ... )\(\backslash\)}}
\DoxyCodeLine{1088 \textcolor{preprocessor}{        CATCH\_INTERNAL\_START\_WARNINGS\_SUPPRESSION \(\backslash\)}}
\DoxyCodeLine{1089 \textcolor{preprocessor}{        CATCH\_INTERNAL\_SUPPRESS\_GLOBALS\_WARNINGS \(\backslash\)}}
\DoxyCodeLine{1090 \textcolor{preprocessor}{        CATCH\_INTERNAL\_SUPPRESS\_ZERO\_VARIADIC\_WARNINGS \(\backslash\)}}
\DoxyCodeLine{1091 \textcolor{preprocessor}{        CATCH\_INTERNAL\_SUPPRESS\_UNUSED\_TEMPLATE\_WARNINGS \(\backslash\)}}
\DoxyCodeLine{1092 \textcolor{preprocessor}{        INTERNAL\_CATCH\_DECLARE\_SIG\_TEST(TestFunc, INTERNAL\_CATCH\_REMOVE\_PARENS(Signature));\(\backslash\)}}
\DoxyCodeLine{1093 \textcolor{preprocessor}{        namespace \{\(\backslash\)}}
\DoxyCodeLine{1094 \textcolor{preprocessor}{        namespace INTERNAL\_CATCH\_MAKE\_NAMESPACE(TestName)\{\(\backslash\)}}
\DoxyCodeLine{1095 \textcolor{preprocessor}{            INTERNAL\_CATCH\_TYPE\_GEN\(\backslash\)}}
\DoxyCodeLine{1096 \textcolor{preprocessor}{            INTERNAL\_CATCH\_NTTP\_GEN(INTERNAL\_CATCH\_REMOVE\_PARENS(Signature))\(\backslash\)}}
\DoxyCodeLine{1097 \textcolor{preprocessor}{            INTERNAL\_CATCH\_NTTP\_REG\_GEN(TestFunc,INTERNAL\_CATCH\_REMOVE\_PARENS(Signature))\(\backslash\)}}
\DoxyCodeLine{1098 \textcolor{preprocessor}{            template<typename...Types> \(\backslash\)}}
\DoxyCodeLine{1099 \textcolor{preprocessor}{            struct TestName\{\(\backslash\)}}
\DoxyCodeLine{1100 \textcolor{preprocessor}{                TestName()\{\(\backslash\)}}
\DoxyCodeLine{1101 \textcolor{preprocessor}{                    int index = 0;                                    \(\backslash\)}}
\DoxyCodeLine{1102 \textcolor{preprocessor}{                    constexpr char const* tmpl\_types[] = \{CATCH\_REC\_LIST(INTERNAL\_CATCH\_STRINGIZE\_WITHOUT\_PARENS, \_\_VA\_ARGS\_\_)\};\(\backslash\)}}
\DoxyCodeLine{1103 \textcolor{preprocessor}{                    using expander = int[];\(\backslash\)}}
\DoxyCodeLine{1104 \textcolor{preprocessor}{                    (void)expander\{(reg\_test(Types\{\}, Catch::NameAndTags\{ Name "{} -\/ "{}} + std::string(tmpl\_types[index]), Tags \} ), index++)... \};\textcolor{comment}{/* NOLINT */}\textcolor{preprocessor}{ \(\backslash\)}}
\DoxyCodeLine{1105 \textcolor{preprocessor}{                \}\(\backslash\)}}
\DoxyCodeLine{1106 \textcolor{preprocessor}{            \};\(\backslash\)}}
\DoxyCodeLine{1107 \textcolor{preprocessor}{            static int INTERNAL\_CATCH\_UNIQUE\_NAME( globalRegistrar ) = []()\{\(\backslash\)}}
\DoxyCodeLine{1108 \textcolor{preprocessor}{            TestName<INTERNAL\_CATCH\_MAKE\_TYPE\_LISTS\_FROM\_TYPES(\_\_VA\_ARGS\_\_)>();\(\backslash\)}}
\DoxyCodeLine{1109 \textcolor{preprocessor}{            return 0;\(\backslash\)}}
\DoxyCodeLine{1110 \textcolor{preprocessor}{        \}();\(\backslash\)}}
\DoxyCodeLine{1111 \textcolor{preprocessor}{        \}\(\backslash\)}}
\DoxyCodeLine{1112 \textcolor{preprocessor}{        \}\(\backslash\)}}
\DoxyCodeLine{1113 \textcolor{preprocessor}{        CATCH\_INTERNAL\_STOP\_WARNINGS\_SUPPRESSION \(\backslash\)}}
\DoxyCodeLine{1114 \textcolor{preprocessor}{        INTERNAL\_CATCH\_DEFINE\_SIG\_TEST(TestFunc,INTERNAL\_CATCH\_REMOVE\_PARENS(Signature))}}
\DoxyCodeLine{1115 }
\DoxyCodeLine{1116 \textcolor{preprocessor}{\#ifndef CATCH\_CONFIG\_TRADITIONAL\_MSVC\_PREPROCESSOR}}
\DoxyCodeLine{1117 \textcolor{preprocessor}{    \#define INTERNAL\_CATCH\_TEMPLATE\_TEST\_CASE(Name, Tags, ...) \(\backslash\)}}
\DoxyCodeLine{1118 \textcolor{preprocessor}{        INTERNAL\_CATCH\_TEMPLATE\_TEST\_CASE\_2( INTERNAL\_CATCH\_UNIQUE\_NAME( C\_A\_T\_C\_H\_T\_E\_M\_P\_L\_A\_T\_E\_T\_E\_S\_T\_ ), INTERNAL\_CATCH\_UNIQUE\_NAME( C\_A\_T\_C\_H\_T\_E\_M\_P\_L\_A\_T\_E\_T\_E\_S\_T\_F\_U\_N\_C\_ ), Name, Tags, typename TestType, \_\_VA\_ARGS\_\_ )}}
\DoxyCodeLine{1119 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{1120 \textcolor{preprocessor}{    \#define INTERNAL\_CATCH\_TEMPLATE\_TEST\_CASE(Name, Tags, ...) \(\backslash\)}}
\DoxyCodeLine{1121 \textcolor{preprocessor}{        INTERNAL\_CATCH\_EXPAND\_VARGS( INTERNAL\_CATCH\_TEMPLATE\_TEST\_CASE\_2( INTERNAL\_CATCH\_UNIQUE\_NAME( C\_A\_T\_C\_H\_T\_E\_M\_P\_L\_A\_T\_E\_T\_E\_S\_T\_ ), INTERNAL\_CATCH\_UNIQUE\_NAME( C\_A\_T\_C\_H\_T\_E\_M\_P\_L\_A\_T\_E\_T\_E\_S\_T\_F\_U\_N\_C\_ ), Name, Tags, typename TestType, \_\_VA\_ARGS\_\_ ) )}}
\DoxyCodeLine{1122 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{1123 }
\DoxyCodeLine{1124 \textcolor{preprocessor}{\#ifndef CATCH\_CONFIG\_TRADITIONAL\_MSVC\_PREPROCESSOR}}
\DoxyCodeLine{1125 \textcolor{preprocessor}{    \#define INTERNAL\_CATCH\_TEMPLATE\_TEST\_CASE\_SIG(Name, Tags, Signature, ...) \(\backslash\)}}
\DoxyCodeLine{1126 \textcolor{preprocessor}{        INTERNAL\_CATCH\_TEMPLATE\_TEST\_CASE\_2( INTERNAL\_CATCH\_UNIQUE\_NAME( C\_A\_T\_C\_H\_T\_E\_M\_P\_L\_A\_T\_E\_T\_E\_S\_T\_ ), INTERNAL\_CATCH\_UNIQUE\_NAME( C\_A\_T\_C\_H\_T\_E\_M\_P\_L\_A\_T\_E\_T\_E\_S\_T\_F\_U\_N\_C\_ ), Name, Tags, Signature, \_\_VA\_ARGS\_\_ )}}
\DoxyCodeLine{1127 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{1128 \textcolor{preprocessor}{    \#define INTERNAL\_CATCH\_TEMPLATE\_TEST\_CASE\_SIG(Name, Tags, Signature, ...) \(\backslash\)}}
\DoxyCodeLine{1129 \textcolor{preprocessor}{        INTERNAL\_CATCH\_EXPAND\_VARGS( INTERNAL\_CATCH\_TEMPLATE\_TEST\_CASE\_2( INTERNAL\_CATCH\_UNIQUE\_NAME( C\_A\_T\_C\_H\_T\_E\_M\_P\_L\_A\_T\_E\_T\_E\_S\_T\_ ), INTERNAL\_CATCH\_UNIQUE\_NAME( C\_A\_T\_C\_H\_T\_E\_M\_P\_L\_A\_T\_E\_T\_E\_S\_T\_F\_U\_N\_C\_ ), Name, Tags, Signature, \_\_VA\_ARGS\_\_ ) )}}
\DoxyCodeLine{1130 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{1131 }
\DoxyCodeLine{1132 \textcolor{preprocessor}{    \#define INTERNAL\_CATCH\_TEMPLATE\_PRODUCT\_TEST\_CASE2(TestName, TestFuncName, Name, Tags, Signature, TmplTypes, TypesList) \(\backslash\)}}
\DoxyCodeLine{1133 \textcolor{preprocessor}{        CATCH\_INTERNAL\_START\_WARNINGS\_SUPPRESSION                      \(\backslash\)}}
\DoxyCodeLine{1134 \textcolor{preprocessor}{        CATCH\_INTERNAL\_SUPPRESS\_GLOBALS\_WARNINGS                      \(\backslash\)}}
\DoxyCodeLine{1135 \textcolor{preprocessor}{        CATCH\_INTERNAL\_SUPPRESS\_ZERO\_VARIADIC\_WARNINGS                \(\backslash\)}}
\DoxyCodeLine{1136 \textcolor{preprocessor}{        CATCH\_INTERNAL\_SUPPRESS\_UNUSED\_TEMPLATE\_WARNINGS              \(\backslash\)}}
\DoxyCodeLine{1137 \textcolor{preprocessor}{        template<typename TestType> static void TestFuncName();       \(\backslash\)}}
\DoxyCodeLine{1138 \textcolor{preprocessor}{        namespace \{\(\backslash\)}}
\DoxyCodeLine{1139 \textcolor{preprocessor}{        namespace INTERNAL\_CATCH\_MAKE\_NAMESPACE(TestName) \{                                     \(\backslash\)}}
\DoxyCodeLine{1140 \textcolor{preprocessor}{            INTERNAL\_CATCH\_TYPE\_GEN                                                  \(\backslash\)}}
\DoxyCodeLine{1141 \textcolor{preprocessor}{            INTERNAL\_CATCH\_NTTP\_GEN(INTERNAL\_CATCH\_REMOVE\_PARENS(Signature))         \(\backslash\)}}
\DoxyCodeLine{1142 \textcolor{preprocessor}{            template<typename... Types>                               \(\backslash\)}}
\DoxyCodeLine{1143 \textcolor{preprocessor}{            struct TestName \{                                         \(\backslash\)}}
\DoxyCodeLine{1144 \textcolor{preprocessor}{                void reg\_tests() \{                                          \(\backslash\)}}
\DoxyCodeLine{1145 \textcolor{preprocessor}{                    int index = 0;                                    \(\backslash\)}}
\DoxyCodeLine{1146 \textcolor{preprocessor}{                    using expander = int[];                           \(\backslash\)}}
\DoxyCodeLine{1147 \textcolor{preprocessor}{                    constexpr char const* tmpl\_types[] = \{CATCH\_REC\_LIST(INTERNAL\_CATCH\_STRINGIZE\_WITHOUT\_PARENS, INTERNAL\_CATCH\_REMOVE\_PARENS(TmplTypes))\};\(\backslash\)}}
\DoxyCodeLine{1148 \textcolor{preprocessor}{                    constexpr char const* types\_list[] = \{CATCH\_REC\_LIST(INTERNAL\_CATCH\_STRINGIZE\_WITHOUT\_PARENS, INTERNAL\_CATCH\_REMOVE\_PARENS(TypesList))\};\(\backslash\)}}
\DoxyCodeLine{1149 \textcolor{preprocessor}{                    constexpr auto num\_types = sizeof(types\_list) / sizeof(types\_list[0]);\(\backslash\)}}
\DoxyCodeLine{1150 \textcolor{preprocessor}{                    (void)expander\{(Catch::AutoReg( Catch::makeTestInvoker( \&TestFuncName<Types> ), CATCH\_INTERNAL\_LINEINFO, Catch::StringRef(), Catch::NameAndTags\{ Name "{} -\/ "{}} + std::string(tmpl\_types[index / num\_types]) + "{}<"{} + std::string(types\_list[index \% num\_types]) + "{}>"{}, Tags \} ), index++)... \};\textcolor{comment}{/* NOLINT */}\textcolor{preprocessor}{\(\backslash\)}}
\DoxyCodeLine{1151 \textcolor{preprocessor}{                \}                                                     \(\backslash\)}}
\DoxyCodeLine{1152 \textcolor{preprocessor}{            \};                                                        \(\backslash\)}}
\DoxyCodeLine{1153 \textcolor{preprocessor}{            static int INTERNAL\_CATCH\_UNIQUE\_NAME( globalRegistrar ) = []()\{ \(\backslash\)}}
\DoxyCodeLine{1154 \textcolor{preprocessor}{                using TestInit = typename create<TestName, decltype(get\_wrapper<INTERNAL\_CATCH\_REMOVE\_PARENS(TmplTypes)>()), TypeList<INTERNAL\_CATCH\_MAKE\_TYPE\_LISTS\_FROM\_TYPES(INTERNAL\_CATCH\_REMOVE\_PARENS(TypesList))>>::type; \(\backslash\)}}
\DoxyCodeLine{1155 \textcolor{preprocessor}{                TestInit t;                                           \(\backslash\)}}
\DoxyCodeLine{1156 \textcolor{preprocessor}{                t.reg\_tests();                                        \(\backslash\)}}
\DoxyCodeLine{1157 \textcolor{preprocessor}{                return 0;                                             \(\backslash\)}}
\DoxyCodeLine{1158 \textcolor{preprocessor}{            \}();                                                      \(\backslash\)}}
\DoxyCodeLine{1159 \textcolor{preprocessor}{        \}                                                             \(\backslash\)}}
\DoxyCodeLine{1160 \textcolor{preprocessor}{        \}                                                             \(\backslash\)}}
\DoxyCodeLine{1161 \textcolor{preprocessor}{        CATCH\_INTERNAL\_STOP\_WARNINGS\_SUPPRESSION                       \(\backslash\)}}
\DoxyCodeLine{1162 \textcolor{preprocessor}{        template<typename TestType>                                   \(\backslash\)}}
\DoxyCodeLine{1163 \textcolor{preprocessor}{        static void TestFuncName()}}
\DoxyCodeLine{1164 }
\DoxyCodeLine{1165 \textcolor{preprocessor}{\#ifndef CATCH\_CONFIG\_TRADITIONAL\_MSVC\_PREPROCESSOR}}
\DoxyCodeLine{1166 \textcolor{preprocessor}{    \#define INTERNAL\_CATCH\_TEMPLATE\_PRODUCT\_TEST\_CASE(Name, Tags, ...)\(\backslash\)}}
\DoxyCodeLine{1167 \textcolor{preprocessor}{        INTERNAL\_CATCH\_TEMPLATE\_PRODUCT\_TEST\_CASE2(INTERNAL\_CATCH\_UNIQUE\_NAME( C\_A\_T\_C\_H\_T\_E\_M\_P\_L\_A\_T\_E\_T\_E\_S\_T\_ ), INTERNAL\_CATCH\_UNIQUE\_NAME( C\_A\_T\_C\_H\_T\_E\_M\_P\_L\_A\_T\_E\_T\_E\_S\_T\_F\_U\_N\_C\_ ), Name, Tags, typename T,\_\_VA\_ARGS\_\_)}}
\DoxyCodeLine{1168 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{1169 \textcolor{preprocessor}{    \#define INTERNAL\_CATCH\_TEMPLATE\_PRODUCT\_TEST\_CASE(Name, Tags, ...)\(\backslash\)}}
\DoxyCodeLine{1170 \textcolor{preprocessor}{        INTERNAL\_CATCH\_EXPAND\_VARGS( INTERNAL\_CATCH\_TEMPLATE\_PRODUCT\_TEST\_CASE2( INTERNAL\_CATCH\_UNIQUE\_NAME( C\_A\_T\_C\_H\_T\_E\_M\_P\_L\_A\_T\_E\_T\_E\_S\_T\_ ), INTERNAL\_CATCH\_UNIQUE\_NAME( C\_A\_T\_C\_H\_T\_E\_M\_P\_L\_A\_T\_E\_T\_E\_S\_T\_F\_U\_N\_C\_ ), Name, Tags, typename T, \_\_VA\_ARGS\_\_ ) )}}
\DoxyCodeLine{1171 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{1172 }
\DoxyCodeLine{1173 \textcolor{preprocessor}{\#ifndef CATCH\_CONFIG\_TRADITIONAL\_MSVC\_PREPROCESSOR}}
\DoxyCodeLine{1174 \textcolor{preprocessor}{    \#define INTERNAL\_CATCH\_TEMPLATE\_PRODUCT\_TEST\_CASE\_SIG(Name, Tags, Signature, ...)\(\backslash\)}}
\DoxyCodeLine{1175 \textcolor{preprocessor}{        INTERNAL\_CATCH\_TEMPLATE\_PRODUCT\_TEST\_CASE2(INTERNAL\_CATCH\_UNIQUE\_NAME( C\_A\_T\_C\_H\_T\_E\_M\_P\_L\_A\_T\_E\_T\_E\_S\_T\_ ), INTERNAL\_CATCH\_UNIQUE\_NAME( C\_A\_T\_C\_H\_T\_E\_M\_P\_L\_A\_T\_E\_T\_E\_S\_T\_F\_U\_N\_C\_ ), Name, Tags, Signature, \_\_VA\_ARGS\_\_)}}
\DoxyCodeLine{1176 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{1177 \textcolor{preprocessor}{    \#define INTERNAL\_CATCH\_TEMPLATE\_PRODUCT\_TEST\_CASE\_SIG(Name, Tags, Signature, ...)\(\backslash\)}}
\DoxyCodeLine{1178 \textcolor{preprocessor}{        INTERNAL\_CATCH\_EXPAND\_VARGS( INTERNAL\_CATCH\_TEMPLATE\_PRODUCT\_TEST\_CASE2( INTERNAL\_CATCH\_UNIQUE\_NAME( C\_A\_T\_C\_H\_T\_E\_M\_P\_L\_A\_T\_E\_T\_E\_S\_T\_ ), INTERNAL\_CATCH\_UNIQUE\_NAME( C\_A\_T\_C\_H\_T\_E\_M\_P\_L\_A\_T\_E\_T\_E\_S\_T\_F\_U\_N\_C\_ ), Name, Tags, Signature, \_\_VA\_ARGS\_\_ ) )}}
\DoxyCodeLine{1179 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{1180 }
\DoxyCodeLine{1181 \textcolor{preprocessor}{    \#define INTERNAL\_CATCH\_TEMPLATE\_LIST\_TEST\_CASE\_2(TestName, TestFunc, Name, Tags, TmplList)\(\backslash\)}}
\DoxyCodeLine{1182 \textcolor{preprocessor}{        CATCH\_INTERNAL\_START\_WARNINGS\_SUPPRESSION \(\backslash\)}}
\DoxyCodeLine{1183 \textcolor{preprocessor}{        CATCH\_INTERNAL\_SUPPRESS\_GLOBALS\_WARNINGS \(\backslash\)}}
\DoxyCodeLine{1184 \textcolor{preprocessor}{        CATCH\_INTERNAL\_SUPPRESS\_UNUSED\_TEMPLATE\_WARNINGS \(\backslash\)}}
\DoxyCodeLine{1185 \textcolor{preprocessor}{        template<typename TestType> static void TestFunc();       \(\backslash\)}}
\DoxyCodeLine{1186 \textcolor{preprocessor}{        namespace \{\(\backslash\)}}
\DoxyCodeLine{1187 \textcolor{preprocessor}{        namespace INTERNAL\_CATCH\_MAKE\_NAMESPACE(TestName)\{\(\backslash\)}}
\DoxyCodeLine{1188 \textcolor{preprocessor}{        INTERNAL\_CATCH\_TYPE\_GEN\(\backslash\)}}
\DoxyCodeLine{1189 \textcolor{preprocessor}{        template<typename... Types>                               \(\backslash\)}}
\DoxyCodeLine{1190 \textcolor{preprocessor}{        struct TestName \{                                         \(\backslash\)}}
\DoxyCodeLine{1191 \textcolor{preprocessor}{            void reg\_tests() \{                                          \(\backslash\)}}
\DoxyCodeLine{1192 \textcolor{preprocessor}{                int index = 0;                                    \(\backslash\)}}
\DoxyCodeLine{1193 \textcolor{preprocessor}{                using expander = int[];                           \(\backslash\)}}
\DoxyCodeLine{1194 \textcolor{preprocessor}{                (void)expander\{(Catch::AutoReg( Catch::makeTestInvoker( \&TestFunc<Types> ), CATCH\_INTERNAL\_LINEINFO, Catch::StringRef(), Catch::NameAndTags\{ Name "{} -\/ "{}} + std::string(INTERNAL\_CATCH\_STRINGIZE(TmplList)) + "{} -\/ "{} + std::to\_string(index), Tags \} ), index++)... \};\textcolor{comment}{/* NOLINT */}\textcolor{preprocessor}{\(\backslash\)}}
\DoxyCodeLine{1195 \textcolor{preprocessor}{            \}                                                     \(\backslash\)}}
\DoxyCodeLine{1196 \textcolor{preprocessor}{        \};\(\backslash\)}}
\DoxyCodeLine{1197 \textcolor{preprocessor}{        static int INTERNAL\_CATCH\_UNIQUE\_NAME( globalRegistrar ) = []()\{ \(\backslash\)}}
\DoxyCodeLine{1198 \textcolor{preprocessor}{                using TestInit = typename convert<TestName, TmplList>::type; \(\backslash\)}}
\DoxyCodeLine{1199 \textcolor{preprocessor}{                TestInit t;                                           \(\backslash\)}}
\DoxyCodeLine{1200 \textcolor{preprocessor}{                t.reg\_tests();                                        \(\backslash\)}}
\DoxyCodeLine{1201 \textcolor{preprocessor}{                return 0;                                             \(\backslash\)}}
\DoxyCodeLine{1202 \textcolor{preprocessor}{            \}();                                                      \(\backslash\)}}
\DoxyCodeLine{1203 \textcolor{preprocessor}{        \}\}\(\backslash\)}}
\DoxyCodeLine{1204 \textcolor{preprocessor}{        CATCH\_INTERNAL\_STOP\_WARNINGS\_SUPPRESSION                       \(\backslash\)}}
\DoxyCodeLine{1205 \textcolor{preprocessor}{        template<typename TestType>                                   \(\backslash\)}}
\DoxyCodeLine{1206 \textcolor{preprocessor}{        static void TestFunc()}}
\DoxyCodeLine{1207 }
\DoxyCodeLine{1208 \textcolor{preprocessor}{    \#define INTERNAL\_CATCH\_TEMPLATE\_LIST\_TEST\_CASE(Name, Tags, TmplList) \(\backslash\)}}
\DoxyCodeLine{1209 \textcolor{preprocessor}{        INTERNAL\_CATCH\_TEMPLATE\_LIST\_TEST\_CASE\_2( INTERNAL\_CATCH\_UNIQUE\_NAME( C\_A\_T\_C\_H\_T\_E\_M\_P\_L\_A\_T\_E\_T\_E\_S\_T\_ ), INTERNAL\_CATCH\_UNIQUE\_NAME( C\_A\_T\_C\_H\_T\_E\_M\_P\_L\_A\_T\_E\_T\_E\_S\_T\_F\_U\_N\_C\_ ), Name, Tags, TmplList )}}
\DoxyCodeLine{1210 }
\DoxyCodeLine{1211 \textcolor{preprocessor}{    \#define INTERNAL\_CATCH\_TEMPLATE\_TEST\_CASE\_METHOD\_2( TestNameClass, TestName, ClassName, Name, Tags, Signature, ... ) \(\backslash\)}}
\DoxyCodeLine{1212 \textcolor{preprocessor}{        CATCH\_INTERNAL\_START\_WARNINGS\_SUPPRESSION \(\backslash\)}}
\DoxyCodeLine{1213 \textcolor{preprocessor}{        CATCH\_INTERNAL\_SUPPRESS\_GLOBALS\_WARNINGS \(\backslash\)}}
\DoxyCodeLine{1214 \textcolor{preprocessor}{        CATCH\_INTERNAL\_SUPPRESS\_ZERO\_VARIADIC\_WARNINGS \(\backslash\)}}
\DoxyCodeLine{1215 \textcolor{preprocessor}{        CATCH\_INTERNAL\_SUPPRESS\_UNUSED\_TEMPLATE\_WARNINGS \(\backslash\)}}
\DoxyCodeLine{1216 \textcolor{preprocessor}{        namespace \{\(\backslash\)}}
\DoxyCodeLine{1217 \textcolor{preprocessor}{        namespace INTERNAL\_CATCH\_MAKE\_NAMESPACE(TestName)\{ \(\backslash\)}}
\DoxyCodeLine{1218 \textcolor{preprocessor}{            INTERNAL\_CATCH\_TYPE\_GEN\(\backslash\)}}
\DoxyCodeLine{1219 \textcolor{preprocessor}{            INTERNAL\_CATCH\_NTTP\_GEN(INTERNAL\_CATCH\_REMOVE\_PARENS(Signature))\(\backslash\)}}
\DoxyCodeLine{1220 \textcolor{preprocessor}{            INTERNAL\_CATCH\_DECLARE\_SIG\_TEST\_METHOD(TestName, ClassName, INTERNAL\_CATCH\_REMOVE\_PARENS(Signature));\(\backslash\)}}
\DoxyCodeLine{1221 \textcolor{preprocessor}{            INTERNAL\_CATCH\_NTTP\_REG\_METHOD\_GEN(TestName, INTERNAL\_CATCH\_REMOVE\_PARENS(Signature))\(\backslash\)}}
\DoxyCodeLine{1222 \textcolor{preprocessor}{            template<typename...Types> \(\backslash\)}}
\DoxyCodeLine{1223 \textcolor{preprocessor}{            struct TestNameClass\{\(\backslash\)}}
\DoxyCodeLine{1224 \textcolor{preprocessor}{                TestNameClass()\{\(\backslash\)}}
\DoxyCodeLine{1225 \textcolor{preprocessor}{                    int index = 0;                                    \(\backslash\)}}
\DoxyCodeLine{1226 \textcolor{preprocessor}{                    constexpr char const* tmpl\_types[] = \{CATCH\_REC\_LIST(INTERNAL\_CATCH\_STRINGIZE\_WITHOUT\_PARENS, \_\_VA\_ARGS\_\_)\};\(\backslash\)}}
\DoxyCodeLine{1227 \textcolor{preprocessor}{                    using expander = int[];\(\backslash\)}}
\DoxyCodeLine{1228 \textcolor{preprocessor}{                    (void)expander\{(reg\_test(Types\{\}, \#ClassName, Catch::NameAndTags\{ Name "{} -\/ "{}} + std::string(tmpl\_types[index]), Tags \} ), index++)... \};\textcolor{comment}{/* NOLINT */}\textcolor{preprocessor}{ \(\backslash\)}}
\DoxyCodeLine{1229 \textcolor{preprocessor}{                \}\(\backslash\)}}
\DoxyCodeLine{1230 \textcolor{preprocessor}{            \};\(\backslash\)}}
\DoxyCodeLine{1231 \textcolor{preprocessor}{            static int INTERNAL\_CATCH\_UNIQUE\_NAME( globalRegistrar ) = []()\{\(\backslash\)}}
\DoxyCodeLine{1232 \textcolor{preprocessor}{                TestNameClass<INTERNAL\_CATCH\_MAKE\_TYPE\_LISTS\_FROM\_TYPES(\_\_VA\_ARGS\_\_)>();\(\backslash\)}}
\DoxyCodeLine{1233 \textcolor{preprocessor}{                return 0;\(\backslash\)}}
\DoxyCodeLine{1234 \textcolor{preprocessor}{        \}();\(\backslash\)}}
\DoxyCodeLine{1235 \textcolor{preprocessor}{        \}\(\backslash\)}}
\DoxyCodeLine{1236 \textcolor{preprocessor}{        \}\(\backslash\)}}
\DoxyCodeLine{1237 \textcolor{preprocessor}{        CATCH\_INTERNAL\_STOP\_WARNINGS\_SUPPRESSION \(\backslash\)}}
\DoxyCodeLine{1238 \textcolor{preprocessor}{        INTERNAL\_CATCH\_DEFINE\_SIG\_TEST\_METHOD(TestName, INTERNAL\_CATCH\_REMOVE\_PARENS(Signature))}}
\DoxyCodeLine{1239 }
\DoxyCodeLine{1240 \textcolor{preprocessor}{\#ifndef CATCH\_CONFIG\_TRADITIONAL\_MSVC\_PREPROCESSOR}}
\DoxyCodeLine{1241 \textcolor{preprocessor}{    \#define INTERNAL\_CATCH\_TEMPLATE\_TEST\_CASE\_METHOD( ClassName, Name, Tags,... ) \(\backslash\)}}
\DoxyCodeLine{1242 \textcolor{preprocessor}{        INTERNAL\_CATCH\_TEMPLATE\_TEST\_CASE\_METHOD\_2( INTERNAL\_CATCH\_UNIQUE\_NAME( C\_A\_T\_C\_H\_T\_E\_M\_P\_L\_A\_T\_E\_T\_E\_S\_T\_C\_L\_A\_S\_S\_ ), INTERNAL\_CATCH\_UNIQUE\_NAME( C\_A\_T\_C\_H\_T\_E\_M\_P\_L\_A\_T\_E\_T\_E\_S\_T\_ ) , ClassName, Name, Tags, typename T, \_\_VA\_ARGS\_\_ )}}
\DoxyCodeLine{1243 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{1244 \textcolor{preprocessor}{    \#define INTERNAL\_CATCH\_TEMPLATE\_TEST\_CASE\_METHOD( ClassName, Name, Tags,... ) \(\backslash\)}}
\DoxyCodeLine{1245 \textcolor{preprocessor}{        INTERNAL\_CATCH\_EXPAND\_VARGS( INTERNAL\_CATCH\_TEMPLATE\_TEST\_CASE\_METHOD\_2( INTERNAL\_CATCH\_UNIQUE\_NAME( C\_A\_T\_C\_H\_T\_E\_M\_P\_L\_A\_T\_E\_T\_E\_S\_T\_C\_L\_A\_S\_S\_ ), INTERNAL\_CATCH\_UNIQUE\_NAME( C\_A\_T\_C\_H\_T\_E\_M\_P\_L\_A\_T\_E\_T\_E\_S\_T\_ ) , ClassName, Name, Tags, typename T, \_\_VA\_ARGS\_\_ ) )}}
\DoxyCodeLine{1246 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{1247 }
\DoxyCodeLine{1248 \textcolor{preprocessor}{\#ifndef CATCH\_CONFIG\_TRADITIONAL\_MSVC\_PREPROCESSOR}}
\DoxyCodeLine{1249 \textcolor{preprocessor}{    \#define INTERNAL\_CATCH\_TEMPLATE\_TEST\_CASE\_METHOD\_SIG( ClassName, Name, Tags, Signature, ... ) \(\backslash\)}}
\DoxyCodeLine{1250 \textcolor{preprocessor}{        INTERNAL\_CATCH\_TEMPLATE\_TEST\_CASE\_METHOD\_2( INTERNAL\_CATCH\_UNIQUE\_NAME( C\_A\_T\_C\_H\_T\_E\_M\_P\_L\_A\_T\_E\_T\_E\_S\_T\_C\_L\_A\_S\_S\_ ), INTERNAL\_CATCH\_UNIQUE\_NAME( C\_A\_T\_C\_H\_T\_E\_M\_P\_L\_A\_T\_E\_T\_E\_S\_T\_ ) , ClassName, Name, Tags, Signature, \_\_VA\_ARGS\_\_ )}}
\DoxyCodeLine{1251 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{1252 \textcolor{preprocessor}{    \#define INTERNAL\_CATCH\_TEMPLATE\_TEST\_CASE\_METHOD\_SIG( ClassName, Name, Tags, Signature, ... ) \(\backslash\)}}
\DoxyCodeLine{1253 \textcolor{preprocessor}{        INTERNAL\_CATCH\_EXPAND\_VARGS( INTERNAL\_CATCH\_TEMPLATE\_TEST\_CASE\_METHOD\_2( INTERNAL\_CATCH\_UNIQUE\_NAME( C\_A\_T\_C\_H\_T\_E\_M\_P\_L\_A\_T\_E\_T\_E\_S\_T\_C\_L\_A\_S\_S\_ ), INTERNAL\_CATCH\_UNIQUE\_NAME( C\_A\_T\_C\_H\_T\_E\_M\_P\_L\_A\_T\_E\_T\_E\_S\_T\_ ) , ClassName, Name, Tags, Signature, \_\_VA\_ARGS\_\_ ) )}}
\DoxyCodeLine{1254 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{1255 }
\DoxyCodeLine{1256 \textcolor{preprocessor}{    \#define INTERNAL\_CATCH\_TEMPLATE\_PRODUCT\_TEST\_CASE\_METHOD\_2(TestNameClass, TestName, ClassName, Name, Tags, Signature, TmplTypes, TypesList)\(\backslash\)}}
\DoxyCodeLine{1257 \textcolor{preprocessor}{        CATCH\_INTERNAL\_START\_WARNINGS\_SUPPRESSION \(\backslash\)}}
\DoxyCodeLine{1258 \textcolor{preprocessor}{        CATCH\_INTERNAL\_SUPPRESS\_GLOBALS\_WARNINGS \(\backslash\)}}
\DoxyCodeLine{1259 \textcolor{preprocessor}{        CATCH\_INTERNAL\_SUPPRESS\_ZERO\_VARIADIC\_WARNINGS \(\backslash\)}}
\DoxyCodeLine{1260 \textcolor{preprocessor}{        CATCH\_INTERNAL\_SUPPRESS\_UNUSED\_TEMPLATE\_WARNINGS \(\backslash\)}}
\DoxyCodeLine{1261 \textcolor{preprocessor}{        template<typename TestType> \(\backslash\)}}
\DoxyCodeLine{1262 \textcolor{preprocessor}{            struct TestName : INTERNAL\_CATCH\_REMOVE\_PARENS(ClassName <TestType>) \{ \(\backslash\)}}
\DoxyCodeLine{1263 \textcolor{preprocessor}{                void test();\(\backslash\)}}
\DoxyCodeLine{1264 \textcolor{preprocessor}{            \};\(\backslash\)}}
\DoxyCodeLine{1265 \textcolor{preprocessor}{        namespace \{\(\backslash\)}}
\DoxyCodeLine{1266 \textcolor{preprocessor}{        namespace INTERNAL\_CATCH\_MAKE\_NAMESPACE(TestNameClass) \{\(\backslash\)}}
\DoxyCodeLine{1267 \textcolor{preprocessor}{            INTERNAL\_CATCH\_TYPE\_GEN                  \(\backslash\)}}
\DoxyCodeLine{1268 \textcolor{preprocessor}{            INTERNAL\_CATCH\_NTTP\_GEN(INTERNAL\_CATCH\_REMOVE\_PARENS(Signature))\(\backslash\)}}
\DoxyCodeLine{1269 \textcolor{preprocessor}{            template<typename...Types>\(\backslash\)}}
\DoxyCodeLine{1270 \textcolor{preprocessor}{            struct TestNameClass\{\(\backslash\)}}
\DoxyCodeLine{1271 \textcolor{preprocessor}{                void reg\_tests()\{\(\backslash\)}}
\DoxyCodeLine{1272 \textcolor{preprocessor}{                    int index = 0;\(\backslash\)}}
\DoxyCodeLine{1273 \textcolor{preprocessor}{                    using expander = int[];\(\backslash\)}}
\DoxyCodeLine{1274 \textcolor{preprocessor}{                    constexpr char const* tmpl\_types[] = \{CATCH\_REC\_LIST(INTERNAL\_CATCH\_STRINGIZE\_WITHOUT\_PARENS, INTERNAL\_CATCH\_REMOVE\_PARENS(TmplTypes))\};\(\backslash\)}}
\DoxyCodeLine{1275 \textcolor{preprocessor}{                    constexpr char const* types\_list[] = \{CATCH\_REC\_LIST(INTERNAL\_CATCH\_STRINGIZE\_WITHOUT\_PARENS, INTERNAL\_CATCH\_REMOVE\_PARENS(TypesList))\};\(\backslash\)}}
\DoxyCodeLine{1276 \textcolor{preprocessor}{                    constexpr auto num\_types = sizeof(types\_list) / sizeof(types\_list[0]);\(\backslash\)}}
\DoxyCodeLine{1277 \textcolor{preprocessor}{                    (void)expander\{(Catch::AutoReg( Catch::makeTestInvoker( \&TestName<Types>::test ), CATCH\_INTERNAL\_LINEINFO, \#ClassName, Catch::NameAndTags\{ Name "{} -\/ "{}} + std::string(tmpl\_types[index / num\_types]) + "{}<"{} + std::string(types\_list[index \% num\_types]) + "{}>"{}, Tags \} ), index++)... \};\textcolor{comment}{/* NOLINT */}\textcolor{preprocessor}{ \(\backslash\)}}
\DoxyCodeLine{1278 \textcolor{preprocessor}{                \}\(\backslash\)}}
\DoxyCodeLine{1279 \textcolor{preprocessor}{            \};\(\backslash\)}}
\DoxyCodeLine{1280 \textcolor{preprocessor}{            static int INTERNAL\_CATCH\_UNIQUE\_NAME( globalRegistrar ) = []()\{\(\backslash\)}}
\DoxyCodeLine{1281 \textcolor{preprocessor}{                using TestInit = typename create<TestNameClass, decltype(get\_wrapper<INTERNAL\_CATCH\_REMOVE\_PARENS(TmplTypes)>()), TypeList<INTERNAL\_CATCH\_MAKE\_TYPE\_LISTS\_FROM\_TYPES(INTERNAL\_CATCH\_REMOVE\_PARENS(TypesList))>>::type;\(\backslash\)}}
\DoxyCodeLine{1282 \textcolor{preprocessor}{                TestInit t;\(\backslash\)}}
\DoxyCodeLine{1283 \textcolor{preprocessor}{                t.reg\_tests();\(\backslash\)}}
\DoxyCodeLine{1284 \textcolor{preprocessor}{                return 0;\(\backslash\)}}
\DoxyCodeLine{1285 \textcolor{preprocessor}{            \}(); \(\backslash\)}}
\DoxyCodeLine{1286 \textcolor{preprocessor}{        \}\(\backslash\)}}
\DoxyCodeLine{1287 \textcolor{preprocessor}{        \}\(\backslash\)}}
\DoxyCodeLine{1288 \textcolor{preprocessor}{        CATCH\_INTERNAL\_STOP\_WARNINGS\_SUPPRESSION \(\backslash\)}}
\DoxyCodeLine{1289 \textcolor{preprocessor}{        template<typename TestType> \(\backslash\)}}
\DoxyCodeLine{1290 \textcolor{preprocessor}{        void TestName<TestType>::test()}}
\DoxyCodeLine{1291 }
\DoxyCodeLine{1292 \textcolor{preprocessor}{\#ifndef CATCH\_CONFIG\_TRADITIONAL\_MSVC\_PREPROCESSOR}}
\DoxyCodeLine{1293 \textcolor{preprocessor}{    \#define INTERNAL\_CATCH\_TEMPLATE\_PRODUCT\_TEST\_CASE\_METHOD( ClassName, Name, Tags, ... )\(\backslash\)}}
\DoxyCodeLine{1294 \textcolor{preprocessor}{        INTERNAL\_CATCH\_TEMPLATE\_PRODUCT\_TEST\_CASE\_METHOD\_2( INTERNAL\_CATCH\_UNIQUE\_NAME( C\_A\_T\_C\_H\_T\_E\_M\_P\_L\_A\_T\_E\_T\_E\_S\_T\_ ), INTERNAL\_CATCH\_UNIQUE\_NAME( C\_A\_T\_C\_H\_T\_E\_M\_P\_L\_A\_T\_E\_T\_E\_S\_T\_F\_U\_N\_C\_ ), ClassName, Name, Tags, typename T, \_\_VA\_ARGS\_\_ )}}
\DoxyCodeLine{1295 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{1296 \textcolor{preprocessor}{    \#define INTERNAL\_CATCH\_TEMPLATE\_PRODUCT\_TEST\_CASE\_METHOD( ClassName, Name, Tags, ... )\(\backslash\)}}
\DoxyCodeLine{1297 \textcolor{preprocessor}{        INTERNAL\_CATCH\_EXPAND\_VARGS( INTERNAL\_CATCH\_TEMPLATE\_PRODUCT\_TEST\_CASE\_METHOD\_2( INTERNAL\_CATCH\_UNIQUE\_NAME( C\_A\_T\_C\_H\_T\_E\_M\_P\_L\_A\_T\_E\_T\_E\_S\_T\_ ), INTERNAL\_CATCH\_UNIQUE\_NAME( C\_A\_T\_C\_H\_T\_E\_M\_P\_L\_A\_T\_E\_T\_E\_S\_T\_F\_U\_N\_C\_ ), ClassName, Name, Tags, typename T,\_\_VA\_ARGS\_\_ ) )}}
\DoxyCodeLine{1298 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{1299 }
\DoxyCodeLine{1300 \textcolor{preprocessor}{\#ifndef CATCH\_CONFIG\_TRADITIONAL\_MSVC\_PREPROCESSOR}}
\DoxyCodeLine{1301 \textcolor{preprocessor}{    \#define INTERNAL\_CATCH\_TEMPLATE\_PRODUCT\_TEST\_CASE\_METHOD\_SIG( ClassName, Name, Tags, Signature, ... )\(\backslash\)}}
\DoxyCodeLine{1302 \textcolor{preprocessor}{        INTERNAL\_CATCH\_TEMPLATE\_PRODUCT\_TEST\_CASE\_METHOD\_2( INTERNAL\_CATCH\_UNIQUE\_NAME( C\_A\_T\_C\_H\_T\_E\_M\_P\_L\_A\_T\_E\_T\_E\_S\_T\_ ), INTERNAL\_CATCH\_UNIQUE\_NAME( C\_A\_T\_C\_H\_T\_E\_M\_P\_L\_A\_T\_E\_T\_E\_S\_T\_F\_U\_N\_C\_ ), ClassName, Name, Tags, Signature, \_\_VA\_ARGS\_\_ )}}
\DoxyCodeLine{1303 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{1304 \textcolor{preprocessor}{    \#define INTERNAL\_CATCH\_TEMPLATE\_PRODUCT\_TEST\_CASE\_METHOD\_SIG( ClassName, Name, Tags, Signature, ... )\(\backslash\)}}
\DoxyCodeLine{1305 \textcolor{preprocessor}{        INTERNAL\_CATCH\_EXPAND\_VARGS( INTERNAL\_CATCH\_TEMPLATE\_PRODUCT\_TEST\_CASE\_METHOD\_2( INTERNAL\_CATCH\_UNIQUE\_NAME( C\_A\_T\_C\_H\_T\_E\_M\_P\_L\_A\_T\_E\_T\_E\_S\_T\_ ), INTERNAL\_CATCH\_UNIQUE\_NAME( C\_A\_T\_C\_H\_T\_E\_M\_P\_L\_A\_T\_E\_T\_E\_S\_T\_F\_U\_N\_C\_ ), ClassName, Name, Tags, Signature,\_\_VA\_ARGS\_\_ ) )}}
\DoxyCodeLine{1306 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{1307 }
\DoxyCodeLine{1308 \textcolor{preprocessor}{    \#define INTERNAL\_CATCH\_TEMPLATE\_LIST\_TEST\_CASE\_METHOD\_2( TestNameClass, TestName, ClassName, Name, Tags, TmplList) \(\backslash\)}}
\DoxyCodeLine{1309 \textcolor{preprocessor}{        CATCH\_INTERNAL\_START\_WARNINGS\_SUPPRESSION \(\backslash\)}}
\DoxyCodeLine{1310 \textcolor{preprocessor}{        CATCH\_INTERNAL\_SUPPRESS\_GLOBALS\_WARNINGS \(\backslash\)}}
\DoxyCodeLine{1311 \textcolor{preprocessor}{        CATCH\_INTERNAL\_SUPPRESS\_UNUSED\_TEMPLATE\_WARNINGS \(\backslash\)}}
\DoxyCodeLine{1312 \textcolor{preprocessor}{        template<typename TestType> \(\backslash\)}}
\DoxyCodeLine{1313 \textcolor{preprocessor}{        struct TestName : INTERNAL\_CATCH\_REMOVE\_PARENS(ClassName <TestType>) \{ \(\backslash\)}}
\DoxyCodeLine{1314 \textcolor{preprocessor}{            void test();\(\backslash\)}}
\DoxyCodeLine{1315 \textcolor{preprocessor}{        \};\(\backslash\)}}
\DoxyCodeLine{1316 \textcolor{preprocessor}{        namespace \{\(\backslash\)}}
\DoxyCodeLine{1317 \textcolor{preprocessor}{        namespace INTERNAL\_CATCH\_MAKE\_NAMESPACE(TestName)\{ \(\backslash\)}}
\DoxyCodeLine{1318 \textcolor{preprocessor}{            INTERNAL\_CATCH\_TYPE\_GEN\(\backslash\)}}
\DoxyCodeLine{1319 \textcolor{preprocessor}{            template<typename...Types>\(\backslash\)}}
\DoxyCodeLine{1320 \textcolor{preprocessor}{            struct TestNameClass\{\(\backslash\)}}
\DoxyCodeLine{1321 \textcolor{preprocessor}{                void reg\_tests()\{\(\backslash\)}}
\DoxyCodeLine{1322 \textcolor{preprocessor}{                    int index = 0;\(\backslash\)}}
\DoxyCodeLine{1323 \textcolor{preprocessor}{                    using expander = int[];\(\backslash\)}}
\DoxyCodeLine{1324 \textcolor{preprocessor}{                    (void)expander\{(Catch::AutoReg( Catch::makeTestInvoker( \&TestName<Types>::test ), CATCH\_INTERNAL\_LINEINFO, \#ClassName, Catch::NameAndTags\{ Name "{} -\/ "{}} + std::string(INTERNAL\_CATCH\_STRINGIZE(TmplList)) + "{} -\/ "{} + std::to\_string(index), Tags \} ), index++)... \};\textcolor{comment}{/* NOLINT */}\textcolor{preprocessor}{ \(\backslash\)}}
\DoxyCodeLine{1325 \textcolor{preprocessor}{                \}\(\backslash\)}}
\DoxyCodeLine{1326 \textcolor{preprocessor}{            \};\(\backslash\)}}
\DoxyCodeLine{1327 \textcolor{preprocessor}{            static int INTERNAL\_CATCH\_UNIQUE\_NAME( globalRegistrar ) = []()\{\(\backslash\)}}
\DoxyCodeLine{1328 \textcolor{preprocessor}{                using TestInit = typename convert<TestNameClass, TmplList>::type;\(\backslash\)}}
\DoxyCodeLine{1329 \textcolor{preprocessor}{                TestInit t;\(\backslash\)}}
\DoxyCodeLine{1330 \textcolor{preprocessor}{                t.reg\_tests();\(\backslash\)}}
\DoxyCodeLine{1331 \textcolor{preprocessor}{                return 0;\(\backslash\)}}
\DoxyCodeLine{1332 \textcolor{preprocessor}{            \}(); \(\backslash\)}}
\DoxyCodeLine{1333 \textcolor{preprocessor}{        \}\}\(\backslash\)}}
\DoxyCodeLine{1334 \textcolor{preprocessor}{        CATCH\_INTERNAL\_STOP\_WARNINGS\_SUPPRESSION \(\backslash\)}}
\DoxyCodeLine{1335 \textcolor{preprocessor}{        template<typename TestType> \(\backslash\)}}
\DoxyCodeLine{1336 \textcolor{preprocessor}{        void TestName<TestType>::test()}}
\DoxyCodeLine{1337 }
\DoxyCodeLine{1338 \textcolor{preprocessor}{\#define INTERNAL\_CATCH\_TEMPLATE\_LIST\_TEST\_CASE\_METHOD(ClassName, Name, Tags, TmplList) \(\backslash\)}}
\DoxyCodeLine{1339 \textcolor{preprocessor}{        INTERNAL\_CATCH\_TEMPLATE\_LIST\_TEST\_CASE\_METHOD\_2( INTERNAL\_CATCH\_UNIQUE\_NAME( C\_A\_T\_C\_H\_T\_E\_M\_P\_L\_A\_T\_E\_T\_E\_S\_T\_ ), INTERNAL\_CATCH\_UNIQUE\_NAME( C\_A\_T\_C\_H\_T\_E\_M\_P\_L\_A\_T\_E\_T\_E\_S\_T\_F\_U\_N\_C\_ ), ClassName, Name, Tags, TmplList )}}
\DoxyCodeLine{1340 }
\DoxyCodeLine{1341 \textcolor{comment}{// end catch\_test\_registry.h}}
\DoxyCodeLine{1342 \textcolor{comment}{// start catch\_capture.hpp}}
\DoxyCodeLine{1343 }
\DoxyCodeLine{1344 \textcolor{comment}{// start catch\_assertionhandler.h}}
\DoxyCodeLine{1345 }
\DoxyCodeLine{1346 \textcolor{comment}{// start catch\_assertioninfo.h}}
\DoxyCodeLine{1347 }
\DoxyCodeLine{1348 \textcolor{comment}{// start catch\_result\_type.h}}
\DoxyCodeLine{1349 }
\DoxyCodeLine{1350 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{1351 }
\DoxyCodeLine{1352     \textcolor{comment}{// ResultWas::OfType enum}}
\DoxyCodeLine{1353     \textcolor{keyword}{struct }\mbox{\hyperlink{structCatch_1_1ResultWas}{ResultWas}} \{ \textcolor{keyword}{enum} OfType \{}
\DoxyCodeLine{1354         Unknown = -\/1,}
\DoxyCodeLine{1355         Ok = 0,}
\DoxyCodeLine{1356         Info = 1,}
\DoxyCodeLine{1357         Warning = 2,}
\DoxyCodeLine{1358 }
\DoxyCodeLine{1359         FailureBit = 0x10,}
\DoxyCodeLine{1360 }
\DoxyCodeLine{1361         ExpressionFailed = FailureBit | 1,}
\DoxyCodeLine{1362         ExplicitFailure = FailureBit | 2,}
\DoxyCodeLine{1363 }
\DoxyCodeLine{1364         Exception = 0x100 | FailureBit,}
\DoxyCodeLine{1365 }
\DoxyCodeLine{1366         ThrewException = Exception | 1,}
\DoxyCodeLine{1367         DidntThrowException = Exception | 2,}
\DoxyCodeLine{1368 }
\DoxyCodeLine{1369         FatalErrorCondition = 0x200 | FailureBit}
\DoxyCodeLine{1370 }
\DoxyCodeLine{1371     \}; \};}
\DoxyCodeLine{1372 }
\DoxyCodeLine{1373     \textcolor{keywordtype}{bool} isOk( ResultWas::OfType resultType );}
\DoxyCodeLine{1374     \textcolor{keywordtype}{bool} isJustInfo( \textcolor{keywordtype}{int} flags );}
\DoxyCodeLine{1375 }
\DoxyCodeLine{1376     \textcolor{comment}{// ResultDisposition::Flags enum}}
\DoxyCodeLine{1377     \textcolor{keyword}{struct }\mbox{\hyperlink{structCatch_1_1ResultDisposition}{ResultDisposition}} \{ \textcolor{keyword}{enum} Flags \{}
\DoxyCodeLine{1378         Normal = 0x01,}
\DoxyCodeLine{1379 }
\DoxyCodeLine{1380         ContinueOnFailure = 0x02,   \textcolor{comment}{// Failures fail test, but execution continues}}
\DoxyCodeLine{1381         FalseTest = 0x04,           \textcolor{comment}{// Prefix expression with !}}
\DoxyCodeLine{1382         SuppressFail = 0x08         \textcolor{comment}{// Failures are reported but do not fail the test}}
\DoxyCodeLine{1383     \}; \};}
\DoxyCodeLine{1384 }
\DoxyCodeLine{1385     ResultDisposition::Flags operator | ( ResultDisposition::Flags lhs, ResultDisposition::Flags rhs );}
\DoxyCodeLine{1386 }
\DoxyCodeLine{1387     \textcolor{keywordtype}{bool} shouldContinueOnFailure( \textcolor{keywordtype}{int} flags );}
\DoxyCodeLine{1388     \textcolor{keyword}{inline} \textcolor{keywordtype}{bool} isFalseTest( \textcolor{keywordtype}{int} flags ) \{ \textcolor{keywordflow}{return} ( flags \& ResultDisposition::FalseTest ) != 0; \}}
\DoxyCodeLine{1389     \textcolor{keywordtype}{bool} shouldSuppressFailure( \textcolor{keywordtype}{int} flags );}
\DoxyCodeLine{1390 }
\DoxyCodeLine{1391 \} \textcolor{comment}{// end namespace Catch}}
\DoxyCodeLine{1392 }
\DoxyCodeLine{1393 \textcolor{comment}{// end catch\_result\_type.h}}
\DoxyCodeLine{1394 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{1395 }
\DoxyCodeLine{1396     \textcolor{keyword}{struct }\mbox{\hyperlink{structCatch_1_1AssertionInfo}{AssertionInfo}}}
\DoxyCodeLine{1397     \{}
\DoxyCodeLine{1398         \mbox{\hyperlink{classCatch_1_1StringRef}{StringRef}} macroName;}
\DoxyCodeLine{1399         \mbox{\hyperlink{structCatch_1_1SourceLineInfo}{SourceLineInfo}} lineInfo;}
\DoxyCodeLine{1400         \mbox{\hyperlink{classCatch_1_1StringRef}{StringRef}} capturedExpression;}
\DoxyCodeLine{1401         ResultDisposition::Flags resultDisposition;}
\DoxyCodeLine{1402 }
\DoxyCodeLine{1403         \textcolor{comment}{// We want to delete this constructor but a compiler bug in 4.8 means}}
\DoxyCodeLine{1404         \textcolor{comment}{// the struct is then treated as non-\/aggregate}}
\DoxyCodeLine{1405         \textcolor{comment}{//AssertionInfo() = delete;}}
\DoxyCodeLine{1406     \};}
\DoxyCodeLine{1407 }
\DoxyCodeLine{1408 \} \textcolor{comment}{// end namespace Catch}}
\DoxyCodeLine{1409 }
\DoxyCodeLine{1410 \textcolor{comment}{// end catch\_assertioninfo.h}}
\DoxyCodeLine{1411 \textcolor{comment}{// start catch\_decomposer.h}}
\DoxyCodeLine{1412 }
\DoxyCodeLine{1413 \textcolor{comment}{// start catch\_tostring.h}}
\DoxyCodeLine{1414 }
\DoxyCodeLine{1415 \textcolor{preprocessor}{\#include <vector>}}
\DoxyCodeLine{1416 \textcolor{preprocessor}{\#include <cstddef>}}
\DoxyCodeLine{1417 \textcolor{preprocessor}{\#include <type\_traits>}}
\DoxyCodeLine{1418 \textcolor{preprocessor}{\#include <string>}}
\DoxyCodeLine{1419 \textcolor{comment}{// start catch\_stream.h}}
\DoxyCodeLine{1420 }
\DoxyCodeLine{1421 \textcolor{preprocessor}{\#include <iosfwd>}}
\DoxyCodeLine{1422 \textcolor{preprocessor}{\#include <cstddef>}}
\DoxyCodeLine{1423 \textcolor{preprocessor}{\#include <ostream>}}
\DoxyCodeLine{1424 }
\DoxyCodeLine{1425 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{1426 }
\DoxyCodeLine{1427     std::ostream\& cout();}
\DoxyCodeLine{1428     std::ostream\& cerr();}
\DoxyCodeLine{1429     std::ostream\& clog();}
\DoxyCodeLine{1430 }
\DoxyCodeLine{1431     \textcolor{keyword}{class }StringRef;}
\DoxyCodeLine{1432 }
\DoxyCodeLine{1433     \textcolor{keyword}{struct }\mbox{\hyperlink{structCatch_1_1IStream}{IStream}} \{}
\DoxyCodeLine{1434         \textcolor{keyword}{virtual} \mbox{\hyperlink{structCatch_1_1IStream}{\string~IStream}}();}
\DoxyCodeLine{1435         \textcolor{keyword}{virtual} std::ostream\& stream() \textcolor{keyword}{const} = 0;}
\DoxyCodeLine{1436     \};}
\DoxyCodeLine{1437 }
\DoxyCodeLine{1438     \textcolor{keyword}{auto} makeStream( \mbox{\hyperlink{classCatch_1_1StringRef}{StringRef}} \textcolor{keyword}{const} \&filename ) -\/> \mbox{\hyperlink{structCatch_1_1IStream}{IStream}} \textcolor{keyword}{const}*;}
\DoxyCodeLine{1439 }
\DoxyCodeLine{1440     \textcolor{keyword}{class }\mbox{\hyperlink{classCatch_1_1ReusableStringStream}{ReusableStringStream}} : \mbox{\hyperlink{classCatch_1_1NonCopyable}{NonCopyable}} \{}
\DoxyCodeLine{1441         std::size\_t m\_index;}
\DoxyCodeLine{1442         std::ostream* m\_oss;}
\DoxyCodeLine{1443     \textcolor{keyword}{public}:}
\DoxyCodeLine{1444         \mbox{\hyperlink{classCatch_1_1ReusableStringStream}{ReusableStringStream}}();}
\DoxyCodeLine{1445         \mbox{\hyperlink{classCatch_1_1ReusableStringStream}{\string~ReusableStringStream}}();}
\DoxyCodeLine{1446 }
\DoxyCodeLine{1447         \textcolor{keyword}{auto} str() \textcolor{keyword}{const} -\/> std::string;}
\DoxyCodeLine{1448 }
\DoxyCodeLine{1449         \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{1450         \textcolor{keyword}{auto} operator << ( T \textcolor{keyword}{const}\& value ) -\/> \mbox{\hyperlink{classCatch_1_1ReusableStringStream}{ReusableStringStream}}\& \{}
\DoxyCodeLine{1451             *m\_oss << value;}
\DoxyCodeLine{1452             \textcolor{keywordflow}{return} *\textcolor{keyword}{this};}
\DoxyCodeLine{1453         \}}
\DoxyCodeLine{1454         \textcolor{keyword}{auto} get() -\/> std::ostream\& \{ \textcolor{keywordflow}{return} *m\_oss; \}}
\DoxyCodeLine{1455     \};}
\DoxyCodeLine{1456 \}}
\DoxyCodeLine{1457 }
\DoxyCodeLine{1458 \textcolor{comment}{// end catch\_stream.h}}
\DoxyCodeLine{1459 \textcolor{comment}{// start catch\_interfaces\_enum\_values\_registry.h}}
\DoxyCodeLine{1460 }
\DoxyCodeLine{1461 \textcolor{preprocessor}{\#include <vector>}}
\DoxyCodeLine{1462 }
\DoxyCodeLine{1463 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{1464 }
\DoxyCodeLine{1465     \textcolor{keyword}{namespace }Detail \{}
\DoxyCodeLine{1466         \textcolor{keyword}{struct }\mbox{\hyperlink{structCatch_1_1Detail_1_1EnumInfo}{EnumInfo}} \{}
\DoxyCodeLine{1467             \mbox{\hyperlink{classCatch_1_1StringRef}{StringRef}} m\_name;}
\DoxyCodeLine{1468             std::vector<std::pair<int, StringRef>> m\_values;}
\DoxyCodeLine{1469 }
\DoxyCodeLine{1470             \mbox{\hyperlink{structCatch_1_1Detail_1_1EnumInfo}{\string~EnumInfo}}();}
\DoxyCodeLine{1471 }
\DoxyCodeLine{1472             \mbox{\hyperlink{classCatch_1_1StringRef}{StringRef}} lookup( \textcolor{keywordtype}{int} value ) \textcolor{keyword}{const};}
\DoxyCodeLine{1473         \};}
\DoxyCodeLine{1474     \} \textcolor{comment}{// namespace Detail}}
\DoxyCodeLine{1475 }
\DoxyCodeLine{1476     \textcolor{keyword}{struct }\mbox{\hyperlink{structCatch_1_1IMutableEnumValuesRegistry}{IMutableEnumValuesRegistry}} \{}
\DoxyCodeLine{1477         \textcolor{keyword}{virtual} \mbox{\hyperlink{structCatch_1_1IMutableEnumValuesRegistry}{\string~IMutableEnumValuesRegistry}}();}
\DoxyCodeLine{1478 }
\DoxyCodeLine{1479         \textcolor{keyword}{virtual} \mbox{\hyperlink{structCatch_1_1Detail_1_1EnumInfo}{Detail::EnumInfo}} \textcolor{keyword}{const}\& registerEnum( \mbox{\hyperlink{classCatch_1_1StringRef}{StringRef}} enumName, \mbox{\hyperlink{classCatch_1_1StringRef}{StringRef}} allEnums, std::vector<int> \textcolor{keyword}{const}\& values ) = 0;}
\DoxyCodeLine{1480 }
\DoxyCodeLine{1481         \textcolor{keyword}{template}<\textcolor{keyword}{typename} E>}
\DoxyCodeLine{1482         \mbox{\hyperlink{structCatch_1_1Detail_1_1EnumInfo}{Detail::EnumInfo}} \textcolor{keyword}{const}\& registerEnum( \mbox{\hyperlink{classCatch_1_1StringRef}{StringRef}} enumName, \mbox{\hyperlink{classCatch_1_1StringRef}{StringRef}} allEnums, std::initializer\_list<E> values ) \{}
\DoxyCodeLine{1483             \textcolor{keyword}{static\_assert}(\textcolor{keyword}{sizeof}(int) >= \textcolor{keyword}{sizeof}(E), \textcolor{stringliteral}{"{}Cannot serialize enum to int"{}});}
\DoxyCodeLine{1484             std::vector<int> intValues;}
\DoxyCodeLine{1485             intValues.reserve( values.size() );}
\DoxyCodeLine{1486             \textcolor{keywordflow}{for}( \textcolor{keyword}{auto} enumValue : values )}
\DoxyCodeLine{1487                 intValues.push\_back( \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{int}\textcolor{keyword}{>}( enumValue ) );}
\DoxyCodeLine{1488             \textcolor{keywordflow}{return} registerEnum( enumName, allEnums, intValues );}
\DoxyCodeLine{1489         \}}
\DoxyCodeLine{1490     \};}
\DoxyCodeLine{1491 }
\DoxyCodeLine{1492 \} \textcolor{comment}{// Catch}}
\DoxyCodeLine{1493 }
\DoxyCodeLine{1494 \textcolor{comment}{// end catch\_interfaces\_enum\_values\_registry.h}}
\DoxyCodeLine{1495 }
\DoxyCodeLine{1496 \textcolor{preprocessor}{\#ifdef CATCH\_CONFIG\_CPP17\_STRING\_VIEW}}
\DoxyCodeLine{1497 \textcolor{preprocessor}{\#include <string\_view>}}
\DoxyCodeLine{1498 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{1499 }
\DoxyCodeLine{1500 \textcolor{preprocessor}{\#ifdef \_\_OBJC\_\_}}
\DoxyCodeLine{1501 \textcolor{comment}{// start catch\_objc\_arc.hpp}}
\DoxyCodeLine{1502 }
\DoxyCodeLine{1503 \textcolor{preprocessor}{\#import <Foundation/Foundation.h>}}
\DoxyCodeLine{1504 }
\DoxyCodeLine{1505 \textcolor{preprocessor}{\#ifdef \_\_has\_feature}}
\DoxyCodeLine{1506 \textcolor{preprocessor}{\#define CATCH\_ARC\_ENABLED \_\_has\_feature(objc\_arc)}}
\DoxyCodeLine{1507 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{1508 \textcolor{preprocessor}{\#define CATCH\_ARC\_ENABLED 0}}
\DoxyCodeLine{1509 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{1510 }
\DoxyCodeLine{1511 \textcolor{keywordtype}{void} arcSafeRelease( NSObject* obj );}
\DoxyCodeLine{1512 \textcolor{keywordtype}{id} performOptionalSelector( \textcolor{keywordtype}{id} obj, \textcolor{keywordtype}{SEL} sel );}
\DoxyCodeLine{1513 }
\DoxyCodeLine{1514 \textcolor{preprocessor}{\#if !CATCH\_ARC\_ENABLED}}
\DoxyCodeLine{1515 \textcolor{keyword}{inline} \textcolor{keywordtype}{void} arcSafeRelease( NSObject* obj ) \{}
\DoxyCodeLine{1516     [obj release];}
\DoxyCodeLine{1517 \}}
\DoxyCodeLine{1518 \textcolor{keyword}{inline} \textcolor{keywordtype}{id} performOptionalSelector( \textcolor{keywordtype}{id} obj, \textcolor{keywordtype}{SEL} sel ) \{}
\DoxyCodeLine{1519     \textcolor{keywordflow}{if}( [obj respondsToSelector: sel] )}
\DoxyCodeLine{1520         \textcolor{keywordflow}{return} [obj performSelector: sel];}
\DoxyCodeLine{1521     \textcolor{keywordflow}{return} nil;}
\DoxyCodeLine{1522 \}}
\DoxyCodeLine{1523 \textcolor{preprocessor}{\#define CATCH\_UNSAFE\_UNRETAINED}}
\DoxyCodeLine{1524 \textcolor{preprocessor}{\#define CATCH\_ARC\_STRONG}}
\DoxyCodeLine{1525 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{1526 \textcolor{keyword}{inline} \textcolor{keywordtype}{void} arcSafeRelease( NSObject* )\{\}}
\DoxyCodeLine{1527 \textcolor{keyword}{inline} \textcolor{keywordtype}{id} performOptionalSelector( \textcolor{keywordtype}{id} obj, \textcolor{keywordtype}{SEL} sel ) \{}
\DoxyCodeLine{1528 \textcolor{preprocessor}{\#ifdef \_\_clang\_\_}}
\DoxyCodeLine{1529 \textcolor{preprocessor}{\#pragma clang diagnostic push}}
\DoxyCodeLine{1530 \textcolor{preprocessor}{\#pragma clang diagnostic ignored "{}-\/Warc-\/performSelector-\/leaks"{}}}
\DoxyCodeLine{1531 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{1532     \textcolor{keywordflow}{if}( [obj respondsToSelector: sel] )}
\DoxyCodeLine{1533         \textcolor{keywordflow}{return} [obj performSelector: sel];}
\DoxyCodeLine{1534 \textcolor{preprocessor}{\#ifdef \_\_clang\_\_}}
\DoxyCodeLine{1535 \textcolor{preprocessor}{\#pragma clang diagnostic pop}}
\DoxyCodeLine{1536 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{1537     \textcolor{keywordflow}{return} nil;}
\DoxyCodeLine{1538 \}}
\DoxyCodeLine{1539 \textcolor{preprocessor}{\#define CATCH\_UNSAFE\_UNRETAINED \_\_unsafe\_unretained}}
\DoxyCodeLine{1540 \textcolor{preprocessor}{\#define CATCH\_ARC\_STRONG \_\_strong}}
\DoxyCodeLine{1541 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{1542 }
\DoxyCodeLine{1543 \textcolor{comment}{// end catch\_objc\_arc.hpp}}
\DoxyCodeLine{1544 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{1545 }
\DoxyCodeLine{1546 \textcolor{preprocessor}{\#ifdef \_MSC\_VER}}
\DoxyCodeLine{1547 \textcolor{preprocessor}{\#pragma warning(push)}}
\DoxyCodeLine{1548 \textcolor{preprocessor}{\#pragma warning(disable:4180) }\textcolor{comment}{// We attempt to stream a function (address) by const\&, which MSVC complains about but is harmless}}
\DoxyCodeLine{1549 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{1550 }
\DoxyCodeLine{1551 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{1552     \textcolor{keyword}{namespace }Detail \{}
\DoxyCodeLine{1553 }
\DoxyCodeLine{1554         \textcolor{keyword}{extern} \textcolor{keyword}{const} std::string unprintableString;}
\DoxyCodeLine{1555 }
\DoxyCodeLine{1556         std::string rawMemoryToString( \textcolor{keyword}{const} \textcolor{keywordtype}{void} *\textcolor{keywordtype}{object}, std::size\_t size );}
\DoxyCodeLine{1557 }
\DoxyCodeLine{1558         \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{1559         std::string rawMemoryToString( \textcolor{keyword}{const} T\& \textcolor{keywordtype}{object} ) \{}
\DoxyCodeLine{1560           \textcolor{keywordflow}{return} rawMemoryToString( \&\textcolor{keywordtype}{object}, \textcolor{keyword}{sizeof}(\textcolor{keywordtype}{object}) );}
\DoxyCodeLine{1561         \}}
\DoxyCodeLine{1562 }
\DoxyCodeLine{1563         \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{1564         \textcolor{keyword}{class }\mbox{\hyperlink{classCatch_1_1Detail_1_1IsStreamInsertable}{IsStreamInsertable}} \{}
\DoxyCodeLine{1565             \textcolor{keyword}{template}<\textcolor{keyword}{typename} Stream, \textcolor{keyword}{typename} U>}
\DoxyCodeLine{1566             \textcolor{keyword}{static} \textcolor{keyword}{auto} test(\textcolor{keywordtype}{int})}
\DoxyCodeLine{1567                 -\/> \textcolor{keyword}{decltype}(std::declval<Stream\&>() << std::declval<U>(), std::true\_type());}
\DoxyCodeLine{1568 }
\DoxyCodeLine{1569             \textcolor{keyword}{template}<\textcolor{keyword}{typename}, \textcolor{keyword}{typename}>}
\DoxyCodeLine{1570             \textcolor{keyword}{static} \textcolor{keyword}{auto} test(...)-\/>std::false\_type;}
\DoxyCodeLine{1571 }
\DoxyCodeLine{1572         \textcolor{keyword}{public}:}
\DoxyCodeLine{1573             \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{bool} value = \textcolor{keyword}{decltype}(test<std::ostream, const T\&>(0))::value;}
\DoxyCodeLine{1574         \};}
\DoxyCodeLine{1575 }
\DoxyCodeLine{1576         \textcolor{keyword}{template}<\textcolor{keyword}{typename} E>}
\DoxyCodeLine{1577         std::string convertUnknownEnumToString( E e );}
\DoxyCodeLine{1578 }
\DoxyCodeLine{1579         \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{1580         \textcolor{keyword}{typename} std::enable\_if<}
\DoxyCodeLine{1581             !std::is\_enum<T>::value \&\& !std::is\_base\_of<std::exception, T>::value,}
\DoxyCodeLine{1582         std::string>::type convertUnstreamable( T \textcolor{keyword}{const}\& ) \{}
\DoxyCodeLine{1583             \textcolor{keywordflow}{return} Detail::unprintableString;}
\DoxyCodeLine{1584         \}}
\DoxyCodeLine{1585         \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{1586         \textcolor{keyword}{typename} std::enable\_if<}
\DoxyCodeLine{1587             !std::is\_enum<T>::value \&\& std::is\_base\_of<std::exception, T>::value,}
\DoxyCodeLine{1588          std::string>::type convertUnstreamable(T \textcolor{keyword}{const}\& ex) \{}
\DoxyCodeLine{1589             \textcolor{keywordflow}{return} ex.what();}
\DoxyCodeLine{1590         \}}
\DoxyCodeLine{1591 }
\DoxyCodeLine{1592         \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{1593         \textcolor{keyword}{typename} std::enable\_if<}
\DoxyCodeLine{1594             std::is\_enum<T>::value}
\DoxyCodeLine{1595         , std::string>::type convertUnstreamable( T \textcolor{keyword}{const}\& value ) \{}
\DoxyCodeLine{1596             \textcolor{keywordflow}{return} convertUnknownEnumToString( value );}
\DoxyCodeLine{1597         \}}
\DoxyCodeLine{1598 }
\DoxyCodeLine{1599 \textcolor{preprocessor}{\#if defined(\_MANAGED)}}
\DoxyCodeLine{1601         \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{1602         std::string clrReferenceToString( T\string^ ref ) \{}
\DoxyCodeLine{1603             \textcolor{keywordflow}{if} (ref == \textcolor{keyword}{nullptr})}
\DoxyCodeLine{1604                 \textcolor{keywordflow}{return} std::string(\textcolor{stringliteral}{"{}null"{}});}
\DoxyCodeLine{1605             \textcolor{keyword}{auto} bytes = System::Text::Encoding::UTF8-\/>GetBytes(ref-\/>ToString());}
\DoxyCodeLine{1606             cli::pin\_ptr<System::Byte> p = \&bytes[0];}
\DoxyCodeLine{1607             \textcolor{keywordflow}{return} std::string(\textcolor{keyword}{reinterpret\_cast<}\textcolor{keywordtype}{char} \textcolor{keyword}{const }*\textcolor{keyword}{>}(p), bytes-\/>Length);}
\DoxyCodeLine{1608         \}}
\DoxyCodeLine{1609 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{1610 }
\DoxyCodeLine{1611     \} \textcolor{comment}{// namespace Detail}}
\DoxyCodeLine{1612 }
\DoxyCodeLine{1613     \textcolor{comment}{// If we decide for C++14, change these to enable\_if\_ts}}
\DoxyCodeLine{1614     \textcolor{keyword}{template} <\textcolor{keyword}{typename} T, \textcolor{keyword}{typename} = \textcolor{keywordtype}{void}>}
\DoxyCodeLine{1615     \textcolor{keyword}{struct }\mbox{\hyperlink{structCatch_1_1StringMaker}{StringMaker}} \{}
\DoxyCodeLine{1616         \textcolor{keyword}{template} <\textcolor{keyword}{typename} Fake = T>}
\DoxyCodeLine{1617         \textcolor{keyword}{static}}
\DoxyCodeLine{1618         \textcolor{keyword}{typename} std::enable\_if<::Catch::Detail::IsStreamInsertable<Fake>::value, std::string>::type}
\DoxyCodeLine{1619             convert(\textcolor{keyword}{const} Fake\& value) \{}
\DoxyCodeLine{1620                 \mbox{\hyperlink{classCatch_1_1ReusableStringStream}{ReusableStringStream}} rss;}
\DoxyCodeLine{1621                 \textcolor{comment}{// NB: call using the function-\/like syntax to avoid ambiguity with}}
\DoxyCodeLine{1622                 \textcolor{comment}{// user-\/defined templated operator<< under clang.}}
\DoxyCodeLine{1623                 rss.operator<<(value);}
\DoxyCodeLine{1624                 \textcolor{keywordflow}{return} rss.str();}
\DoxyCodeLine{1625         \}}
\DoxyCodeLine{1626 }
\DoxyCodeLine{1627         \textcolor{keyword}{template} <\textcolor{keyword}{typename} Fake = T>}
\DoxyCodeLine{1628         \textcolor{keyword}{static}}
\DoxyCodeLine{1629         \textcolor{keyword}{typename} std::enable\_if<!::Catch::Detail::IsStreamInsertable<Fake>::value, std::string>::type}
\DoxyCodeLine{1630             convert( \textcolor{keyword}{const} Fake\& value ) \{}
\DoxyCodeLine{1631 \textcolor{preprocessor}{\#if !defined(CATCH\_CONFIG\_FALLBACK\_STRINGIFIER)}}
\DoxyCodeLine{1632             \textcolor{keywordflow}{return} Detail::convertUnstreamable(value);}
\DoxyCodeLine{1633 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{1634             \textcolor{keywordflow}{return} CATCH\_CONFIG\_FALLBACK\_STRINGIFIER(value);}
\DoxyCodeLine{1635 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{1636         \}}
\DoxyCodeLine{1637     \};}
\DoxyCodeLine{1638 }
\DoxyCodeLine{1639     \textcolor{keyword}{namespace }Detail \{}
\DoxyCodeLine{1640 }
\DoxyCodeLine{1641         \textcolor{comment}{// This function dispatches all stringification requests inside of Catch.}}
\DoxyCodeLine{1642         \textcolor{comment}{// Should be preferably called fully qualified, like ::Catch::Detail::stringify}}
\DoxyCodeLine{1643         \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{1644         std::string stringify(\textcolor{keyword}{const} T\& e) \{}
\DoxyCodeLine{1645             return ::Catch::StringMaker<typename std::remove\_cv<typename std::remove\_reference<T>::type>::type>::convert(e);}
\DoxyCodeLine{1646         \}}
\DoxyCodeLine{1647 }
\DoxyCodeLine{1648         \textcolor{keyword}{template}<\textcolor{keyword}{typename} E>}
\DoxyCodeLine{1649         std::string convertUnknownEnumToString( E e ) \{}
\DoxyCodeLine{1650             return ::Catch::Detail::stringify(\textcolor{keyword}{static\_cast<}typename std::underlying\_type<E>::type\textcolor{keyword}{>}(e));}
\DoxyCodeLine{1651         \}}
\DoxyCodeLine{1652 }
\DoxyCodeLine{1653 \textcolor{preprocessor}{\#if defined(\_MANAGED)}}
\DoxyCodeLine{1654         \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{1655         std::string stringify( T\string^ e ) \{}
\DoxyCodeLine{1656             return ::Catch::StringMaker<T\string^>::convert(e);}
\DoxyCodeLine{1657         \}}
\DoxyCodeLine{1658 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{1659 }
\DoxyCodeLine{1660     \} \textcolor{comment}{// namespace Detail}}
\DoxyCodeLine{1661 }
\DoxyCodeLine{1662     \textcolor{comment}{// Some predefined specializations}}
\DoxyCodeLine{1663 }
\DoxyCodeLine{1664     \textcolor{keyword}{template}<>}
\DoxyCodeLine{1665     \textcolor{keyword}{struct }\mbox{\hyperlink{structCatch_1_1StringMaker}{StringMaker}}<std::string> \{}
\DoxyCodeLine{1666         \textcolor{keyword}{static} std::string convert(\textcolor{keyword}{const} std::string\& str);}
\DoxyCodeLine{1667     \};}
\DoxyCodeLine{1668 }
\DoxyCodeLine{1669 \textcolor{preprocessor}{\#ifdef CATCH\_CONFIG\_CPP17\_STRING\_VIEW}}
\DoxyCodeLine{1670     \textcolor{keyword}{template}<>}
\DoxyCodeLine{1671     \textcolor{keyword}{struct }\mbox{\hyperlink{structCatch_1_1StringMaker}{StringMaker}}<std::string\_view> \{}
\DoxyCodeLine{1672         \textcolor{keyword}{static} std::string convert(std::string\_view str);}
\DoxyCodeLine{1673     \};}
\DoxyCodeLine{1674 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{1675 }
\DoxyCodeLine{1676     \textcolor{keyword}{template}<>}
\DoxyCodeLine{1677     \textcolor{keyword}{struct }\mbox{\hyperlink{structCatch_1_1StringMaker}{StringMaker}}<char const *> \{}
\DoxyCodeLine{1678         \textcolor{keyword}{static} std::string convert(\textcolor{keywordtype}{char} \textcolor{keyword}{const} * str);}
\DoxyCodeLine{1679     \};}
\DoxyCodeLine{1680     \textcolor{keyword}{template}<>}
\DoxyCodeLine{1681     \textcolor{keyword}{struct }\mbox{\hyperlink{structCatch_1_1StringMaker}{StringMaker}}<char *> \{}
\DoxyCodeLine{1682         \textcolor{keyword}{static} std::string convert(\textcolor{keywordtype}{char} * str);}
\DoxyCodeLine{1683     \};}
\DoxyCodeLine{1684 }
\DoxyCodeLine{1685 \textcolor{preprocessor}{\#ifdef CATCH\_CONFIG\_WCHAR}}
\DoxyCodeLine{1686     \textcolor{keyword}{template}<>}
\DoxyCodeLine{1687     \textcolor{keyword}{struct }\mbox{\hyperlink{structCatch_1_1StringMaker}{StringMaker}}<std::wstring> \{}
\DoxyCodeLine{1688         \textcolor{keyword}{static} std::string convert(\textcolor{keyword}{const} std::wstring\& wstr);}
\DoxyCodeLine{1689     \};}
\DoxyCodeLine{1690 }
\DoxyCodeLine{1691 \textcolor{preprocessor}{\# ifdef CATCH\_CONFIG\_CPP17\_STRING\_VIEW}}
\DoxyCodeLine{1692     \textcolor{keyword}{template}<>}
\DoxyCodeLine{1693     \textcolor{keyword}{struct }\mbox{\hyperlink{structCatch_1_1StringMaker}{StringMaker}}<std::wstring\_view> \{}
\DoxyCodeLine{1694         \textcolor{keyword}{static} std::string convert(std::wstring\_view str);}
\DoxyCodeLine{1695     \};}
\DoxyCodeLine{1696 \textcolor{preprocessor}{\# endif}}
\DoxyCodeLine{1697 }
\DoxyCodeLine{1698     \textcolor{keyword}{template}<>}
\DoxyCodeLine{1699     \textcolor{keyword}{struct }\mbox{\hyperlink{structCatch_1_1StringMaker}{StringMaker}}<wchar\_t const *> \{}
\DoxyCodeLine{1700         \textcolor{keyword}{static} std::string convert(\textcolor{keywordtype}{wchar\_t} \textcolor{keyword}{const} * str);}
\DoxyCodeLine{1701     \};}
\DoxyCodeLine{1702     \textcolor{keyword}{template}<>}
\DoxyCodeLine{1703     \textcolor{keyword}{struct }\mbox{\hyperlink{structCatch_1_1StringMaker}{StringMaker}}<wchar\_t *> \{}
\DoxyCodeLine{1704         \textcolor{keyword}{static} std::string convert(\textcolor{keywordtype}{wchar\_t} * str);}
\DoxyCodeLine{1705     \};}
\DoxyCodeLine{1706 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{1707 }
\DoxyCodeLine{1708     \textcolor{comment}{// TBD: Should we use `strnlen` to ensure that we don't go out of the buffer,}}
\DoxyCodeLine{1709     \textcolor{comment}{//      while keeping string semantics?}}
\DoxyCodeLine{1710     \textcolor{keyword}{template}<\textcolor{keywordtype}{int} SZ>}
\DoxyCodeLine{1711     \textcolor{keyword}{struct }\mbox{\hyperlink{structCatch_1_1StringMaker}{StringMaker}}<char[SZ]> \{}
\DoxyCodeLine{1712         \textcolor{keyword}{static} std::string convert(\textcolor{keywordtype}{char} \textcolor{keyword}{const}* str) \{}
\DoxyCodeLine{1713             return ::Catch::Detail::stringify(std::string\{ str \});}
\DoxyCodeLine{1714         \}}
\DoxyCodeLine{1715     \};}
\DoxyCodeLine{1716     \textcolor{keyword}{template}<\textcolor{keywordtype}{int} SZ>}
\DoxyCodeLine{1717     \textcolor{keyword}{struct }\mbox{\hyperlink{structCatch_1_1StringMaker}{StringMaker}}<signed char[SZ]> \{}
\DoxyCodeLine{1718         \textcolor{keyword}{static} std::string convert(\textcolor{keywordtype}{signed} \textcolor{keywordtype}{char} \textcolor{keyword}{const}* str) \{}
\DoxyCodeLine{1719             return ::Catch::Detail::stringify(std::string\{ \textcolor{keyword}{reinterpret\_cast<}\textcolor{keywordtype}{char} \textcolor{keyword}{const }*\textcolor{keyword}{>}(str) \});}
\DoxyCodeLine{1720         \}}
\DoxyCodeLine{1721     \};}
\DoxyCodeLine{1722     \textcolor{keyword}{template}<\textcolor{keywordtype}{int} SZ>}
\DoxyCodeLine{1723     \textcolor{keyword}{struct }\mbox{\hyperlink{structCatch_1_1StringMaker}{StringMaker}}<unsigned char[SZ]> \{}
\DoxyCodeLine{1724         \textcolor{keyword}{static} std::string convert(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} \textcolor{keyword}{const}* str) \{}
\DoxyCodeLine{1725             return ::Catch::Detail::stringify(std::string\{ \textcolor{keyword}{reinterpret\_cast<}\textcolor{keywordtype}{char} \textcolor{keyword}{const }*\textcolor{keyword}{>}(str) \});}
\DoxyCodeLine{1726         \}}
\DoxyCodeLine{1727     \};}
\DoxyCodeLine{1728 }
\DoxyCodeLine{1729 \textcolor{preprocessor}{\#if defined(CATCH\_CONFIG\_CPP17\_BYTE)}}
\DoxyCodeLine{1730     \textcolor{keyword}{template}<>}
\DoxyCodeLine{1731     \textcolor{keyword}{struct }\mbox{\hyperlink{structCatch_1_1StringMaker}{StringMaker}}<std::byte> \{}
\DoxyCodeLine{1732         \textcolor{keyword}{static} std::string convert(std::byte value);}
\DoxyCodeLine{1733     \};}
\DoxyCodeLine{1734 \textcolor{preprocessor}{\#endif }\textcolor{comment}{// defined(CATCH\_CONFIG\_CPP17\_BYTE)}}
\DoxyCodeLine{1735     \textcolor{keyword}{template}<>}
\DoxyCodeLine{1736     \textcolor{keyword}{struct }\mbox{\hyperlink{structCatch_1_1StringMaker}{StringMaker}}<int> \{}
\DoxyCodeLine{1737         \textcolor{keyword}{static} std::string convert(\textcolor{keywordtype}{int} value);}
\DoxyCodeLine{1738     \};}
\DoxyCodeLine{1739     \textcolor{keyword}{template}<>}
\DoxyCodeLine{1740     \textcolor{keyword}{struct }\mbox{\hyperlink{structCatch_1_1StringMaker}{StringMaker}}<long> \{}
\DoxyCodeLine{1741         \textcolor{keyword}{static} std::string convert(\textcolor{keywordtype}{long} value);}
\DoxyCodeLine{1742     \};}
\DoxyCodeLine{1743     \textcolor{keyword}{template}<>}
\DoxyCodeLine{1744     \textcolor{keyword}{struct }\mbox{\hyperlink{structCatch_1_1StringMaker}{StringMaker}}<long long> \{}
\DoxyCodeLine{1745         \textcolor{keyword}{static} std::string convert(\textcolor{keywordtype}{long} \textcolor{keywordtype}{long} value);}
\DoxyCodeLine{1746     \};}
\DoxyCodeLine{1747     \textcolor{keyword}{template}<>}
\DoxyCodeLine{1748     \textcolor{keyword}{struct }\mbox{\hyperlink{structCatch_1_1StringMaker}{StringMaker}}<unsigned int> \{}
\DoxyCodeLine{1749         \textcolor{keyword}{static} std::string convert(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} value);}
\DoxyCodeLine{1750     \};}
\DoxyCodeLine{1751     \textcolor{keyword}{template}<>}
\DoxyCodeLine{1752     \textcolor{keyword}{struct }\mbox{\hyperlink{structCatch_1_1StringMaker}{StringMaker}}<unsigned long> \{}
\DoxyCodeLine{1753         \textcolor{keyword}{static} std::string convert(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} value);}
\DoxyCodeLine{1754     \};}
\DoxyCodeLine{1755     \textcolor{keyword}{template}<>}
\DoxyCodeLine{1756     \textcolor{keyword}{struct }\mbox{\hyperlink{structCatch_1_1StringMaker}{StringMaker}}<unsigned long long> \{}
\DoxyCodeLine{1757         \textcolor{keyword}{static} std::string convert(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} value);}
\DoxyCodeLine{1758     \};}
\DoxyCodeLine{1759 }
\DoxyCodeLine{1760     \textcolor{keyword}{template}<>}
\DoxyCodeLine{1761     \textcolor{keyword}{struct }\mbox{\hyperlink{structCatch_1_1StringMaker}{StringMaker}}<bool> \{}
\DoxyCodeLine{1762         \textcolor{keyword}{static} std::string convert(\textcolor{keywordtype}{bool} b);}
\DoxyCodeLine{1763     \};}
\DoxyCodeLine{1764 }
\DoxyCodeLine{1765     \textcolor{keyword}{template}<>}
\DoxyCodeLine{1766     \textcolor{keyword}{struct }\mbox{\hyperlink{structCatch_1_1StringMaker}{StringMaker}}<char> \{}
\DoxyCodeLine{1767         \textcolor{keyword}{static} std::string convert(\textcolor{keywordtype}{char} c);}
\DoxyCodeLine{1768     \};}
\DoxyCodeLine{1769     \textcolor{keyword}{template}<>}
\DoxyCodeLine{1770     \textcolor{keyword}{struct }\mbox{\hyperlink{structCatch_1_1StringMaker}{StringMaker}}<signed char> \{}
\DoxyCodeLine{1771         \textcolor{keyword}{static} std::string convert(\textcolor{keywordtype}{signed} \textcolor{keywordtype}{char} c);}
\DoxyCodeLine{1772     \};}
\DoxyCodeLine{1773     \textcolor{keyword}{template}<>}
\DoxyCodeLine{1774     \textcolor{keyword}{struct }\mbox{\hyperlink{structCatch_1_1StringMaker}{StringMaker}}<unsigned char> \{}
\DoxyCodeLine{1775         \textcolor{keyword}{static} std::string convert(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} c);}
\DoxyCodeLine{1776     \};}
\DoxyCodeLine{1777 }
\DoxyCodeLine{1778     \textcolor{keyword}{template}<>}
\DoxyCodeLine{1779     \textcolor{keyword}{struct }\mbox{\hyperlink{structCatch_1_1StringMaker}{StringMaker}}<std::nullptr\_t> \{}
\DoxyCodeLine{1780         \textcolor{keyword}{static} std::string convert(std::nullptr\_t);}
\DoxyCodeLine{1781     \};}
\DoxyCodeLine{1782 }
\DoxyCodeLine{1783     \textcolor{keyword}{template}<>}
\DoxyCodeLine{1784     \textcolor{keyword}{struct }\mbox{\hyperlink{structCatch_1_1StringMaker}{StringMaker}}<float> \{}
\DoxyCodeLine{1785         \textcolor{keyword}{static} std::string convert(\textcolor{keywordtype}{float} value);}
\DoxyCodeLine{1786         \textcolor{keyword}{static} \textcolor{keywordtype}{int} precision;}
\DoxyCodeLine{1787     \};}
\DoxyCodeLine{1788 }
\DoxyCodeLine{1789     \textcolor{keyword}{template}<>}
\DoxyCodeLine{1790     \textcolor{keyword}{struct }\mbox{\hyperlink{structCatch_1_1StringMaker}{StringMaker}}<double> \{}
\DoxyCodeLine{1791         \textcolor{keyword}{static} std::string convert(\textcolor{keywordtype}{double} value);}
\DoxyCodeLine{1792         \textcolor{keyword}{static} \textcolor{keywordtype}{int} precision;}
\DoxyCodeLine{1793     \};}
\DoxyCodeLine{1794 }
\DoxyCodeLine{1795     \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{1796     \textcolor{keyword}{struct }\mbox{\hyperlink{structCatch_1_1StringMaker}{StringMaker}}<T*> \{}
\DoxyCodeLine{1797         \textcolor{keyword}{template} <\textcolor{keyword}{typename} U>}
\DoxyCodeLine{1798         \textcolor{keyword}{static} std::string convert(U* p) \{}
\DoxyCodeLine{1799             \textcolor{keywordflow}{if} (p) \{}
\DoxyCodeLine{1800                 return ::Catch::Detail::rawMemoryToString(p);}
\DoxyCodeLine{1801             \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{1802                 \textcolor{keywordflow}{return} \textcolor{stringliteral}{"{}nullptr"{}};}
\DoxyCodeLine{1803             \}}
\DoxyCodeLine{1804         \}}
\DoxyCodeLine{1805     \};}
\DoxyCodeLine{1806 }
\DoxyCodeLine{1807     \textcolor{keyword}{template} <\textcolor{keyword}{typename} R, \textcolor{keyword}{typename} C>}
\DoxyCodeLine{1808     \textcolor{keyword}{struct }\mbox{\hyperlink{structCatch_1_1StringMaker}{StringMaker}}<R C::*> \{}
\DoxyCodeLine{1809         \textcolor{keyword}{static} std::string convert(R C::* p) \{}
\DoxyCodeLine{1810             \textcolor{keywordflow}{if} (p) \{}
\DoxyCodeLine{1811                 return ::Catch::Detail::rawMemoryToString(p);}
\DoxyCodeLine{1812             \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{1813                 \textcolor{keywordflow}{return} \textcolor{stringliteral}{"{}nullptr"{}};}
\DoxyCodeLine{1814             \}}
\DoxyCodeLine{1815         \}}
\DoxyCodeLine{1816     \};}
\DoxyCodeLine{1817 }
\DoxyCodeLine{1818 \textcolor{preprocessor}{\#if defined(\_MANAGED)}}
\DoxyCodeLine{1819     \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{1820     \textcolor{keyword}{struct }\mbox{\hyperlink{structCatch_1_1StringMaker}{StringMaker}}<T\string^> \{}
\DoxyCodeLine{1821         \textcolor{keyword}{static} std::string convert( T\string^ ref ) \{}
\DoxyCodeLine{1822             return ::Catch::Detail::clrReferenceToString(ref);}
\DoxyCodeLine{1823         \}}
\DoxyCodeLine{1824     \};}
\DoxyCodeLine{1825 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{1826 }
\DoxyCodeLine{1827     \textcolor{keyword}{namespace }Detail \{}
\DoxyCodeLine{1828         \textcolor{keyword}{template}<\textcolor{keyword}{typename} InputIterator, \textcolor{keyword}{typename} Sentinel = InputIterator>}
\DoxyCodeLine{1829         std::string rangeToString(InputIterator first, Sentinel last) \{}
\DoxyCodeLine{1830             ReusableStringStream rss;}
\DoxyCodeLine{1831             rss << \textcolor{stringliteral}{"{}\{ "{}};}
\DoxyCodeLine{1832             \textcolor{keywordflow}{if} (first != last) \{}
\DoxyCodeLine{1833                 rss << ::Catch::Detail::stringify(*first);}
\DoxyCodeLine{1834                 \textcolor{keywordflow}{for} (++first; first != last; ++first)}
\DoxyCodeLine{1835                     rss << \textcolor{stringliteral}{"{}, "{}} << ::Catch::Detail::stringify(*first);}
\DoxyCodeLine{1836             \}}
\DoxyCodeLine{1837             rss << \textcolor{stringliteral}{"{} \}"{}};}
\DoxyCodeLine{1838             \textcolor{keywordflow}{return} rss.str();}
\DoxyCodeLine{1839         \}}
\DoxyCodeLine{1840     \}}
\DoxyCodeLine{1841 }
\DoxyCodeLine{1842 \textcolor{preprocessor}{\#ifdef \_\_OBJC\_\_}}
\DoxyCodeLine{1843     \textcolor{keyword}{template}<>}
\DoxyCodeLine{1844     \textcolor{keyword}{struct }StringMaker<NSString*> \{}
\DoxyCodeLine{1845         \textcolor{keyword}{static} std::string convert(NSString * nsstring) \{}
\DoxyCodeLine{1846             \textcolor{keywordflow}{if} (!nsstring)}
\DoxyCodeLine{1847                 \textcolor{keywordflow}{return} \textcolor{stringliteral}{"{}nil"{}};}
\DoxyCodeLine{1848             \textcolor{keywordflow}{return} std::string(\textcolor{stringliteral}{"{}@"{}}) + [nsstring UTF8String];}
\DoxyCodeLine{1849         \}}
\DoxyCodeLine{1850     \};}
\DoxyCodeLine{1851     \textcolor{keyword}{template}<>}
\DoxyCodeLine{1852     \textcolor{keyword}{struct }StringMaker<NSObject*> \{}
\DoxyCodeLine{1853         \textcolor{keyword}{static} std::string convert(NSObject* nsObject) \{}
\DoxyCodeLine{1854             return ::Catch::Detail::stringify([nsObject description]);}
\DoxyCodeLine{1855         \}}
\DoxyCodeLine{1856 }
\DoxyCodeLine{1857     \};}
\DoxyCodeLine{1858     \textcolor{keyword}{namespace }Detail \{}
\DoxyCodeLine{1859         \textcolor{keyword}{inline} std::string stringify( NSString* nsstring ) \{}
\DoxyCodeLine{1860             \textcolor{keywordflow}{return} StringMaker<NSString*>::convert( nsstring );}
\DoxyCodeLine{1861         \}}
\DoxyCodeLine{1862 }
\DoxyCodeLine{1863     \} \textcolor{comment}{// namespace Detail}}
\DoxyCodeLine{1864 \textcolor{preprocessor}{\#endif }\textcolor{comment}{// \_\_OBJC\_\_}}
\DoxyCodeLine{1865 }
\DoxyCodeLine{1866 \} \textcolor{comment}{// namespace Catch}}
\DoxyCodeLine{1867 }
\DoxyCodeLine{1869 \textcolor{comment}{// Separate std-\/lib types stringification, so it can be selectively enabled}}
\DoxyCodeLine{1870 \textcolor{comment}{// This means that we do not bring in}}
\DoxyCodeLine{1871 }
\DoxyCodeLine{1872 \textcolor{preprocessor}{\#if defined(CATCH\_CONFIG\_ENABLE\_ALL\_STRINGMAKERS)}}
\DoxyCodeLine{1873 \textcolor{preprocessor}{\#  define CATCH\_CONFIG\_ENABLE\_PAIR\_STRINGMAKER}}
\DoxyCodeLine{1874 \textcolor{preprocessor}{\#  define CATCH\_CONFIG\_ENABLE\_TUPLE\_STRINGMAKER}}
\DoxyCodeLine{1875 \textcolor{preprocessor}{\#  define CATCH\_CONFIG\_ENABLE\_VARIANT\_STRINGMAKER}}
\DoxyCodeLine{1876 \textcolor{preprocessor}{\#  define CATCH\_CONFIG\_ENABLE\_CHRONO\_STRINGMAKER}}
\DoxyCodeLine{1877 \textcolor{preprocessor}{\#  define CATCH\_CONFIG\_ENABLE\_OPTIONAL\_STRINGMAKER}}
\DoxyCodeLine{1878 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{1879 }
\DoxyCodeLine{1880 \textcolor{comment}{// Separate std::pair specialization}}
\DoxyCodeLine{1881 \textcolor{preprocessor}{\#if defined(CATCH\_CONFIG\_ENABLE\_PAIR\_STRINGMAKER)}}
\DoxyCodeLine{1882 \textcolor{preprocessor}{\#include <utility>}}
\DoxyCodeLine{1883 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{1884     \textcolor{keyword}{template}<\textcolor{keyword}{typename} T1, \textcolor{keyword}{typename} T2>}
\DoxyCodeLine{1885     \textcolor{keyword}{struct }StringMaker<std::pair<T1, T2> > \{}
\DoxyCodeLine{1886         \textcolor{keyword}{static} std::string convert(\textcolor{keyword}{const} std::pair<T1, T2>\& pair) \{}
\DoxyCodeLine{1887             ReusableStringStream rss;}
\DoxyCodeLine{1888             rss << \textcolor{stringliteral}{"{}\{ "{}}}
\DoxyCodeLine{1889                 << ::Catch::Detail::stringify(pair.first)}
\DoxyCodeLine{1890                 << \textcolor{stringliteral}{"{}, "{}}}
\DoxyCodeLine{1891                 << ::Catch::Detail::stringify(pair.second)}
\DoxyCodeLine{1892                 << \textcolor{stringliteral}{"{} \}"{}};}
\DoxyCodeLine{1893             \textcolor{keywordflow}{return} rss.str();}
\DoxyCodeLine{1894         \}}
\DoxyCodeLine{1895     \};}
\DoxyCodeLine{1896 \}}
\DoxyCodeLine{1897 \textcolor{preprocessor}{\#endif }\textcolor{comment}{// CATCH\_CONFIG\_ENABLE\_PAIR\_STRINGMAKER}}
\DoxyCodeLine{1898 }
\DoxyCodeLine{1899 \textcolor{preprocessor}{\#if defined(CATCH\_CONFIG\_ENABLE\_OPTIONAL\_STRINGMAKER) \&\& defined(CATCH\_CONFIG\_CPP17\_OPTIONAL)}}
\DoxyCodeLine{1900 \textcolor{preprocessor}{\#include <optional>}}
\DoxyCodeLine{1901 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{1902     \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{1903     \textcolor{keyword}{struct }StringMaker<std::optional<T> > \{}
\DoxyCodeLine{1904         \textcolor{keyword}{static} std::string convert(\textcolor{keyword}{const} std::optional<T>\& optional) \{}
\DoxyCodeLine{1905             ReusableStringStream rss;}
\DoxyCodeLine{1906             \textcolor{keywordflow}{if} (optional.has\_value()) \{}
\DoxyCodeLine{1907                 rss << ::Catch::Detail::stringify(*optional);}
\DoxyCodeLine{1908             \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{1909                 rss << \textcolor{stringliteral}{"{}\{ \}"{}};}
\DoxyCodeLine{1910             \}}
\DoxyCodeLine{1911             \textcolor{keywordflow}{return} rss.str();}
\DoxyCodeLine{1912         \}}
\DoxyCodeLine{1913     \};}
\DoxyCodeLine{1914 \}}
\DoxyCodeLine{1915 \textcolor{preprocessor}{\#endif }\textcolor{comment}{// CATCH\_CONFIG\_ENABLE\_OPTIONAL\_STRINGMAKER}}
\DoxyCodeLine{1916 }
\DoxyCodeLine{1917 \textcolor{comment}{// Separate std::tuple specialization}}
\DoxyCodeLine{1918 \textcolor{preprocessor}{\#if defined(CATCH\_CONFIG\_ENABLE\_TUPLE\_STRINGMAKER)}}
\DoxyCodeLine{1919 \textcolor{preprocessor}{\#include <tuple>}}
\DoxyCodeLine{1920 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{1921     \textcolor{keyword}{namespace }Detail \{}
\DoxyCodeLine{1922         \textcolor{keyword}{template}<}
\DoxyCodeLine{1923             \textcolor{keyword}{typename} Tuple,}
\DoxyCodeLine{1924             std::size\_t N = 0,}
\DoxyCodeLine{1925             \textcolor{keywordtype}{bool} = (N < std::tuple\_size<Tuple>::value)}
\DoxyCodeLine{1926             >}
\DoxyCodeLine{1927             \textcolor{keyword}{struct} TupleElementPrinter \{}
\DoxyCodeLine{1928             \textcolor{keyword}{static} \textcolor{keywordtype}{void} print(\textcolor{keyword}{const} Tuple\& tuple, std::ostream\& os) \{}
\DoxyCodeLine{1929                 os << (N ? \textcolor{stringliteral}{"{}, "{}} : \textcolor{stringliteral}{"{} "{}})}
\DoxyCodeLine{1930                     << ::Catch::Detail::stringify(std::get<N>(tuple));}
\DoxyCodeLine{1931                 TupleElementPrinter<Tuple, N + 1>::print(tuple, os);}
\DoxyCodeLine{1932             \}}
\DoxyCodeLine{1933         \};}
\DoxyCodeLine{1934 }
\DoxyCodeLine{1935         \textcolor{keyword}{template}<}
\DoxyCodeLine{1936             \textcolor{keyword}{typename} Tuple,}
\DoxyCodeLine{1937             std::size\_t N}
\DoxyCodeLine{1938         >}
\DoxyCodeLine{1939             \textcolor{keyword}{struct }TupleElementPrinter<Tuple, N, false> \{}
\DoxyCodeLine{1940             \textcolor{keyword}{static} \textcolor{keywordtype}{void} print(\textcolor{keyword}{const} Tuple\&, std::ostream\&) \{\}}
\DoxyCodeLine{1941         \};}
\DoxyCodeLine{1942 }
\DoxyCodeLine{1943     \}}
\DoxyCodeLine{1944 }
\DoxyCodeLine{1945     \textcolor{keyword}{template}<\textcolor{keyword}{typename} ...Types>}
\DoxyCodeLine{1946     \textcolor{keyword}{struct }StringMaker<std::tuple<Types...>> \{}
\DoxyCodeLine{1947         \textcolor{keyword}{static} std::string convert(\textcolor{keyword}{const} std::tuple<Types...>\& tuple) \{}
\DoxyCodeLine{1948             ReusableStringStream rss;}
\DoxyCodeLine{1949             rss << \textcolor{charliteral}{'\{'};}
\DoxyCodeLine{1950             Detail::TupleElementPrinter<std::tuple<Types...>>::print(tuple, rss.get());}
\DoxyCodeLine{1951             rss << \textcolor{stringliteral}{"{} \}"{}};}
\DoxyCodeLine{1952             \textcolor{keywordflow}{return} rss.str();}
\DoxyCodeLine{1953         \}}
\DoxyCodeLine{1954     \};}
\DoxyCodeLine{1955 \}}
\DoxyCodeLine{1956 \textcolor{preprocessor}{\#endif }\textcolor{comment}{// CATCH\_CONFIG\_ENABLE\_TUPLE\_STRINGMAKER}}
\DoxyCodeLine{1957 }
\DoxyCodeLine{1958 \textcolor{preprocessor}{\#if defined(CATCH\_CONFIG\_ENABLE\_VARIANT\_STRINGMAKER) \&\& defined(CATCH\_CONFIG\_CPP17\_VARIANT)}}
\DoxyCodeLine{1959 \textcolor{preprocessor}{\#include <variant>}}
\DoxyCodeLine{1960 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{1961     \textcolor{keyword}{template}<>}
\DoxyCodeLine{1962     \textcolor{keyword}{struct }StringMaker<std::monostate> \{}
\DoxyCodeLine{1963         \textcolor{keyword}{static} std::string convert(\textcolor{keyword}{const} std::monostate\&) \{}
\DoxyCodeLine{1964             \textcolor{keywordflow}{return} \textcolor{stringliteral}{"{}\{ \}"{}};}
\DoxyCodeLine{1965         \}}
\DoxyCodeLine{1966     \};}
\DoxyCodeLine{1967 }
\DoxyCodeLine{1968     \textcolor{keyword}{template}<\textcolor{keyword}{typename}... Elements>}
\DoxyCodeLine{1969     \textcolor{keyword}{struct }StringMaker<std::variant<Elements...>> \{}
\DoxyCodeLine{1970         \textcolor{keyword}{static} std::string convert(\textcolor{keyword}{const} std::variant<Elements...>\& variant) \{}
\DoxyCodeLine{1971             \textcolor{keywordflow}{if} (variant.valueless\_by\_exception()) \{}
\DoxyCodeLine{1972                 \textcolor{keywordflow}{return} \textcolor{stringliteral}{"{}\{valueless variant\}"{}};}
\DoxyCodeLine{1973             \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{1974                 \textcolor{keywordflow}{return} std::visit(}
\DoxyCodeLine{1975                     [](\textcolor{keyword}{const} \textcolor{keyword}{auto}\& value) \{}
\DoxyCodeLine{1976                         return ::Catch::Detail::stringify(value);}
\DoxyCodeLine{1977                     \},}
\DoxyCodeLine{1978                     variant}
\DoxyCodeLine{1979                 );}
\DoxyCodeLine{1980             \}}
\DoxyCodeLine{1981         \}}
\DoxyCodeLine{1982     \};}
\DoxyCodeLine{1983 \}}
\DoxyCodeLine{1984 \textcolor{preprocessor}{\#endif }\textcolor{comment}{// CATCH\_CONFIG\_ENABLE\_VARIANT\_STRINGMAKER}}
\DoxyCodeLine{1985 }
\DoxyCodeLine{1986 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{1987     \textcolor{comment}{// Import begin/ end from std here}}
\DoxyCodeLine{1988     \textcolor{keyword}{using }std::begin;}
\DoxyCodeLine{1989     \textcolor{keyword}{using }std::end;}
\DoxyCodeLine{1990 }
\DoxyCodeLine{1991     \textcolor{keyword}{namespace }detail \{}
\DoxyCodeLine{1992         \textcolor{keyword}{template} <\textcolor{keyword}{typename}...>}
\DoxyCodeLine{1993         \textcolor{keyword}{struct }\mbox{\hyperlink{structCatch_1_1detail_1_1void__type}{void\_type}} \{}
\DoxyCodeLine{1994             \textcolor{keyword}{using }type = void;}
\DoxyCodeLine{1995         \};}
\DoxyCodeLine{1996 }
\DoxyCodeLine{1997         \textcolor{keyword}{template} <\textcolor{keyword}{typename} T, \textcolor{keyword}{typename} = \textcolor{keywordtype}{void}>}
\DoxyCodeLine{1998         \textcolor{keyword}{struct }\mbox{\hyperlink{structCatch_1_1detail_1_1is__range__impl}{is\_range\_impl}} : std::false\_type \{}
\DoxyCodeLine{1999         \};}
\DoxyCodeLine{2000 }
\DoxyCodeLine{2001         \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{2002         \textcolor{keyword}{struct }\mbox{\hyperlink{structCatch_1_1detail_1_1is__range__impl}{is\_range\_impl<T, typename void\_type<decltype(begin(std::declval<T>}}()))>::type> : std::true\_type \{}
\DoxyCodeLine{2003         \};}
\DoxyCodeLine{2004     \} \textcolor{comment}{// namespace detail}}
\DoxyCodeLine{2005 }
\DoxyCodeLine{2006     \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{2007     \textcolor{keyword}{struct }\mbox{\hyperlink{structCatch_1_1is__range}{is\_range}} : \mbox{\hyperlink{structCatch_1_1detail_1_1is__range__impl}{detail::is\_range\_impl}}<T> \{}
\DoxyCodeLine{2008     \};}
\DoxyCodeLine{2009 }
\DoxyCodeLine{2010 \textcolor{preprocessor}{\#if defined(\_MANAGED) }\textcolor{comment}{// Managed types are never ranges}}
\DoxyCodeLine{2011     \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{2012     \textcolor{keyword}{struct }\mbox{\hyperlink{structCatch_1_1is__range}{is\_range}}<T\string^> \{}
\DoxyCodeLine{2013         \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{bool} value = \textcolor{keyword}{false};}
\DoxyCodeLine{2014     \};}
\DoxyCodeLine{2015 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{2016 }
\DoxyCodeLine{2017     \textcolor{keyword}{template}<\textcolor{keyword}{typename} Range>}
\DoxyCodeLine{2018     std::string rangeToString( Range \textcolor{keyword}{const}\& range ) \{}
\DoxyCodeLine{2019         return ::Catch::Detail::rangeToString( begin( range ), end( range ) );}
\DoxyCodeLine{2020     \}}
\DoxyCodeLine{2021 }
\DoxyCodeLine{2022     \textcolor{comment}{// Handle vector<bool> specially}}
\DoxyCodeLine{2023     \textcolor{keyword}{template}<\textcolor{keyword}{typename} Allocator>}
\DoxyCodeLine{2024     std::string rangeToString( std::vector<bool, Allocator> \textcolor{keyword}{const}\& v ) \{}
\DoxyCodeLine{2025         ReusableStringStream rss;}
\DoxyCodeLine{2026         rss << \textcolor{stringliteral}{"{}\{ "{}};}
\DoxyCodeLine{2027         \textcolor{keywordtype}{bool} first = \textcolor{keyword}{true};}
\DoxyCodeLine{2028         \textcolor{keywordflow}{for}( \textcolor{keywordtype}{bool} b : v ) \{}
\DoxyCodeLine{2029             \textcolor{keywordflow}{if}( first )}
\DoxyCodeLine{2030                 first = \textcolor{keyword}{false};}
\DoxyCodeLine{2031             \textcolor{keywordflow}{else}}
\DoxyCodeLine{2032                 rss << \textcolor{stringliteral}{"{}, "{}};}
\DoxyCodeLine{2033             rss << ::Catch::Detail::stringify( b );}
\DoxyCodeLine{2034         \}}
\DoxyCodeLine{2035         rss << \textcolor{stringliteral}{"{} \}"{}};}
\DoxyCodeLine{2036         \textcolor{keywordflow}{return} rss.str();}
\DoxyCodeLine{2037     \}}
\DoxyCodeLine{2038 }
\DoxyCodeLine{2039     \textcolor{keyword}{template}<\textcolor{keyword}{typename} R>}
\DoxyCodeLine{2040     \textcolor{keyword}{struct }\mbox{\hyperlink{structCatch_1_1StringMaker}{StringMaker}}<R, typename std::enable\_if<is\_range<R>::value \&\& !::Catch::Detail::IsStreamInsertable<R>::value>::type> \{}
\DoxyCodeLine{2041         \textcolor{keyword}{static} std::string convert( R \textcolor{keyword}{const}\& range ) \{}
\DoxyCodeLine{2042             \textcolor{keywordflow}{return} rangeToString( range );}
\DoxyCodeLine{2043         \}}
\DoxyCodeLine{2044     \};}
\DoxyCodeLine{2045 }
\DoxyCodeLine{2046     \textcolor{keyword}{template} <\textcolor{keyword}{typename} T, \textcolor{keywordtype}{int} SZ>}
\DoxyCodeLine{2047     \textcolor{keyword}{struct }\mbox{\hyperlink{structCatch_1_1StringMaker}{StringMaker}}<T[SZ]> \{}
\DoxyCodeLine{2048         \textcolor{keyword}{static} std::string convert(T \textcolor{keyword}{const}(\&arr)[SZ]) \{}
\DoxyCodeLine{2049             \textcolor{keywordflow}{return} rangeToString(arr);}
\DoxyCodeLine{2050         \}}
\DoxyCodeLine{2051     \};}
\DoxyCodeLine{2052 }
\DoxyCodeLine{2053 \} \textcolor{comment}{// namespace Catch}}
\DoxyCodeLine{2054 }
\DoxyCodeLine{2055 \textcolor{comment}{// Separate std::chrono::duration specialization}}
\DoxyCodeLine{2056 \textcolor{preprocessor}{\#if defined(CATCH\_CONFIG\_ENABLE\_CHRONO\_STRINGMAKER)}}
\DoxyCodeLine{2057 \textcolor{preprocessor}{\#include <ctime>}}
\DoxyCodeLine{2058 \textcolor{preprocessor}{\#include <ratio>}}
\DoxyCodeLine{2059 \textcolor{preprocessor}{\#include <chrono>}}
\DoxyCodeLine{2060 }
\DoxyCodeLine{2061 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{2062 }
\DoxyCodeLine{2063 \textcolor{keyword}{template} <\textcolor{keyword}{class} Ratio>}
\DoxyCodeLine{2064 \textcolor{keyword}{struct }ratio\_string \{}
\DoxyCodeLine{2065     \textcolor{keyword}{static} std::string symbol();}
\DoxyCodeLine{2066 \};}
\DoxyCodeLine{2067 }
\DoxyCodeLine{2068 \textcolor{keyword}{template} <\textcolor{keyword}{class} Ratio>}
\DoxyCodeLine{2069 std::string ratio\_string<Ratio>::symbol() \{}
\DoxyCodeLine{2070     \mbox{\hyperlink{classCatch_1_1ReusableStringStream}{Catch::ReusableStringStream}} rss;}
\DoxyCodeLine{2071     rss << \textcolor{charliteral}{'['} << Ratio::num << \textcolor{charliteral}{'/'}}
\DoxyCodeLine{2072         << Ratio::den << \textcolor{charliteral}{']'};}
\DoxyCodeLine{2073     \textcolor{keywordflow}{return} rss.str();}
\DoxyCodeLine{2074 \}}
\DoxyCodeLine{2075 \textcolor{keyword}{template} <>}
\DoxyCodeLine{2076 \textcolor{keyword}{struct }ratio\_string<std::atto> \{}
\DoxyCodeLine{2077     \textcolor{keyword}{static} std::string symbol();}
\DoxyCodeLine{2078 \};}
\DoxyCodeLine{2079 \textcolor{keyword}{template} <>}
\DoxyCodeLine{2080 \textcolor{keyword}{struct }ratio\_string<std::femto> \{}
\DoxyCodeLine{2081     \textcolor{keyword}{static} std::string symbol();}
\DoxyCodeLine{2082 \};}
\DoxyCodeLine{2083 \textcolor{keyword}{template} <>}
\DoxyCodeLine{2084 \textcolor{keyword}{struct }ratio\_string<std::pico> \{}
\DoxyCodeLine{2085     \textcolor{keyword}{static} std::string symbol();}
\DoxyCodeLine{2086 \};}
\DoxyCodeLine{2087 \textcolor{keyword}{template} <>}
\DoxyCodeLine{2088 \textcolor{keyword}{struct }ratio\_string<std::nano> \{}
\DoxyCodeLine{2089     \textcolor{keyword}{static} std::string symbol();}
\DoxyCodeLine{2090 \};}
\DoxyCodeLine{2091 \textcolor{keyword}{template} <>}
\DoxyCodeLine{2092 \textcolor{keyword}{struct }ratio\_string<std::micro> \{}
\DoxyCodeLine{2093     \textcolor{keyword}{static} std::string symbol();}
\DoxyCodeLine{2094 \};}
\DoxyCodeLine{2095 \textcolor{keyword}{template} <>}
\DoxyCodeLine{2096 \textcolor{keyword}{struct }ratio\_string<std::milli> \{}
\DoxyCodeLine{2097     \textcolor{keyword}{static} std::string symbol();}
\DoxyCodeLine{2098 \};}
\DoxyCodeLine{2099 }
\DoxyCodeLine{2101     \textcolor{comment}{// std::chrono::duration specializations}}
\DoxyCodeLine{2102     \textcolor{keyword}{template}<\textcolor{keyword}{typename} Value, \textcolor{keyword}{typename} Ratio>}
\DoxyCodeLine{2103     \textcolor{keyword}{struct }StringMaker<std::chrono::duration<Value, Ratio>> \{}
\DoxyCodeLine{2104         \textcolor{keyword}{static} std::string convert(std::chrono::duration<Value, Ratio> \textcolor{keyword}{const}\& duration) \{}
\DoxyCodeLine{2105             ReusableStringStream rss;}
\DoxyCodeLine{2106             rss << duration.count() << \textcolor{charliteral}{' '} << ratio\_string<Ratio>::symbol() << \textcolor{charliteral}{'s'};}
\DoxyCodeLine{2107             \textcolor{keywordflow}{return} rss.str();}
\DoxyCodeLine{2108         \}}
\DoxyCodeLine{2109     \};}
\DoxyCodeLine{2110     \textcolor{keyword}{template}<\textcolor{keyword}{typename} Value>}
\DoxyCodeLine{2111     \textcolor{keyword}{struct }StringMaker<std::chrono::duration<Value, std::ratio<1>>> \{}
\DoxyCodeLine{2112         \textcolor{keyword}{static} std::string convert(std::chrono::duration<Value, std::ratio<1>> \textcolor{keyword}{const}\& duration) \{}
\DoxyCodeLine{2113             ReusableStringStream rss;}
\DoxyCodeLine{2114             rss << duration.count() << \textcolor{stringliteral}{"{} s"{}};}
\DoxyCodeLine{2115             \textcolor{keywordflow}{return} rss.str();}
\DoxyCodeLine{2116         \}}
\DoxyCodeLine{2117     \};}
\DoxyCodeLine{2118     \textcolor{keyword}{template}<\textcolor{keyword}{typename} Value>}
\DoxyCodeLine{2119     \textcolor{keyword}{struct }StringMaker<std::chrono::duration<Value, std::ratio<60>>> \{}
\DoxyCodeLine{2120         \textcolor{keyword}{static} std::string convert(std::chrono::duration<Value, std::ratio<60>> \textcolor{keyword}{const}\& duration) \{}
\DoxyCodeLine{2121             ReusableStringStream rss;}
\DoxyCodeLine{2122             rss << duration.count() << \textcolor{stringliteral}{"{} m"{}};}
\DoxyCodeLine{2123             \textcolor{keywordflow}{return} rss.str();}
\DoxyCodeLine{2124         \}}
\DoxyCodeLine{2125     \};}
\DoxyCodeLine{2126     \textcolor{keyword}{template}<\textcolor{keyword}{typename} Value>}
\DoxyCodeLine{2127     \textcolor{keyword}{struct }StringMaker<std::chrono::duration<Value, std::ratio<3600>>> \{}
\DoxyCodeLine{2128         \textcolor{keyword}{static} std::string convert(std::chrono::duration<Value, std::ratio<3600>> \textcolor{keyword}{const}\& duration) \{}
\DoxyCodeLine{2129             ReusableStringStream rss;}
\DoxyCodeLine{2130             rss << duration.count() << \textcolor{stringliteral}{"{} h"{}};}
\DoxyCodeLine{2131             \textcolor{keywordflow}{return} rss.str();}
\DoxyCodeLine{2132         \}}
\DoxyCodeLine{2133     \};}
\DoxyCodeLine{2134 }
\DoxyCodeLine{2136     \textcolor{comment}{// std::chrono::time\_point specialization}}
\DoxyCodeLine{2137     \textcolor{comment}{// Generic time\_point cannot be specialized, only std::chrono::time\_point<system\_clock>}}
\DoxyCodeLine{2138     \textcolor{keyword}{template}<\textcolor{keyword}{typename} Clock, \textcolor{keyword}{typename} Duration>}
\DoxyCodeLine{2139     \textcolor{keyword}{struct }StringMaker<std::chrono::time\_point<Clock, Duration>> \{}
\DoxyCodeLine{2140         \textcolor{keyword}{static} std::string convert(std::chrono::time\_point<Clock, Duration> \textcolor{keyword}{const}\& time\_point) \{}
\DoxyCodeLine{2141             return ::Catch::Detail::stringify(time\_point.time\_since\_epoch()) + \textcolor{stringliteral}{"{} since epoch"{}};}
\DoxyCodeLine{2142         \}}
\DoxyCodeLine{2143     \};}
\DoxyCodeLine{2144     \textcolor{comment}{// std::chrono::time\_point<system\_clock> specialization}}
\DoxyCodeLine{2145     \textcolor{keyword}{template}<\textcolor{keyword}{typename} Duration>}
\DoxyCodeLine{2146     \textcolor{keyword}{struct }StringMaker<std::chrono::time\_point<std::chrono::system\_clock, Duration>> \{}
\DoxyCodeLine{2147         \textcolor{keyword}{static} std::string convert(std::chrono::time\_point<std::chrono::system\_clock, Duration> \textcolor{keyword}{const}\& time\_point) \{}
\DoxyCodeLine{2148             \textcolor{keyword}{auto} converted = std::chrono::system\_clock::to\_time\_t(time\_point);}
\DoxyCodeLine{2149 }
\DoxyCodeLine{2150 \textcolor{preprocessor}{\#ifdef \_MSC\_VER}}
\DoxyCodeLine{2151             std::tm timeInfo = \{\};}
\DoxyCodeLine{2152             gmtime\_s(\&timeInfo, \&converted);}
\DoxyCodeLine{2153 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{2154             std::tm* timeInfo = std::gmtime(\&converted);}
\DoxyCodeLine{2155 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{2156 }
\DoxyCodeLine{2157             \textcolor{keyword}{auto} \textcolor{keyword}{const} timeStampSize = \textcolor{keyword}{sizeof}(\textcolor{stringliteral}{"{}2017-\/01-\/16T17:06:45Z"{}});}
\DoxyCodeLine{2158             \textcolor{keywordtype}{char} timeStamp[timeStampSize];}
\DoxyCodeLine{2159             \textcolor{keyword}{const} \textcolor{keywordtype}{char} * \textcolor{keyword}{const} fmt = \textcolor{stringliteral}{"{}\%Y-\/\%m-\/\%dT\%H:\%M:\%SZ"{}};}
\DoxyCodeLine{2160 }
\DoxyCodeLine{2161 \textcolor{preprocessor}{\#ifdef \_MSC\_VER}}
\DoxyCodeLine{2162             std::strftime(timeStamp, timeStampSize, fmt, \&timeInfo);}
\DoxyCodeLine{2163 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{2164             std::strftime(timeStamp, timeStampSize, fmt, timeInfo);}
\DoxyCodeLine{2165 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{2166             \textcolor{keywordflow}{return} std::string(timeStamp);}
\DoxyCodeLine{2167         \}}
\DoxyCodeLine{2168     \};}
\DoxyCodeLine{2169 \}}
\DoxyCodeLine{2170 \textcolor{preprocessor}{\#endif }\textcolor{comment}{// CATCH\_CONFIG\_ENABLE\_CHRONO\_STRINGMAKER}}
\DoxyCodeLine{2171 }
\DoxyCodeLine{2172 \textcolor{preprocessor}{\#define INTERNAL\_CATCH\_REGISTER\_ENUM( enumName, ... ) \(\backslash\)}}
\DoxyCodeLine{2173 \textcolor{preprocessor}{namespace Catch \{ \(\backslash\)}}
\DoxyCodeLine{2174 \textcolor{preprocessor}{    template<> struct StringMaker<enumName> \{ \(\backslash\)}}
\DoxyCodeLine{2175 \textcolor{preprocessor}{        static std::string convert( enumName value ) \{ \(\backslash\)}}
\DoxyCodeLine{2176 \textcolor{preprocessor}{            static const auto\& enumInfo = ::Catch::getMutableRegistryHub().getMutableEnumValuesRegistry().registerEnum( \#enumName, \#\_\_VA\_ARGS\_\_, \{ \_\_VA\_ARGS\_\_ \} ); \(\backslash\)}}
\DoxyCodeLine{2177 \textcolor{preprocessor}{            return static\_cast<std::string>(enumInfo.lookup( static\_cast<int>( value ) )); \(\backslash\)}}
\DoxyCodeLine{2178 \textcolor{preprocessor}{        \} \(\backslash\)}}
\DoxyCodeLine{2179 \textcolor{preprocessor}{    \}; \(\backslash\)}}
\DoxyCodeLine{2180 \textcolor{preprocessor}{\}}}
\DoxyCodeLine{2181 }
\DoxyCodeLine{2182 \textcolor{preprocessor}{\#define CATCH\_REGISTER\_ENUM( enumName, ... ) INTERNAL\_CATCH\_REGISTER\_ENUM( enumName, \_\_VA\_ARGS\_\_ )}}
\DoxyCodeLine{2183 }
\DoxyCodeLine{2184 \textcolor{preprocessor}{\#ifdef \_MSC\_VER}}
\DoxyCodeLine{2185 \textcolor{preprocessor}{\#pragma warning(pop)}}
\DoxyCodeLine{2186 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{2187 }
\DoxyCodeLine{2188 \textcolor{comment}{// end catch\_tostring.h}}
\DoxyCodeLine{2189 \textcolor{preprocessor}{\#include <iosfwd>}}
\DoxyCodeLine{2190 }
\DoxyCodeLine{2191 \textcolor{preprocessor}{\#ifdef \_MSC\_VER}}
\DoxyCodeLine{2192 \textcolor{preprocessor}{\#pragma warning(push)}}
\DoxyCodeLine{2193 \textcolor{preprocessor}{\#pragma warning(disable:4389) }\textcolor{comment}{// '==' : signed/unsigned mismatch}}
\DoxyCodeLine{2194 \textcolor{preprocessor}{\#pragma warning(disable:4018) }\textcolor{comment}{// more "{}signed/unsigned mismatch"{}}}
\DoxyCodeLine{2195 \textcolor{preprocessor}{\#pragma warning(disable:4312) }\textcolor{comment}{// Converting int to T* using reinterpret\_cast (issue on x64 platform)}}
\DoxyCodeLine{2196 \textcolor{preprocessor}{\#pragma warning(disable:4180) }\textcolor{comment}{// qualifier applied to function type has no meaning}}
\DoxyCodeLine{2197 \textcolor{preprocessor}{\#pragma warning(disable:4800) }\textcolor{comment}{// Forcing result to true or false}}
\DoxyCodeLine{2198 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{2199 }
\DoxyCodeLine{2200 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{2201 }
\DoxyCodeLine{2202     \textcolor{keyword}{struct }\mbox{\hyperlink{structCatch_1_1ITransientExpression}{ITransientExpression}} \{}
\DoxyCodeLine{2203         \textcolor{keyword}{auto} isBinaryExpression() \textcolor{keyword}{const} -\/> \textcolor{keywordtype}{bool} \{ \textcolor{keywordflow}{return} m\_isBinaryExpression; \}}
\DoxyCodeLine{2204         \textcolor{keyword}{auto} getResult() \textcolor{keyword}{const} -\/> \textcolor{keywordtype}{bool} \{ \textcolor{keywordflow}{return} m\_result; \}}
\DoxyCodeLine{2205         \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} streamReconstructedExpression( std::ostream \&os ) \textcolor{keyword}{const} = 0;}
\DoxyCodeLine{2206 }
\DoxyCodeLine{2207         \mbox{\hyperlink{structCatch_1_1ITransientExpression}{ITransientExpression}}( \textcolor{keywordtype}{bool} isBinaryExpression, \textcolor{keywordtype}{bool} result )}
\DoxyCodeLine{2208         :   m\_isBinaryExpression( isBinaryExpression ),}
\DoxyCodeLine{2209             m\_result( result )}
\DoxyCodeLine{2210         \{\}}
\DoxyCodeLine{2211 }
\DoxyCodeLine{2212         \textcolor{comment}{// We don't actually need a virtual destructor, but many static analysers}}
\DoxyCodeLine{2213         \textcolor{comment}{// complain if it's not here :-\/(}}
\DoxyCodeLine{2214         \textcolor{keyword}{virtual} \mbox{\hyperlink{structCatch_1_1ITransientExpression}{\string~ITransientExpression}}();}
\DoxyCodeLine{2215 }
\DoxyCodeLine{2216         \textcolor{keywordtype}{bool} m\_isBinaryExpression;}
\DoxyCodeLine{2217         \textcolor{keywordtype}{bool} m\_result;}
\DoxyCodeLine{2218 }
\DoxyCodeLine{2219     \};}
\DoxyCodeLine{2220 }
\DoxyCodeLine{2221     \textcolor{keywordtype}{void} formatReconstructedExpression( std::ostream \&os, std::string \textcolor{keyword}{const}\& lhs, \mbox{\hyperlink{classCatch_1_1StringRef}{StringRef}} op, std::string \textcolor{keyword}{const}\& rhs );}
\DoxyCodeLine{2222 }
\DoxyCodeLine{2223     \textcolor{keyword}{template}<\textcolor{keyword}{typename} LhsT, \textcolor{keyword}{typename} RhsT>}
\DoxyCodeLine{2224     \textcolor{keyword}{class }\mbox{\hyperlink{classCatch_1_1BinaryExpr}{BinaryExpr}}  : \textcolor{keyword}{public} \mbox{\hyperlink{structCatch_1_1ITransientExpression}{ITransientExpression}} \{}
\DoxyCodeLine{2225         LhsT m\_lhs;}
\DoxyCodeLine{2226         \mbox{\hyperlink{classCatch_1_1StringRef}{StringRef}} m\_op;}
\DoxyCodeLine{2227         RhsT m\_rhs;}
\DoxyCodeLine{2228 }
\DoxyCodeLine{2229         \textcolor{keywordtype}{void} streamReconstructedExpression( std::ostream \&os )\textcolor{keyword}{ const override }\{}
\DoxyCodeLine{2230             formatReconstructedExpression}
\DoxyCodeLine{2231                     ( os, Catch::Detail::stringify( m\_lhs ), m\_op, Catch::Detail::stringify( m\_rhs ) );}
\DoxyCodeLine{2232         \}}
\DoxyCodeLine{2233 }
\DoxyCodeLine{2234     \textcolor{keyword}{public}:}
\DoxyCodeLine{2235         \mbox{\hyperlink{classCatch_1_1BinaryExpr}{BinaryExpr}}( \textcolor{keywordtype}{bool} comparisonResult, LhsT lhs, \mbox{\hyperlink{classCatch_1_1StringRef}{StringRef}} op, RhsT rhs )}
\DoxyCodeLine{2236         :   \mbox{\hyperlink{structCatch_1_1ITransientExpression}{ITransientExpression}}\{ \textcolor{keyword}{true}, comparisonResult \},}
\DoxyCodeLine{2237             m\_lhs( lhs ),}
\DoxyCodeLine{2238             m\_op( op ),}
\DoxyCodeLine{2239             m\_rhs( rhs )}
\DoxyCodeLine{2240         \{\}}
\DoxyCodeLine{2241 }
\DoxyCodeLine{2242         \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{2243         \textcolor{keyword}{auto} operator \&\& ( T ) \textcolor{keyword}{const} -\/> \mbox{\hyperlink{classCatch_1_1BinaryExpr}{BinaryExpr<LhsT, RhsT const\&>}} \textcolor{keyword}{const} \{}
\DoxyCodeLine{2244             \textcolor{keyword}{static\_assert}(\mbox{\hyperlink{structCatch_1_1always__false}{always\_false<T>::value}},}
\DoxyCodeLine{2245             \textcolor{stringliteral}{"{}chained comparisons are not supported inside assertions, "{}}}
\DoxyCodeLine{2246             \textcolor{stringliteral}{"{}wrap the expression inside parentheses, or decompose it"{}});}
\DoxyCodeLine{2247         \}}
\DoxyCodeLine{2248 }
\DoxyCodeLine{2249         \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{2250         \textcolor{keyword}{auto} operator || ( T ) \textcolor{keyword}{const} -\/> \mbox{\hyperlink{classCatch_1_1BinaryExpr}{BinaryExpr<LhsT, RhsT const\&>}} \textcolor{keyword}{const} \{}
\DoxyCodeLine{2251             \textcolor{keyword}{static\_assert}(\mbox{\hyperlink{structCatch_1_1always__false}{always\_false<T>::value}},}
\DoxyCodeLine{2252             \textcolor{stringliteral}{"{}chained comparisons are not supported inside assertions, "{}}}
\DoxyCodeLine{2253             \textcolor{stringliteral}{"{}wrap the expression inside parentheses, or decompose it"{}});}
\DoxyCodeLine{2254         \}}
\DoxyCodeLine{2255 }
\DoxyCodeLine{2256         \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{2257         \textcolor{keyword}{auto} operator == ( T ) \textcolor{keyword}{const} -\/> \mbox{\hyperlink{classCatch_1_1BinaryExpr}{BinaryExpr<LhsT, RhsT const\&>}} \textcolor{keyword}{const} \{}
\DoxyCodeLine{2258             \textcolor{keyword}{static\_assert}(\mbox{\hyperlink{structCatch_1_1always__false}{always\_false<T>::value}},}
\DoxyCodeLine{2259             \textcolor{stringliteral}{"{}chained comparisons are not supported inside assertions, "{}}}
\DoxyCodeLine{2260             \textcolor{stringliteral}{"{}wrap the expression inside parentheses, or decompose it"{}});}
\DoxyCodeLine{2261         \}}
\DoxyCodeLine{2262 }
\DoxyCodeLine{2263         \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{2264         \textcolor{keyword}{auto} operator != ( T ) \textcolor{keyword}{const} -\/> \mbox{\hyperlink{classCatch_1_1BinaryExpr}{BinaryExpr<LhsT, RhsT const\&>}} \textcolor{keyword}{const} \{}
\DoxyCodeLine{2265             \textcolor{keyword}{static\_assert}(\mbox{\hyperlink{structCatch_1_1always__false}{always\_false<T>::value}},}
\DoxyCodeLine{2266             \textcolor{stringliteral}{"{}chained comparisons are not supported inside assertions, "{}}}
\DoxyCodeLine{2267             \textcolor{stringliteral}{"{}wrap the expression inside parentheses, or decompose it"{}});}
\DoxyCodeLine{2268         \}}
\DoxyCodeLine{2269 }
\DoxyCodeLine{2270         \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{2271         \textcolor{keyword}{auto} operator > ( T ) \textcolor{keyword}{const} -\/> \mbox{\hyperlink{classCatch_1_1BinaryExpr}{BinaryExpr<LhsT, RhsT const\&>}} \textcolor{keyword}{const} \{}
\DoxyCodeLine{2272             \textcolor{keyword}{static\_assert}(\mbox{\hyperlink{structCatch_1_1always__false}{always\_false<T>::value}},}
\DoxyCodeLine{2273             \textcolor{stringliteral}{"{}chained comparisons are not supported inside assertions, "{}}}
\DoxyCodeLine{2274             \textcolor{stringliteral}{"{}wrap the expression inside parentheses, or decompose it"{}});}
\DoxyCodeLine{2275         \}}
\DoxyCodeLine{2276 }
\DoxyCodeLine{2277         \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{2278         \textcolor{keyword}{auto} operator < ( T ) \textcolor{keyword}{const} -\/> \mbox{\hyperlink{classCatch_1_1BinaryExpr}{BinaryExpr<LhsT, RhsT const\&>}} \textcolor{keyword}{const} \{}
\DoxyCodeLine{2279             \textcolor{keyword}{static\_assert}(\mbox{\hyperlink{structCatch_1_1always__false}{always\_false<T>::value}},}
\DoxyCodeLine{2280             \textcolor{stringliteral}{"{}chained comparisons are not supported inside assertions, "{}}}
\DoxyCodeLine{2281             \textcolor{stringliteral}{"{}wrap the expression inside parentheses, or decompose it"{}});}
\DoxyCodeLine{2282         \}}
\DoxyCodeLine{2283 }
\DoxyCodeLine{2284         \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{2285         \textcolor{keyword}{auto} operator >= ( T ) \textcolor{keyword}{const} -\/> \mbox{\hyperlink{classCatch_1_1BinaryExpr}{BinaryExpr<LhsT, RhsT const\&>}} \textcolor{keyword}{const} \{}
\DoxyCodeLine{2286             \textcolor{keyword}{static\_assert}(\mbox{\hyperlink{structCatch_1_1always__false}{always\_false<T>::value}},}
\DoxyCodeLine{2287             \textcolor{stringliteral}{"{}chained comparisons are not supported inside assertions, "{}}}
\DoxyCodeLine{2288             \textcolor{stringliteral}{"{}wrap the expression inside parentheses, or decompose it"{}});}
\DoxyCodeLine{2289         \}}
\DoxyCodeLine{2290 }
\DoxyCodeLine{2291         \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{2292         \textcolor{keyword}{auto} operator <= ( T ) \textcolor{keyword}{const} -\/> \mbox{\hyperlink{classCatch_1_1BinaryExpr}{BinaryExpr<LhsT, RhsT const\&>}} \textcolor{keyword}{const} \{}
\DoxyCodeLine{2293             \textcolor{keyword}{static\_assert}(\mbox{\hyperlink{structCatch_1_1always__false}{always\_false<T>::value}},}
\DoxyCodeLine{2294             \textcolor{stringliteral}{"{}chained comparisons are not supported inside assertions, "{}}}
\DoxyCodeLine{2295             \textcolor{stringliteral}{"{}wrap the expression inside parentheses, or decompose it"{}});}
\DoxyCodeLine{2296         \}}
\DoxyCodeLine{2297     \};}
\DoxyCodeLine{2298 }
\DoxyCodeLine{2299     \textcolor{keyword}{template}<\textcolor{keyword}{typename} LhsT>}
\DoxyCodeLine{2300     \textcolor{keyword}{class }\mbox{\hyperlink{classCatch_1_1UnaryExpr}{UnaryExpr}} : \textcolor{keyword}{public} \mbox{\hyperlink{structCatch_1_1ITransientExpression}{ITransientExpression}} \{}
\DoxyCodeLine{2301         LhsT m\_lhs;}
\DoxyCodeLine{2302 }
\DoxyCodeLine{2303         \textcolor{keywordtype}{void} streamReconstructedExpression( std::ostream \&os )\textcolor{keyword}{ const override }\{}
\DoxyCodeLine{2304             os << Catch::Detail::stringify( m\_lhs );}
\DoxyCodeLine{2305         \}}
\DoxyCodeLine{2306 }
\DoxyCodeLine{2307     \textcolor{keyword}{public}:}
\DoxyCodeLine{2308         \textcolor{keyword}{explicit} \mbox{\hyperlink{classCatch_1_1UnaryExpr}{UnaryExpr}}( LhsT lhs )}
\DoxyCodeLine{2309         :   \mbox{\hyperlink{structCatch_1_1ITransientExpression}{ITransientExpression}}\{ \textcolor{keyword}{false}, \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{bool}\textcolor{keyword}{>}(lhs) \},}
\DoxyCodeLine{2310             m\_lhs( lhs )}
\DoxyCodeLine{2311         \{\}}
\DoxyCodeLine{2312     \};}
\DoxyCodeLine{2313 }
\DoxyCodeLine{2314     \textcolor{comment}{// Specialised comparison functions to handle equality comparisons between ints and pointers (NULL deduces as an int)}}
\DoxyCodeLine{2315     \textcolor{keyword}{template}<\textcolor{keyword}{typename} LhsT, \textcolor{keyword}{typename} RhsT>}
\DoxyCodeLine{2316     \textcolor{keyword}{auto} compareEqual( LhsT \textcolor{keyword}{const}\& lhs, RhsT \textcolor{keyword}{const}\& rhs ) -\/> \textcolor{keywordtype}{bool} \{ \textcolor{keywordflow}{return} \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{bool}\textcolor{keyword}{>}(lhs == rhs); \}}
\DoxyCodeLine{2317     \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{2318     \textcolor{keyword}{auto} compareEqual( T* \textcolor{keyword}{const}\& lhs, \textcolor{keywordtype}{int} rhs ) -\/> \textcolor{keywordtype}{bool} \{ \textcolor{keywordflow}{return} lhs == \textcolor{keyword}{reinterpret\_cast<}\textcolor{keywordtype}{void} const*\textcolor{keyword}{>}( rhs ); \}}
\DoxyCodeLine{2319     \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{2320     \textcolor{keyword}{auto} compareEqual( T* \textcolor{keyword}{const}\& lhs, \textcolor{keywordtype}{long} rhs ) -\/> \textcolor{keywordtype}{bool} \{ \textcolor{keywordflow}{return} lhs == \textcolor{keyword}{reinterpret\_cast<}\textcolor{keywordtype}{void} const*\textcolor{keyword}{>}( rhs ); \}}
\DoxyCodeLine{2321     \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{2322     \textcolor{keyword}{auto} compareEqual( \textcolor{keywordtype}{int} lhs, T* \textcolor{keyword}{const}\& rhs ) -\/> \textcolor{keywordtype}{bool} \{ \textcolor{keywordflow}{return} \textcolor{keyword}{reinterpret\_cast<}\textcolor{keywordtype}{void} const*\textcolor{keyword}{>}( lhs ) == rhs; \}}
\DoxyCodeLine{2323     \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{2324     \textcolor{keyword}{auto} compareEqual( \textcolor{keywordtype}{long} lhs, T* \textcolor{keyword}{const}\& rhs ) -\/> \textcolor{keywordtype}{bool} \{ \textcolor{keywordflow}{return} \textcolor{keyword}{reinterpret\_cast<}\textcolor{keywordtype}{void} const*\textcolor{keyword}{>}( lhs ) == rhs; \}}
\DoxyCodeLine{2325 }
\DoxyCodeLine{2326     \textcolor{keyword}{template}<\textcolor{keyword}{typename} LhsT, \textcolor{keyword}{typename} RhsT>}
\DoxyCodeLine{2327     \textcolor{keyword}{auto} compareNotEqual( LhsT \textcolor{keyword}{const}\& lhs, RhsT\&\& rhs ) -\/> \textcolor{keywordtype}{bool} \{ \textcolor{keywordflow}{return} \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{bool}\textcolor{keyword}{>}(lhs != rhs); \}}
\DoxyCodeLine{2328     \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{2329     \textcolor{keyword}{auto} compareNotEqual( T* \textcolor{keyword}{const}\& lhs, \textcolor{keywordtype}{int} rhs ) -\/> \textcolor{keywordtype}{bool} \{ \textcolor{keywordflow}{return} lhs != \textcolor{keyword}{reinterpret\_cast<}\textcolor{keywordtype}{void} const*\textcolor{keyword}{>}( rhs ); \}}
\DoxyCodeLine{2330     \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{2331     \textcolor{keyword}{auto} compareNotEqual( T* \textcolor{keyword}{const}\& lhs, \textcolor{keywordtype}{long} rhs ) -\/> \textcolor{keywordtype}{bool} \{ \textcolor{keywordflow}{return} lhs != \textcolor{keyword}{reinterpret\_cast<}\textcolor{keywordtype}{void} const*\textcolor{keyword}{>}( rhs ); \}}
\DoxyCodeLine{2332     \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{2333     \textcolor{keyword}{auto} compareNotEqual( \textcolor{keywordtype}{int} lhs, T* \textcolor{keyword}{const}\& rhs ) -\/> \textcolor{keywordtype}{bool} \{ \textcolor{keywordflow}{return} \textcolor{keyword}{reinterpret\_cast<}\textcolor{keywordtype}{void} const*\textcolor{keyword}{>}( lhs ) != rhs; \}}
\DoxyCodeLine{2334     \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{2335     \textcolor{keyword}{auto} compareNotEqual( \textcolor{keywordtype}{long} lhs, T* \textcolor{keyword}{const}\& rhs ) -\/> \textcolor{keywordtype}{bool} \{ \textcolor{keywordflow}{return} \textcolor{keyword}{reinterpret\_cast<}\textcolor{keywordtype}{void} const*\textcolor{keyword}{>}( lhs ) != rhs; \}}
\DoxyCodeLine{2336 }
\DoxyCodeLine{2337     \textcolor{keyword}{template}<\textcolor{keyword}{typename} LhsT>}
\DoxyCodeLine{2338     \textcolor{keyword}{class }\mbox{\hyperlink{classCatch_1_1ExprLhs}{ExprLhs}} \{}
\DoxyCodeLine{2339         LhsT m\_lhs;}
\DoxyCodeLine{2340     \textcolor{keyword}{public}:}
\DoxyCodeLine{2341         \textcolor{keyword}{explicit} \mbox{\hyperlink{classCatch_1_1ExprLhs}{ExprLhs}}( LhsT lhs ) : m\_lhs( lhs ) \{\}}
\DoxyCodeLine{2342 }
\DoxyCodeLine{2343         \textcolor{keyword}{template}<\textcolor{keyword}{typename} RhsT>}
\DoxyCodeLine{2344         \textcolor{keyword}{auto} operator == ( RhsT \textcolor{keyword}{const}\& rhs ) -\/> \mbox{\hyperlink{classCatch_1_1BinaryExpr}{BinaryExpr<LhsT, RhsT const\&>}} \textcolor{keyword}{const} \{}
\DoxyCodeLine{2345             \textcolor{keywordflow}{return} \{ compareEqual( m\_lhs, rhs ), m\_lhs, \textcolor{stringliteral}{"{}=="{}}, rhs \};}
\DoxyCodeLine{2346         \}}
\DoxyCodeLine{2347         \textcolor{keyword}{auto} operator == ( \textcolor{keywordtype}{bool} rhs ) -\/> \mbox{\hyperlink{classCatch_1_1BinaryExpr}{BinaryExpr<LhsT, bool>}} \textcolor{keyword}{const} \{}
\DoxyCodeLine{2348             \textcolor{keywordflow}{return} \{ m\_lhs == rhs, m\_lhs, \textcolor{stringliteral}{"{}=="{}}, rhs \};}
\DoxyCodeLine{2349         \}}
\DoxyCodeLine{2350 }
\DoxyCodeLine{2351         \textcolor{keyword}{template}<\textcolor{keyword}{typename} RhsT>}
\DoxyCodeLine{2352         \textcolor{keyword}{auto} operator != ( RhsT \textcolor{keyword}{const}\& rhs ) -\/> \mbox{\hyperlink{classCatch_1_1BinaryExpr}{BinaryExpr<LhsT, RhsT const\&>}} \textcolor{keyword}{const} \{}
\DoxyCodeLine{2353             \textcolor{keywordflow}{return} \{ compareNotEqual( m\_lhs, rhs ), m\_lhs, \textcolor{stringliteral}{"{}!="{}}, rhs \};}
\DoxyCodeLine{2354         \}}
\DoxyCodeLine{2355         \textcolor{keyword}{auto} operator != ( \textcolor{keywordtype}{bool} rhs ) -\/> \mbox{\hyperlink{classCatch_1_1BinaryExpr}{BinaryExpr<LhsT, bool>}} \textcolor{keyword}{const} \{}
\DoxyCodeLine{2356             \textcolor{keywordflow}{return} \{ m\_lhs != rhs, m\_lhs, \textcolor{stringliteral}{"{}!="{}}, rhs \};}
\DoxyCodeLine{2357         \}}
\DoxyCodeLine{2358 }
\DoxyCodeLine{2359         \textcolor{keyword}{template}<\textcolor{keyword}{typename} RhsT>}
\DoxyCodeLine{2360         \textcolor{keyword}{auto} operator > ( RhsT \textcolor{keyword}{const}\& rhs ) -\/> \mbox{\hyperlink{classCatch_1_1BinaryExpr}{BinaryExpr<LhsT, RhsT const\&>}} \textcolor{keyword}{const} \{}
\DoxyCodeLine{2361             \textcolor{keywordflow}{return} \{ \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{bool}\textcolor{keyword}{>}(m\_lhs > rhs), m\_lhs, \textcolor{stringliteral}{"{}>"{}}, rhs \};}
\DoxyCodeLine{2362         \}}
\DoxyCodeLine{2363         \textcolor{keyword}{template}<\textcolor{keyword}{typename} RhsT>}
\DoxyCodeLine{2364         \textcolor{keyword}{auto} operator < ( RhsT \textcolor{keyword}{const}\& rhs ) -\/> \mbox{\hyperlink{classCatch_1_1BinaryExpr}{BinaryExpr<LhsT, RhsT const\&>}} \textcolor{keyword}{const} \{}
\DoxyCodeLine{2365             \textcolor{keywordflow}{return} \{ \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{bool}\textcolor{keyword}{>}(m\_lhs < rhs), m\_lhs, \textcolor{stringliteral}{"{}<"{}}, rhs \};}
\DoxyCodeLine{2366         \}}
\DoxyCodeLine{2367         \textcolor{keyword}{template}<\textcolor{keyword}{typename} RhsT>}
\DoxyCodeLine{2368         \textcolor{keyword}{auto} operator >= ( RhsT \textcolor{keyword}{const}\& rhs ) -\/> \mbox{\hyperlink{classCatch_1_1BinaryExpr}{BinaryExpr<LhsT, RhsT const\&>}} \textcolor{keyword}{const} \{}
\DoxyCodeLine{2369             \textcolor{keywordflow}{return} \{ \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{bool}\textcolor{keyword}{>}(m\_lhs >= rhs), m\_lhs, \textcolor{stringliteral}{"{}>="{}}, rhs \};}
\DoxyCodeLine{2370         \}}
\DoxyCodeLine{2371         \textcolor{keyword}{template}<\textcolor{keyword}{typename} RhsT>}
\DoxyCodeLine{2372         \textcolor{keyword}{auto} operator <= ( RhsT \textcolor{keyword}{const}\& rhs ) -\/> \mbox{\hyperlink{classCatch_1_1BinaryExpr}{BinaryExpr<LhsT, RhsT const\&>}} \textcolor{keyword}{const} \{}
\DoxyCodeLine{2373             \textcolor{keywordflow}{return} \{ \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{bool}\textcolor{keyword}{>}(m\_lhs <= rhs), m\_lhs, \textcolor{stringliteral}{"{}<="{}}, rhs \};}
\DoxyCodeLine{2374         \}}
\DoxyCodeLine{2375         \textcolor{keyword}{template} <\textcolor{keyword}{typename} RhsT>}
\DoxyCodeLine{2376         \textcolor{keyword}{auto} operator | (RhsT \textcolor{keyword}{const}\& rhs) -\/> \mbox{\hyperlink{classCatch_1_1BinaryExpr}{BinaryExpr<LhsT, RhsT const\&>}} \textcolor{keyword}{const} \{}
\DoxyCodeLine{2377             \textcolor{keywordflow}{return} \{ \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{bool}\textcolor{keyword}{>}(m\_lhs | rhs), m\_lhs, \textcolor{stringliteral}{"{}|"{}}, rhs \};}
\DoxyCodeLine{2378         \}}
\DoxyCodeLine{2379         \textcolor{keyword}{template} <\textcolor{keyword}{typename} RhsT>}
\DoxyCodeLine{2380         \textcolor{keyword}{auto} operator \& (RhsT \textcolor{keyword}{const}\& rhs) -\/> \mbox{\hyperlink{classCatch_1_1BinaryExpr}{BinaryExpr<LhsT, RhsT const\&>}} \textcolor{keyword}{const} \{}
\DoxyCodeLine{2381             \textcolor{keywordflow}{return} \{ \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{bool}\textcolor{keyword}{>}(m\_lhs \& rhs), m\_lhs, \textcolor{stringliteral}{"{}\&"{}}, rhs \};}
\DoxyCodeLine{2382         \}}
\DoxyCodeLine{2383         \textcolor{keyword}{template} <\textcolor{keyword}{typename} RhsT>}
\DoxyCodeLine{2384         \textcolor{keyword}{auto} operator \string^ (RhsT \textcolor{keyword}{const}\& rhs) -\/> \mbox{\hyperlink{classCatch_1_1BinaryExpr}{BinaryExpr<LhsT, RhsT const\&>}} \textcolor{keyword}{const} \{}
\DoxyCodeLine{2385             \textcolor{keywordflow}{return} \{ \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{bool}\textcolor{keyword}{>}(m\_lhs \string^ rhs), m\_lhs, \textcolor{stringliteral}{"{}\string^"{}}, rhs \};}
\DoxyCodeLine{2386         \}}
\DoxyCodeLine{2387 }
\DoxyCodeLine{2388         \textcolor{keyword}{template}<\textcolor{keyword}{typename} RhsT>}
\DoxyCodeLine{2389         \textcolor{keyword}{auto} operator \&\& ( RhsT \textcolor{keyword}{const}\& ) -\/> \mbox{\hyperlink{classCatch_1_1BinaryExpr}{BinaryExpr<LhsT, RhsT const\&>}} \textcolor{keyword}{const} \{}
\DoxyCodeLine{2390             \textcolor{keyword}{static\_assert}(\mbox{\hyperlink{structCatch_1_1always__false}{always\_false<RhsT>::value}},}
\DoxyCodeLine{2391             \textcolor{stringliteral}{"{}operator\&\& is not supported inside assertions, "{}}}
\DoxyCodeLine{2392             \textcolor{stringliteral}{"{}wrap the expression inside parentheses, or decompose it"{}});}
\DoxyCodeLine{2393         \}}
\DoxyCodeLine{2394 }
\DoxyCodeLine{2395         \textcolor{keyword}{template}<\textcolor{keyword}{typename} RhsT>}
\DoxyCodeLine{2396         \textcolor{keyword}{auto} operator || ( RhsT \textcolor{keyword}{const}\& ) -\/> \mbox{\hyperlink{classCatch_1_1BinaryExpr}{BinaryExpr<LhsT, RhsT const\&>}} \textcolor{keyword}{const} \{}
\DoxyCodeLine{2397             \textcolor{keyword}{static\_assert}(\mbox{\hyperlink{structCatch_1_1always__false}{always\_false<RhsT>::value}},}
\DoxyCodeLine{2398             \textcolor{stringliteral}{"{}operator|| is not supported inside assertions, "{}}}
\DoxyCodeLine{2399             \textcolor{stringliteral}{"{}wrap the expression inside parentheses, or decompose it"{}});}
\DoxyCodeLine{2400         \}}
\DoxyCodeLine{2401 }
\DoxyCodeLine{2402         \textcolor{keyword}{auto} makeUnaryExpr() \textcolor{keyword}{const} -\/> \mbox{\hyperlink{classCatch_1_1UnaryExpr}{UnaryExpr<LhsT>}} \{}
\DoxyCodeLine{2403             \textcolor{keywordflow}{return} \mbox{\hyperlink{classCatch_1_1UnaryExpr}{UnaryExpr<LhsT>}}\{ m\_lhs \};}
\DoxyCodeLine{2404         \}}
\DoxyCodeLine{2405     \};}
\DoxyCodeLine{2406 }
\DoxyCodeLine{2407     \textcolor{keywordtype}{void} handleExpression( \mbox{\hyperlink{structCatch_1_1ITransientExpression}{ITransientExpression}} \textcolor{keyword}{const}\& expr );}
\DoxyCodeLine{2408 }
\DoxyCodeLine{2409     \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{2410     \textcolor{keywordtype}{void} handleExpression( \mbox{\hyperlink{classCatch_1_1ExprLhs}{ExprLhs<T>}} \textcolor{keyword}{const}\& expr ) \{}
\DoxyCodeLine{2411         handleExpression( expr.makeUnaryExpr() );}
\DoxyCodeLine{2412     \}}
\DoxyCodeLine{2413 }
\DoxyCodeLine{2414     \textcolor{keyword}{struct }\mbox{\hyperlink{structCatch_1_1Decomposer}{Decomposer}} \{}
\DoxyCodeLine{2415         \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{2416         \textcolor{keyword}{auto} operator <= ( T \textcolor{keyword}{const}\& lhs ) -\/> \mbox{\hyperlink{classCatch_1_1ExprLhs}{ExprLhs<T const\&>}} \{}
\DoxyCodeLine{2417             \textcolor{keywordflow}{return} \mbox{\hyperlink{classCatch_1_1ExprLhs}{ExprLhs<T const\&>}}\{ lhs \};}
\DoxyCodeLine{2418         \}}
\DoxyCodeLine{2419 }
\DoxyCodeLine{2420         \textcolor{keyword}{auto} operator <=( \textcolor{keywordtype}{bool} value ) -\/> \mbox{\hyperlink{classCatch_1_1ExprLhs}{ExprLhs<bool>}} \{}
\DoxyCodeLine{2421             \textcolor{keywordflow}{return} \mbox{\hyperlink{classCatch_1_1ExprLhs}{ExprLhs<bool>}}\{ value \};}
\DoxyCodeLine{2422         \}}
\DoxyCodeLine{2423     \};}
\DoxyCodeLine{2424 }
\DoxyCodeLine{2425 \} \textcolor{comment}{// end namespace Catch}}
\DoxyCodeLine{2426 }
\DoxyCodeLine{2427 \textcolor{preprocessor}{\#ifdef \_MSC\_VER}}
\DoxyCodeLine{2428 \textcolor{preprocessor}{\#pragma warning(pop)}}
\DoxyCodeLine{2429 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{2430 }
\DoxyCodeLine{2431 \textcolor{comment}{// end catch\_decomposer.h}}
\DoxyCodeLine{2432 \textcolor{comment}{// start catch\_interfaces\_capture.h}}
\DoxyCodeLine{2433 }
\DoxyCodeLine{2434 \textcolor{preprocessor}{\#include <string>}}
\DoxyCodeLine{2435 \textcolor{preprocessor}{\#include <chrono>}}
\DoxyCodeLine{2436 }
\DoxyCodeLine{2437 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{2438 }
\DoxyCodeLine{2439     \textcolor{keyword}{class }AssertionResult;}
\DoxyCodeLine{2440     \textcolor{keyword}{struct }AssertionInfo;}
\DoxyCodeLine{2441     \textcolor{keyword}{struct }SectionInfo;}
\DoxyCodeLine{2442     \textcolor{keyword}{struct }SectionEndInfo;}
\DoxyCodeLine{2443     \textcolor{keyword}{struct }MessageInfo;}
\DoxyCodeLine{2444     \textcolor{keyword}{struct }MessageBuilder;}
\DoxyCodeLine{2445     \textcolor{keyword}{struct }Counts;}
\DoxyCodeLine{2446     \textcolor{keyword}{struct }AssertionReaction;}
\DoxyCodeLine{2447     \textcolor{keyword}{struct }SourceLineInfo;}
\DoxyCodeLine{2448 }
\DoxyCodeLine{2449     \textcolor{keyword}{struct }ITransientExpression;}
\DoxyCodeLine{2450     \textcolor{keyword}{struct }IGeneratorTracker;}
\DoxyCodeLine{2451 }
\DoxyCodeLine{2452 \textcolor{preprocessor}{\#if defined(CATCH\_CONFIG\_ENABLE\_BENCHMARKING)}}
\DoxyCodeLine{2453     \textcolor{keyword}{struct }BenchmarkInfo;}
\DoxyCodeLine{2454     \textcolor{keyword}{template} <\textcolor{keyword}{typename} Duration = std::chrono::duration<\textcolor{keywordtype}{double}, std::nano>>}
\DoxyCodeLine{2455     \textcolor{keyword}{struct }BenchmarkStats;}
\DoxyCodeLine{2456 \textcolor{preprocessor}{\#endif }\textcolor{comment}{// CATCH\_CONFIG\_ENABLE\_BENCHMARKING}}
\DoxyCodeLine{2457 }
\DoxyCodeLine{2458     \textcolor{keyword}{struct }\mbox{\hyperlink{structCatch_1_1IResultCapture}{IResultCapture}} \{}
\DoxyCodeLine{2459 }
\DoxyCodeLine{2460         \textcolor{keyword}{virtual} \mbox{\hyperlink{structCatch_1_1IResultCapture}{\string~IResultCapture}}();}
\DoxyCodeLine{2461 }
\DoxyCodeLine{2462         \textcolor{keyword}{virtual} \textcolor{keywordtype}{bool} sectionStarted(    \mbox{\hyperlink{structCatch_1_1SectionInfo}{SectionInfo}} \textcolor{keyword}{const}\& sectionInfo,}
\DoxyCodeLine{2463                                         \mbox{\hyperlink{structCatch_1_1Counts}{Counts}}\& assertions ) = 0;}
\DoxyCodeLine{2464         \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} sectionEnded( \mbox{\hyperlink{structCatch_1_1SectionEndInfo}{SectionEndInfo}} \textcolor{keyword}{const}\& endInfo ) = 0;}
\DoxyCodeLine{2465         \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} sectionEndedEarly( \mbox{\hyperlink{structCatch_1_1SectionEndInfo}{SectionEndInfo}} \textcolor{keyword}{const}\& endInfo ) = 0;}
\DoxyCodeLine{2466 }
\DoxyCodeLine{2467         \textcolor{keyword}{virtual} \textcolor{keyword}{auto} acquireGeneratorTracker( \mbox{\hyperlink{classCatch_1_1StringRef}{StringRef}} generatorName, \mbox{\hyperlink{structCatch_1_1SourceLineInfo}{SourceLineInfo}} \textcolor{keyword}{const}\& lineInfo ) -\/> \mbox{\hyperlink{structCatch_1_1IGeneratorTracker}{IGeneratorTracker}}\& = 0;}
\DoxyCodeLine{2468 }
\DoxyCodeLine{2469 \textcolor{preprocessor}{\#if defined(CATCH\_CONFIG\_ENABLE\_BENCHMARKING)}}
\DoxyCodeLine{2470         \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} benchmarkPreparing( std::string \textcolor{keyword}{const}\& name ) = 0;}
\DoxyCodeLine{2471         \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} benchmarkStarting( BenchmarkInfo \textcolor{keyword}{const}\& info ) = 0;}
\DoxyCodeLine{2472         \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} benchmarkEnded( BenchmarkStats<> \textcolor{keyword}{const}\& stats ) = 0;}
\DoxyCodeLine{2473         \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} benchmarkFailed( std::string \textcolor{keyword}{const}\& error ) = 0;}
\DoxyCodeLine{2474 \textcolor{preprocessor}{\#endif }\textcolor{comment}{// CATCH\_CONFIG\_ENABLE\_BENCHMARKING}}
\DoxyCodeLine{2475 }
\DoxyCodeLine{2476         \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} pushScopedMessage( \mbox{\hyperlink{structCatch_1_1MessageInfo}{MessageInfo}} \textcolor{keyword}{const}\& message ) = 0;}
\DoxyCodeLine{2477         \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} popScopedMessage( \mbox{\hyperlink{structCatch_1_1MessageInfo}{MessageInfo}} \textcolor{keyword}{const}\& message ) = 0;}
\DoxyCodeLine{2478 }
\DoxyCodeLine{2479         \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} emplaceUnscopedMessage( \mbox{\hyperlink{structCatch_1_1MessageBuilder}{MessageBuilder}} \textcolor{keyword}{const}\& builder ) = 0;}
\DoxyCodeLine{2480 }
\DoxyCodeLine{2481         \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} handleFatalErrorCondition( \mbox{\hyperlink{classCatch_1_1StringRef}{StringRef}} message ) = 0;}
\DoxyCodeLine{2482 }
\DoxyCodeLine{2483         \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} handleExpr}
\DoxyCodeLine{2484                 (   \mbox{\hyperlink{structCatch_1_1AssertionInfo}{AssertionInfo}} \textcolor{keyword}{const}\& info,}
\DoxyCodeLine{2485                     \mbox{\hyperlink{structCatch_1_1ITransientExpression}{ITransientExpression}} \textcolor{keyword}{const}\& expr,}
\DoxyCodeLine{2486                     \mbox{\hyperlink{structCatch_1_1AssertionReaction}{AssertionReaction}}\& reaction ) = 0;}
\DoxyCodeLine{2487         \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} handleMessage}
\DoxyCodeLine{2488                 (   \mbox{\hyperlink{structCatch_1_1AssertionInfo}{AssertionInfo}} \textcolor{keyword}{const}\& info,}
\DoxyCodeLine{2489                     ResultWas::OfType resultType,}
\DoxyCodeLine{2490                     \mbox{\hyperlink{classCatch_1_1StringRef}{StringRef}} \textcolor{keyword}{const}\& message,}
\DoxyCodeLine{2491                     \mbox{\hyperlink{structCatch_1_1AssertionReaction}{AssertionReaction}}\& reaction ) = 0;}
\DoxyCodeLine{2492         \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} handleUnexpectedExceptionNotThrown}
\DoxyCodeLine{2493                 (   \mbox{\hyperlink{structCatch_1_1AssertionInfo}{AssertionInfo}} \textcolor{keyword}{const}\& info,}
\DoxyCodeLine{2494                     \mbox{\hyperlink{structCatch_1_1AssertionReaction}{AssertionReaction}}\& reaction ) = 0;}
\DoxyCodeLine{2495         \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} handleUnexpectedInflightException}
\DoxyCodeLine{2496                 (   \mbox{\hyperlink{structCatch_1_1AssertionInfo}{AssertionInfo}} \textcolor{keyword}{const}\& info,}
\DoxyCodeLine{2497                     std::string \textcolor{keyword}{const}\& message,}
\DoxyCodeLine{2498                     \mbox{\hyperlink{structCatch_1_1AssertionReaction}{AssertionReaction}}\& reaction ) = 0;}
\DoxyCodeLine{2499         \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} handleIncomplete}
\DoxyCodeLine{2500                 (   \mbox{\hyperlink{structCatch_1_1AssertionInfo}{AssertionInfo}} \textcolor{keyword}{const}\& info ) = 0;}
\DoxyCodeLine{2501         \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} handleNonExpr}
\DoxyCodeLine{2502                 (   \mbox{\hyperlink{structCatch_1_1AssertionInfo}{AssertionInfo}} \textcolor{keyword}{const} \&info,}
\DoxyCodeLine{2503                     ResultWas::OfType resultType,}
\DoxyCodeLine{2504                     \mbox{\hyperlink{structCatch_1_1AssertionReaction}{AssertionReaction}} \&reaction ) = 0;}
\DoxyCodeLine{2505 }
\DoxyCodeLine{2506         \textcolor{keyword}{virtual} \textcolor{keywordtype}{bool} lastAssertionPassed() = 0;}
\DoxyCodeLine{2507         \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} assertionPassed() = 0;}
\DoxyCodeLine{2508 }
\DoxyCodeLine{2509         \textcolor{comment}{// Deprecated, do not use:}}
\DoxyCodeLine{2510         \textcolor{keyword}{virtual} std::string getCurrentTestName() \textcolor{keyword}{const} = 0;}
\DoxyCodeLine{2511         \textcolor{keyword}{virtual} \textcolor{keyword}{const} AssertionResult* getLastResult() \textcolor{keyword}{const} = 0;}
\DoxyCodeLine{2512         \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} exceptionEarlyReported() = 0;}
\DoxyCodeLine{2513     \};}
\DoxyCodeLine{2514 }
\DoxyCodeLine{2515     \mbox{\hyperlink{structCatch_1_1IResultCapture}{IResultCapture}}\& getResultCapture();}
\DoxyCodeLine{2516 \}}
\DoxyCodeLine{2517 }
\DoxyCodeLine{2518 \textcolor{comment}{// end catch\_interfaces\_capture.h}}
\DoxyCodeLine{2519 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{2520 }
\DoxyCodeLine{2521     \textcolor{keyword}{struct }\mbox{\hyperlink{structCatch_1_1TestFailureException}{TestFailureException}}\{\};}
\DoxyCodeLine{2522     \textcolor{keyword}{struct }AssertionResultData;}
\DoxyCodeLine{2523     \textcolor{keyword}{struct }\mbox{\hyperlink{structCatch_1_1IResultCapture}{IResultCapture}};}
\DoxyCodeLine{2524     \textcolor{keyword}{class }RunContext;}
\DoxyCodeLine{2525 }
\DoxyCodeLine{2526     \textcolor{keyword}{class }\mbox{\hyperlink{classCatch_1_1LazyExpression}{LazyExpression}} \{}
\DoxyCodeLine{2527         \textcolor{keyword}{friend} \textcolor{keyword}{class }\mbox{\hyperlink{classCatch_1_1AssertionHandler}{AssertionHandler}};}
\DoxyCodeLine{2528         \textcolor{keyword}{friend} \textcolor{keyword}{struct }AssertionStats;}
\DoxyCodeLine{2529         \textcolor{keyword}{friend} \textcolor{keyword}{class }RunContext;}
\DoxyCodeLine{2530 }
\DoxyCodeLine{2531         \mbox{\hyperlink{structCatch_1_1ITransientExpression}{ITransientExpression}} \textcolor{keyword}{const}* m\_transientExpression = \textcolor{keyword}{nullptr};}
\DoxyCodeLine{2532         \textcolor{keywordtype}{bool} m\_isNegated;}
\DoxyCodeLine{2533     \textcolor{keyword}{public}:}
\DoxyCodeLine{2534         \mbox{\hyperlink{classCatch_1_1LazyExpression}{LazyExpression}}( \textcolor{keywordtype}{bool} isNegated );}
\DoxyCodeLine{2535         \mbox{\hyperlink{classCatch_1_1LazyExpression}{LazyExpression}}( \mbox{\hyperlink{classCatch_1_1LazyExpression}{LazyExpression}} \textcolor{keyword}{const}\& other );}
\DoxyCodeLine{2536         \mbox{\hyperlink{classCatch_1_1LazyExpression}{LazyExpression}}\& operator = ( \mbox{\hyperlink{classCatch_1_1LazyExpression}{LazyExpression}} \textcolor{keyword}{const}\& ) = \textcolor{keyword}{delete};}
\DoxyCodeLine{2537 }
\DoxyCodeLine{2538         \textcolor{keyword}{explicit} \textcolor{keyword}{operator} bool() \textcolor{keyword}{const};}
\DoxyCodeLine{2539 }
\DoxyCodeLine{2540         \textcolor{keyword}{friend} \textcolor{keyword}{auto} operator << ( std::ostream\& os, \mbox{\hyperlink{classCatch_1_1LazyExpression}{LazyExpression}} \textcolor{keyword}{const}\& lazyExpr ) -\/> std::ostream\&;}
\DoxyCodeLine{2541     \};}
\DoxyCodeLine{2542 }
\DoxyCodeLine{2543     \textcolor{keyword}{struct }\mbox{\hyperlink{structCatch_1_1AssertionReaction}{AssertionReaction}} \{}
\DoxyCodeLine{2544         \textcolor{keywordtype}{bool} shouldDebugBreak = \textcolor{keyword}{false};}
\DoxyCodeLine{2545         \textcolor{keywordtype}{bool} shouldThrow = \textcolor{keyword}{false};}
\DoxyCodeLine{2546     \};}
\DoxyCodeLine{2547 }
\DoxyCodeLine{2548     \textcolor{keyword}{class }\mbox{\hyperlink{classCatch_1_1AssertionHandler}{AssertionHandler}} \{}
\DoxyCodeLine{2549         \mbox{\hyperlink{structCatch_1_1AssertionInfo}{AssertionInfo}} m\_assertionInfo;}
\DoxyCodeLine{2550         \mbox{\hyperlink{structCatch_1_1AssertionReaction}{AssertionReaction}} m\_reaction;}
\DoxyCodeLine{2551         \textcolor{keywordtype}{bool} m\_completed = \textcolor{keyword}{false};}
\DoxyCodeLine{2552         \mbox{\hyperlink{structCatch_1_1IResultCapture}{IResultCapture}}\& m\_resultCapture;}
\DoxyCodeLine{2553 }
\DoxyCodeLine{2554     \textcolor{keyword}{public}:}
\DoxyCodeLine{2555         \mbox{\hyperlink{classCatch_1_1AssertionHandler}{AssertionHandler}}}
\DoxyCodeLine{2556             (   \mbox{\hyperlink{classCatch_1_1StringRef}{StringRef}} \textcolor{keyword}{const}\& macroName,}
\DoxyCodeLine{2557                 \mbox{\hyperlink{structCatch_1_1SourceLineInfo}{SourceLineInfo}} \textcolor{keyword}{const}\& lineInfo,}
\DoxyCodeLine{2558                 \mbox{\hyperlink{classCatch_1_1StringRef}{StringRef}} capturedExpression,}
\DoxyCodeLine{2559                 ResultDisposition::Flags resultDisposition );}
\DoxyCodeLine{2560         \mbox{\hyperlink{classCatch_1_1AssertionHandler}{\string~AssertionHandler}}() \{}
\DoxyCodeLine{2561             \textcolor{keywordflow}{if} ( !m\_completed ) \{}
\DoxyCodeLine{2562                 m\_resultCapture.handleIncomplete( m\_assertionInfo );}
\DoxyCodeLine{2563             \}}
\DoxyCodeLine{2564         \}}
\DoxyCodeLine{2565 }
\DoxyCodeLine{2566         \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{2567         \textcolor{keywordtype}{void} handleExpr( \mbox{\hyperlink{classCatch_1_1ExprLhs}{ExprLhs<T>}} \textcolor{keyword}{const}\& expr ) \{}
\DoxyCodeLine{2568             handleExpr( expr.makeUnaryExpr() );}
\DoxyCodeLine{2569         \}}
\DoxyCodeLine{2570         \textcolor{keywordtype}{void} handleExpr( \mbox{\hyperlink{structCatch_1_1ITransientExpression}{ITransientExpression}} \textcolor{keyword}{const}\& expr );}
\DoxyCodeLine{2571 }
\DoxyCodeLine{2572         \textcolor{keywordtype}{void} handleMessage(ResultWas::OfType resultType, \mbox{\hyperlink{classCatch_1_1StringRef}{StringRef}} \textcolor{keyword}{const}\& message);}
\DoxyCodeLine{2573 }
\DoxyCodeLine{2574         \textcolor{keywordtype}{void} handleExceptionThrownAsExpected();}
\DoxyCodeLine{2575         \textcolor{keywordtype}{void} handleUnexpectedExceptionNotThrown();}
\DoxyCodeLine{2576         \textcolor{keywordtype}{void} handleExceptionNotThrownAsExpected();}
\DoxyCodeLine{2577         \textcolor{keywordtype}{void} handleThrowingCallSkipped();}
\DoxyCodeLine{2578         \textcolor{keywordtype}{void} handleUnexpectedInflightException();}
\DoxyCodeLine{2579 }
\DoxyCodeLine{2580         \textcolor{keywordtype}{void} complete();}
\DoxyCodeLine{2581         \textcolor{keywordtype}{void} setCompleted();}
\DoxyCodeLine{2582 }
\DoxyCodeLine{2583         \textcolor{comment}{// query}}
\DoxyCodeLine{2584         \textcolor{keyword}{auto} allowThrows() \textcolor{keyword}{const} -\/> bool;}
\DoxyCodeLine{2585     \};}
\DoxyCodeLine{2586 }
\DoxyCodeLine{2587     \textcolor{keywordtype}{void} handleExceptionMatchExpr( \mbox{\hyperlink{classCatch_1_1AssertionHandler}{AssertionHandler}}\& handler, std::string \textcolor{keyword}{const}\& str, \mbox{\hyperlink{classCatch_1_1StringRef}{StringRef}} \textcolor{keyword}{const}\& matcherString );}
\DoxyCodeLine{2588 }
\DoxyCodeLine{2589 \} \textcolor{comment}{// namespace Catch}}
\DoxyCodeLine{2590 }
\DoxyCodeLine{2591 \textcolor{comment}{// end catch\_assertionhandler.h}}
\DoxyCodeLine{2592 \textcolor{comment}{// start catch\_message.h}}
\DoxyCodeLine{2593 }
\DoxyCodeLine{2594 \textcolor{preprocessor}{\#include <string>}}
\DoxyCodeLine{2595 \textcolor{preprocessor}{\#include <vector>}}
\DoxyCodeLine{2596 }
\DoxyCodeLine{2597 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{2598 }
\DoxyCodeLine{2599     \textcolor{keyword}{struct }\mbox{\hyperlink{structCatch_1_1MessageInfo}{MessageInfo}} \{}
\DoxyCodeLine{2600         \mbox{\hyperlink{structCatch_1_1MessageInfo}{MessageInfo}}(    \mbox{\hyperlink{classCatch_1_1StringRef}{StringRef}} \textcolor{keyword}{const}\& \_macroName,}
\DoxyCodeLine{2601                         \mbox{\hyperlink{structCatch_1_1SourceLineInfo}{SourceLineInfo}} \textcolor{keyword}{const}\& \_lineInfo,}
\DoxyCodeLine{2602                         ResultWas::OfType \_type );}
\DoxyCodeLine{2603 }
\DoxyCodeLine{2604         \mbox{\hyperlink{classCatch_1_1StringRef}{StringRef}} macroName;}
\DoxyCodeLine{2605         std::string message;}
\DoxyCodeLine{2606         \mbox{\hyperlink{structCatch_1_1SourceLineInfo}{SourceLineInfo}} lineInfo;}
\DoxyCodeLine{2607         ResultWas::OfType type;}
\DoxyCodeLine{2608         \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} sequence;}
\DoxyCodeLine{2609 }
\DoxyCodeLine{2610         \textcolor{keywordtype}{bool} operator == ( \mbox{\hyperlink{structCatch_1_1MessageInfo}{MessageInfo}} \textcolor{keyword}{const}\& other ) \textcolor{keyword}{const};}
\DoxyCodeLine{2611         \textcolor{keywordtype}{bool} operator < ( \mbox{\hyperlink{structCatch_1_1MessageInfo}{MessageInfo}} \textcolor{keyword}{const}\& other ) \textcolor{keyword}{const};}
\DoxyCodeLine{2612     \textcolor{keyword}{private}:}
\DoxyCodeLine{2613         \textcolor{keyword}{static} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} globalCount;}
\DoxyCodeLine{2614     \};}
\DoxyCodeLine{2615 }
\DoxyCodeLine{2616     \textcolor{keyword}{struct }\mbox{\hyperlink{structCatch_1_1MessageStream}{MessageStream}} \{}
\DoxyCodeLine{2617 }
\DoxyCodeLine{2618         \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{2619         \mbox{\hyperlink{structCatch_1_1MessageStream}{MessageStream}}\& operator << ( T \textcolor{keyword}{const}\& value ) \{}
\DoxyCodeLine{2620             m\_stream << value;}
\DoxyCodeLine{2621             \textcolor{keywordflow}{return} *\textcolor{keyword}{this};}
\DoxyCodeLine{2622         \}}
\DoxyCodeLine{2623 }
\DoxyCodeLine{2624         \mbox{\hyperlink{classCatch_1_1ReusableStringStream}{ReusableStringStream}} m\_stream;}
\DoxyCodeLine{2625     \};}
\DoxyCodeLine{2626 }
\DoxyCodeLine{2627     \textcolor{keyword}{struct }\mbox{\hyperlink{structCatch_1_1MessageBuilder}{MessageBuilder}} : \mbox{\hyperlink{structCatch_1_1MessageStream}{MessageStream}} \{}
\DoxyCodeLine{2628         \mbox{\hyperlink{structCatch_1_1MessageBuilder}{MessageBuilder}}( \mbox{\hyperlink{classCatch_1_1StringRef}{StringRef}} \textcolor{keyword}{const}\& macroName,}
\DoxyCodeLine{2629                         \mbox{\hyperlink{structCatch_1_1SourceLineInfo}{SourceLineInfo}} \textcolor{keyword}{const}\& lineInfo,}
\DoxyCodeLine{2630                         ResultWas::OfType type );}
\DoxyCodeLine{2631 }
\DoxyCodeLine{2632         \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{2633         \mbox{\hyperlink{structCatch_1_1MessageBuilder}{MessageBuilder}}\& operator << ( T \textcolor{keyword}{const}\& value ) \{}
\DoxyCodeLine{2634             m\_stream << value;}
\DoxyCodeLine{2635             \textcolor{keywordflow}{return} *\textcolor{keyword}{this};}
\DoxyCodeLine{2636         \}}
\DoxyCodeLine{2637 }
\DoxyCodeLine{2638         \mbox{\hyperlink{structCatch_1_1MessageInfo}{MessageInfo}} m\_info;}
\DoxyCodeLine{2639     \};}
\DoxyCodeLine{2640 }
\DoxyCodeLine{2641     \textcolor{keyword}{class }\mbox{\hyperlink{classCatch_1_1ScopedMessage}{ScopedMessage}} \{}
\DoxyCodeLine{2642     \textcolor{keyword}{public}:}
\DoxyCodeLine{2643         \textcolor{keyword}{explicit} \mbox{\hyperlink{classCatch_1_1ScopedMessage}{ScopedMessage}}( \mbox{\hyperlink{structCatch_1_1MessageBuilder}{MessageBuilder}} \textcolor{keyword}{const}\& builder );}
\DoxyCodeLine{2644         \mbox{\hyperlink{classCatch_1_1ScopedMessage}{ScopedMessage}}( \mbox{\hyperlink{classCatch_1_1ScopedMessage}{ScopedMessage}}\& duplicate ) = \textcolor{keyword}{delete};}
\DoxyCodeLine{2645         \mbox{\hyperlink{classCatch_1_1ScopedMessage}{ScopedMessage}}( \mbox{\hyperlink{classCatch_1_1ScopedMessage}{ScopedMessage}}\&\& old );}
\DoxyCodeLine{2646         \mbox{\hyperlink{classCatch_1_1ScopedMessage}{\string~ScopedMessage}}();}
\DoxyCodeLine{2647 }
\DoxyCodeLine{2648         \mbox{\hyperlink{structCatch_1_1MessageInfo}{MessageInfo}} m\_info;}
\DoxyCodeLine{2649         \textcolor{keywordtype}{bool} m\_moved;}
\DoxyCodeLine{2650     \};}
\DoxyCodeLine{2651 }
\DoxyCodeLine{2652     \textcolor{keyword}{class }\mbox{\hyperlink{classCatch_1_1Capturer}{Capturer}} \{}
\DoxyCodeLine{2653         std::vector<MessageInfo> m\_messages;}
\DoxyCodeLine{2654         \mbox{\hyperlink{structCatch_1_1IResultCapture}{IResultCapture}}\& m\_resultCapture = getResultCapture();}
\DoxyCodeLine{2655         \textcolor{keywordtype}{size\_t} m\_captured = 0;}
\DoxyCodeLine{2656     \textcolor{keyword}{public}:}
\DoxyCodeLine{2657         \mbox{\hyperlink{classCatch_1_1Capturer}{Capturer}}( \mbox{\hyperlink{classCatch_1_1StringRef}{StringRef}} macroName, \mbox{\hyperlink{structCatch_1_1SourceLineInfo}{SourceLineInfo}} \textcolor{keyword}{const}\& lineInfo, ResultWas::OfType resultType, \mbox{\hyperlink{classCatch_1_1StringRef}{StringRef}} names );}
\DoxyCodeLine{2658         \mbox{\hyperlink{classCatch_1_1Capturer}{\string~Capturer}}();}
\DoxyCodeLine{2659 }
\DoxyCodeLine{2660         \textcolor{keywordtype}{void} captureValue( \textcolor{keywordtype}{size\_t} index, std::string \textcolor{keyword}{const}\& value );}
\DoxyCodeLine{2661 }
\DoxyCodeLine{2662         \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{2663         \textcolor{keywordtype}{void} captureValues( \textcolor{keywordtype}{size\_t} index, T \textcolor{keyword}{const}\& value ) \{}
\DoxyCodeLine{2664             captureValue( index, Catch::Detail::stringify( value ) );}
\DoxyCodeLine{2665         \}}
\DoxyCodeLine{2666 }
\DoxyCodeLine{2667         \textcolor{keyword}{template}<\textcolor{keyword}{typename} T, \textcolor{keyword}{typename}... Ts>}
\DoxyCodeLine{2668         \textcolor{keywordtype}{void} captureValues( \textcolor{keywordtype}{size\_t} index, T \textcolor{keyword}{const}\& value, Ts \textcolor{keyword}{const}\&... values ) \{}
\DoxyCodeLine{2669             captureValue( index, Catch::Detail::stringify(value) );}
\DoxyCodeLine{2670             captureValues( index+1, values... );}
\DoxyCodeLine{2671         \}}
\DoxyCodeLine{2672     \};}
\DoxyCodeLine{2673 }
\DoxyCodeLine{2674 \} \textcolor{comment}{// end namespace Catch}}
\DoxyCodeLine{2675 }
\DoxyCodeLine{2676 \textcolor{comment}{// end catch\_message.h}}
\DoxyCodeLine{2677 \textcolor{preprocessor}{\#if !defined(CATCH\_CONFIG\_DISABLE)}}
\DoxyCodeLine{2678 }
\DoxyCodeLine{2679 \textcolor{preprocessor}{\#if !defined(CATCH\_CONFIG\_DISABLE\_STRINGIFICATION)}}
\DoxyCodeLine{2680 \textcolor{preprocessor}{  \#define CATCH\_INTERNAL\_STRINGIFY(...) \#\_\_VA\_ARGS\_\_}}
\DoxyCodeLine{2681 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{2682 \textcolor{preprocessor}{  \#define CATCH\_INTERNAL\_STRINGIFY(...) "{}Disabled by CATCH\_CONFIG\_DISABLE\_STRINGIFICATION"{}}}
\DoxyCodeLine{2683 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{2684 }
\DoxyCodeLine{2685 \textcolor{preprocessor}{\#if defined(CATCH\_CONFIG\_FAST\_COMPILE) || defined(CATCH\_CONFIG\_DISABLE\_EXCEPTIONS)}}
\DoxyCodeLine{2686 }
\DoxyCodeLine{2688 \textcolor{comment}{// Another way to speed-\/up compilation is to omit local try-\/catch for REQUIRE*}}
\DoxyCodeLine{2689 \textcolor{comment}{// macros.}}
\DoxyCodeLine{2690 \textcolor{preprocessor}{\#define INTERNAL\_CATCH\_TRY}}
\DoxyCodeLine{2691 \textcolor{preprocessor}{\#define INTERNAL\_CATCH\_CATCH( capturer )}}
\DoxyCodeLine{2692 }
\DoxyCodeLine{2693 \textcolor{preprocessor}{\#else }\textcolor{comment}{// CATCH\_CONFIG\_FAST\_COMPILE}}
\DoxyCodeLine{2694 }
\DoxyCodeLine{2695 \textcolor{preprocessor}{\#define INTERNAL\_CATCH\_TRY try}}
\DoxyCodeLine{2696 \textcolor{preprocessor}{\#define INTERNAL\_CATCH\_CATCH( handler ) catch(...) \{ handler.handleUnexpectedInflightException(); \}}}
\DoxyCodeLine{2697 }
\DoxyCodeLine{2698 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{2699 }
\DoxyCodeLine{2700 \textcolor{preprocessor}{\#define INTERNAL\_CATCH\_REACT( handler ) handler.complete();}}
\DoxyCodeLine{2701 }
\DoxyCodeLine{2703 \textcolor{preprocessor}{\#define INTERNAL\_CATCH\_TEST( macroName, resultDisposition, ... ) \(\backslash\)}}
\DoxyCodeLine{2704 \textcolor{preprocessor}{    do \{ \(\backslash\)}}
\DoxyCodeLine{2705 \textcolor{preprocessor}{        CATCH\_INTERNAL\_IGNORE\_BUT\_WARN(\_\_VA\_ARGS\_\_); \(\backslash\)}}
\DoxyCodeLine{2706 \textcolor{preprocessor}{        Catch::AssertionHandler catchAssertionHandler( macroName\#\#\_catch\_sr, CATCH\_INTERNAL\_LINEINFO, CATCH\_INTERNAL\_STRINGIFY(\_\_VA\_ARGS\_\_), resultDisposition ); \(\backslash\)}}
\DoxyCodeLine{2707 \textcolor{preprocessor}{        INTERNAL\_CATCH\_TRY \{ \(\backslash\)}}
\DoxyCodeLine{2708 \textcolor{preprocessor}{            CATCH\_INTERNAL\_START\_WARNINGS\_SUPPRESSION \(\backslash\)}}
\DoxyCodeLine{2709 \textcolor{preprocessor}{            CATCH\_INTERNAL\_SUPPRESS\_PARENTHESES\_WARNINGS \(\backslash\)}}
\DoxyCodeLine{2710 \textcolor{preprocessor}{            catchAssertionHandler.handleExpr( Catch::Decomposer() <= \_\_VA\_ARGS\_\_ ); \(\backslash\)}}
\DoxyCodeLine{2711 \textcolor{preprocessor}{            CATCH\_INTERNAL\_STOP\_WARNINGS\_SUPPRESSION \(\backslash\)}}
\DoxyCodeLine{2712 \textcolor{preprocessor}{        \} INTERNAL\_CATCH\_CATCH( catchAssertionHandler ) \(\backslash\)}}
\DoxyCodeLine{2713 \textcolor{preprocessor}{        INTERNAL\_CATCH\_REACT( catchAssertionHandler ) \(\backslash\)}}
\DoxyCodeLine{2714 \textcolor{preprocessor}{    \} while( (void)0, (false) \&\& static\_cast<bool>( !!(\_\_VA\_ARGS\_\_) ) )}}
\DoxyCodeLine{2715 }
\DoxyCodeLine{2717 \textcolor{preprocessor}{\#define INTERNAL\_CATCH\_IF( macroName, resultDisposition, ... ) \(\backslash\)}}
\DoxyCodeLine{2718 \textcolor{preprocessor}{    INTERNAL\_CATCH\_TEST( macroName, resultDisposition, \_\_VA\_ARGS\_\_ ); \(\backslash\)}}
\DoxyCodeLine{2719 \textcolor{preprocessor}{    if( Catch::getResultCapture().lastAssertionPassed() )}}
\DoxyCodeLine{2720 }
\DoxyCodeLine{2722 \textcolor{preprocessor}{\#define INTERNAL\_CATCH\_ELSE( macroName, resultDisposition, ... ) \(\backslash\)}}
\DoxyCodeLine{2723 \textcolor{preprocessor}{    INTERNAL\_CATCH\_TEST( macroName, resultDisposition, \_\_VA\_ARGS\_\_ ); \(\backslash\)}}
\DoxyCodeLine{2724 \textcolor{preprocessor}{    if( !Catch::getResultCapture().lastAssertionPassed() )}}
\DoxyCodeLine{2725 }
\DoxyCodeLine{2727 \textcolor{preprocessor}{\#define INTERNAL\_CATCH\_NO\_THROW( macroName, resultDisposition, ... ) \(\backslash\)}}
\DoxyCodeLine{2728 \textcolor{preprocessor}{    do \{ \(\backslash\)}}
\DoxyCodeLine{2729 \textcolor{preprocessor}{        Catch::AssertionHandler catchAssertionHandler( macroName\#\#\_catch\_sr, CATCH\_INTERNAL\_LINEINFO, CATCH\_INTERNAL\_STRINGIFY(\_\_VA\_ARGS\_\_), resultDisposition ); \(\backslash\)}}
\DoxyCodeLine{2730 \textcolor{preprocessor}{        try \{ \(\backslash\)}}
\DoxyCodeLine{2731 \textcolor{preprocessor}{            static\_cast<void>(\_\_VA\_ARGS\_\_); \(\backslash\)}}
\DoxyCodeLine{2732 \textcolor{preprocessor}{            catchAssertionHandler.handleExceptionNotThrownAsExpected(); \(\backslash\)}}
\DoxyCodeLine{2733 \textcolor{preprocessor}{        \} \(\backslash\)}}
\DoxyCodeLine{2734 \textcolor{preprocessor}{        catch( ... ) \{ \(\backslash\)}}
\DoxyCodeLine{2735 \textcolor{preprocessor}{            catchAssertionHandler.handleUnexpectedInflightException(); \(\backslash\)}}
\DoxyCodeLine{2736 \textcolor{preprocessor}{        \} \(\backslash\)}}
\DoxyCodeLine{2737 \textcolor{preprocessor}{        INTERNAL\_CATCH\_REACT( catchAssertionHandler ) \(\backslash\)}}
\DoxyCodeLine{2738 \textcolor{preprocessor}{    \} while( false )}}
\DoxyCodeLine{2739 }
\DoxyCodeLine{2741 \textcolor{preprocessor}{\#define INTERNAL\_CATCH\_THROWS( macroName, resultDisposition, ... ) \(\backslash\)}}
\DoxyCodeLine{2742 \textcolor{preprocessor}{    do \{ \(\backslash\)}}
\DoxyCodeLine{2743 \textcolor{preprocessor}{        Catch::AssertionHandler catchAssertionHandler( macroName\#\#\_catch\_sr, CATCH\_INTERNAL\_LINEINFO, CATCH\_INTERNAL\_STRINGIFY(\_\_VA\_ARGS\_\_), resultDisposition); \(\backslash\)}}
\DoxyCodeLine{2744 \textcolor{preprocessor}{        if( catchAssertionHandler.allowThrows() ) \(\backslash\)}}
\DoxyCodeLine{2745 \textcolor{preprocessor}{            try \{ \(\backslash\)}}
\DoxyCodeLine{2746 \textcolor{preprocessor}{                static\_cast<void>(\_\_VA\_ARGS\_\_); \(\backslash\)}}
\DoxyCodeLine{2747 \textcolor{preprocessor}{                catchAssertionHandler.handleUnexpectedExceptionNotThrown(); \(\backslash\)}}
\DoxyCodeLine{2748 \textcolor{preprocessor}{            \} \(\backslash\)}}
\DoxyCodeLine{2749 \textcolor{preprocessor}{            catch( ... ) \{ \(\backslash\)}}
\DoxyCodeLine{2750 \textcolor{preprocessor}{                catchAssertionHandler.handleExceptionThrownAsExpected(); \(\backslash\)}}
\DoxyCodeLine{2751 \textcolor{preprocessor}{            \} \(\backslash\)}}
\DoxyCodeLine{2752 \textcolor{preprocessor}{        else \(\backslash\)}}
\DoxyCodeLine{2753 \textcolor{preprocessor}{            catchAssertionHandler.handleThrowingCallSkipped(); \(\backslash\)}}
\DoxyCodeLine{2754 \textcolor{preprocessor}{        INTERNAL\_CATCH\_REACT( catchAssertionHandler ) \(\backslash\)}}
\DoxyCodeLine{2755 \textcolor{preprocessor}{    \} while( false )}}
\DoxyCodeLine{2756 }
\DoxyCodeLine{2758 \textcolor{preprocessor}{\#define INTERNAL\_CATCH\_THROWS\_AS( macroName, exceptionType, resultDisposition, expr ) \(\backslash\)}}
\DoxyCodeLine{2759 \textcolor{preprocessor}{    do \{ \(\backslash\)}}
\DoxyCodeLine{2760 \textcolor{preprocessor}{        Catch::AssertionHandler catchAssertionHandler( macroName\#\#\_catch\_sr, CATCH\_INTERNAL\_LINEINFO, CATCH\_INTERNAL\_STRINGIFY(expr) "{}, "{}} CATCH\_INTERNAL\_STRINGIFY(exceptionType), resultDisposition ); \(\backslash\)}
\DoxyCodeLine{2761         if( catchAssertionHandler.allowThrows() ) \(\backslash\)}
\DoxyCodeLine{2762             try \{ \(\backslash\)}
\DoxyCodeLine{2763                 static\_cast<void>(expr); \(\backslash\)}
\DoxyCodeLine{2764                 catchAssertionHandler.handleUnexpectedExceptionNotThrown(); \(\backslash\)}
\DoxyCodeLine{2765             \} \(\backslash\)}
\DoxyCodeLine{2766             catch( exceptionType const\& ) \{ \(\backslash\)}
\DoxyCodeLine{2767                 catchAssertionHandler.handleExceptionThrownAsExpected(); \(\backslash\)}
\DoxyCodeLine{2768             \} \(\backslash\)}
\DoxyCodeLine{2769             catch( ... ) \{ \(\backslash\)}
\DoxyCodeLine{2770                 catchAssertionHandler.handleUnexpectedInflightException(); \(\backslash\)}
\DoxyCodeLine{2771             \} \(\backslash\)}
\DoxyCodeLine{2772         else \(\backslash\)}
\DoxyCodeLine{2773             catchAssertionHandler.handleThrowingCallSkipped(); \(\backslash\)}
\DoxyCodeLine{2774         INTERNAL\_CATCH\_REACT( catchAssertionHandler ) \(\backslash\)}
\DoxyCodeLine{2775     \} while( false )}
\DoxyCodeLine{2776 }
\DoxyCodeLine{2778 \textcolor{preprocessor}{\#define INTERNAL\_CATCH\_MSG( macroName, messageType, resultDisposition, ... ) \(\backslash\)}}
\DoxyCodeLine{2779 \textcolor{preprocessor}{    do \{ \(\backslash\)}}
\DoxyCodeLine{2780 \textcolor{preprocessor}{        Catch::AssertionHandler catchAssertionHandler( macroName\#\#\_catch\_sr, CATCH\_INTERNAL\_LINEINFO, Catch::StringRef(), resultDisposition ); \(\backslash\)}}
\DoxyCodeLine{2781 \textcolor{preprocessor}{        catchAssertionHandler.handleMessage( messageType, ( Catch::MessageStream() << \_\_VA\_ARGS\_\_ + ::Catch::StreamEndStop() ).m\_stream.str() ); \(\backslash\)}}
\DoxyCodeLine{2782 \textcolor{preprocessor}{        INTERNAL\_CATCH\_REACT( catchAssertionHandler ) \(\backslash\)}}
\DoxyCodeLine{2783 \textcolor{preprocessor}{    \} while( false )}}
\DoxyCodeLine{2784 }
\DoxyCodeLine{2786 \textcolor{preprocessor}{\#define INTERNAL\_CATCH\_CAPTURE( varName, macroName, ... ) \(\backslash\)}}
\DoxyCodeLine{2787 \textcolor{preprocessor}{    auto varName = Catch::Capturer( macroName, CATCH\_INTERNAL\_LINEINFO, Catch::ResultWas::Info, \#\_\_VA\_ARGS\_\_ ); \(\backslash\)}}
\DoxyCodeLine{2788 \textcolor{preprocessor}{    varName.captureValues( 0, \_\_VA\_ARGS\_\_ )}}
\DoxyCodeLine{2789 }
\DoxyCodeLine{2791 \textcolor{preprocessor}{\#define INTERNAL\_CATCH\_INFO( macroName, log ) \(\backslash\)}}
\DoxyCodeLine{2792 \textcolor{preprocessor}{    Catch::ScopedMessage INTERNAL\_CATCH\_UNIQUE\_NAME( scopedMessage )( Catch::MessageBuilder( macroName\#\#\_catch\_sr, CATCH\_INTERNAL\_LINEINFO, Catch::ResultWas::Info ) << log );}}
\DoxyCodeLine{2793 }
\DoxyCodeLine{2795 \textcolor{preprocessor}{\#define INTERNAL\_CATCH\_UNSCOPED\_INFO( macroName, log ) \(\backslash\)}}
\DoxyCodeLine{2796 \textcolor{preprocessor}{    Catch::getResultCapture().emplaceUnscopedMessage( Catch::MessageBuilder( macroName\#\#\_catch\_sr, CATCH\_INTERNAL\_LINEINFO, Catch::ResultWas::Info ) << log )}}
\DoxyCodeLine{2797 }
\DoxyCodeLine{2799 \textcolor{comment}{// Although this is matcher-\/based, it can be used with just a string}}
\DoxyCodeLine{2800 \textcolor{preprocessor}{\#define INTERNAL\_CATCH\_THROWS\_STR\_MATCHES( macroName, resultDisposition, matcher, ... ) \(\backslash\)}}
\DoxyCodeLine{2801 \textcolor{preprocessor}{    do \{ \(\backslash\)}}
\DoxyCodeLine{2802 \textcolor{preprocessor}{        Catch::AssertionHandler catchAssertionHandler( macroName\#\#\_catch\_sr, CATCH\_INTERNAL\_LINEINFO, CATCH\_INTERNAL\_STRINGIFY(\_\_VA\_ARGS\_\_) "{}, "{}} CATCH\_INTERNAL\_STRINGIFY(matcher), resultDisposition ); \(\backslash\)}
\DoxyCodeLine{2803         if( catchAssertionHandler.allowThrows() ) \(\backslash\)}
\DoxyCodeLine{2804             try \{ \(\backslash\)}
\DoxyCodeLine{2805                 static\_cast<void>(\_\_VA\_ARGS\_\_); \(\backslash\)}
\DoxyCodeLine{2806                 catchAssertionHandler.handleUnexpectedExceptionNotThrown(); \(\backslash\)}
\DoxyCodeLine{2807             \} \(\backslash\)}
\DoxyCodeLine{2808             catch( ... ) \{ \(\backslash\)}
\DoxyCodeLine{2809                 Catch::handleExceptionMatchExpr( catchAssertionHandler, matcher, \#matcher\#\#\_catch\_sr ); \(\backslash\)}
\DoxyCodeLine{2810             \} \(\backslash\)}
\DoxyCodeLine{2811         else \(\backslash\)}
\DoxyCodeLine{2812             catchAssertionHandler.handleThrowingCallSkipped(); \(\backslash\)}
\DoxyCodeLine{2813         INTERNAL\_CATCH\_REACT( catchAssertionHandler ) \(\backslash\)}
\DoxyCodeLine{2814     \} while( false )}
\DoxyCodeLine{2815 }
\DoxyCodeLine{2816 \textcolor{preprocessor}{\#endif }\textcolor{comment}{// CATCH\_CONFIG\_DISABLE}}
\DoxyCodeLine{2817 }
\DoxyCodeLine{2818 \textcolor{comment}{// end catch\_capture.hpp}}
\DoxyCodeLine{2819 \textcolor{comment}{// start catch\_section.h}}
\DoxyCodeLine{2820 }
\DoxyCodeLine{2821 \textcolor{comment}{// start catch\_section\_info.h}}
\DoxyCodeLine{2822 }
\DoxyCodeLine{2823 \textcolor{comment}{// start catch\_totals.h}}
\DoxyCodeLine{2824 }
\DoxyCodeLine{2825 \textcolor{preprocessor}{\#include <cstddef>}}
\DoxyCodeLine{2826 }
\DoxyCodeLine{2827 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{2828 }
\DoxyCodeLine{2829     \textcolor{keyword}{struct }\mbox{\hyperlink{structCatch_1_1Counts}{Counts}} \{}
\DoxyCodeLine{2830         \mbox{\hyperlink{structCatch_1_1Counts}{Counts}} operator -\/ ( \mbox{\hyperlink{structCatch_1_1Counts}{Counts}} \textcolor{keyword}{const}\& other ) \textcolor{keyword}{const};}
\DoxyCodeLine{2831         \mbox{\hyperlink{structCatch_1_1Counts}{Counts}}\& operator += ( \mbox{\hyperlink{structCatch_1_1Counts}{Counts}} \textcolor{keyword}{const}\& other );}
\DoxyCodeLine{2832 }
\DoxyCodeLine{2833         std::size\_t total() \textcolor{keyword}{const};}
\DoxyCodeLine{2834         \textcolor{keywordtype}{bool} allPassed() \textcolor{keyword}{const};}
\DoxyCodeLine{2835         \textcolor{keywordtype}{bool} allOk() \textcolor{keyword}{const};}
\DoxyCodeLine{2836 }
\DoxyCodeLine{2837         std::size\_t passed = 0;}
\DoxyCodeLine{2838         std::size\_t failed = 0;}
\DoxyCodeLine{2839         std::size\_t failedButOk = 0;}
\DoxyCodeLine{2840     \};}
\DoxyCodeLine{2841 }
\DoxyCodeLine{2842     \textcolor{keyword}{struct }\mbox{\hyperlink{structCatch_1_1Totals}{Totals}} \{}
\DoxyCodeLine{2843 }
\DoxyCodeLine{2844         \mbox{\hyperlink{structCatch_1_1Totals}{Totals}} operator -\/ ( \mbox{\hyperlink{structCatch_1_1Totals}{Totals}} \textcolor{keyword}{const}\& other ) \textcolor{keyword}{const};}
\DoxyCodeLine{2845         \mbox{\hyperlink{structCatch_1_1Totals}{Totals}}\& operator += ( \mbox{\hyperlink{structCatch_1_1Totals}{Totals}} \textcolor{keyword}{const}\& other );}
\DoxyCodeLine{2846 }
\DoxyCodeLine{2847         \mbox{\hyperlink{structCatch_1_1Totals}{Totals}} delta( \mbox{\hyperlink{structCatch_1_1Totals}{Totals}} \textcolor{keyword}{const}\& prevTotals ) \textcolor{keyword}{const};}
\DoxyCodeLine{2848 }
\DoxyCodeLine{2849         \textcolor{keywordtype}{int} error = 0;}
\DoxyCodeLine{2850         \mbox{\hyperlink{structCatch_1_1Counts}{Counts}} assertions;}
\DoxyCodeLine{2851         \mbox{\hyperlink{structCatch_1_1Counts}{Counts}} testCases;}
\DoxyCodeLine{2852     \};}
\DoxyCodeLine{2853 \}}
\DoxyCodeLine{2854 }
\DoxyCodeLine{2855 \textcolor{comment}{// end catch\_totals.h}}
\DoxyCodeLine{2856 \textcolor{preprocessor}{\#include <string>}}
\DoxyCodeLine{2857 }
\DoxyCodeLine{2858 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{2859 }
\DoxyCodeLine{2860     \textcolor{keyword}{struct }\mbox{\hyperlink{structCatch_1_1SectionInfo}{SectionInfo}} \{}
\DoxyCodeLine{2861         \mbox{\hyperlink{structCatch_1_1SectionInfo}{SectionInfo}}}
\DoxyCodeLine{2862             (   \mbox{\hyperlink{structCatch_1_1SourceLineInfo}{SourceLineInfo}} \textcolor{keyword}{const}\& \_lineInfo,}
\DoxyCodeLine{2863                 std::string \textcolor{keyword}{const}\& \_name );}
\DoxyCodeLine{2864 }
\DoxyCodeLine{2865         \textcolor{comment}{// Deprecated}}
\DoxyCodeLine{2866         \mbox{\hyperlink{structCatch_1_1SectionInfo}{SectionInfo}}}
\DoxyCodeLine{2867             (   \mbox{\hyperlink{structCatch_1_1SourceLineInfo}{SourceLineInfo}} \textcolor{keyword}{const}\& \_lineInfo,}
\DoxyCodeLine{2868                 std::string \textcolor{keyword}{const}\& \_name,}
\DoxyCodeLine{2869                 std::string \textcolor{keyword}{const}\& ) : \mbox{\hyperlink{structCatch_1_1SectionInfo}{SectionInfo}}( \_lineInfo, \_name ) \{\}}
\DoxyCodeLine{2870 }
\DoxyCodeLine{2871         std::string name;}
\DoxyCodeLine{2872         std::string description; \textcolor{comment}{// !Deprecated: this will always be empty}}
\DoxyCodeLine{2873         \mbox{\hyperlink{structCatch_1_1SourceLineInfo}{SourceLineInfo}} lineInfo;}
\DoxyCodeLine{2874     \};}
\DoxyCodeLine{2875 }
\DoxyCodeLine{2876     \textcolor{keyword}{struct }\mbox{\hyperlink{structCatch_1_1SectionEndInfo}{SectionEndInfo}} \{}
\DoxyCodeLine{2877         \mbox{\hyperlink{structCatch_1_1SectionInfo}{SectionInfo}} sectionInfo;}
\DoxyCodeLine{2878         \mbox{\hyperlink{structCatch_1_1Counts}{Counts}} prevAssertions;}
\DoxyCodeLine{2879         \textcolor{keywordtype}{double} durationInSeconds;}
\DoxyCodeLine{2880     \};}
\DoxyCodeLine{2881 }
\DoxyCodeLine{2882 \} \textcolor{comment}{// end namespace Catch}}
\DoxyCodeLine{2883 }
\DoxyCodeLine{2884 \textcolor{comment}{// end catch\_section\_info.h}}
\DoxyCodeLine{2885 \textcolor{comment}{// start catch\_timer.h}}
\DoxyCodeLine{2886 }
\DoxyCodeLine{2887 \textcolor{preprocessor}{\#include <cstdint>}}
\DoxyCodeLine{2888 }
\DoxyCodeLine{2889 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{2890 }
\DoxyCodeLine{2891     \textcolor{keyword}{auto} getCurrentNanosecondsSinceEpoch() -\/> uint64\_t;}
\DoxyCodeLine{2892     \textcolor{keyword}{auto} getEstimatedClockResolution() -\/> uint64\_t;}
\DoxyCodeLine{2893 }
\DoxyCodeLine{2894     \textcolor{keyword}{class }\mbox{\hyperlink{classCatch_1_1Timer}{Timer}} \{}
\DoxyCodeLine{2895         uint64\_t m\_nanoseconds = 0;}
\DoxyCodeLine{2896     \textcolor{keyword}{public}:}
\DoxyCodeLine{2897         \textcolor{keywordtype}{void} start();}
\DoxyCodeLine{2898         \textcolor{keyword}{auto} getElapsedNanoseconds() \textcolor{keyword}{const} -\/> uint64\_t;}
\DoxyCodeLine{2899         \textcolor{keyword}{auto} getElapsedMicroseconds() \textcolor{keyword}{const} -\/> uint64\_t;}
\DoxyCodeLine{2900         \textcolor{keyword}{auto} getElapsedMilliseconds() \textcolor{keyword}{const} -\/> \textcolor{keywordtype}{unsigned} int;}
\DoxyCodeLine{2901         \textcolor{keyword}{auto} getElapsedSeconds() \textcolor{keyword}{const} -\/> double;}
\DoxyCodeLine{2902     \};}
\DoxyCodeLine{2903 }
\DoxyCodeLine{2904 \} \textcolor{comment}{// namespace Catch}}
\DoxyCodeLine{2905 }
\DoxyCodeLine{2906 \textcolor{comment}{// end catch\_timer.h}}
\DoxyCodeLine{2907 \textcolor{preprocessor}{\#include <string>}}
\DoxyCodeLine{2908 }
\DoxyCodeLine{2909 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{2910 }
\DoxyCodeLine{2911     \textcolor{keyword}{class }\mbox{\hyperlink{classCatch_1_1Section}{Section}} : \mbox{\hyperlink{classCatch_1_1NonCopyable}{NonCopyable}} \{}
\DoxyCodeLine{2912     \textcolor{keyword}{public}:}
\DoxyCodeLine{2913         \mbox{\hyperlink{classCatch_1_1Section}{Section}}( \mbox{\hyperlink{structCatch_1_1SectionInfo}{SectionInfo}} \textcolor{keyword}{const}\& info );}
\DoxyCodeLine{2914         \mbox{\hyperlink{classCatch_1_1Section}{\string~Section}}();}
\DoxyCodeLine{2915 }
\DoxyCodeLine{2916         \textcolor{comment}{// This indicates whether the section should be executed or not}}
\DoxyCodeLine{2917         \textcolor{keyword}{explicit} \textcolor{keyword}{operator} bool() \textcolor{keyword}{const};}
\DoxyCodeLine{2918 }
\DoxyCodeLine{2919     \textcolor{keyword}{private}:}
\DoxyCodeLine{2920         \mbox{\hyperlink{structCatch_1_1SectionInfo}{SectionInfo}} m\_info;}
\DoxyCodeLine{2921 }
\DoxyCodeLine{2922         std::string m\_name;}
\DoxyCodeLine{2923         \mbox{\hyperlink{structCatch_1_1Counts}{Counts}} m\_assertions;}
\DoxyCodeLine{2924         \textcolor{keywordtype}{bool} m\_sectionIncluded;}
\DoxyCodeLine{2925         \mbox{\hyperlink{classCatch_1_1Timer}{Timer}} m\_timer;}
\DoxyCodeLine{2926     \};}
\DoxyCodeLine{2927 }
\DoxyCodeLine{2928 \} \textcolor{comment}{// end namespace Catch}}
\DoxyCodeLine{2929 }
\DoxyCodeLine{2930 \textcolor{preprocessor}{\#define INTERNAL\_CATCH\_SECTION( ... ) \(\backslash\)}}
\DoxyCodeLine{2931 \textcolor{preprocessor}{    CATCH\_INTERNAL\_START\_WARNINGS\_SUPPRESSION \(\backslash\)}}
\DoxyCodeLine{2932 \textcolor{preprocessor}{    CATCH\_INTERNAL\_SUPPRESS\_UNUSED\_WARNINGS \(\backslash\)}}
\DoxyCodeLine{2933 \textcolor{preprocessor}{    if( Catch::Section const\& INTERNAL\_CATCH\_UNIQUE\_NAME( catch\_internal\_Section ) = Catch::SectionInfo( CATCH\_INTERNAL\_LINEINFO, \_\_VA\_ARGS\_\_ ) ) \(\backslash\)}}
\DoxyCodeLine{2934 \textcolor{preprocessor}{    CATCH\_INTERNAL\_STOP\_WARNINGS\_SUPPRESSION}}
\DoxyCodeLine{2935 }
\DoxyCodeLine{2936 \textcolor{preprocessor}{\#define INTERNAL\_CATCH\_DYNAMIC\_SECTION( ... ) \(\backslash\)}}
\DoxyCodeLine{2937 \textcolor{preprocessor}{    CATCH\_INTERNAL\_START\_WARNINGS\_SUPPRESSION \(\backslash\)}}
\DoxyCodeLine{2938 \textcolor{preprocessor}{    CATCH\_INTERNAL\_SUPPRESS\_UNUSED\_WARNINGS \(\backslash\)}}
\DoxyCodeLine{2939 \textcolor{preprocessor}{    if( Catch::Section const\& INTERNAL\_CATCH\_UNIQUE\_NAME( catch\_internal\_Section ) = Catch::SectionInfo( CATCH\_INTERNAL\_LINEINFO, (Catch::ReusableStringStream() << \_\_VA\_ARGS\_\_).str() ) ) \(\backslash\)}}
\DoxyCodeLine{2940 \textcolor{preprocessor}{    CATCH\_INTERNAL\_STOP\_WARNINGS\_SUPPRESSION}}
\DoxyCodeLine{2941 }
\DoxyCodeLine{2942 \textcolor{comment}{// end catch\_section.h}}
\DoxyCodeLine{2943 \textcolor{comment}{// start catch\_interfaces\_exception.h}}
\DoxyCodeLine{2944 }
\DoxyCodeLine{2945 \textcolor{comment}{// start catch\_interfaces\_registry\_hub.h}}
\DoxyCodeLine{2946 }
\DoxyCodeLine{2947 \textcolor{preprocessor}{\#include <string>}}
\DoxyCodeLine{2948 \textcolor{preprocessor}{\#include <memory>}}
\DoxyCodeLine{2949 }
\DoxyCodeLine{2950 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{2951 }
\DoxyCodeLine{2952     \textcolor{keyword}{class }TestCase;}
\DoxyCodeLine{2953     \textcolor{keyword}{struct }ITestCaseRegistry;}
\DoxyCodeLine{2954     \textcolor{keyword}{struct }IExceptionTranslatorRegistry;}
\DoxyCodeLine{2955     \textcolor{keyword}{struct }IExceptionTranslator;}
\DoxyCodeLine{2956     \textcolor{keyword}{struct }IReporterRegistry;}
\DoxyCodeLine{2957     \textcolor{keyword}{struct }IReporterFactory;}
\DoxyCodeLine{2958     \textcolor{keyword}{struct }ITagAliasRegistry;}
\DoxyCodeLine{2959     \textcolor{keyword}{struct }IMutableEnumValuesRegistry;}
\DoxyCodeLine{2960 }
\DoxyCodeLine{2961     \textcolor{keyword}{class }StartupExceptionRegistry;}
\DoxyCodeLine{2962 }
\DoxyCodeLine{2963     \textcolor{keyword}{using }IReporterFactoryPtr = std::shared\_ptr<IReporterFactory>;}
\DoxyCodeLine{2964 }
\DoxyCodeLine{2965     \textcolor{keyword}{struct }\mbox{\hyperlink{structCatch_1_1IRegistryHub}{IRegistryHub}} \{}
\DoxyCodeLine{2966         \textcolor{keyword}{virtual} \mbox{\hyperlink{structCatch_1_1IRegistryHub}{\string~IRegistryHub}}();}
\DoxyCodeLine{2967 }
\DoxyCodeLine{2968         \textcolor{keyword}{virtual} IReporterRegistry \textcolor{keyword}{const}\& getReporterRegistry() \textcolor{keyword}{const} = 0;}
\DoxyCodeLine{2969         \textcolor{keyword}{virtual} \mbox{\hyperlink{structCatch_1_1ITestCaseRegistry}{ITestCaseRegistry}} \textcolor{keyword}{const}\& getTestCaseRegistry() \textcolor{keyword}{const} = 0;}
\DoxyCodeLine{2970         \textcolor{keyword}{virtual} ITagAliasRegistry \textcolor{keyword}{const}\& getTagAliasRegistry() \textcolor{keyword}{const} = 0;}
\DoxyCodeLine{2971         \textcolor{keyword}{virtual} \mbox{\hyperlink{structCatch_1_1IExceptionTranslatorRegistry}{IExceptionTranslatorRegistry}} \textcolor{keyword}{const}\& getExceptionTranslatorRegistry() \textcolor{keyword}{const} = 0;}
\DoxyCodeLine{2972 }
\DoxyCodeLine{2973         \textcolor{keyword}{virtual} StartupExceptionRegistry \textcolor{keyword}{const}\& getStartupExceptionRegistry() \textcolor{keyword}{const} = 0;}
\DoxyCodeLine{2974     \};}
\DoxyCodeLine{2975 }
\DoxyCodeLine{2976     \textcolor{keyword}{struct }\mbox{\hyperlink{structCatch_1_1IMutableRegistryHub}{IMutableRegistryHub}} \{}
\DoxyCodeLine{2977         \textcolor{keyword}{virtual} \mbox{\hyperlink{structCatch_1_1IMutableRegistryHub}{\string~IMutableRegistryHub}}();}
\DoxyCodeLine{2978         \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} registerReporter( std::string \textcolor{keyword}{const}\& name, IReporterFactoryPtr \textcolor{keyword}{const}\& factory ) = 0;}
\DoxyCodeLine{2979         \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} registerListener( IReporterFactoryPtr \textcolor{keyword}{const}\& factory ) = 0;}
\DoxyCodeLine{2980         \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} registerTest( \mbox{\hyperlink{classCatch_1_1TestCase}{TestCase}} \textcolor{keyword}{const}\& testInfo ) = 0;}
\DoxyCodeLine{2981         \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} registerTranslator( \textcolor{keyword}{const} \mbox{\hyperlink{structCatch_1_1IExceptionTranslator}{IExceptionTranslator}}* translator ) = 0;}
\DoxyCodeLine{2982         \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} registerTagAlias( std::string \textcolor{keyword}{const}\& alias, std::string \textcolor{keyword}{const}\& tag, \mbox{\hyperlink{structCatch_1_1SourceLineInfo}{SourceLineInfo}} \textcolor{keyword}{const}\& lineInfo ) = 0;}
\DoxyCodeLine{2983         \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} registerStartupException() \textcolor{keyword}{noexcept} = 0;}
\DoxyCodeLine{2984         \textcolor{keyword}{virtual} \mbox{\hyperlink{structCatch_1_1IMutableEnumValuesRegistry}{IMutableEnumValuesRegistry}}\& getMutableEnumValuesRegistry() = 0;}
\DoxyCodeLine{2985     \};}
\DoxyCodeLine{2986 }
\DoxyCodeLine{2987     \mbox{\hyperlink{structCatch_1_1IRegistryHub}{IRegistryHub}} \textcolor{keyword}{const}\& getRegistryHub();}
\DoxyCodeLine{2988     \mbox{\hyperlink{structCatch_1_1IMutableRegistryHub}{IMutableRegistryHub}}\& getMutableRegistryHub();}
\DoxyCodeLine{2989     \textcolor{keywordtype}{void} cleanUp();}
\DoxyCodeLine{2990     std::string translateActiveException();}
\DoxyCodeLine{2991 }
\DoxyCodeLine{2992 \}}
\DoxyCodeLine{2993 }
\DoxyCodeLine{2994 \textcolor{comment}{// end catch\_interfaces\_registry\_hub.h}}
\DoxyCodeLine{2995 \textcolor{preprocessor}{\#if defined(CATCH\_CONFIG\_DISABLE)}}
\DoxyCodeLine{2996 \textcolor{preprocessor}{    \#define INTERNAL\_CATCH\_TRANSLATE\_EXCEPTION\_NO\_REG( translatorName, signature) \(\backslash\)}}
\DoxyCodeLine{2997 \textcolor{preprocessor}{        static std::string translatorName( signature )}}
\DoxyCodeLine{2998 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{2999 }
\DoxyCodeLine{3000 \textcolor{preprocessor}{\#include <exception>}}
\DoxyCodeLine{3001 \textcolor{preprocessor}{\#include <string>}}
\DoxyCodeLine{3002 \textcolor{preprocessor}{\#include <vector>}}
\DoxyCodeLine{3003 }
\DoxyCodeLine{3004 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{3005     \textcolor{keyword}{using }exceptionTranslateFunction = std::string(*)();}
\DoxyCodeLine{3006 }
\DoxyCodeLine{3007     \textcolor{keyword}{struct }IExceptionTranslator;}
\DoxyCodeLine{3008     \textcolor{keyword}{using }ExceptionTranslators = std::vector<std::unique\_ptr<IExceptionTranslator const>>;}
\DoxyCodeLine{3009 }
\DoxyCodeLine{3010     \textcolor{keyword}{struct }\mbox{\hyperlink{structCatch_1_1IExceptionTranslator}{IExceptionTranslator}} \{}
\DoxyCodeLine{3011         \textcolor{keyword}{virtual} \mbox{\hyperlink{structCatch_1_1IExceptionTranslator}{\string~IExceptionTranslator}}();}
\DoxyCodeLine{3012         \textcolor{keyword}{virtual} std::string translate( ExceptionTranslators::const\_iterator it, ExceptionTranslators::const\_iterator itEnd ) \textcolor{keyword}{const} = 0;}
\DoxyCodeLine{3013     \};}
\DoxyCodeLine{3014 }
\DoxyCodeLine{3015     \textcolor{keyword}{struct }\mbox{\hyperlink{structCatch_1_1IExceptionTranslatorRegistry}{IExceptionTranslatorRegistry}} \{}
\DoxyCodeLine{3016         \textcolor{keyword}{virtual} \mbox{\hyperlink{structCatch_1_1IExceptionTranslatorRegistry}{\string~IExceptionTranslatorRegistry}}();}
\DoxyCodeLine{3017 }
\DoxyCodeLine{3018         \textcolor{keyword}{virtual} std::string translateActiveException() \textcolor{keyword}{const} = 0;}
\DoxyCodeLine{3019     \};}
\DoxyCodeLine{3020 }
\DoxyCodeLine{3021     \textcolor{keyword}{class }\mbox{\hyperlink{classCatch_1_1ExceptionTranslatorRegistrar}{ExceptionTranslatorRegistrar}} \{}
\DoxyCodeLine{3022         \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{3023         \textcolor{keyword}{class }ExceptionTranslator : \textcolor{keyword}{public} \mbox{\hyperlink{structCatch_1_1IExceptionTranslator}{IExceptionTranslator}} \{}
\DoxyCodeLine{3024         \textcolor{keyword}{public}:}
\DoxyCodeLine{3025 }
\DoxyCodeLine{3026             ExceptionTranslator( std::string(*translateFunction)( T\& ) )}
\DoxyCodeLine{3027             : m\_translateFunction( translateFunction )}
\DoxyCodeLine{3028             \{\}}
\DoxyCodeLine{3029 }
\DoxyCodeLine{3030             std::string translate( ExceptionTranslators::const\_iterator it, ExceptionTranslators::const\_iterator itEnd )\textcolor{keyword}{ const override }\{}
\DoxyCodeLine{3031 \textcolor{preprocessor}{\#if defined(CATCH\_CONFIG\_DISABLE\_EXCEPTIONS)}}
\DoxyCodeLine{3032                 \textcolor{keywordflow}{return} \textcolor{stringliteral}{"{}"{}};}
\DoxyCodeLine{3033 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{3034                 \textcolor{keywordflow}{try} \{}
\DoxyCodeLine{3035                     \textcolor{keywordflow}{if}( it == itEnd )}
\DoxyCodeLine{3036                         std::rethrow\_exception(std::current\_exception());}
\DoxyCodeLine{3037                     \textcolor{keywordflow}{else}}
\DoxyCodeLine{3038                         \textcolor{keywordflow}{return} (*it)-\/>translate( it+1, itEnd );}
\DoxyCodeLine{3039                 \}}
\DoxyCodeLine{3040                 \textcolor{keywordflow}{catch}( T\& ex ) \{}
\DoxyCodeLine{3041                     \textcolor{keywordflow}{return} m\_translateFunction( ex );}
\DoxyCodeLine{3042                 \}}
\DoxyCodeLine{3043 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{3044             \}}
\DoxyCodeLine{3045 }
\DoxyCodeLine{3046         \textcolor{keyword}{protected}:}
\DoxyCodeLine{3047             std::string(*m\_translateFunction)( T\& );}
\DoxyCodeLine{3048         \};}
\DoxyCodeLine{3049 }
\DoxyCodeLine{3050     \textcolor{keyword}{public}:}
\DoxyCodeLine{3051         \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{3052         \mbox{\hyperlink{classCatch_1_1ExceptionTranslatorRegistrar}{ExceptionTranslatorRegistrar}}( std::string(*translateFunction)( T\& ) ) \{}
\DoxyCodeLine{3053             getMutableRegistryHub().registerTranslator}
\DoxyCodeLine{3054                 ( \textcolor{keyword}{new} ExceptionTranslator<T>( translateFunction ) );}
\DoxyCodeLine{3055         \}}
\DoxyCodeLine{3056     \};}
\DoxyCodeLine{3057 \}}
\DoxyCodeLine{3058 }
\DoxyCodeLine{3060 \textcolor{preprocessor}{\#define INTERNAL\_CATCH\_TRANSLATE\_EXCEPTION2( translatorName, signature ) \(\backslash\)}}
\DoxyCodeLine{3061 \textcolor{preprocessor}{    static std::string translatorName( signature ); \(\backslash\)}}
\DoxyCodeLine{3062 \textcolor{preprocessor}{    CATCH\_INTERNAL\_START\_WARNINGS\_SUPPRESSION \(\backslash\)}}
\DoxyCodeLine{3063 \textcolor{preprocessor}{    CATCH\_INTERNAL\_SUPPRESS\_GLOBALS\_WARNINGS \(\backslash\)}}
\DoxyCodeLine{3064 \textcolor{preprocessor}{    namespace\{ Catch::ExceptionTranslatorRegistrar INTERNAL\_CATCH\_UNIQUE\_NAME( catch\_internal\_ExceptionRegistrar )( \&translatorName ); \} \(\backslash\)}}
\DoxyCodeLine{3065 \textcolor{preprocessor}{    CATCH\_INTERNAL\_STOP\_WARNINGS\_SUPPRESSION \(\backslash\)}}
\DoxyCodeLine{3066 \textcolor{preprocessor}{    static std::string translatorName( signature )}}
\DoxyCodeLine{3067 }
\DoxyCodeLine{3068 \textcolor{preprocessor}{\#define INTERNAL\_CATCH\_TRANSLATE\_EXCEPTION( signature ) INTERNAL\_CATCH\_TRANSLATE\_EXCEPTION2( INTERNAL\_CATCH\_UNIQUE\_NAME( catch\_internal\_ExceptionTranslator ), signature )}}
\DoxyCodeLine{3069 }
\DoxyCodeLine{3070 \textcolor{comment}{// end catch\_interfaces\_exception.h}}
\DoxyCodeLine{3071 \textcolor{comment}{// start catch\_approx.h}}
\DoxyCodeLine{3072 }
\DoxyCodeLine{3073 \textcolor{preprocessor}{\#include <type\_traits>}}
\DoxyCodeLine{3074 }
\DoxyCodeLine{3075 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{3076 \textcolor{keyword}{namespace }Detail \{}
\DoxyCodeLine{3077 }
\DoxyCodeLine{3078     \textcolor{keyword}{class }\mbox{\hyperlink{classCatch_1_1Detail_1_1Approx}{Approx}} \{}
\DoxyCodeLine{3079     \textcolor{keyword}{private}:}
\DoxyCodeLine{3080         \textcolor{keywordtype}{bool} equalityComparisonImpl(\textcolor{keywordtype}{double} other) \textcolor{keyword}{const};}
\DoxyCodeLine{3081         \textcolor{comment}{// Validates the new margin (margin >= 0)}}
\DoxyCodeLine{3082         \textcolor{comment}{// out-\/of-\/line to avoid including stdexcept in the header}}
\DoxyCodeLine{3083         \textcolor{keywordtype}{void} setMargin(\textcolor{keywordtype}{double} margin);}
\DoxyCodeLine{3084         \textcolor{comment}{// Validates the new epsilon (0 < epsilon < 1)}}
\DoxyCodeLine{3085         \textcolor{comment}{// out-\/of-\/line to avoid including stdexcept in the header}}
\DoxyCodeLine{3086         \textcolor{keywordtype}{void} setEpsilon(\textcolor{keywordtype}{double} epsilon);}
\DoxyCodeLine{3087 }
\DoxyCodeLine{3088     \textcolor{keyword}{public}:}
\DoxyCodeLine{3089         \textcolor{keyword}{explicit} \mbox{\hyperlink{classCatch_1_1Detail_1_1Approx}{Approx}} ( \textcolor{keywordtype}{double} value );}
\DoxyCodeLine{3090 }
\DoxyCodeLine{3091         \textcolor{keyword}{static} \mbox{\hyperlink{classCatch_1_1Detail_1_1Approx}{Approx}} custom();}
\DoxyCodeLine{3092 }
\DoxyCodeLine{3093         \mbox{\hyperlink{classCatch_1_1Detail_1_1Approx}{Approx}} operator-\/() \textcolor{keyword}{const};}
\DoxyCodeLine{3094 }
\DoxyCodeLine{3095         template <typename T, typename = typename std::enable\_if<std::is\_constructible<double, T>::value>::type>}
\DoxyCodeLine{3096         \mbox{\hyperlink{classCatch_1_1Detail_1_1Approx}{Approx}} operator()( T \textcolor{keyword}{const}\& value )\textcolor{keyword}{ const }\{}
\DoxyCodeLine{3097             \mbox{\hyperlink{classCatch_1_1Detail_1_1Approx}{Approx}} approx( \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{double}\textcolor{keyword}{>}(value) );}
\DoxyCodeLine{3098             approx.m\_epsilon = m\_epsilon;}
\DoxyCodeLine{3099             approx.m\_margin = m\_margin;}
\DoxyCodeLine{3100             approx.m\_scale = m\_scale;}
\DoxyCodeLine{3101             \textcolor{keywordflow}{return} approx;}
\DoxyCodeLine{3102         \}}
\DoxyCodeLine{3103 }
\DoxyCodeLine{3104         template <typename T, typename = typename std::enable\_if<std::is\_constructible<double, T>::value>::type>}
\DoxyCodeLine{3105         \textcolor{keyword}{explicit} \mbox{\hyperlink{classCatch_1_1Detail_1_1Approx}{Approx}}( T \textcolor{keyword}{const}\& value ): \mbox{\hyperlink{classCatch_1_1Detail_1_1Approx}{Approx}}(\textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{double}\textcolor{keyword}{>}(value))}
\DoxyCodeLine{3106         \{\}}
\DoxyCodeLine{3107 }
\DoxyCodeLine{3108         template <typename T, typename = typename std::enable\_if<std::is\_constructible<double, T>::value>::type>}
\DoxyCodeLine{3109         \textcolor{keyword}{friend} \textcolor{keywordtype}{bool} operator == ( \textcolor{keyword}{const} T\& lhs, \mbox{\hyperlink{classCatch_1_1Detail_1_1Approx}{Approx}} \textcolor{keyword}{const}\& rhs ) \{}
\DoxyCodeLine{3110             \textcolor{keyword}{auto} lhs\_v = \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{double}\textcolor{keyword}{>}(lhs);}
\DoxyCodeLine{3111             \textcolor{keywordflow}{return} rhs.equalityComparisonImpl(lhs\_v);}
\DoxyCodeLine{3112         \}}
\DoxyCodeLine{3113 }
\DoxyCodeLine{3114         template <typename T, typename = typename std::enable\_if<std::is\_constructible<double, T>::value>::type>}
\DoxyCodeLine{3115         \textcolor{keyword}{friend} \textcolor{keywordtype}{bool} operator == ( \mbox{\hyperlink{classCatch_1_1Detail_1_1Approx}{Approx}} \textcolor{keyword}{const}\& lhs, \textcolor{keyword}{const} T\& rhs ) \{}
\DoxyCodeLine{3116             \textcolor{keywordflow}{return} operator==( rhs, lhs );}
\DoxyCodeLine{3117         \}}
\DoxyCodeLine{3118 }
\DoxyCodeLine{3119         template <typename T, typename = typename std::enable\_if<std::is\_constructible<double, T>::value>::type>}
\DoxyCodeLine{3120         \textcolor{keyword}{friend} \textcolor{keywordtype}{bool} operator != ( T \textcolor{keyword}{const}\& lhs, \mbox{\hyperlink{classCatch_1_1Detail_1_1Approx}{Approx}} \textcolor{keyword}{const}\& rhs ) \{}
\DoxyCodeLine{3121             \textcolor{keywordflow}{return} !operator==( lhs, rhs );}
\DoxyCodeLine{3122         \}}
\DoxyCodeLine{3123 }
\DoxyCodeLine{3124         template <typename T, typename = typename std::enable\_if<std::is\_constructible<double, T>::value>::type>}
\DoxyCodeLine{3125         \textcolor{keyword}{friend} \textcolor{keywordtype}{bool} operator != ( \mbox{\hyperlink{classCatch_1_1Detail_1_1Approx}{Approx}} \textcolor{keyword}{const}\& lhs, T \textcolor{keyword}{const}\& rhs ) \{}
\DoxyCodeLine{3126             \textcolor{keywordflow}{return} !operator==( rhs, lhs );}
\DoxyCodeLine{3127         \}}
\DoxyCodeLine{3128 }
\DoxyCodeLine{3129         template <typename T, typename = typename std::enable\_if<std::is\_constructible<double, T>::value>::type>}
\DoxyCodeLine{3130         \textcolor{keyword}{friend} \textcolor{keywordtype}{bool} operator <= ( T \textcolor{keyword}{const}\& lhs, \mbox{\hyperlink{classCatch_1_1Detail_1_1Approx}{Approx}} \textcolor{keyword}{const}\& rhs ) \{}
\DoxyCodeLine{3131             \textcolor{keywordflow}{return} \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{double}\textcolor{keyword}{>}(lhs) < rhs.m\_value || lhs == rhs;}
\DoxyCodeLine{3132         \}}
\DoxyCodeLine{3133 }
\DoxyCodeLine{3134         template <typename T, typename = typename std::enable\_if<std::is\_constructible<double, T>::value>::type>}
\DoxyCodeLine{3135         \textcolor{keyword}{friend} \textcolor{keywordtype}{bool} operator <= ( \mbox{\hyperlink{classCatch_1_1Detail_1_1Approx}{Approx}} \textcolor{keyword}{const}\& lhs, T \textcolor{keyword}{const}\& rhs ) \{}
\DoxyCodeLine{3136             \textcolor{keywordflow}{return} lhs.m\_value < \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{double}\textcolor{keyword}{>}(rhs) || lhs == rhs;}
\DoxyCodeLine{3137         \}}
\DoxyCodeLine{3138 }
\DoxyCodeLine{3139         template <typename T, typename = typename std::enable\_if<std::is\_constructible<double, T>::value>::type>}
\DoxyCodeLine{3140         \textcolor{keyword}{friend} \textcolor{keywordtype}{bool} operator >= ( T \textcolor{keyword}{const}\& lhs, \mbox{\hyperlink{classCatch_1_1Detail_1_1Approx}{Approx}} \textcolor{keyword}{const}\& rhs ) \{}
\DoxyCodeLine{3141             \textcolor{keywordflow}{return} \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{double}\textcolor{keyword}{>}(lhs) > rhs.m\_value || lhs == rhs;}
\DoxyCodeLine{3142         \}}
\DoxyCodeLine{3143 }
\DoxyCodeLine{3144         template <typename T, typename = typename std::enable\_if<std::is\_constructible<double, T>::value>::type>}
\DoxyCodeLine{3145         \textcolor{keyword}{friend} \textcolor{keywordtype}{bool} operator >= ( \mbox{\hyperlink{classCatch_1_1Detail_1_1Approx}{Approx}} \textcolor{keyword}{const}\& lhs, T \textcolor{keyword}{const}\& rhs ) \{}
\DoxyCodeLine{3146             \textcolor{keywordflow}{return} lhs.m\_value > \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{double}\textcolor{keyword}{>}(rhs) || lhs == rhs;}
\DoxyCodeLine{3147         \}}
\DoxyCodeLine{3148 }
\DoxyCodeLine{3149         template <typename T, typename = typename std::enable\_if<std::is\_constructible<double, T>::value>::type>}
\DoxyCodeLine{3150         \mbox{\hyperlink{classCatch_1_1Detail_1_1Approx}{Approx}}\& epsilon( T \textcolor{keyword}{const}\& newEpsilon ) \{}
\DoxyCodeLine{3151             \textcolor{keywordtype}{double} epsilonAsDouble = \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{double}\textcolor{keyword}{>}(newEpsilon);}
\DoxyCodeLine{3152             setEpsilon(epsilonAsDouble);}
\DoxyCodeLine{3153             \textcolor{keywordflow}{return} *\textcolor{keyword}{this};}
\DoxyCodeLine{3154         \}}
\DoxyCodeLine{3155 }
\DoxyCodeLine{3156         template <typename T, typename = typename std::enable\_if<std::is\_constructible<double, T>::value>::type>}
\DoxyCodeLine{3157         \mbox{\hyperlink{classCatch_1_1Detail_1_1Approx}{Approx}}\& margin( T \textcolor{keyword}{const}\& newMargin ) \{}
\DoxyCodeLine{3158             \textcolor{keywordtype}{double} marginAsDouble = \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{double}\textcolor{keyword}{>}(newMargin);}
\DoxyCodeLine{3159             setMargin(marginAsDouble);}
\DoxyCodeLine{3160             \textcolor{keywordflow}{return} *\textcolor{keyword}{this};}
\DoxyCodeLine{3161         \}}
\DoxyCodeLine{3162 }
\DoxyCodeLine{3163         template <typename T, typename = typename std::enable\_if<std::is\_constructible<double, T>::value>::type>}
\DoxyCodeLine{3164         \mbox{\hyperlink{classCatch_1_1Detail_1_1Approx}{Approx}}\& scale( T \textcolor{keyword}{const}\& newScale ) \{}
\DoxyCodeLine{3165             m\_scale = \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{double}\textcolor{keyword}{>}(newScale);}
\DoxyCodeLine{3166             \textcolor{keywordflow}{return} *\textcolor{keyword}{this};}
\DoxyCodeLine{3167         \}}
\DoxyCodeLine{3168 }
\DoxyCodeLine{3169         std::string toString() \textcolor{keyword}{const};}
\DoxyCodeLine{3170 }
\DoxyCodeLine{3171     \textcolor{keyword}{private}:}
\DoxyCodeLine{3172         \textcolor{keywordtype}{double} m\_epsilon;}
\DoxyCodeLine{3173         \textcolor{keywordtype}{double} m\_margin;}
\DoxyCodeLine{3174         \textcolor{keywordtype}{double} m\_scale;}
\DoxyCodeLine{3175         \textcolor{keywordtype}{double} m\_value;}
\DoxyCodeLine{3176     \};}
\DoxyCodeLine{3177 \} \textcolor{comment}{// end namespace Detail}}
\DoxyCodeLine{3178 }
\DoxyCodeLine{3179 \textcolor{keyword}{namespace }literals \{}
\DoxyCodeLine{3180     \mbox{\hyperlink{classCatch_1_1Detail_1_1Approx}{Detail::Approx}} \textcolor{keyword}{operator} \textcolor{stringliteral}{"{}"{}} \_a(\textcolor{keywordtype}{long} \textcolor{keywordtype}{double} val);}
\DoxyCodeLine{3181     \mbox{\hyperlink{classCatch_1_1Detail_1_1Approx}{Detail::Approx}} \textcolor{keyword}{operator} \textcolor{stringliteral}{"{}"{}} \_a(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} val);}
\DoxyCodeLine{3182 \} \textcolor{comment}{// end namespace literals}}
\DoxyCodeLine{3183 }
\DoxyCodeLine{3184 \textcolor{keyword}{template}<>}
\DoxyCodeLine{3185 \textcolor{keyword}{struct }\mbox{\hyperlink{structCatch_1_1StringMaker}{StringMaker}}<Catch::\mbox{\hyperlink{classCatch_1_1Detail_1_1Approx}{Detail::Approx}}> \{}
\DoxyCodeLine{3186     \textcolor{keyword}{static} std::string convert(\mbox{\hyperlink{classCatch_1_1Detail_1_1Approx}{Catch::Detail::Approx}} \textcolor{keyword}{const}\& value);}
\DoxyCodeLine{3187 \};}
\DoxyCodeLine{3188 }
\DoxyCodeLine{3189 \} \textcolor{comment}{// end namespace Catch}}
\DoxyCodeLine{3190 }
\DoxyCodeLine{3191 \textcolor{comment}{// end catch\_approx.h}}
\DoxyCodeLine{3192 \textcolor{comment}{// start catch\_string\_manip.h}}
\DoxyCodeLine{3193 }
\DoxyCodeLine{3194 \textcolor{preprocessor}{\#include <string>}}
\DoxyCodeLine{3195 \textcolor{preprocessor}{\#include <iosfwd>}}
\DoxyCodeLine{3196 \textcolor{preprocessor}{\#include <vector>}}
\DoxyCodeLine{3197 }
\DoxyCodeLine{3198 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{3199 }
\DoxyCodeLine{3200     \textcolor{keywordtype}{bool} startsWith( std::string \textcolor{keyword}{const}\& s, std::string \textcolor{keyword}{const}\& prefix );}
\DoxyCodeLine{3201     \textcolor{keywordtype}{bool} startsWith( std::string \textcolor{keyword}{const}\& s, \textcolor{keywordtype}{char} prefix );}
\DoxyCodeLine{3202     \textcolor{keywordtype}{bool} endsWith( std::string \textcolor{keyword}{const}\& s, std::string \textcolor{keyword}{const}\& suffix );}
\DoxyCodeLine{3203     \textcolor{keywordtype}{bool} endsWith( std::string \textcolor{keyword}{const}\& s, \textcolor{keywordtype}{char} suffix );}
\DoxyCodeLine{3204     \textcolor{keywordtype}{bool} contains( std::string \textcolor{keyword}{const}\& s, std::string \textcolor{keyword}{const}\& infix );}
\DoxyCodeLine{3205     \textcolor{keywordtype}{void} toLowerInPlace( std::string\& s );}
\DoxyCodeLine{3206     std::string toLower( std::string \textcolor{keyword}{const}\& s );}
\DoxyCodeLine{3208     std::string trim( std::string \textcolor{keyword}{const}\& str );}
\DoxyCodeLine{3210     StringRef trim(StringRef ref);}
\DoxyCodeLine{3211 }
\DoxyCodeLine{3212     \textcolor{comment}{// !!! Be aware, returns refs into original string -\/ make sure original string outlives them}}
\DoxyCodeLine{3213     std::vector<StringRef> splitStringRef( StringRef str, \textcolor{keywordtype}{char} delimiter );}
\DoxyCodeLine{3214     \textcolor{keywordtype}{bool} replaceInPlace( std::string\& str, std::string \textcolor{keyword}{const}\& replaceThis, std::string \textcolor{keyword}{const}\& withThis );}
\DoxyCodeLine{3215 }
\DoxyCodeLine{3216     \textcolor{keyword}{struct }\mbox{\hyperlink{structCatch_1_1pluralise}{pluralise}} \{}
\DoxyCodeLine{3217         \mbox{\hyperlink{structCatch_1_1pluralise}{pluralise}}( std::size\_t count, std::string \textcolor{keyword}{const}\& label );}
\DoxyCodeLine{3218 }
\DoxyCodeLine{3219         \textcolor{keyword}{friend} std::ostream\& operator << ( std::ostream\& os, \mbox{\hyperlink{structCatch_1_1pluralise}{pluralise}} \textcolor{keyword}{const}\& pluraliser );}
\DoxyCodeLine{3220 }
\DoxyCodeLine{3221         std::size\_t m\_count;}
\DoxyCodeLine{3222         std::string m\_label;}
\DoxyCodeLine{3223     \};}
\DoxyCodeLine{3224 \}}
\DoxyCodeLine{3225 }
\DoxyCodeLine{3226 \textcolor{comment}{// end catch\_string\_manip.h}}
\DoxyCodeLine{3227 \textcolor{preprocessor}{\#ifndef CATCH\_CONFIG\_DISABLE\_MATCHERS}}
\DoxyCodeLine{3228 \textcolor{comment}{// start catch\_capture\_matchers.h}}
\DoxyCodeLine{3229 }
\DoxyCodeLine{3230 \textcolor{comment}{// start catch\_matchers.h}}
\DoxyCodeLine{3231 }
\DoxyCodeLine{3232 \textcolor{preprocessor}{\#include <string>}}
\DoxyCodeLine{3233 \textcolor{preprocessor}{\#include <vector>}}
\DoxyCodeLine{3234 }
\DoxyCodeLine{3235 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{3236 \textcolor{keyword}{namespace }Matchers \{}
\DoxyCodeLine{3237     \textcolor{keyword}{namespace }Impl \{}
\DoxyCodeLine{3238 }
\DoxyCodeLine{3239         \textcolor{keyword}{template}<\textcolor{keyword}{typename} ArgT> \textcolor{keyword}{struct }MatchAllOf;}
\DoxyCodeLine{3240         \textcolor{keyword}{template}<\textcolor{keyword}{typename} ArgT> \textcolor{keyword}{struct }MatchAnyOf;}
\DoxyCodeLine{3241         \textcolor{keyword}{template}<\textcolor{keyword}{typename} ArgT> \textcolor{keyword}{struct }MatchNotOf;}
\DoxyCodeLine{3242 }
\DoxyCodeLine{3243         \textcolor{keyword}{class }\mbox{\hyperlink{classCatch_1_1Matchers_1_1Impl_1_1MatcherUntypedBase}{MatcherUntypedBase}} \{}
\DoxyCodeLine{3244         \textcolor{keyword}{public}:}
\DoxyCodeLine{3245             \mbox{\hyperlink{classCatch_1_1Matchers_1_1Impl_1_1MatcherUntypedBase}{MatcherUntypedBase}}() = \textcolor{keywordflow}{default};}
\DoxyCodeLine{3246             \mbox{\hyperlink{classCatch_1_1Matchers_1_1Impl_1_1MatcherUntypedBase}{MatcherUntypedBase}} ( \mbox{\hyperlink{classCatch_1_1Matchers_1_1Impl_1_1MatcherUntypedBase}{MatcherUntypedBase}} \textcolor{keyword}{const}\& ) = \textcolor{keywordflow}{default};}
\DoxyCodeLine{3247             \mbox{\hyperlink{classCatch_1_1Matchers_1_1Impl_1_1MatcherUntypedBase}{MatcherUntypedBase}}\& operator = ( \mbox{\hyperlink{classCatch_1_1Matchers_1_1Impl_1_1MatcherUntypedBase}{MatcherUntypedBase}} \textcolor{keyword}{const}\& ) = \textcolor{keyword}{delete};}
\DoxyCodeLine{3248             std::string toString() \textcolor{keyword}{const};}
\DoxyCodeLine{3249 }
\DoxyCodeLine{3250         \textcolor{keyword}{protected}:}
\DoxyCodeLine{3251             \textcolor{keyword}{virtual} \mbox{\hyperlink{classCatch_1_1Matchers_1_1Impl_1_1MatcherUntypedBase}{\string~MatcherUntypedBase}}();}
\DoxyCodeLine{3252             \textcolor{keyword}{virtual} std::string describe() \textcolor{keyword}{const} = 0;}
\DoxyCodeLine{3253             \textcolor{keyword}{mutable} std::string m\_cachedToString;}
\DoxyCodeLine{3254         \};}
\DoxyCodeLine{3255 }
\DoxyCodeLine{3256 \textcolor{preprocessor}{\#ifdef \_\_clang\_\_}}
\DoxyCodeLine{3257 \textcolor{preprocessor}{\#    pragma clang diagnostic push}}
\DoxyCodeLine{3258 \textcolor{preprocessor}{\#    pragma clang diagnostic ignored "{}-\/Wnon-\/virtual-\/dtor"{}}}
\DoxyCodeLine{3259 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{3260 }
\DoxyCodeLine{3261         \textcolor{keyword}{template}<\textcolor{keyword}{typename} ObjectT>}
\DoxyCodeLine{3262         \textcolor{keyword}{struct }\mbox{\hyperlink{structCatch_1_1Matchers_1_1Impl_1_1MatcherMethod}{MatcherMethod}} \{}
\DoxyCodeLine{3263             \textcolor{keyword}{virtual} \textcolor{keywordtype}{bool} match( ObjectT \textcolor{keyword}{const}\& arg ) \textcolor{keyword}{const} = 0;}
\DoxyCodeLine{3264         \};}
\DoxyCodeLine{3265 }
\DoxyCodeLine{3266 \textcolor{preprocessor}{\#if defined(\_\_OBJC\_\_)}}
\DoxyCodeLine{3267         \textcolor{comment}{// Hack to fix Catch GH issue \#1661. Could use id for generic Object support.}}
\DoxyCodeLine{3268         \textcolor{comment}{// use of const for Object pointers is very uncommon and under ARC it causes some kind of signature mismatch that breaks compilation}}
\DoxyCodeLine{3269         \textcolor{keyword}{template}<>}
\DoxyCodeLine{3270         \textcolor{keyword}{struct }\mbox{\hyperlink{structCatch_1_1Matchers_1_1Impl_1_1MatcherMethod}{MatcherMethod}}<NSString*> \{}
\DoxyCodeLine{3271             \textcolor{keyword}{virtual} \textcolor{keywordtype}{bool} match( NSString* arg ) \textcolor{keyword}{const} = 0;}
\DoxyCodeLine{3272         \};}
\DoxyCodeLine{3273 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{3274 }
\DoxyCodeLine{3275 \textcolor{preprocessor}{\#ifdef \_\_clang\_\_}}
\DoxyCodeLine{3276 \textcolor{preprocessor}{\#    pragma clang diagnostic pop}}
\DoxyCodeLine{3277 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{3278 }
\DoxyCodeLine{3279         \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{3280         \textcolor{keyword}{struct }\mbox{\hyperlink{structCatch_1_1Matchers_1_1Impl_1_1MatcherBase}{MatcherBase}} : \mbox{\hyperlink{classCatch_1_1Matchers_1_1Impl_1_1MatcherUntypedBase}{MatcherUntypedBase}}, \mbox{\hyperlink{structCatch_1_1Matchers_1_1Impl_1_1MatcherMethod}{MatcherMethod}}<T> \{}
\DoxyCodeLine{3281 }
\DoxyCodeLine{3282             \mbox{\hyperlink{structCatch_1_1Matchers_1_1Impl_1_1MatchAllOf}{MatchAllOf<T>}} operator \&\& ( \mbox{\hyperlink{structCatch_1_1Matchers_1_1Impl_1_1MatcherBase}{MatcherBase}} \textcolor{keyword}{const}\& other ) \textcolor{keyword}{const};}
\DoxyCodeLine{3283             \mbox{\hyperlink{structCatch_1_1Matchers_1_1Impl_1_1MatchAnyOf}{MatchAnyOf<T>}} operator || ( \mbox{\hyperlink{structCatch_1_1Matchers_1_1Impl_1_1MatcherBase}{MatcherBase}} \textcolor{keyword}{const}\& other ) \textcolor{keyword}{const};}
\DoxyCodeLine{3284             \mbox{\hyperlink{structCatch_1_1Matchers_1_1Impl_1_1MatchNotOf}{MatchNotOf<T>}} operator ! () \textcolor{keyword}{const};}
\DoxyCodeLine{3285         \};}
\DoxyCodeLine{3286 }
\DoxyCodeLine{3287         \textcolor{keyword}{template}<\textcolor{keyword}{typename} ArgT>}
\DoxyCodeLine{3288         \textcolor{keyword}{struct }\mbox{\hyperlink{structCatch_1_1Matchers_1_1Impl_1_1MatchAllOf}{MatchAllOf}} : \mbox{\hyperlink{structCatch_1_1Matchers_1_1Impl_1_1MatcherBase}{MatcherBase}}<ArgT> \{}
\DoxyCodeLine{3289             \textcolor{keywordtype}{bool} match( ArgT \textcolor{keyword}{const}\& arg )\textcolor{keyword}{ const override }\{}
\DoxyCodeLine{3290                 \textcolor{keywordflow}{for}( \textcolor{keyword}{auto} matcher : m\_matchers ) \{}
\DoxyCodeLine{3291                     \textcolor{keywordflow}{if} (!matcher-\/>match(arg))}
\DoxyCodeLine{3292                         \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{3293                 \}}
\DoxyCodeLine{3294                 \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{3295             \}}
\DoxyCodeLine{3296             std::string describe()\textcolor{keyword}{ const override }\{}
\DoxyCodeLine{3297                 std::string description;}
\DoxyCodeLine{3298                 description.reserve( 4 + m\_matchers.size()*32 );}
\DoxyCodeLine{3299                 description += \textcolor{stringliteral}{"{}( "{}};}
\DoxyCodeLine{3300                 \textcolor{keywordtype}{bool} first = \textcolor{keyword}{true};}
\DoxyCodeLine{3301                 \textcolor{keywordflow}{for}( \textcolor{keyword}{auto} matcher : m\_matchers ) \{}
\DoxyCodeLine{3302                     \textcolor{keywordflow}{if}( first )}
\DoxyCodeLine{3303                         first = \textcolor{keyword}{false};}
\DoxyCodeLine{3304                     \textcolor{keywordflow}{else}}
\DoxyCodeLine{3305                         description += \textcolor{stringliteral}{"{} and "{}};}
\DoxyCodeLine{3306                     description += matcher-\/>toString();}
\DoxyCodeLine{3307                 \}}
\DoxyCodeLine{3308                 description += \textcolor{stringliteral}{"{} )"{}};}
\DoxyCodeLine{3309                 \textcolor{keywordflow}{return} description;}
\DoxyCodeLine{3310             \}}
\DoxyCodeLine{3311 }
\DoxyCodeLine{3312             \mbox{\hyperlink{structCatch_1_1Matchers_1_1Impl_1_1MatchAllOf}{MatchAllOf<ArgT>}} operator \&\& ( \mbox{\hyperlink{structCatch_1_1Matchers_1_1Impl_1_1MatcherBase}{MatcherBase<ArgT>}} \textcolor{keyword}{const}\& other ) \{}
\DoxyCodeLine{3313                 \textcolor{keyword}{auto} copy(*\textcolor{keyword}{this});}
\DoxyCodeLine{3314                 copy.m\_matchers.push\_back( \&other );}
\DoxyCodeLine{3315                 \textcolor{keywordflow}{return} copy;}
\DoxyCodeLine{3316             \}}
\DoxyCodeLine{3317 }
\DoxyCodeLine{3318             std::vector<MatcherBase<ArgT> \textcolor{keyword}{const}*> m\_matchers;}
\DoxyCodeLine{3319         \};}
\DoxyCodeLine{3320         \textcolor{keyword}{template}<\textcolor{keyword}{typename} ArgT>}
\DoxyCodeLine{3321         \textcolor{keyword}{struct }\mbox{\hyperlink{structCatch_1_1Matchers_1_1Impl_1_1MatchAnyOf}{MatchAnyOf}} : \mbox{\hyperlink{structCatch_1_1Matchers_1_1Impl_1_1MatcherBase}{MatcherBase}}<ArgT> \{}
\DoxyCodeLine{3322 }
\DoxyCodeLine{3323             \textcolor{keywordtype}{bool} match( ArgT \textcolor{keyword}{const}\& arg )\textcolor{keyword}{ const override }\{}
\DoxyCodeLine{3324                 \textcolor{keywordflow}{for}( \textcolor{keyword}{auto} matcher : m\_matchers ) \{}
\DoxyCodeLine{3325                     \textcolor{keywordflow}{if} (matcher-\/>match(arg))}
\DoxyCodeLine{3326                         \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{3327                 \}}
\DoxyCodeLine{3328                 \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{3329             \}}
\DoxyCodeLine{3330             std::string describe()\textcolor{keyword}{ const override }\{}
\DoxyCodeLine{3331                 std::string description;}
\DoxyCodeLine{3332                 description.reserve( 4 + m\_matchers.size()*32 );}
\DoxyCodeLine{3333                 description += \textcolor{stringliteral}{"{}( "{}};}
\DoxyCodeLine{3334                 \textcolor{keywordtype}{bool} first = \textcolor{keyword}{true};}
\DoxyCodeLine{3335                 \textcolor{keywordflow}{for}( \textcolor{keyword}{auto} matcher : m\_matchers ) \{}
\DoxyCodeLine{3336                     \textcolor{keywordflow}{if}( first )}
\DoxyCodeLine{3337                         first = \textcolor{keyword}{false};}
\DoxyCodeLine{3338                     \textcolor{keywordflow}{else}}
\DoxyCodeLine{3339                         description += \textcolor{stringliteral}{"{} or "{}};}
\DoxyCodeLine{3340                     description += matcher-\/>toString();}
\DoxyCodeLine{3341                 \}}
\DoxyCodeLine{3342                 description += \textcolor{stringliteral}{"{} )"{}};}
\DoxyCodeLine{3343                 \textcolor{keywordflow}{return} description;}
\DoxyCodeLine{3344             \}}
\DoxyCodeLine{3345 }
\DoxyCodeLine{3346             \mbox{\hyperlink{structCatch_1_1Matchers_1_1Impl_1_1MatchAnyOf}{MatchAnyOf<ArgT>}} operator || ( \mbox{\hyperlink{structCatch_1_1Matchers_1_1Impl_1_1MatcherBase}{MatcherBase<ArgT>}} \textcolor{keyword}{const}\& other ) \{}
\DoxyCodeLine{3347                 \textcolor{keyword}{auto} copy(*\textcolor{keyword}{this});}
\DoxyCodeLine{3348                 copy.m\_matchers.push\_back( \&other );}
\DoxyCodeLine{3349                 \textcolor{keywordflow}{return} copy;}
\DoxyCodeLine{3350             \}}
\DoxyCodeLine{3351 }
\DoxyCodeLine{3352             std::vector<MatcherBase<ArgT> \textcolor{keyword}{const}*> m\_matchers;}
\DoxyCodeLine{3353         \};}
\DoxyCodeLine{3354 }
\DoxyCodeLine{3355         \textcolor{keyword}{template}<\textcolor{keyword}{typename} ArgT>}
\DoxyCodeLine{3356         \textcolor{keyword}{struct }\mbox{\hyperlink{structCatch_1_1Matchers_1_1Impl_1_1MatchNotOf}{MatchNotOf}} : \mbox{\hyperlink{structCatch_1_1Matchers_1_1Impl_1_1MatcherBase}{MatcherBase}}<ArgT> \{}
\DoxyCodeLine{3357 }
\DoxyCodeLine{3358             \mbox{\hyperlink{structCatch_1_1Matchers_1_1Impl_1_1MatchNotOf}{MatchNotOf}}( \mbox{\hyperlink{structCatch_1_1Matchers_1_1Impl_1_1MatcherBase}{MatcherBase<ArgT>}} \textcolor{keyword}{const}\& underlyingMatcher ) : m\_underlyingMatcher( underlyingMatcher ) \{\}}
\DoxyCodeLine{3359 }
\DoxyCodeLine{3360             \textcolor{keywordtype}{bool} match( ArgT \textcolor{keyword}{const}\& arg )\textcolor{keyword}{ const override }\{}
\DoxyCodeLine{3361                 \textcolor{keywordflow}{return} !m\_underlyingMatcher.match( arg );}
\DoxyCodeLine{3362             \}}
\DoxyCodeLine{3363 }
\DoxyCodeLine{3364             std::string describe()\textcolor{keyword}{ const override }\{}
\DoxyCodeLine{3365                 \textcolor{keywordflow}{return} \textcolor{stringliteral}{"{}not "{}} + m\_underlyingMatcher.toString();}
\DoxyCodeLine{3366             \}}
\DoxyCodeLine{3367             \mbox{\hyperlink{structCatch_1_1Matchers_1_1Impl_1_1MatcherBase}{MatcherBase<ArgT>}} \textcolor{keyword}{const}\& m\_underlyingMatcher;}
\DoxyCodeLine{3368         \};}
\DoxyCodeLine{3369 }
\DoxyCodeLine{3370         \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{3371         \mbox{\hyperlink{structCatch_1_1Matchers_1_1Impl_1_1MatchAllOf}{MatchAllOf<T>}} \mbox{\hyperlink{structCatch_1_1Matchers_1_1Impl_1_1MatcherBase}{MatcherBase<T>::operator \&\& }}( \mbox{\hyperlink{structCatch_1_1Matchers_1_1Impl_1_1MatcherBase}{MatcherBase}} \textcolor{keyword}{const}\& other )\textcolor{keyword}{ const }\{}
\DoxyCodeLine{3372             \textcolor{keywordflow}{return} \mbox{\hyperlink{structCatch_1_1Matchers_1_1Impl_1_1MatchAllOf}{MatchAllOf<T>}}() \&\& *\textcolor{keyword}{this} \&\& other;}
\DoxyCodeLine{3373         \}}
\DoxyCodeLine{3374         \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{3375         MatchAnyOf<T> \mbox{\hyperlink{structCatch_1_1Matchers_1_1Impl_1_1MatcherBase}{MatcherBase<T>::operator || }}( \mbox{\hyperlink{structCatch_1_1Matchers_1_1Impl_1_1MatcherBase}{MatcherBase}} \textcolor{keyword}{const}\& other )\textcolor{keyword}{ const }\{}
\DoxyCodeLine{3376             \textcolor{keywordflow}{return} MatchAnyOf<T>() || *\textcolor{keyword}{this} || other;}
\DoxyCodeLine{3377         \}}
\DoxyCodeLine{3378         \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{3379         MatchNotOf<T> \mbox{\hyperlink{structCatch_1_1Matchers_1_1Impl_1_1MatcherBase}{MatcherBase<T>::operator ! }}()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{3380             \textcolor{keywordflow}{return} MatchNotOf<T>( *\textcolor{keyword}{this} );}
\DoxyCodeLine{3381         \}}
\DoxyCodeLine{3382 }
\DoxyCodeLine{3383     \} \textcolor{comment}{// namespace Impl}}
\DoxyCodeLine{3384 }
\DoxyCodeLine{3385 \} \textcolor{comment}{// namespace Matchers}}
\DoxyCodeLine{3386 }
\DoxyCodeLine{3387 \textcolor{keyword}{using namespace }Matchers;}
\DoxyCodeLine{3388 \textcolor{keyword}{using }Matchers::Impl::MatcherBase;}
\DoxyCodeLine{3389 }
\DoxyCodeLine{3390 \} \textcolor{comment}{// namespace Catch}}
\DoxyCodeLine{3391 }
\DoxyCodeLine{3392 \textcolor{comment}{// end catch\_matchers.h}}
\DoxyCodeLine{3393 \textcolor{comment}{// start catch\_matchers\_exception.hpp}}
\DoxyCodeLine{3394 }
\DoxyCodeLine{3395 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{3396 \textcolor{keyword}{namespace }Matchers \{}
\DoxyCodeLine{3397 \textcolor{keyword}{namespace }Exception \{}
\DoxyCodeLine{3398 }
\DoxyCodeLine{3399 \textcolor{keyword}{class }\mbox{\hyperlink{classCatch_1_1Matchers_1_1Exception_1_1ExceptionMessageMatcher}{ExceptionMessageMatcher}} : \textcolor{keyword}{public} \mbox{\hyperlink{structCatch_1_1Matchers_1_1Impl_1_1MatcherBase}{MatcherBase}}<std::exception> \{}
\DoxyCodeLine{3400     std::string m\_message;}
\DoxyCodeLine{3401 \textcolor{keyword}{public}:}
\DoxyCodeLine{3402 }
\DoxyCodeLine{3403     \mbox{\hyperlink{classCatch_1_1Matchers_1_1Exception_1_1ExceptionMessageMatcher}{ExceptionMessageMatcher}}(std::string \textcolor{keyword}{const}\& message):}
\DoxyCodeLine{3404         m\_message(message)}
\DoxyCodeLine{3405     \{\}}
\DoxyCodeLine{3406 }
\DoxyCodeLine{3407     \textcolor{keywordtype}{bool} match(std::exception \textcolor{keyword}{const}\& ex) \textcolor{keyword}{const override};}
\DoxyCodeLine{3408 }
\DoxyCodeLine{3409     std::string describe() \textcolor{keyword}{const override};}
\DoxyCodeLine{3410 \};}
\DoxyCodeLine{3411 }
\DoxyCodeLine{3412 \} \textcolor{comment}{// namespace Exception}}
\DoxyCodeLine{3413 }
\DoxyCodeLine{3414 \mbox{\hyperlink{classCatch_1_1Matchers_1_1Exception_1_1ExceptionMessageMatcher}{Exception::ExceptionMessageMatcher}} Message(std::string \textcolor{keyword}{const}\& message);}
\DoxyCodeLine{3415 }
\DoxyCodeLine{3416 \} \textcolor{comment}{// namespace Matchers}}
\DoxyCodeLine{3417 \} \textcolor{comment}{// namespace Catch}}
\DoxyCodeLine{3418 }
\DoxyCodeLine{3419 \textcolor{comment}{// end catch\_matchers\_exception.hpp}}
\DoxyCodeLine{3420 \textcolor{comment}{// start catch\_matchers\_floating.h}}
\DoxyCodeLine{3421 }
\DoxyCodeLine{3422 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{3423 \textcolor{keyword}{namespace }Matchers \{}
\DoxyCodeLine{3424 }
\DoxyCodeLine{3425     \textcolor{keyword}{namespace }Floating \{}
\DoxyCodeLine{3426 }
\DoxyCodeLine{3427         \textcolor{keyword}{enum class} FloatingPointKind : uint8\_t;}
\DoxyCodeLine{3428 }
\DoxyCodeLine{3429         \textcolor{keyword}{struct }\mbox{\hyperlink{structCatch_1_1Matchers_1_1Floating_1_1WithinAbsMatcher}{WithinAbsMatcher}} : \mbox{\hyperlink{structCatch_1_1Matchers_1_1Impl_1_1MatcherBase}{MatcherBase}}<double> \{}
\DoxyCodeLine{3430             \mbox{\hyperlink{structCatch_1_1Matchers_1_1Floating_1_1WithinAbsMatcher}{WithinAbsMatcher}}(\textcolor{keywordtype}{double} target, \textcolor{keywordtype}{double} margin);}
\DoxyCodeLine{3431             \textcolor{keywordtype}{bool} match(\textcolor{keywordtype}{double} \textcolor{keyword}{const}\& matchee) \textcolor{keyword}{const override};}
\DoxyCodeLine{3432             std::string describe() \textcolor{keyword}{const override};}
\DoxyCodeLine{3433         \textcolor{keyword}{private}:}
\DoxyCodeLine{3434             \textcolor{keywordtype}{double} m\_target;}
\DoxyCodeLine{3435             \textcolor{keywordtype}{double} m\_margin;}
\DoxyCodeLine{3436         \};}
\DoxyCodeLine{3437 }
\DoxyCodeLine{3438         \textcolor{keyword}{struct }\mbox{\hyperlink{structCatch_1_1Matchers_1_1Floating_1_1WithinUlpsMatcher}{WithinUlpsMatcher}} : \mbox{\hyperlink{structCatch_1_1Matchers_1_1Impl_1_1MatcherBase}{MatcherBase}}<double> \{}
\DoxyCodeLine{3439             \mbox{\hyperlink{structCatch_1_1Matchers_1_1Floating_1_1WithinUlpsMatcher}{WithinUlpsMatcher}}(\textcolor{keywordtype}{double} target, uint64\_t ulps, FloatingPointKind baseType);}
\DoxyCodeLine{3440             \textcolor{keywordtype}{bool} match(\textcolor{keywordtype}{double} \textcolor{keyword}{const}\& matchee) \textcolor{keyword}{const override};}
\DoxyCodeLine{3441             std::string describe() \textcolor{keyword}{const override};}
\DoxyCodeLine{3442         \textcolor{keyword}{private}:}
\DoxyCodeLine{3443             \textcolor{keywordtype}{double} m\_target;}
\DoxyCodeLine{3444             uint64\_t m\_ulps;}
\DoxyCodeLine{3445             FloatingPointKind m\_type;}
\DoxyCodeLine{3446         \};}
\DoxyCodeLine{3447 }
\DoxyCodeLine{3448         \textcolor{comment}{// Given IEEE-\/754 format for floats and doubles, we can assume}}
\DoxyCodeLine{3449         \textcolor{comment}{// that float -\/> double promotion is lossless. Given this, we can}}
\DoxyCodeLine{3450         \textcolor{comment}{// assume that if we do the standard relative comparison of}}
\DoxyCodeLine{3451         \textcolor{comment}{// |lhs -\/ rhs| <= epsilon * max(fabs(lhs), fabs(rhs)), then we get}}
\DoxyCodeLine{3452         \textcolor{comment}{// the same result if we do this for floats, as if we do this for}}
\DoxyCodeLine{3453         \textcolor{comment}{// doubles that were promoted from floats.}}
\DoxyCodeLine{3454         \textcolor{keyword}{struct }\mbox{\hyperlink{structCatch_1_1Matchers_1_1Floating_1_1WithinRelMatcher}{WithinRelMatcher}} : \mbox{\hyperlink{structCatch_1_1Matchers_1_1Impl_1_1MatcherBase}{MatcherBase}}<double> \{}
\DoxyCodeLine{3455             \mbox{\hyperlink{structCatch_1_1Matchers_1_1Floating_1_1WithinRelMatcher}{WithinRelMatcher}}(\textcolor{keywordtype}{double} target, \textcolor{keywordtype}{double} epsilon);}
\DoxyCodeLine{3456             \textcolor{keywordtype}{bool} match(\textcolor{keywordtype}{double} \textcolor{keyword}{const}\& matchee) \textcolor{keyword}{const override};}
\DoxyCodeLine{3457             std::string describe() \textcolor{keyword}{const override};}
\DoxyCodeLine{3458         \textcolor{keyword}{private}:}
\DoxyCodeLine{3459             \textcolor{keywordtype}{double} m\_target;}
\DoxyCodeLine{3460             \textcolor{keywordtype}{double} m\_epsilon;}
\DoxyCodeLine{3461         \};}
\DoxyCodeLine{3462 }
\DoxyCodeLine{3463     \} \textcolor{comment}{// namespace Floating}}
\DoxyCodeLine{3464 }
\DoxyCodeLine{3465     \textcolor{comment}{// The following functions create the actual matcher objects.}}
\DoxyCodeLine{3466     \textcolor{comment}{// This allows the types to be inferred}}
\DoxyCodeLine{3467     \mbox{\hyperlink{structCatch_1_1Matchers_1_1Floating_1_1WithinUlpsMatcher}{Floating::WithinUlpsMatcher}} WithinULP(\textcolor{keywordtype}{double} target, uint64\_t maxUlpDiff);}
\DoxyCodeLine{3468     \mbox{\hyperlink{structCatch_1_1Matchers_1_1Floating_1_1WithinUlpsMatcher}{Floating::WithinUlpsMatcher}} WithinULP(\textcolor{keywordtype}{float} target, uint64\_t maxUlpDiff);}
\DoxyCodeLine{3469     \mbox{\hyperlink{structCatch_1_1Matchers_1_1Floating_1_1WithinAbsMatcher}{Floating::WithinAbsMatcher}} WithinAbs(\textcolor{keywordtype}{double} target, \textcolor{keywordtype}{double} margin);}
\DoxyCodeLine{3470     \mbox{\hyperlink{structCatch_1_1Matchers_1_1Floating_1_1WithinRelMatcher}{Floating::WithinRelMatcher}} WithinRel(\textcolor{keywordtype}{double} target, \textcolor{keywordtype}{double} eps);}
\DoxyCodeLine{3471     \textcolor{comment}{// defaults epsilon to 100*numeric\_limits<double>::epsilon()}}
\DoxyCodeLine{3472     \mbox{\hyperlink{structCatch_1_1Matchers_1_1Floating_1_1WithinRelMatcher}{Floating::WithinRelMatcher}} WithinRel(\textcolor{keywordtype}{double} target);}
\DoxyCodeLine{3473     \mbox{\hyperlink{structCatch_1_1Matchers_1_1Floating_1_1WithinRelMatcher}{Floating::WithinRelMatcher}} WithinRel(\textcolor{keywordtype}{float} target, \textcolor{keywordtype}{float} eps);}
\DoxyCodeLine{3474     \textcolor{comment}{// defaults epsilon to 100*numeric\_limits<float>::epsilon()}}
\DoxyCodeLine{3475     \mbox{\hyperlink{structCatch_1_1Matchers_1_1Floating_1_1WithinRelMatcher}{Floating::WithinRelMatcher}} WithinRel(\textcolor{keywordtype}{float} target);}
\DoxyCodeLine{3476 }
\DoxyCodeLine{3477 \} \textcolor{comment}{// namespace Matchers}}
\DoxyCodeLine{3478 \} \textcolor{comment}{// namespace Catch}}
\DoxyCodeLine{3479 }
\DoxyCodeLine{3480 \textcolor{comment}{// end catch\_matchers\_floating.h}}
\DoxyCodeLine{3481 \textcolor{comment}{// start catch\_matchers\_generic.hpp}}
\DoxyCodeLine{3482 }
\DoxyCodeLine{3483 \textcolor{preprocessor}{\#include <functional>}}
\DoxyCodeLine{3484 \textcolor{preprocessor}{\#include <string>}}
\DoxyCodeLine{3485 }
\DoxyCodeLine{3486 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{3487 \textcolor{keyword}{namespace }Matchers \{}
\DoxyCodeLine{3488 \textcolor{keyword}{namespace }Generic \{}
\DoxyCodeLine{3489 }
\DoxyCodeLine{3490 \textcolor{keyword}{namespace }Detail \{}
\DoxyCodeLine{3491     std::string finalizeDescription(\textcolor{keyword}{const} std::string\& desc);}
\DoxyCodeLine{3492 \}}
\DoxyCodeLine{3493 }
\DoxyCodeLine{3494 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{3495 \textcolor{keyword}{class }\mbox{\hyperlink{classCatch_1_1Matchers_1_1Generic_1_1PredicateMatcher}{PredicateMatcher}} : \textcolor{keyword}{public} \mbox{\hyperlink{structCatch_1_1Matchers_1_1Impl_1_1MatcherBase}{MatcherBase}}<T> \{}
\DoxyCodeLine{3496     std::function<bool(T \textcolor{keyword}{const}\&)> m\_predicate;}
\DoxyCodeLine{3497     std::string m\_description;}
\DoxyCodeLine{3498 \textcolor{keyword}{public}:}
\DoxyCodeLine{3499 }
\DoxyCodeLine{3500     \mbox{\hyperlink{classCatch_1_1Matchers_1_1Generic_1_1PredicateMatcher}{PredicateMatcher}}(std::function<\textcolor{keywordtype}{bool}(T \textcolor{keyword}{const}\&)> \textcolor{keyword}{const}\& elem, std::string \textcolor{keyword}{const}\& descr)}
\DoxyCodeLine{3501         :m\_predicate(std::move(elem)),}
\DoxyCodeLine{3502         m\_description(Detail::finalizeDescription(descr))}
\DoxyCodeLine{3503     \{\}}
\DoxyCodeLine{3504 }
\DoxyCodeLine{3505     \textcolor{keywordtype}{bool} match( T \textcolor{keyword}{const}\& item )\textcolor{keyword}{ const override }\{}
\DoxyCodeLine{3506         \textcolor{keywordflow}{return} m\_predicate(item);}
\DoxyCodeLine{3507     \}}
\DoxyCodeLine{3508 }
\DoxyCodeLine{3509     std::string describe()\textcolor{keyword}{ const override }\{}
\DoxyCodeLine{3510         \textcolor{keywordflow}{return} m\_description;}
\DoxyCodeLine{3511     \}}
\DoxyCodeLine{3512 \};}
\DoxyCodeLine{3513 }
\DoxyCodeLine{3514 \} \textcolor{comment}{// namespace Generic}}
\DoxyCodeLine{3515 }
\DoxyCodeLine{3516     \textcolor{comment}{// The following functions create the actual matcher objects.}}
\DoxyCodeLine{3517     \textcolor{comment}{// The user has to explicitly specify type to the function, because}}
\DoxyCodeLine{3518     \textcolor{comment}{// inferring std::function<bool(T const\&)> is hard (but possible) and}}
\DoxyCodeLine{3519     \textcolor{comment}{// requires a lot of TMP.}}
\DoxyCodeLine{3520     \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{3521     \mbox{\hyperlink{classCatch_1_1Matchers_1_1Generic_1_1PredicateMatcher}{Generic::PredicateMatcher<T>}} Predicate(std::function<\textcolor{keywordtype}{bool}(T \textcolor{keyword}{const}\&)> \textcolor{keyword}{const}\& predicate, std::string \textcolor{keyword}{const}\& description = \textcolor{stringliteral}{"{}"{}}) \{}
\DoxyCodeLine{3522         \textcolor{keywordflow}{return} \mbox{\hyperlink{classCatch_1_1Matchers_1_1Generic_1_1PredicateMatcher}{Generic::PredicateMatcher<T>}}(predicate, description);}
\DoxyCodeLine{3523     \}}
\DoxyCodeLine{3524 }
\DoxyCodeLine{3525 \} \textcolor{comment}{// namespace Matchers}}
\DoxyCodeLine{3526 \} \textcolor{comment}{// namespace Catch}}
\DoxyCodeLine{3527 }
\DoxyCodeLine{3528 \textcolor{comment}{// end catch\_matchers\_generic.hpp}}
\DoxyCodeLine{3529 \textcolor{comment}{// start catch\_matchers\_string.h}}
\DoxyCodeLine{3530 }
\DoxyCodeLine{3531 \textcolor{preprocessor}{\#include <string>}}
\DoxyCodeLine{3532 }
\DoxyCodeLine{3533 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{3534 \textcolor{keyword}{namespace }Matchers \{}
\DoxyCodeLine{3535 }
\DoxyCodeLine{3536     \textcolor{keyword}{namespace }StdString \{}
\DoxyCodeLine{3537 }
\DoxyCodeLine{3538         \textcolor{keyword}{struct }\mbox{\hyperlink{structCatch_1_1Matchers_1_1StdString_1_1CasedString}{CasedString}}}
\DoxyCodeLine{3539         \{}
\DoxyCodeLine{3540             \mbox{\hyperlink{structCatch_1_1Matchers_1_1StdString_1_1CasedString}{CasedString}}( std::string \textcolor{keyword}{const}\& str, CaseSensitive::Choice caseSensitivity );}
\DoxyCodeLine{3541             std::string adjustString( std::string \textcolor{keyword}{const}\& str ) \textcolor{keyword}{const};}
\DoxyCodeLine{3542             std::string caseSensitivitySuffix() \textcolor{keyword}{const};}
\DoxyCodeLine{3543 }
\DoxyCodeLine{3544             CaseSensitive::Choice m\_caseSensitivity;}
\DoxyCodeLine{3545             std::string m\_str;}
\DoxyCodeLine{3546         \};}
\DoxyCodeLine{3547 }
\DoxyCodeLine{3548         \textcolor{keyword}{struct }\mbox{\hyperlink{structCatch_1_1Matchers_1_1StdString_1_1StringMatcherBase}{StringMatcherBase}} : \mbox{\hyperlink{structCatch_1_1Matchers_1_1Impl_1_1MatcherBase}{MatcherBase}}<std::string> \{}
\DoxyCodeLine{3549             \mbox{\hyperlink{structCatch_1_1Matchers_1_1StdString_1_1StringMatcherBase}{StringMatcherBase}}( std::string \textcolor{keyword}{const}\& operation, \mbox{\hyperlink{structCatch_1_1Matchers_1_1StdString_1_1CasedString}{CasedString}} \textcolor{keyword}{const}\& comparator );}
\DoxyCodeLine{3550             std::string describe() \textcolor{keyword}{const override};}
\DoxyCodeLine{3551 }
\DoxyCodeLine{3552             \mbox{\hyperlink{structCatch_1_1Matchers_1_1StdString_1_1CasedString}{CasedString}} m\_comparator;}
\DoxyCodeLine{3553             std::string m\_operation;}
\DoxyCodeLine{3554         \};}
\DoxyCodeLine{3555 }
\DoxyCodeLine{3556         \textcolor{keyword}{struct }\mbox{\hyperlink{structCatch_1_1Matchers_1_1StdString_1_1EqualsMatcher}{EqualsMatcher}} : \mbox{\hyperlink{structCatch_1_1Matchers_1_1StdString_1_1StringMatcherBase}{StringMatcherBase}} \{}
\DoxyCodeLine{3557             \mbox{\hyperlink{structCatch_1_1Matchers_1_1StdString_1_1EqualsMatcher}{EqualsMatcher}}( \mbox{\hyperlink{structCatch_1_1Matchers_1_1StdString_1_1CasedString}{CasedString}} \textcolor{keyword}{const}\& comparator );}
\DoxyCodeLine{3558             \textcolor{keywordtype}{bool} match( std::string \textcolor{keyword}{const}\& source ) \textcolor{keyword}{const override};}
\DoxyCodeLine{3559         \};}
\DoxyCodeLine{3560         \textcolor{keyword}{struct }\mbox{\hyperlink{structCatch_1_1Matchers_1_1StdString_1_1ContainsMatcher}{ContainsMatcher}} : \mbox{\hyperlink{structCatch_1_1Matchers_1_1StdString_1_1StringMatcherBase}{StringMatcherBase}} \{}
\DoxyCodeLine{3561             \mbox{\hyperlink{structCatch_1_1Matchers_1_1StdString_1_1ContainsMatcher}{ContainsMatcher}}( \mbox{\hyperlink{structCatch_1_1Matchers_1_1StdString_1_1CasedString}{CasedString}} \textcolor{keyword}{const}\& comparator );}
\DoxyCodeLine{3562             \textcolor{keywordtype}{bool} match( std::string \textcolor{keyword}{const}\& source ) \textcolor{keyword}{const override};}
\DoxyCodeLine{3563         \};}
\DoxyCodeLine{3564         \textcolor{keyword}{struct }\mbox{\hyperlink{structCatch_1_1Matchers_1_1StdString_1_1StartsWithMatcher}{StartsWithMatcher}} : \mbox{\hyperlink{structCatch_1_1Matchers_1_1StdString_1_1StringMatcherBase}{StringMatcherBase}} \{}
\DoxyCodeLine{3565             \mbox{\hyperlink{structCatch_1_1Matchers_1_1StdString_1_1StartsWithMatcher}{StartsWithMatcher}}( \mbox{\hyperlink{structCatch_1_1Matchers_1_1StdString_1_1CasedString}{CasedString}} \textcolor{keyword}{const}\& comparator );}
\DoxyCodeLine{3566             \textcolor{keywordtype}{bool} match( std::string \textcolor{keyword}{const}\& source ) \textcolor{keyword}{const override};}
\DoxyCodeLine{3567         \};}
\DoxyCodeLine{3568         \textcolor{keyword}{struct }\mbox{\hyperlink{structCatch_1_1Matchers_1_1StdString_1_1EndsWithMatcher}{EndsWithMatcher}} : \mbox{\hyperlink{structCatch_1_1Matchers_1_1StdString_1_1StringMatcherBase}{StringMatcherBase}} \{}
\DoxyCodeLine{3569             \mbox{\hyperlink{structCatch_1_1Matchers_1_1StdString_1_1EndsWithMatcher}{EndsWithMatcher}}( \mbox{\hyperlink{structCatch_1_1Matchers_1_1StdString_1_1CasedString}{CasedString}} \textcolor{keyword}{const}\& comparator );}
\DoxyCodeLine{3570             \textcolor{keywordtype}{bool} match( std::string \textcolor{keyword}{const}\& source ) \textcolor{keyword}{const override};}
\DoxyCodeLine{3571         \};}
\DoxyCodeLine{3572 }
\DoxyCodeLine{3573         \textcolor{keyword}{struct }\mbox{\hyperlink{structCatch_1_1Matchers_1_1StdString_1_1RegexMatcher}{RegexMatcher}} : \mbox{\hyperlink{structCatch_1_1Matchers_1_1Impl_1_1MatcherBase}{MatcherBase}}<std::string> \{}
\DoxyCodeLine{3574             \mbox{\hyperlink{structCatch_1_1Matchers_1_1StdString_1_1RegexMatcher}{RegexMatcher}}( std::string regex, CaseSensitive::Choice caseSensitivity );}
\DoxyCodeLine{3575             \textcolor{keywordtype}{bool} match( std::string \textcolor{keyword}{const}\& matchee ) \textcolor{keyword}{const override};}
\DoxyCodeLine{3576             std::string describe() \textcolor{keyword}{const override};}
\DoxyCodeLine{3577 }
\DoxyCodeLine{3578         \textcolor{keyword}{private}:}
\DoxyCodeLine{3579             std::string m\_regex;}
\DoxyCodeLine{3580             CaseSensitive::Choice m\_caseSensitivity;}
\DoxyCodeLine{3581         \};}
\DoxyCodeLine{3582 }
\DoxyCodeLine{3583     \} \textcolor{comment}{// namespace StdString}}
\DoxyCodeLine{3584 }
\DoxyCodeLine{3585     \textcolor{comment}{// The following functions create the actual matcher objects.}}
\DoxyCodeLine{3586     \textcolor{comment}{// This allows the types to be inferred}}
\DoxyCodeLine{3587 }
\DoxyCodeLine{3588     \mbox{\hyperlink{structCatch_1_1Matchers_1_1StdString_1_1EqualsMatcher}{StdString::EqualsMatcher}} Equals( std::string \textcolor{keyword}{const}\& str, CaseSensitive::Choice caseSensitivity = CaseSensitive::Yes );}
\DoxyCodeLine{3589     \mbox{\hyperlink{structCatch_1_1Matchers_1_1StdString_1_1ContainsMatcher}{StdString::ContainsMatcher}} Contains( std::string \textcolor{keyword}{const}\& str, CaseSensitive::Choice caseSensitivity = CaseSensitive::Yes );}
\DoxyCodeLine{3590     \mbox{\hyperlink{structCatch_1_1Matchers_1_1StdString_1_1EndsWithMatcher}{StdString::EndsWithMatcher}} EndsWith( std::string \textcolor{keyword}{const}\& str, CaseSensitive::Choice caseSensitivity = CaseSensitive::Yes );}
\DoxyCodeLine{3591     \mbox{\hyperlink{structCatch_1_1Matchers_1_1StdString_1_1StartsWithMatcher}{StdString::StartsWithMatcher}} StartsWith( std::string \textcolor{keyword}{const}\& str, CaseSensitive::Choice caseSensitivity = CaseSensitive::Yes );}
\DoxyCodeLine{3592     \mbox{\hyperlink{structCatch_1_1Matchers_1_1StdString_1_1RegexMatcher}{StdString::RegexMatcher}} Matches( std::string \textcolor{keyword}{const}\& regex, CaseSensitive::Choice caseSensitivity = CaseSensitive::Yes );}
\DoxyCodeLine{3593 }
\DoxyCodeLine{3594 \} \textcolor{comment}{// namespace Matchers}}
\DoxyCodeLine{3595 \} \textcolor{comment}{// namespace Catch}}
\DoxyCodeLine{3596 }
\DoxyCodeLine{3597 \textcolor{comment}{// end catch\_matchers\_string.h}}
\DoxyCodeLine{3598 \textcolor{comment}{// start catch\_matchers\_vector.h}}
\DoxyCodeLine{3599 }
\DoxyCodeLine{3600 \textcolor{preprocessor}{\#include <algorithm>}}
\DoxyCodeLine{3601 }
\DoxyCodeLine{3602 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{3603 \textcolor{keyword}{namespace }Matchers \{}
\DoxyCodeLine{3604 }
\DoxyCodeLine{3605     \textcolor{keyword}{namespace }Vector \{}
\DoxyCodeLine{3606         \textcolor{keyword}{template}<\textcolor{keyword}{typename} T, \textcolor{keyword}{typename} Alloc>}
\DoxyCodeLine{3607         \textcolor{keyword}{struct }\mbox{\hyperlink{structCatch_1_1Matchers_1_1Vector_1_1ContainsElementMatcher}{ContainsElementMatcher}} : \mbox{\hyperlink{structCatch_1_1Matchers_1_1Impl_1_1MatcherBase}{MatcherBase}}<std::vector<T, Alloc>> \{}
\DoxyCodeLine{3608 }
\DoxyCodeLine{3609             \mbox{\hyperlink{structCatch_1_1Matchers_1_1Vector_1_1ContainsElementMatcher}{ContainsElementMatcher}}(T \textcolor{keyword}{const} \&comparator) : m\_comparator( comparator) \{\}}
\DoxyCodeLine{3610 }
\DoxyCodeLine{3611             \textcolor{keywordtype}{bool} match(std::vector<T, Alloc> \textcolor{keyword}{const} \&v)\textcolor{keyword}{ const override }\{}
\DoxyCodeLine{3612                 \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} \textcolor{keyword}{const}\& el : v) \{}
\DoxyCodeLine{3613                     \textcolor{keywordflow}{if} (el == m\_comparator) \{}
\DoxyCodeLine{3614                         \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{3615                     \}}
\DoxyCodeLine{3616                 \}}
\DoxyCodeLine{3617                 \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{3618             \}}
\DoxyCodeLine{3619 }
\DoxyCodeLine{3620             std::string describe()\textcolor{keyword}{ const override }\{}
\DoxyCodeLine{3621                 \textcolor{keywordflow}{return} \textcolor{stringliteral}{"{}Contains: "{}} + ::Catch::Detail::stringify( m\_comparator );}
\DoxyCodeLine{3622             \}}
\DoxyCodeLine{3623 }
\DoxyCodeLine{3624             T \textcolor{keyword}{const}\& m\_comparator;}
\DoxyCodeLine{3625         \};}
\DoxyCodeLine{3626 }
\DoxyCodeLine{3627         \textcolor{keyword}{template}<\textcolor{keyword}{typename} T, \textcolor{keyword}{typename} AllocComp, \textcolor{keyword}{typename} AllocMatch>}
\DoxyCodeLine{3628         \textcolor{keyword}{struct }\mbox{\hyperlink{structCatch_1_1Matchers_1_1Vector_1_1ContainsMatcher}{ContainsMatcher}} : \mbox{\hyperlink{structCatch_1_1Matchers_1_1Impl_1_1MatcherBase}{MatcherBase}}<std::vector<T, AllocMatch>> \{}
\DoxyCodeLine{3629 }
\DoxyCodeLine{3630             \mbox{\hyperlink{structCatch_1_1Matchers_1_1Vector_1_1ContainsMatcher}{ContainsMatcher}}(std::vector<T, AllocComp> \textcolor{keyword}{const} \&comparator) : m\_comparator( comparator ) \{\}}
\DoxyCodeLine{3631 }
\DoxyCodeLine{3632             \textcolor{keywordtype}{bool} match(std::vector<T, AllocMatch> \textcolor{keyword}{const} \&v)\textcolor{keyword}{ const override }\{}
\DoxyCodeLine{3633                 \textcolor{comment}{// !TBD: see note in EqualsMatcher}}
\DoxyCodeLine{3634                 \textcolor{keywordflow}{if} (m\_comparator.size() > v.size())}
\DoxyCodeLine{3635                     \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{3636                 \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} \textcolor{keyword}{const}\& comparator : m\_comparator) \{}
\DoxyCodeLine{3637                     \textcolor{keyword}{auto} present = \textcolor{keyword}{false};}
\DoxyCodeLine{3638                     \textcolor{keywordflow}{for} (\textcolor{keyword}{const} \textcolor{keyword}{auto}\& el : v) \{}
\DoxyCodeLine{3639                         \textcolor{keywordflow}{if} (el == comparator) \{}
\DoxyCodeLine{3640                             present = \textcolor{keyword}{true};}
\DoxyCodeLine{3641                             \textcolor{keywordflow}{break};}
\DoxyCodeLine{3642                         \}}
\DoxyCodeLine{3643                     \}}
\DoxyCodeLine{3644                     \textcolor{keywordflow}{if} (!present) \{}
\DoxyCodeLine{3645                         \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{3646                     \}}
\DoxyCodeLine{3647                 \}}
\DoxyCodeLine{3648                 \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{3649             \}}
\DoxyCodeLine{3650             std::string describe()\textcolor{keyword}{ const override }\{}
\DoxyCodeLine{3651                 \textcolor{keywordflow}{return} \textcolor{stringliteral}{"{}Contains: "{}} + ::Catch::Detail::stringify( m\_comparator );}
\DoxyCodeLine{3652             \}}
\DoxyCodeLine{3653 }
\DoxyCodeLine{3654             std::vector<T, AllocComp> \textcolor{keyword}{const}\& m\_comparator;}
\DoxyCodeLine{3655         \};}
\DoxyCodeLine{3656 }
\DoxyCodeLine{3657         \textcolor{keyword}{template}<\textcolor{keyword}{typename} T, \textcolor{keyword}{typename} AllocComp, \textcolor{keyword}{typename} AllocMatch>}
\DoxyCodeLine{3658         \textcolor{keyword}{struct }\mbox{\hyperlink{structCatch_1_1Matchers_1_1Vector_1_1EqualsMatcher}{EqualsMatcher}} : \mbox{\hyperlink{structCatch_1_1Matchers_1_1Impl_1_1MatcherBase}{MatcherBase}}<std::vector<T, AllocMatch>> \{}
\DoxyCodeLine{3659 }
\DoxyCodeLine{3660             \mbox{\hyperlink{structCatch_1_1Matchers_1_1Vector_1_1EqualsMatcher}{EqualsMatcher}}(std::vector<T, AllocComp> \textcolor{keyword}{const} \&comparator) : m\_comparator( comparator ) \{\}}
\DoxyCodeLine{3661 }
\DoxyCodeLine{3662             \textcolor{keywordtype}{bool} match(std::vector<T, AllocMatch> \textcolor{keyword}{const} \&v)\textcolor{keyword}{ const override }\{}
\DoxyCodeLine{3663                 \textcolor{comment}{// !TBD: This currently works if all elements can be compared using !=}}
\DoxyCodeLine{3664                 \textcolor{comment}{// -\/ a more general approach would be via a compare template that defaults}}
\DoxyCodeLine{3665                 \textcolor{comment}{// to using !=. but could be specialised for, e.g. std::vector<T, Alloc> etc}}
\DoxyCodeLine{3666                 \textcolor{comment}{// -\/ then just call that directly}}
\DoxyCodeLine{3667                 \textcolor{keywordflow}{if} (m\_comparator.size() != v.size())}
\DoxyCodeLine{3668                     \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{3669                 \textcolor{keywordflow}{for} (std::size\_t i = 0; i < v.size(); ++i)}
\DoxyCodeLine{3670                     \textcolor{keywordflow}{if} (m\_comparator[i] != v[i])}
\DoxyCodeLine{3671                         \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{3672                 \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{3673             \}}
\DoxyCodeLine{3674             std::string describe()\textcolor{keyword}{ const override }\{}
\DoxyCodeLine{3675                 \textcolor{keywordflow}{return} \textcolor{stringliteral}{"{}Equals: "{}} + ::Catch::Detail::stringify( m\_comparator );}
\DoxyCodeLine{3676             \}}
\DoxyCodeLine{3677             std::vector<T, AllocComp> \textcolor{keyword}{const}\& m\_comparator;}
\DoxyCodeLine{3678         \};}
\DoxyCodeLine{3679 }
\DoxyCodeLine{3680         \textcolor{keyword}{template}<\textcolor{keyword}{typename} T, \textcolor{keyword}{typename} AllocComp, \textcolor{keyword}{typename} AllocMatch>}
\DoxyCodeLine{3681         \textcolor{keyword}{struct }\mbox{\hyperlink{structCatch_1_1Matchers_1_1Vector_1_1ApproxMatcher}{ApproxMatcher}} : \mbox{\hyperlink{structCatch_1_1Matchers_1_1Impl_1_1MatcherBase}{MatcherBase}}<std::vector<T, AllocMatch>> \{}
\DoxyCodeLine{3682 }
\DoxyCodeLine{3683             \mbox{\hyperlink{structCatch_1_1Matchers_1_1Vector_1_1ApproxMatcher}{ApproxMatcher}}(std::vector<T, AllocComp> \textcolor{keyword}{const}\& comparator) : m\_comparator( comparator ) \{\}}
\DoxyCodeLine{3684 }
\DoxyCodeLine{3685             \textcolor{keywordtype}{bool} match(std::vector<T, AllocMatch> \textcolor{keyword}{const} \&v)\textcolor{keyword}{ const override }\{}
\DoxyCodeLine{3686                 \textcolor{keywordflow}{if} (m\_comparator.size() != v.size())}
\DoxyCodeLine{3687                     \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{3688                 \textcolor{keywordflow}{for} (std::size\_t i = 0; i < v.size(); ++i)}
\DoxyCodeLine{3689                     \textcolor{keywordflow}{if} (m\_comparator[i] != approx(v[i]))}
\DoxyCodeLine{3690                         \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{3691                 \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{3692             \}}
\DoxyCodeLine{3693             std::string describe()\textcolor{keyword}{ const override }\{}
\DoxyCodeLine{3694                 \textcolor{keywordflow}{return} \textcolor{stringliteral}{"{}is approx: "{}} + ::Catch::Detail::stringify( m\_comparator );}
\DoxyCodeLine{3695             \}}
\DoxyCodeLine{3696             template <typename = typename std::enable\_if<std::is\_constructible<double, T>::value>::type>}
\DoxyCodeLine{3697             \mbox{\hyperlink{structCatch_1_1Matchers_1_1Vector_1_1ApproxMatcher}{ApproxMatcher}}\& epsilon( T \textcolor{keyword}{const}\& newEpsilon ) \{}
\DoxyCodeLine{3698                 approx.epsilon(newEpsilon);}
\DoxyCodeLine{3699                 \textcolor{keywordflow}{return} *\textcolor{keyword}{this};}
\DoxyCodeLine{3700             \}}
\DoxyCodeLine{3701             template <typename = typename std::enable\_if<std::is\_constructible<double, T>::value>::type>}
\DoxyCodeLine{3702             \mbox{\hyperlink{structCatch_1_1Matchers_1_1Vector_1_1ApproxMatcher}{ApproxMatcher}}\& margin( T \textcolor{keyword}{const}\& newMargin ) \{}
\DoxyCodeLine{3703                 approx.margin(newMargin);}
\DoxyCodeLine{3704                 \textcolor{keywordflow}{return} *\textcolor{keyword}{this};}
\DoxyCodeLine{3705             \}}
\DoxyCodeLine{3706             template <typename = typename std::enable\_if<std::is\_constructible<double, T>::value>::type>}
\DoxyCodeLine{3707             \mbox{\hyperlink{structCatch_1_1Matchers_1_1Vector_1_1ApproxMatcher}{ApproxMatcher}}\& scale( T \textcolor{keyword}{const}\& newScale ) \{}
\DoxyCodeLine{3708                 approx.scale(newScale);}
\DoxyCodeLine{3709                 \textcolor{keywordflow}{return} *\textcolor{keyword}{this};}
\DoxyCodeLine{3710             \}}
\DoxyCodeLine{3711 }
\DoxyCodeLine{3712             std::vector<T, AllocComp> \textcolor{keyword}{const}\& m\_comparator;}
\DoxyCodeLine{3713             \textcolor{keyword}{mutable} \mbox{\hyperlink{classCatch_1_1Detail_1_1Approx}{Catch::Detail::Approx}} approx = Catch::Detail::Approx::custom();}
\DoxyCodeLine{3714         \};}
\DoxyCodeLine{3715 }
\DoxyCodeLine{3716         \textcolor{keyword}{template}<\textcolor{keyword}{typename} T, \textcolor{keyword}{typename} AllocComp, \textcolor{keyword}{typename} AllocMatch>}
\DoxyCodeLine{3717         \textcolor{keyword}{struct }\mbox{\hyperlink{structCatch_1_1Matchers_1_1Vector_1_1UnorderedEqualsMatcher}{UnorderedEqualsMatcher}} : \mbox{\hyperlink{structCatch_1_1Matchers_1_1Impl_1_1MatcherBase}{MatcherBase}}<std::vector<T, AllocMatch>> \{}
\DoxyCodeLine{3718             \mbox{\hyperlink{structCatch_1_1Matchers_1_1Vector_1_1UnorderedEqualsMatcher}{UnorderedEqualsMatcher}}(std::vector<T, AllocComp> \textcolor{keyword}{const}\& target) : m\_target(target) \{\}}
\DoxyCodeLine{3719             \textcolor{keywordtype}{bool} match(std::vector<T, AllocMatch> \textcolor{keyword}{const}\& vec)\textcolor{keyword}{ const override }\{}
\DoxyCodeLine{3720                 \textcolor{keywordflow}{if} (m\_target.size() != vec.size()) \{}
\DoxyCodeLine{3721                     \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{3722                 \}}
\DoxyCodeLine{3723                 \textcolor{keywordflow}{return} std::is\_permutation(m\_target.begin(), m\_target.end(), vec.begin());}
\DoxyCodeLine{3724             \}}
\DoxyCodeLine{3725 }
\DoxyCodeLine{3726             std::string describe()\textcolor{keyword}{ const override }\{}
\DoxyCodeLine{3727                 \textcolor{keywordflow}{return} \textcolor{stringliteral}{"{}UnorderedEquals: "{}} + ::Catch::Detail::stringify(m\_target);}
\DoxyCodeLine{3728             \}}
\DoxyCodeLine{3729         \textcolor{keyword}{private}:}
\DoxyCodeLine{3730             std::vector<T, AllocComp> \textcolor{keyword}{const}\& m\_target;}
\DoxyCodeLine{3731         \};}
\DoxyCodeLine{3732 }
\DoxyCodeLine{3733     \} \textcolor{comment}{// namespace Vector}}
\DoxyCodeLine{3734 }
\DoxyCodeLine{3735     \textcolor{comment}{// The following functions create the actual matcher objects.}}
\DoxyCodeLine{3736     \textcolor{comment}{// This allows the types to be inferred}}
\DoxyCodeLine{3737 }
\DoxyCodeLine{3738     \textcolor{keyword}{template}<\textcolor{keyword}{typename} T, \textcolor{keyword}{typename} AllocComp = std::allocator<T>, \textcolor{keyword}{typename} AllocMatch = AllocComp>}
\DoxyCodeLine{3739     \mbox{\hyperlink{structCatch_1_1Matchers_1_1Vector_1_1ContainsMatcher}{Vector::ContainsMatcher<T, AllocComp, AllocMatch>}} Contains( std::vector<T, AllocComp> \textcolor{keyword}{const}\& comparator ) \{}
\DoxyCodeLine{3740         \textcolor{keywordflow}{return} \mbox{\hyperlink{structCatch_1_1Matchers_1_1Vector_1_1ContainsMatcher}{Vector::ContainsMatcher<T, AllocComp, AllocMatch>}}( comparator );}
\DoxyCodeLine{3741     \}}
\DoxyCodeLine{3742 }
\DoxyCodeLine{3743     \textcolor{keyword}{template}<\textcolor{keyword}{typename} T, \textcolor{keyword}{typename} Alloc = std::allocator<T>>}
\DoxyCodeLine{3744     \mbox{\hyperlink{structCatch_1_1Matchers_1_1Vector_1_1ContainsElementMatcher}{Vector::ContainsElementMatcher<T, Alloc>}} VectorContains( T \textcolor{keyword}{const}\& comparator ) \{}
\DoxyCodeLine{3745         \textcolor{keywordflow}{return} \mbox{\hyperlink{structCatch_1_1Matchers_1_1Vector_1_1ContainsElementMatcher}{Vector::ContainsElementMatcher<T, Alloc>}}( comparator );}
\DoxyCodeLine{3746     \}}
\DoxyCodeLine{3747 }
\DoxyCodeLine{3748     \textcolor{keyword}{template}<\textcolor{keyword}{typename} T, \textcolor{keyword}{typename} AllocComp = std::allocator<T>, \textcolor{keyword}{typename} AllocMatch = AllocComp>}
\DoxyCodeLine{3749     Vector::EqualsMatcher<T, AllocComp, AllocMatch> Equals( std::vector<T, AllocComp> \textcolor{keyword}{const}\& comparator ) \{}
\DoxyCodeLine{3750         \textcolor{keywordflow}{return} Vector::EqualsMatcher<T, AllocComp, AllocMatch>( comparator );}
\DoxyCodeLine{3751     \}}
\DoxyCodeLine{3752 }
\DoxyCodeLine{3753     \textcolor{keyword}{template}<\textcolor{keyword}{typename} T, \textcolor{keyword}{typename} AllocComp = std::allocator<T>, \textcolor{keyword}{typename} AllocMatch = AllocComp>}
\DoxyCodeLine{3754     Vector::ApproxMatcher<T, AllocComp, AllocMatch> \mbox{\hyperlink{classCatch_1_1Detail_1_1Approx}{Approx}}( std::vector<T, AllocComp> \textcolor{keyword}{const}\& comparator ) \{}
\DoxyCodeLine{3755         \textcolor{keywordflow}{return} Vector::ApproxMatcher<T, AllocComp, AllocMatch>( comparator );}
\DoxyCodeLine{3756     \}}
\DoxyCodeLine{3757 }
\DoxyCodeLine{3758     \textcolor{keyword}{template}<\textcolor{keyword}{typename} T, \textcolor{keyword}{typename} AllocComp = std::allocator<T>, \textcolor{keyword}{typename} AllocMatch = AllocComp>}
\DoxyCodeLine{3759     Vector::UnorderedEqualsMatcher<T, AllocComp, AllocMatch> UnorderedEquals(std::vector<T, AllocComp> \textcolor{keyword}{const}\& target) \{}
\DoxyCodeLine{3760         \textcolor{keywordflow}{return} Vector::UnorderedEqualsMatcher<T, AllocComp, AllocMatch>( target );}
\DoxyCodeLine{3761     \}}
\DoxyCodeLine{3762 }
\DoxyCodeLine{3763 \} \textcolor{comment}{// namespace Matchers}}
\DoxyCodeLine{3764 \} \textcolor{comment}{// namespace Catch}}
\DoxyCodeLine{3765 }
\DoxyCodeLine{3766 \textcolor{comment}{// end catch\_matchers\_vector.h}}
\DoxyCodeLine{3767 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{3768 }
\DoxyCodeLine{3769     \textcolor{keyword}{template}<\textcolor{keyword}{typename} ArgT, \textcolor{keyword}{typename} MatcherT>}
\DoxyCodeLine{3770     \textcolor{keyword}{class }\mbox{\hyperlink{classCatch_1_1MatchExpr}{MatchExpr}} : \textcolor{keyword}{public} \mbox{\hyperlink{structCatch_1_1ITransientExpression}{ITransientExpression}} \{}
\DoxyCodeLine{3771         ArgT \textcolor{keyword}{const}\& m\_arg;}
\DoxyCodeLine{3772         MatcherT m\_matcher;}
\DoxyCodeLine{3773         \mbox{\hyperlink{classCatch_1_1StringRef}{StringRef}} m\_matcherString;}
\DoxyCodeLine{3774     \textcolor{keyword}{public}:}
\DoxyCodeLine{3775         \mbox{\hyperlink{classCatch_1_1MatchExpr}{MatchExpr}}( ArgT \textcolor{keyword}{const}\& arg, MatcherT \textcolor{keyword}{const}\& matcher, \mbox{\hyperlink{classCatch_1_1StringRef}{StringRef}} \textcolor{keyword}{const}\& matcherString )}
\DoxyCodeLine{3776         :   \mbox{\hyperlink{structCatch_1_1ITransientExpression}{ITransientExpression}}\{ \textcolor{keyword}{true}, matcher.match( arg ) \},}
\DoxyCodeLine{3777             m\_arg( arg ),}
\DoxyCodeLine{3778             m\_matcher( matcher ),}
\DoxyCodeLine{3779             m\_matcherString( matcherString )}
\DoxyCodeLine{3780         \{\}}
\DoxyCodeLine{3781 }
\DoxyCodeLine{3782         \textcolor{keywordtype}{void} streamReconstructedExpression( std::ostream \&os )\textcolor{keyword}{ const override }\{}
\DoxyCodeLine{3783             \textcolor{keyword}{auto} matcherAsString = m\_matcher.toString();}
\DoxyCodeLine{3784             os << Catch::Detail::stringify( m\_arg ) << \textcolor{charliteral}{' '};}
\DoxyCodeLine{3785             \textcolor{keywordflow}{if}( matcherAsString == Detail::unprintableString )}
\DoxyCodeLine{3786                 os << m\_matcherString;}
\DoxyCodeLine{3787             \textcolor{keywordflow}{else}}
\DoxyCodeLine{3788                 os << matcherAsString;}
\DoxyCodeLine{3789         \}}
\DoxyCodeLine{3790     \};}
\DoxyCodeLine{3791 }
\DoxyCodeLine{3792     \textcolor{keyword}{using }\mbox{\hyperlink{structCatch_1_1Matchers_1_1Impl_1_1MatcherBase}{StringMatcher}} = \mbox{\hyperlink{structCatch_1_1Matchers_1_1Impl_1_1MatcherBase}{Matchers::Impl::MatcherBase<std::string>}};}
\DoxyCodeLine{3793 }
\DoxyCodeLine{3794     \textcolor{keywordtype}{void} handleExceptionMatchExpr( \mbox{\hyperlink{classCatch_1_1AssertionHandler}{AssertionHandler}}\& handler, \mbox{\hyperlink{structCatch_1_1Matchers_1_1Impl_1_1MatcherBase}{StringMatcher}} \textcolor{keyword}{const}\& matcher, \mbox{\hyperlink{classCatch_1_1StringRef}{StringRef}} \textcolor{keyword}{const}\& matcherString  );}
\DoxyCodeLine{3795 }
\DoxyCodeLine{3796     \textcolor{keyword}{template}<\textcolor{keyword}{typename} ArgT, \textcolor{keyword}{typename} MatcherT>}
\DoxyCodeLine{3797     \textcolor{keyword}{auto} makeMatchExpr( ArgT \textcolor{keyword}{const}\& arg, MatcherT \textcolor{keyword}{const}\& matcher, \mbox{\hyperlink{classCatch_1_1StringRef}{StringRef}} \textcolor{keyword}{const}\& matcherString  ) -\/> \mbox{\hyperlink{classCatch_1_1MatchExpr}{MatchExpr<ArgT, MatcherT>}} \{}
\DoxyCodeLine{3798         \textcolor{keywordflow}{return} \mbox{\hyperlink{classCatch_1_1MatchExpr}{MatchExpr<ArgT, MatcherT>}}( arg, matcher, matcherString );}
\DoxyCodeLine{3799     \}}
\DoxyCodeLine{3800 }
\DoxyCodeLine{3801 \} \textcolor{comment}{// namespace Catch}}
\DoxyCodeLine{3802 }
\DoxyCodeLine{3804 \textcolor{preprocessor}{\#define INTERNAL\_CHECK\_THAT( macroName, matcher, resultDisposition, arg ) \(\backslash\)}}
\DoxyCodeLine{3805 \textcolor{preprocessor}{    do \{ \(\backslash\)}}
\DoxyCodeLine{3806 \textcolor{preprocessor}{        Catch::AssertionHandler catchAssertionHandler( macroName\#\#\_catch\_sr, CATCH\_INTERNAL\_LINEINFO, CATCH\_INTERNAL\_STRINGIFY(arg) "{}, "{}} CATCH\_INTERNAL\_STRINGIFY(matcher), resultDisposition ); \(\backslash\)}
\DoxyCodeLine{3807         INTERNAL\_CATCH\_TRY \{ \(\backslash\)}
\DoxyCodeLine{3808             catchAssertionHandler.handleExpr( Catch::makeMatchExpr( arg, matcher, \#matcher\#\#\_catch\_sr ) ); \(\backslash\)}
\DoxyCodeLine{3809         \} INTERNAL\_CATCH\_CATCH( catchAssertionHandler ) \(\backslash\)}
\DoxyCodeLine{3810         INTERNAL\_CATCH\_REACT( catchAssertionHandler ) \(\backslash\)}
\DoxyCodeLine{3811     \} while( false )}
\DoxyCodeLine{3812 }
\DoxyCodeLine{3814 \textcolor{preprocessor}{\#define INTERNAL\_CATCH\_THROWS\_MATCHES( macroName, exceptionType, resultDisposition, matcher, ... ) \(\backslash\)}}
\DoxyCodeLine{3815 \textcolor{preprocessor}{    do \{ \(\backslash\)}}
\DoxyCodeLine{3816 \textcolor{preprocessor}{        Catch::AssertionHandler catchAssertionHandler( macroName\#\#\_catch\_sr, CATCH\_INTERNAL\_LINEINFO, CATCH\_INTERNAL\_STRINGIFY(\_\_VA\_ARGS\_\_) "{}, "{}} CATCH\_INTERNAL\_STRINGIFY(exceptionType) "{}, "{} CATCH\_INTERNAL\_STRINGIFY(matcher), resultDisposition ); \(\backslash\)}
\DoxyCodeLine{3817         if( catchAssertionHandler.allowThrows() ) \(\backslash\)}
\DoxyCodeLine{3818             try \{ \(\backslash\)}
\DoxyCodeLine{3819                 static\_cast<void>(\_\_VA\_ARGS\_\_ ); \(\backslash\)}
\DoxyCodeLine{3820                 catchAssertionHandler.handleUnexpectedExceptionNotThrown(); \(\backslash\)}
\DoxyCodeLine{3821             \} \(\backslash\)}
\DoxyCodeLine{3822             catch( exceptionType const\& ex ) \{ \(\backslash\)}
\DoxyCodeLine{3823                 catchAssertionHandler.handleExpr( Catch::makeMatchExpr( ex, matcher, \#matcher\#\#\_catch\_sr ) ); \(\backslash\)}
\DoxyCodeLine{3824             \} \(\backslash\)}
\DoxyCodeLine{3825             catch( ... ) \{ \(\backslash\)}
\DoxyCodeLine{3826                 catchAssertionHandler.handleUnexpectedInflightException(); \(\backslash\)}
\DoxyCodeLine{3827             \} \(\backslash\)}
\DoxyCodeLine{3828         else \(\backslash\)}
\DoxyCodeLine{3829             catchAssertionHandler.handleThrowingCallSkipped(); \(\backslash\)}
\DoxyCodeLine{3830         INTERNAL\_CATCH\_REACT( catchAssertionHandler ) \(\backslash\)}
\DoxyCodeLine{3831     \} while( false )}
\DoxyCodeLine{3832 }
\DoxyCodeLine{3833 \textcolor{comment}{// end catch\_capture\_matchers.h}}
\DoxyCodeLine{3834 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{3835 \textcolor{comment}{// start catch\_generators.hpp}}
\DoxyCodeLine{3836 }
\DoxyCodeLine{3837 \textcolor{comment}{// start catch\_interfaces\_generatortracker.h}}
\DoxyCodeLine{3838 }
\DoxyCodeLine{3839 }
\DoxyCodeLine{3840 \textcolor{preprocessor}{\#include <memory>}}
\DoxyCodeLine{3841 }
\DoxyCodeLine{3842 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{3843 }
\DoxyCodeLine{3844     \textcolor{keyword}{namespace }Generators \{}
\DoxyCodeLine{3845         \textcolor{keyword}{class }\mbox{\hyperlink{classCatch_1_1Generators_1_1GeneratorUntypedBase}{GeneratorUntypedBase}} \{}
\DoxyCodeLine{3846         \textcolor{keyword}{public}:}
\DoxyCodeLine{3847             \mbox{\hyperlink{classCatch_1_1Generators_1_1GeneratorUntypedBase}{GeneratorUntypedBase}}() = \textcolor{keywordflow}{default};}
\DoxyCodeLine{3848             \textcolor{keyword}{virtual} \mbox{\hyperlink{classCatch_1_1Generators_1_1GeneratorUntypedBase}{\string~GeneratorUntypedBase}}();}
\DoxyCodeLine{3849             \textcolor{comment}{// Attempts to move the generator to the next element}}
\DoxyCodeLine{3850              \textcolor{comment}{//}}
\DoxyCodeLine{3851              \textcolor{comment}{// Returns true iff the move succeeded (and a valid element}}
\DoxyCodeLine{3852              \textcolor{comment}{// can be retrieved).}}
\DoxyCodeLine{3853             \textcolor{keyword}{virtual} \textcolor{keywordtype}{bool} next() = 0;}
\DoxyCodeLine{3854         \};}
\DoxyCodeLine{3855         \textcolor{keyword}{using }GeneratorBasePtr = std::unique\_ptr<GeneratorUntypedBase>;}
\DoxyCodeLine{3856 }
\DoxyCodeLine{3857     \} \textcolor{comment}{// namespace Generators}}
\DoxyCodeLine{3858 }
\DoxyCodeLine{3859     \textcolor{keyword}{struct }\mbox{\hyperlink{structCatch_1_1IGeneratorTracker}{IGeneratorTracker}} \{}
\DoxyCodeLine{3860         \textcolor{keyword}{virtual} \mbox{\hyperlink{structCatch_1_1IGeneratorTracker}{\string~IGeneratorTracker}}();}
\DoxyCodeLine{3861         \textcolor{keyword}{virtual} \textcolor{keyword}{auto} hasGenerator() \textcolor{keyword}{const} -\/> \textcolor{keywordtype}{bool} = 0;}
\DoxyCodeLine{3862         \textcolor{keyword}{virtual} \textcolor{keyword}{auto} getGenerator() \textcolor{keyword}{const} -\/> Generators::GeneratorBasePtr \textcolor{keyword}{const}\& = 0;}
\DoxyCodeLine{3863         \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} setGenerator( Generators::GeneratorBasePtr\&\& generator ) = 0;}
\DoxyCodeLine{3864     \};}
\DoxyCodeLine{3865 }
\DoxyCodeLine{3866 \} \textcolor{comment}{// namespace Catch}}
\DoxyCodeLine{3867 }
\DoxyCodeLine{3868 \textcolor{comment}{// end catch\_interfaces\_generatortracker.h}}
\DoxyCodeLine{3869 \textcolor{comment}{// start catch\_enforce.h}}
\DoxyCodeLine{3870 }
\DoxyCodeLine{3871 \textcolor{preprocessor}{\#include <exception>}}
\DoxyCodeLine{3872 }
\DoxyCodeLine{3873 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{3874 \textcolor{preprocessor}{\#if !defined(CATCH\_CONFIG\_DISABLE\_EXCEPTIONS)}}
\DoxyCodeLine{3875     \textcolor{keyword}{template} <\textcolor{keyword}{typename} Ex>}
\DoxyCodeLine{3876     [[noreturn]]}
\DoxyCodeLine{3877     \textcolor{keywordtype}{void} throw\_exception(Ex \textcolor{keyword}{const}\& e) \{}
\DoxyCodeLine{3878         \textcolor{keywordflow}{throw} e;}
\DoxyCodeLine{3879     \}}
\DoxyCodeLine{3880 \textcolor{preprocessor}{\#else }\textcolor{comment}{// \string^\string^ Exceptions are enabled //  Exceptions are disabled vv}}
\DoxyCodeLine{3881     [[noreturn]]}
\DoxyCodeLine{3882     \textcolor{keywordtype}{void} throw\_exception(std::exception \textcolor{keyword}{const}\& e);}
\DoxyCodeLine{3883 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{3884 }
\DoxyCodeLine{3885     [[noreturn]]}
\DoxyCodeLine{3886     \textcolor{keywordtype}{void} throw\_logic\_error(std::string \textcolor{keyword}{const}\& msg);}
\DoxyCodeLine{3887     [[noreturn]]}
\DoxyCodeLine{3888     \textcolor{keywordtype}{void} throw\_domain\_error(std::string \textcolor{keyword}{const}\& msg);}
\DoxyCodeLine{3889     [[noreturn]]}
\DoxyCodeLine{3890     \textcolor{keywordtype}{void} throw\_runtime\_error(std::string \textcolor{keyword}{const}\& msg);}
\DoxyCodeLine{3891 }
\DoxyCodeLine{3892 \} \textcolor{comment}{// namespace Catch;}}
\DoxyCodeLine{3893 }
\DoxyCodeLine{3894 \textcolor{preprocessor}{\#define CATCH\_MAKE\_MSG(...) \(\backslash\)}}
\DoxyCodeLine{3895 \textcolor{preprocessor}{    (Catch::ReusableStringStream() << \_\_VA\_ARGS\_\_).str()}}
\DoxyCodeLine{3896 }
\DoxyCodeLine{3897 \textcolor{preprocessor}{\#define CATCH\_INTERNAL\_ERROR(...) \(\backslash\)}}
\DoxyCodeLine{3898 \textcolor{preprocessor}{    Catch::throw\_logic\_error(CATCH\_MAKE\_MSG( CATCH\_INTERNAL\_LINEINFO << "{}: Internal Catch2 error: "{}} << \_\_VA\_ARGS\_\_))}
\DoxyCodeLine{3899 }
\DoxyCodeLine{3900 \textcolor{preprocessor}{\#define CATCH\_ERROR(...) \(\backslash\)}}
\DoxyCodeLine{3901 \textcolor{preprocessor}{    Catch::throw\_domain\_error(CATCH\_MAKE\_MSG( \_\_VA\_ARGS\_\_ ))}}
\DoxyCodeLine{3902 }
\DoxyCodeLine{3903 \textcolor{preprocessor}{\#define CATCH\_RUNTIME\_ERROR(...) \(\backslash\)}}
\DoxyCodeLine{3904 \textcolor{preprocessor}{    Catch::throw\_runtime\_error(CATCH\_MAKE\_MSG( \_\_VA\_ARGS\_\_ ))}}
\DoxyCodeLine{3905 }
\DoxyCodeLine{3906 \textcolor{preprocessor}{\#define CATCH\_ENFORCE( condition, ... ) \(\backslash\)}}
\DoxyCodeLine{3907 \textcolor{preprocessor}{    do\{ if( !(condition) ) CATCH\_ERROR( \_\_VA\_ARGS\_\_ ); \} while(false)}}
\DoxyCodeLine{3908 }
\DoxyCodeLine{3909 \textcolor{comment}{// end catch\_enforce.h}}
\DoxyCodeLine{3910 \textcolor{preprocessor}{\#include <memory>}}
\DoxyCodeLine{3911 \textcolor{preprocessor}{\#include <vector>}}
\DoxyCodeLine{3912 \textcolor{preprocessor}{\#include <cassert>}}
\DoxyCodeLine{3913 }
\DoxyCodeLine{3914 \textcolor{preprocessor}{\#include <utility>}}
\DoxyCodeLine{3915 \textcolor{preprocessor}{\#include <exception>}}
\DoxyCodeLine{3916 }
\DoxyCodeLine{3917 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{3918 }
\DoxyCodeLine{3919 \textcolor{keyword}{class }\mbox{\hyperlink{classCatch_1_1GeneratorException}{GeneratorException}} : \textcolor{keyword}{public} std::exception \{}
\DoxyCodeLine{3920     \textcolor{keyword}{const} \textcolor{keywordtype}{char}* \textcolor{keyword}{const} m\_msg = \textcolor{stringliteral}{"{}"{}};}
\DoxyCodeLine{3921 }
\DoxyCodeLine{3922 \textcolor{keyword}{public}:}
\DoxyCodeLine{3923     \mbox{\hyperlink{classCatch_1_1GeneratorException}{GeneratorException}}(\textcolor{keyword}{const} \textcolor{keywordtype}{char}* msg):}
\DoxyCodeLine{3924         m\_msg(msg)}
\DoxyCodeLine{3925     \{\}}
\DoxyCodeLine{3926 }
\DoxyCodeLine{3927     \textcolor{keyword}{const} \textcolor{keywordtype}{char}* what() \textcolor{keyword}{const} \textcolor{keyword}{noexcept} \textcolor{keyword}{override} \textcolor{keyword}{final};}
\DoxyCodeLine{3928 \};}
\DoxyCodeLine{3929 }
\DoxyCodeLine{3930 \textcolor{keyword}{namespace }Generators \{}
\DoxyCodeLine{3931 }
\DoxyCodeLine{3932     \textcolor{comment}{// !TBD move this into its own location?}}
\DoxyCodeLine{3933     \textcolor{keyword}{namespace }pf\{}
\DoxyCodeLine{3934         \textcolor{keyword}{template}<\textcolor{keyword}{typename} T, \textcolor{keyword}{typename}... Args>}
\DoxyCodeLine{3935         std::unique\_ptr<T> make\_unique( Args\&\&... args ) \{}
\DoxyCodeLine{3936             \textcolor{keywordflow}{return} std::unique\_ptr<T>(\textcolor{keyword}{new} T(std::forward<Args>(args)...));}
\DoxyCodeLine{3937         \}}
\DoxyCodeLine{3938     \}}
\DoxyCodeLine{3939 }
\DoxyCodeLine{3940     \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{3941     \textcolor{keyword}{struct }\mbox{\hyperlink{structCatch_1_1Generators_1_1IGenerator}{IGenerator}} : \mbox{\hyperlink{classCatch_1_1Generators_1_1GeneratorUntypedBase}{GeneratorUntypedBase}} \{}
\DoxyCodeLine{3942         \textcolor{keyword}{virtual} \mbox{\hyperlink{structCatch_1_1Generators_1_1IGenerator}{\string~IGenerator}}() = \textcolor{keywordflow}{default};}
\DoxyCodeLine{3943 }
\DoxyCodeLine{3944         \textcolor{comment}{// Returns the current element of the generator}}
\DoxyCodeLine{3945         \textcolor{comment}{//}}
\DoxyCodeLine{3946         \textcolor{comment}{// \(\backslash\)Precondition The generator is either freshly constructed,}}
\DoxyCodeLine{3947         \textcolor{comment}{// or the last call to `next()` returned true}}
\DoxyCodeLine{3948         \textcolor{keyword}{virtual} T \textcolor{keyword}{const}\& get() \textcolor{keyword}{const} = 0;}
\DoxyCodeLine{3949         \textcolor{keyword}{using }type = T;}
\DoxyCodeLine{3950     \};}
\DoxyCodeLine{3951 }
\DoxyCodeLine{3952     \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{3953     \textcolor{keyword}{class }\mbox{\hyperlink{classCatch_1_1Generators_1_1SingleValueGenerator}{SingleValueGenerator}} final : \textcolor{keyword}{public} \mbox{\hyperlink{structCatch_1_1Generators_1_1IGenerator}{IGenerator}}<T> \{}
\DoxyCodeLine{3954         T m\_value;}
\DoxyCodeLine{3955     \textcolor{keyword}{public}:}
\DoxyCodeLine{3956         \mbox{\hyperlink{classCatch_1_1Generators_1_1SingleValueGenerator}{SingleValueGenerator}}(T\&\& value) : m\_value(std::move(value)) \{\}}
\DoxyCodeLine{3957 }
\DoxyCodeLine{3958         T \textcolor{keyword}{const}\& get()\textcolor{keyword}{ const override }\{}
\DoxyCodeLine{3959             \textcolor{keywordflow}{return} m\_value;}
\DoxyCodeLine{3960         \}}
\DoxyCodeLine{3961         \textcolor{keywordtype}{bool} next()\textcolor{keyword}{ override }\{}
\DoxyCodeLine{3962             \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{3963         \}}
\DoxyCodeLine{3964     \};}
\DoxyCodeLine{3965 }
\DoxyCodeLine{3966     \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{3967     \textcolor{keyword}{class }\mbox{\hyperlink{classCatch_1_1Generators_1_1FixedValuesGenerator}{FixedValuesGenerator}} final : \textcolor{keyword}{public} \mbox{\hyperlink{structCatch_1_1Generators_1_1IGenerator}{IGenerator}}<T> \{}
\DoxyCodeLine{3968         \textcolor{keyword}{static\_assert}(!std::is\_same<T, bool>::value,}
\DoxyCodeLine{3969             \textcolor{stringliteral}{"{}FixedValuesGenerator does not support bools because of std::vector<bool>"{}}}
\DoxyCodeLine{3970             \textcolor{stringliteral}{"{}specialization, use SingleValue Generator instead."{}});}
\DoxyCodeLine{3971         std::vector<T> m\_values;}
\DoxyCodeLine{3972         \textcolor{keywordtype}{size\_t} m\_idx = 0;}
\DoxyCodeLine{3973     \textcolor{keyword}{public}:}
\DoxyCodeLine{3974         \mbox{\hyperlink{classCatch_1_1Generators_1_1FixedValuesGenerator}{FixedValuesGenerator}}( std::initializer\_list<T> values ) : m\_values( values ) \{\}}
\DoxyCodeLine{3975 }
\DoxyCodeLine{3976         T \textcolor{keyword}{const}\& get()\textcolor{keyword}{ const override }\{}
\DoxyCodeLine{3977             \textcolor{keywordflow}{return} m\_values[m\_idx];}
\DoxyCodeLine{3978         \}}
\DoxyCodeLine{3979         \textcolor{keywordtype}{bool} next()\textcolor{keyword}{ override }\{}
\DoxyCodeLine{3980             ++m\_idx;}
\DoxyCodeLine{3981             \textcolor{keywordflow}{return} m\_idx < m\_values.size();}
\DoxyCodeLine{3982         \}}
\DoxyCodeLine{3983     \};}
\DoxyCodeLine{3984 }
\DoxyCodeLine{3985     \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{3986     \textcolor{keyword}{class }\mbox{\hyperlink{classCatch_1_1Generators_1_1GeneratorWrapper}{GeneratorWrapper}} final \{}
\DoxyCodeLine{3987         std::unique\_ptr<IGenerator<T>> m\_generator;}
\DoxyCodeLine{3988     \textcolor{keyword}{public}:}
\DoxyCodeLine{3989         \mbox{\hyperlink{classCatch_1_1Generators_1_1GeneratorWrapper}{GeneratorWrapper}}(std::unique\_ptr<\mbox{\hyperlink{structCatch_1_1Generators_1_1IGenerator}{IGenerator<T>}}> generator):}
\DoxyCodeLine{3990             m\_generator(std::move(generator))}
\DoxyCodeLine{3991         \{\}}
\DoxyCodeLine{3992         T \textcolor{keyword}{const}\& get()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{3993             \textcolor{keywordflow}{return} m\_generator-\/>get();}
\DoxyCodeLine{3994         \}}
\DoxyCodeLine{3995         \textcolor{keywordtype}{bool} next() \{}
\DoxyCodeLine{3996             \textcolor{keywordflow}{return} m\_generator-\/>next();}
\DoxyCodeLine{3997         \}}
\DoxyCodeLine{3998     \};}
\DoxyCodeLine{3999 }
\DoxyCodeLine{4000     \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{4001     \mbox{\hyperlink{classCatch_1_1Generators_1_1GeneratorWrapper}{GeneratorWrapper<T>}} value(T\&\& value) \{}
\DoxyCodeLine{4002         \textcolor{keywordflow}{return} \mbox{\hyperlink{classCatch_1_1Generators_1_1GeneratorWrapper}{GeneratorWrapper<T>}}(pf::make\_unique<\mbox{\hyperlink{classCatch_1_1Generators_1_1SingleValueGenerator}{SingleValueGenerator<T>}}>(std::forward<T>(value)));}
\DoxyCodeLine{4003     \}}
\DoxyCodeLine{4004     \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{4005     GeneratorWrapper<T> values(std::initializer\_list<T> values) \{}
\DoxyCodeLine{4006         \textcolor{keywordflow}{return} GeneratorWrapper<T>(pf::make\_unique<FixedValuesGenerator<T>>(values));}
\DoxyCodeLine{4007     \}}
\DoxyCodeLine{4008 }
\DoxyCodeLine{4009     \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{4010     \textcolor{keyword}{class }\mbox{\hyperlink{classCatch_1_1Generators_1_1Generators}{Generators}} : \textcolor{keyword}{public} \mbox{\hyperlink{structCatch_1_1Generators_1_1IGenerator}{IGenerator}}<T> \{}
\DoxyCodeLine{4011         std::vector<GeneratorWrapper<T>> m\_generators;}
\DoxyCodeLine{4012         \textcolor{keywordtype}{size\_t} m\_current = 0;}
\DoxyCodeLine{4013 }
\DoxyCodeLine{4014         \textcolor{keywordtype}{void} populate(\mbox{\hyperlink{classCatch_1_1Generators_1_1GeneratorWrapper}{GeneratorWrapper<T>}}\&\& generator) \{}
\DoxyCodeLine{4015             m\_generators.emplace\_back(std::move(generator));}
\DoxyCodeLine{4016         \}}
\DoxyCodeLine{4017         \textcolor{keywordtype}{void} populate(T\&\& val) \{}
\DoxyCodeLine{4018             m\_generators.emplace\_back(value(std::forward<T>(val)));}
\DoxyCodeLine{4019         \}}
\DoxyCodeLine{4020         \textcolor{keyword}{template}<\textcolor{keyword}{typename} U>}
\DoxyCodeLine{4021         \textcolor{keywordtype}{void} populate(U\&\& val) \{}
\DoxyCodeLine{4022             populate(T(std::forward<U>(val)));}
\DoxyCodeLine{4023         \}}
\DoxyCodeLine{4024         \textcolor{keyword}{template}<\textcolor{keyword}{typename} U, \textcolor{keyword}{typename}... Gs>}
\DoxyCodeLine{4025         \textcolor{keywordtype}{void} populate(U\&\& valueOrGenerator, Gs \&\&... moreGenerators) \{}
\DoxyCodeLine{4026             populate(std::forward<U>(valueOrGenerator));}
\DoxyCodeLine{4027             populate(std::forward<Gs>(moreGenerators)...);}
\DoxyCodeLine{4028         \}}
\DoxyCodeLine{4029 }
\DoxyCodeLine{4030     \textcolor{keyword}{public}:}
\DoxyCodeLine{4031         \textcolor{keyword}{template} <\textcolor{keyword}{typename}... Gs>}
\DoxyCodeLine{4032         \mbox{\hyperlink{classCatch_1_1Generators_1_1Generators}{Generators}}(Gs \&\&... moreGenerators) \{}
\DoxyCodeLine{4033             m\_generators.reserve(\textcolor{keyword}{sizeof}...(Gs));}
\DoxyCodeLine{4034             populate(std::forward<Gs>(moreGenerators)...);}
\DoxyCodeLine{4035         \}}
\DoxyCodeLine{4036 }
\DoxyCodeLine{4037         T \textcolor{keyword}{const}\& get()\textcolor{keyword}{ const override }\{}
\DoxyCodeLine{4038             \textcolor{keywordflow}{return} m\_generators[m\_current].get();}
\DoxyCodeLine{4039         \}}
\DoxyCodeLine{4040 }
\DoxyCodeLine{4041         \textcolor{keywordtype}{bool} next()\textcolor{keyword}{ override }\{}
\DoxyCodeLine{4042             \textcolor{keywordflow}{if} (m\_current >= m\_generators.size()) \{}
\DoxyCodeLine{4043                 \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{4044             \}}
\DoxyCodeLine{4045             \textcolor{keyword}{const} \textcolor{keywordtype}{bool} current\_status = m\_generators[m\_current].next();}
\DoxyCodeLine{4046             \textcolor{keywordflow}{if} (!current\_status) \{}
\DoxyCodeLine{4047                 ++m\_current;}
\DoxyCodeLine{4048             \}}
\DoxyCodeLine{4049             \textcolor{keywordflow}{return} m\_current < m\_generators.size();}
\DoxyCodeLine{4050         \}}
\DoxyCodeLine{4051     \};}
\DoxyCodeLine{4052 }
\DoxyCodeLine{4053     \textcolor{keyword}{template}<\textcolor{keyword}{typename}... Ts>}
\DoxyCodeLine{4054     \mbox{\hyperlink{classCatch_1_1Generators_1_1GeneratorWrapper}{GeneratorWrapper}}<std::tuple<Ts...>> table( std::initializer\_list<std::tuple<\textcolor{keyword}{typename} std::decay<Ts>::type...>> tuples ) \{}
\DoxyCodeLine{4055         \textcolor{keywordflow}{return} values<std::tuple<Ts...>>( tuples );}
\DoxyCodeLine{4056     \}}
\DoxyCodeLine{4057 }
\DoxyCodeLine{4058     \textcolor{comment}{// Tag type to signal that a generator sequence should convert arguments to a specific type}}
\DoxyCodeLine{4059     \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{4060     \textcolor{keyword}{struct }\mbox{\hyperlink{structCatch_1_1Generators_1_1as}{as}} \{\};}
\DoxyCodeLine{4061 }
\DoxyCodeLine{4062     \textcolor{keyword}{template}<\textcolor{keyword}{typename} T, \textcolor{keyword}{typename}... Gs>}
\DoxyCodeLine{4063     \textcolor{keyword}{auto} makeGenerators( \mbox{\hyperlink{classCatch_1_1Generators_1_1GeneratorWrapper}{GeneratorWrapper<T>}}\&\& generator, Gs \&\&... moreGenerators ) -\/> \mbox{\hyperlink{classCatch_1_1Generators_1_1Generators}{Generators<T>}} \{}
\DoxyCodeLine{4064         \textcolor{keywordflow}{return} \mbox{\hyperlink{classCatch_1_1Generators_1_1Generators}{Generators<T>}}(std::move(generator), std::forward<Gs>(moreGenerators)...);}
\DoxyCodeLine{4065     \}}
\DoxyCodeLine{4066     \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{4067     \textcolor{keyword}{auto} makeGenerators( GeneratorWrapper<T>\&\& generator ) -\/> Generators<T> \{}
\DoxyCodeLine{4068         \textcolor{keywordflow}{return} Generators<T>(std::move(generator));}
\DoxyCodeLine{4069     \}}
\DoxyCodeLine{4070     \textcolor{keyword}{template}<\textcolor{keyword}{typename} T, \textcolor{keyword}{typename}... Gs>}
\DoxyCodeLine{4071     \textcolor{keyword}{auto} makeGenerators( T\&\& val, Gs \&\&... moreGenerators ) -\/> Generators<T> \{}
\DoxyCodeLine{4072         \textcolor{keywordflow}{return} makeGenerators( value( std::forward<T>( val ) ), std::forward<Gs>( moreGenerators )... );}
\DoxyCodeLine{4073     \}}
\DoxyCodeLine{4074     \textcolor{keyword}{template}<\textcolor{keyword}{typename} T, \textcolor{keyword}{typename} U, \textcolor{keyword}{typename}... Gs>}
\DoxyCodeLine{4075     \textcolor{keyword}{auto} makeGenerators( as<T>, U\&\& val, Gs \&\&... moreGenerators ) -\/> Generators<T> \{}
\DoxyCodeLine{4076         \textcolor{keywordflow}{return} makeGenerators( value( T( std::forward<U>( val ) ) ), std::forward<Gs>( moreGenerators )... );}
\DoxyCodeLine{4077     \}}
\DoxyCodeLine{4078 }
\DoxyCodeLine{4079     \textcolor{keyword}{auto} acquireGeneratorTracker( StringRef generatorName, SourceLineInfo \textcolor{keyword}{const}\& lineInfo ) -\/> IGeneratorTracker\&;}
\DoxyCodeLine{4080 }
\DoxyCodeLine{4081     \textcolor{keyword}{template}<\textcolor{keyword}{typename} L>}
\DoxyCodeLine{4082     \textcolor{comment}{// Note: The type after -\/> is weird, because VS2015 cannot parse}}
\DoxyCodeLine{4083     \textcolor{comment}{//       the expression used in the typedef inside, when it is in}}
\DoxyCodeLine{4084     \textcolor{comment}{//       return type. Yeah.}}
\DoxyCodeLine{4085     \textcolor{keyword}{auto} generate( StringRef generatorName, SourceLineInfo \textcolor{keyword}{const}\& lineInfo, L \textcolor{keyword}{const}\& generatorExpression ) -\/> \textcolor{keyword}{decltype}(std::declval<decltype(generatorExpression())>().get()) \{}
\DoxyCodeLine{4086         \textcolor{keyword}{using }UnderlyingType = \textcolor{keyword}{typename} \textcolor{keyword}{decltype}(generatorExpression())::type;}
\DoxyCodeLine{4087 }
\DoxyCodeLine{4088         IGeneratorTracker\& tracker = acquireGeneratorTracker( generatorName, lineInfo );}
\DoxyCodeLine{4089         \textcolor{keywordflow}{if} (!tracker.hasGenerator()) \{}
\DoxyCodeLine{4090             tracker.setGenerator(pf::make\_unique<Generators<UnderlyingType>>(generatorExpression()));}
\DoxyCodeLine{4091         \}}
\DoxyCodeLine{4092 }
\DoxyCodeLine{4093         \textcolor{keyword}{auto} \textcolor{keyword}{const}\& generator = \textcolor{keyword}{static\_cast<}IGenerator<UnderlyingType> const\&\textcolor{keyword}{>}( *tracker.getGenerator() );}
\DoxyCodeLine{4094         \textcolor{keywordflow}{return} generator.get();}
\DoxyCodeLine{4095     \}}
\DoxyCodeLine{4096 }
\DoxyCodeLine{4097 \} \textcolor{comment}{// namespace Generators}}
\DoxyCodeLine{4098 \} \textcolor{comment}{// namespace Catch}}
\DoxyCodeLine{4099 }
\DoxyCodeLine{4100 \textcolor{preprocessor}{\#define GENERATE( ... ) \(\backslash\)}}
\DoxyCodeLine{4101 \textcolor{preprocessor}{    Catch::Generators::generate( INTERNAL\_CATCH\_STRINGIZE(INTERNAL\_CATCH\_UNIQUE\_NAME(generator)), \(\backslash\)}}
\DoxyCodeLine{4102 \textcolor{preprocessor}{                                 CATCH\_INTERNAL\_LINEINFO, \(\backslash\)}}
\DoxyCodeLine{4103 \textcolor{preprocessor}{                                 [ ]\{ using namespace Catch::Generators; return makeGenerators( \_\_VA\_ARGS\_\_ ); \} ) }\textcolor{comment}{//NOLINT(google-\/build-\/using-\/namespace)}}
\DoxyCodeLine{4104 \textcolor{preprocessor}{\#define GENERATE\_COPY( ... ) \(\backslash\)}}
\DoxyCodeLine{4105 \textcolor{preprocessor}{    Catch::Generators::generate( INTERNAL\_CATCH\_STRINGIZE(INTERNAL\_CATCH\_UNIQUE\_NAME(generator)), \(\backslash\)}}
\DoxyCodeLine{4106 \textcolor{preprocessor}{                                 CATCH\_INTERNAL\_LINEINFO, \(\backslash\)}}
\DoxyCodeLine{4107 \textcolor{preprocessor}{                                 [=]\{ using namespace Catch::Generators; return makeGenerators( \_\_VA\_ARGS\_\_ ); \} ) }\textcolor{comment}{//NOLINT(google-\/build-\/using-\/namespace)}}
\DoxyCodeLine{4108 \textcolor{preprocessor}{\#define GENERATE\_REF( ... ) \(\backslash\)}}
\DoxyCodeLine{4109 \textcolor{preprocessor}{    Catch::Generators::generate( INTERNAL\_CATCH\_STRINGIZE(INTERNAL\_CATCH\_UNIQUE\_NAME(generator)), \(\backslash\)}}
\DoxyCodeLine{4110 \textcolor{preprocessor}{                                 CATCH\_INTERNAL\_LINEINFO, \(\backslash\)}}
\DoxyCodeLine{4111 \textcolor{preprocessor}{                                 [\&]\{ using namespace Catch::Generators; return makeGenerators( \_\_VA\_ARGS\_\_ ); \} ) }\textcolor{comment}{//NOLINT(google-\/build-\/using-\/namespace)}}
\DoxyCodeLine{4112 }
\DoxyCodeLine{4113 \textcolor{comment}{// end catch\_generators.hpp}}
\DoxyCodeLine{4114 \textcolor{comment}{// start catch\_generators\_generic.hpp}}
\DoxyCodeLine{4115 }
\DoxyCodeLine{4116 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{4117 \textcolor{keyword}{namespace }Generators \{}
\DoxyCodeLine{4118 }
\DoxyCodeLine{4119     \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{4120     \textcolor{keyword}{class }\mbox{\hyperlink{classCatch_1_1Generators_1_1TakeGenerator}{TakeGenerator}} : \textcolor{keyword}{public} \mbox{\hyperlink{structCatch_1_1Generators_1_1IGenerator}{IGenerator}}<T> \{}
\DoxyCodeLine{4121         \mbox{\hyperlink{classCatch_1_1Generators_1_1GeneratorWrapper}{GeneratorWrapper<T>}} m\_generator;}
\DoxyCodeLine{4122         \textcolor{keywordtype}{size\_t} m\_returned = 0;}
\DoxyCodeLine{4123         \textcolor{keywordtype}{size\_t} m\_target;}
\DoxyCodeLine{4124     \textcolor{keyword}{public}:}
\DoxyCodeLine{4125         \mbox{\hyperlink{classCatch_1_1Generators_1_1TakeGenerator}{TakeGenerator}}(\textcolor{keywordtype}{size\_t} target, \mbox{\hyperlink{classCatch_1_1Generators_1_1GeneratorWrapper}{GeneratorWrapper<T>}}\&\& generator):}
\DoxyCodeLine{4126             m\_generator(std::move(generator)),}
\DoxyCodeLine{4127             m\_target(target)}
\DoxyCodeLine{4128         \{}
\DoxyCodeLine{4129             assert(target != 0 \&\& \textcolor{stringliteral}{"{}Empty generators are not allowed"{}});}
\DoxyCodeLine{4130         \}}
\DoxyCodeLine{4131         T \textcolor{keyword}{const}\& get()\textcolor{keyword}{ const override }\{}
\DoxyCodeLine{4132             \textcolor{keywordflow}{return} m\_generator.get();}
\DoxyCodeLine{4133         \}}
\DoxyCodeLine{4134         \textcolor{keywordtype}{bool} next()\textcolor{keyword}{ override }\{}
\DoxyCodeLine{4135             ++m\_returned;}
\DoxyCodeLine{4136             \textcolor{keywordflow}{if} (m\_returned >= m\_target) \{}
\DoxyCodeLine{4137                 \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{4138             \}}
\DoxyCodeLine{4139 }
\DoxyCodeLine{4140             \textcolor{keyword}{const} \textcolor{keyword}{auto} success = m\_generator.next();}
\DoxyCodeLine{4141             \textcolor{comment}{// If the underlying generator does not contain enough values}}
\DoxyCodeLine{4142             \textcolor{comment}{// then we cut short as well}}
\DoxyCodeLine{4143             \textcolor{keywordflow}{if} (!success) \{}
\DoxyCodeLine{4144                 m\_returned = m\_target;}
\DoxyCodeLine{4145             \}}
\DoxyCodeLine{4146             \textcolor{keywordflow}{return} success;}
\DoxyCodeLine{4147         \}}
\DoxyCodeLine{4148     \};}
\DoxyCodeLine{4149 }
\DoxyCodeLine{4150     \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{4151     \mbox{\hyperlink{classCatch_1_1Generators_1_1GeneratorWrapper}{GeneratorWrapper<T>}} take(\textcolor{keywordtype}{size\_t} target, \mbox{\hyperlink{classCatch_1_1Generators_1_1GeneratorWrapper}{GeneratorWrapper<T>}}\&\& generator) \{}
\DoxyCodeLine{4152         \textcolor{keywordflow}{return} \mbox{\hyperlink{classCatch_1_1Generators_1_1GeneratorWrapper}{GeneratorWrapper<T>}}(pf::make\_unique<\mbox{\hyperlink{classCatch_1_1Generators_1_1TakeGenerator}{TakeGenerator<T>}}>(target, std::move(generator)));}
\DoxyCodeLine{4153     \}}
\DoxyCodeLine{4154 }
\DoxyCodeLine{4155     \textcolor{keyword}{template} <\textcolor{keyword}{typename} T, \textcolor{keyword}{typename} Predicate>}
\DoxyCodeLine{4156     \textcolor{keyword}{class }\mbox{\hyperlink{classCatch_1_1Generators_1_1FilterGenerator}{FilterGenerator}} : \textcolor{keyword}{public} \mbox{\hyperlink{structCatch_1_1Generators_1_1IGenerator}{IGenerator}}<T> \{}
\DoxyCodeLine{4157         \mbox{\hyperlink{classCatch_1_1Generators_1_1GeneratorWrapper}{GeneratorWrapper<T>}} m\_generator;}
\DoxyCodeLine{4158         Predicate m\_predicate;}
\DoxyCodeLine{4159     \textcolor{keyword}{public}:}
\DoxyCodeLine{4160         \textcolor{keyword}{template} <\textcolor{keyword}{typename} P = Predicate>}
\DoxyCodeLine{4161         \mbox{\hyperlink{classCatch_1_1Generators_1_1FilterGenerator}{FilterGenerator}}(P\&\& pred, \mbox{\hyperlink{classCatch_1_1Generators_1_1GeneratorWrapper}{GeneratorWrapper<T>}}\&\& generator):}
\DoxyCodeLine{4162             m\_generator(std::move(generator)),}
\DoxyCodeLine{4163             m\_predicate(std::forward<P>(pred))}
\DoxyCodeLine{4164         \{}
\DoxyCodeLine{4165             \textcolor{keywordflow}{if} (!m\_predicate(m\_generator.get())) \{}
\DoxyCodeLine{4166                 \textcolor{comment}{// It might happen that there are no values that pass the}}
\DoxyCodeLine{4167                 \textcolor{comment}{// filter. In that case we throw an exception.}}
\DoxyCodeLine{4168                 \textcolor{keyword}{auto} has\_initial\_value = nextImpl();}
\DoxyCodeLine{4169                 \textcolor{keywordflow}{if} (!has\_initial\_value) \{}
\DoxyCodeLine{4170                     Catch::throw\_exception(\mbox{\hyperlink{classCatch_1_1GeneratorException}{GeneratorException}}(\textcolor{stringliteral}{"{}No valid value found in filtered generator"{}}));}
\DoxyCodeLine{4171                 \}}
\DoxyCodeLine{4172             \}}
\DoxyCodeLine{4173         \}}
\DoxyCodeLine{4174 }
\DoxyCodeLine{4175         T \textcolor{keyword}{const}\& get()\textcolor{keyword}{ const override }\{}
\DoxyCodeLine{4176             \textcolor{keywordflow}{return} m\_generator.get();}
\DoxyCodeLine{4177         \}}
\DoxyCodeLine{4178 }
\DoxyCodeLine{4179         \textcolor{keywordtype}{bool} next()\textcolor{keyword}{ override }\{}
\DoxyCodeLine{4180             \textcolor{keywordflow}{return} nextImpl();}
\DoxyCodeLine{4181         \}}
\DoxyCodeLine{4182 }
\DoxyCodeLine{4183     \textcolor{keyword}{private}:}
\DoxyCodeLine{4184         \textcolor{keywordtype}{bool} nextImpl() \{}
\DoxyCodeLine{4185             \textcolor{keywordtype}{bool} success = m\_generator.next();}
\DoxyCodeLine{4186             \textcolor{keywordflow}{if} (!success) \{}
\DoxyCodeLine{4187                 \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{4188             \}}
\DoxyCodeLine{4189             \textcolor{keywordflow}{while} (!m\_predicate(m\_generator.get()) \&\& (success = m\_generator.next()) == \textcolor{keyword}{true});}
\DoxyCodeLine{4190             \textcolor{keywordflow}{return} success;}
\DoxyCodeLine{4191         \}}
\DoxyCodeLine{4192     \};}
\DoxyCodeLine{4193 }
\DoxyCodeLine{4194     \textcolor{keyword}{template} <\textcolor{keyword}{typename} T, \textcolor{keyword}{typename} Predicate>}
\DoxyCodeLine{4195     \mbox{\hyperlink{classCatch_1_1Generators_1_1GeneratorWrapper}{GeneratorWrapper<T>}} filter(Predicate\&\& pred, \mbox{\hyperlink{classCatch_1_1Generators_1_1GeneratorWrapper}{GeneratorWrapper<T>}}\&\& generator) \{}
\DoxyCodeLine{4196         \textcolor{keywordflow}{return} \mbox{\hyperlink{classCatch_1_1Generators_1_1GeneratorWrapper}{GeneratorWrapper<T>}}(std::unique\_ptr<\mbox{\hyperlink{structCatch_1_1Generators_1_1IGenerator}{IGenerator<T>}}>(pf::make\_unique<\mbox{\hyperlink{classCatch_1_1Generators_1_1FilterGenerator}{FilterGenerator<T, Predicate>}}>(std::forward<Predicate>(pred), std::move(generator))));}
\DoxyCodeLine{4197     \}}
\DoxyCodeLine{4198 }
\DoxyCodeLine{4199     \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{4200     \textcolor{keyword}{class }\mbox{\hyperlink{classCatch_1_1Generators_1_1RepeatGenerator}{RepeatGenerator}} : \textcolor{keyword}{public} \mbox{\hyperlink{structCatch_1_1Generators_1_1IGenerator}{IGenerator}}<T> \{}
\DoxyCodeLine{4201         \textcolor{keyword}{static\_assert}(!std::is\_same<T, bool>::value,}
\DoxyCodeLine{4202             \textcolor{stringliteral}{"{}RepeatGenerator currently does not support bools"{}}}
\DoxyCodeLine{4203             \textcolor{stringliteral}{"{}because of std::vector<bool> specialization"{}});}
\DoxyCodeLine{4204         \mbox{\hyperlink{classCatch_1_1Generators_1_1GeneratorWrapper}{GeneratorWrapper<T>}} m\_generator;}
\DoxyCodeLine{4205         \textcolor{keyword}{mutable} std::vector<T> m\_returned;}
\DoxyCodeLine{4206         \textcolor{keywordtype}{size\_t} m\_target\_repeats;}
\DoxyCodeLine{4207         \textcolor{keywordtype}{size\_t} m\_current\_repeat = 0;}
\DoxyCodeLine{4208         \textcolor{keywordtype}{size\_t} m\_repeat\_index = 0;}
\DoxyCodeLine{4209     \textcolor{keyword}{public}:}
\DoxyCodeLine{4210         \mbox{\hyperlink{classCatch_1_1Generators_1_1RepeatGenerator}{RepeatGenerator}}(\textcolor{keywordtype}{size\_t} repeats, \mbox{\hyperlink{classCatch_1_1Generators_1_1GeneratorWrapper}{GeneratorWrapper<T>}}\&\& generator):}
\DoxyCodeLine{4211             m\_generator(std::move(generator)),}
\DoxyCodeLine{4212             m\_target\_repeats(repeats)}
\DoxyCodeLine{4213         \{}
\DoxyCodeLine{4214             assert(m\_target\_repeats > 0 \&\& \textcolor{stringliteral}{"{}Repeat generator must repeat at least once"{}});}
\DoxyCodeLine{4215         \}}
\DoxyCodeLine{4216 }
\DoxyCodeLine{4217         T \textcolor{keyword}{const}\& get()\textcolor{keyword}{ const override }\{}
\DoxyCodeLine{4218             \textcolor{keywordflow}{if} (m\_current\_repeat == 0) \{}
\DoxyCodeLine{4219                 m\_returned.push\_back(m\_generator.get());}
\DoxyCodeLine{4220                 \textcolor{keywordflow}{return} m\_returned.back();}
\DoxyCodeLine{4221             \}}
\DoxyCodeLine{4222             \textcolor{keywordflow}{return} m\_returned[m\_repeat\_index];}
\DoxyCodeLine{4223         \}}
\DoxyCodeLine{4224 }
\DoxyCodeLine{4225         \textcolor{keywordtype}{bool} next()\textcolor{keyword}{ override }\{}
\DoxyCodeLine{4226             \textcolor{comment}{// There are 2 basic cases:}}
\DoxyCodeLine{4227             \textcolor{comment}{// 1) We are still reading the generator}}
\DoxyCodeLine{4228             \textcolor{comment}{// 2) We are reading our own cache}}
\DoxyCodeLine{4229 }
\DoxyCodeLine{4230             \textcolor{comment}{// In the first case, we need to poke the underlying generator.}}
\DoxyCodeLine{4231             \textcolor{comment}{// If it happily moves, we are left in that state, otherwise it is time to start reading from our cache}}
\DoxyCodeLine{4232             \textcolor{keywordflow}{if} (m\_current\_repeat == 0) \{}
\DoxyCodeLine{4233                 \textcolor{keyword}{const} \textcolor{keyword}{auto} success = m\_generator.next();}
\DoxyCodeLine{4234                 \textcolor{keywordflow}{if} (!success) \{}
\DoxyCodeLine{4235                     ++m\_current\_repeat;}
\DoxyCodeLine{4236                 \}}
\DoxyCodeLine{4237                 \textcolor{keywordflow}{return} m\_current\_repeat < m\_target\_repeats;}
\DoxyCodeLine{4238             \}}
\DoxyCodeLine{4239 }
\DoxyCodeLine{4240             \textcolor{comment}{// In the second case, we need to move indices forward and check that we haven't run up against the end}}
\DoxyCodeLine{4241             ++m\_repeat\_index;}
\DoxyCodeLine{4242             \textcolor{keywordflow}{if} (m\_repeat\_index == m\_returned.size()) \{}
\DoxyCodeLine{4243                 m\_repeat\_index = 0;}
\DoxyCodeLine{4244                 ++m\_current\_repeat;}
\DoxyCodeLine{4245             \}}
\DoxyCodeLine{4246             \textcolor{keywordflow}{return} m\_current\_repeat < m\_target\_repeats;}
\DoxyCodeLine{4247         \}}
\DoxyCodeLine{4248     \};}
\DoxyCodeLine{4249 }
\DoxyCodeLine{4250     \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{4251     \mbox{\hyperlink{classCatch_1_1Generators_1_1GeneratorWrapper}{GeneratorWrapper<T>}} repeat(\textcolor{keywordtype}{size\_t} repeats, \mbox{\hyperlink{classCatch_1_1Generators_1_1GeneratorWrapper}{GeneratorWrapper<T>}}\&\& generator) \{}
\DoxyCodeLine{4252         \textcolor{keywordflow}{return} \mbox{\hyperlink{classCatch_1_1Generators_1_1GeneratorWrapper}{GeneratorWrapper<T>}}(pf::make\_unique<\mbox{\hyperlink{classCatch_1_1Generators_1_1RepeatGenerator}{RepeatGenerator<T>}}>(repeats, std::move(generator)));}
\DoxyCodeLine{4253     \}}
\DoxyCodeLine{4254 }
\DoxyCodeLine{4255     \textcolor{keyword}{template} <\textcolor{keyword}{typename} T, \textcolor{keyword}{typename} U, \textcolor{keyword}{typename} Func>}
\DoxyCodeLine{4256     \textcolor{keyword}{class }\mbox{\hyperlink{classCatch_1_1Generators_1_1MapGenerator}{MapGenerator}} : \textcolor{keyword}{public} \mbox{\hyperlink{structCatch_1_1Generators_1_1IGenerator}{IGenerator}}<T> \{}
\DoxyCodeLine{4257         \textcolor{comment}{// TBD: provide static assert for mapping function, for friendly error message}}
\DoxyCodeLine{4258         \mbox{\hyperlink{classCatch_1_1Generators_1_1GeneratorWrapper}{GeneratorWrapper<U>}} m\_generator;}
\DoxyCodeLine{4259         Func m\_function;}
\DoxyCodeLine{4260         \textcolor{comment}{// To avoid returning dangling reference, we have to save the values}}
\DoxyCodeLine{4261         T m\_cache;}
\DoxyCodeLine{4262     \textcolor{keyword}{public}:}
\DoxyCodeLine{4263         \textcolor{keyword}{template} <\textcolor{keyword}{typename} F2 = Func>}
\DoxyCodeLine{4264         \mbox{\hyperlink{classCatch_1_1Generators_1_1MapGenerator}{MapGenerator}}(F2\&\& function, \mbox{\hyperlink{classCatch_1_1Generators_1_1GeneratorWrapper}{GeneratorWrapper<U>}}\&\& generator) :}
\DoxyCodeLine{4265             m\_generator(std::move(generator)),}
\DoxyCodeLine{4266             m\_function(std::forward<F2>(function)),}
\DoxyCodeLine{4267             m\_cache(m\_function(m\_generator.get()))}
\DoxyCodeLine{4268         \{\}}
\DoxyCodeLine{4269 }
\DoxyCodeLine{4270         T \textcolor{keyword}{const}\& get()\textcolor{keyword}{ const override }\{}
\DoxyCodeLine{4271             \textcolor{keywordflow}{return} m\_cache;}
\DoxyCodeLine{4272         \}}
\DoxyCodeLine{4273         \textcolor{keywordtype}{bool} next()\textcolor{keyword}{ override }\{}
\DoxyCodeLine{4274             \textcolor{keyword}{const} \textcolor{keyword}{auto} success = m\_generator.next();}
\DoxyCodeLine{4275             \textcolor{keywordflow}{if} (success) \{}
\DoxyCodeLine{4276                 m\_cache = m\_function(m\_generator.get());}
\DoxyCodeLine{4277             \}}
\DoxyCodeLine{4278             \textcolor{keywordflow}{return} success;}
\DoxyCodeLine{4279         \}}
\DoxyCodeLine{4280     \};}
\DoxyCodeLine{4281 }
\DoxyCodeLine{4282     \textcolor{keyword}{template} <\textcolor{keyword}{typename} Func, \textcolor{keyword}{typename} U, \textcolor{keyword}{typename} T = FunctionReturnType<Func, U>>}
\DoxyCodeLine{4283     \mbox{\hyperlink{classCatch_1_1Generators_1_1GeneratorWrapper}{GeneratorWrapper<T>}} map(Func\&\& function, \mbox{\hyperlink{classCatch_1_1Generators_1_1GeneratorWrapper}{GeneratorWrapper<U>}}\&\& generator) \{}
\DoxyCodeLine{4284         \textcolor{keywordflow}{return} \mbox{\hyperlink{classCatch_1_1Generators_1_1GeneratorWrapper}{GeneratorWrapper<T>}}(}
\DoxyCodeLine{4285             pf::make\_unique<\mbox{\hyperlink{classCatch_1_1Generators_1_1MapGenerator}{MapGenerator<T, U, Func>}}>(std::forward<Func>(function), std::move(generator))}
\DoxyCodeLine{4286         );}
\DoxyCodeLine{4287     \}}
\DoxyCodeLine{4288 }
\DoxyCodeLine{4289     \textcolor{keyword}{template} <\textcolor{keyword}{typename} T, \textcolor{keyword}{typename} U, \textcolor{keyword}{typename} Func>}
\DoxyCodeLine{4290     GeneratorWrapper<T> map(Func\&\& function, GeneratorWrapper<U>\&\& generator) \{}
\DoxyCodeLine{4291         \textcolor{keywordflow}{return} GeneratorWrapper<T>(}
\DoxyCodeLine{4292             pf::make\_unique<MapGenerator<T, U, Func>>(std::forward<Func>(function), std::move(generator))}
\DoxyCodeLine{4293         );}
\DoxyCodeLine{4294     \}}
\DoxyCodeLine{4295 }
\DoxyCodeLine{4296     \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{4297     \textcolor{keyword}{class }\mbox{\hyperlink{classCatch_1_1Generators_1_1ChunkGenerator}{ChunkGenerator}} final : \textcolor{keyword}{public} \mbox{\hyperlink{structCatch_1_1Generators_1_1IGenerator}{IGenerator}}<std::vector<T>> \{}
\DoxyCodeLine{4298         std::vector<T> m\_chunk;}
\DoxyCodeLine{4299         \textcolor{keywordtype}{size\_t} m\_chunk\_size;}
\DoxyCodeLine{4300         \mbox{\hyperlink{classCatch_1_1Generators_1_1GeneratorWrapper}{GeneratorWrapper<T>}} m\_generator;}
\DoxyCodeLine{4301         \textcolor{keywordtype}{bool} m\_used\_up = \textcolor{keyword}{false};}
\DoxyCodeLine{4302     \textcolor{keyword}{public}:}
\DoxyCodeLine{4303         \mbox{\hyperlink{classCatch_1_1Generators_1_1ChunkGenerator}{ChunkGenerator}}(\textcolor{keywordtype}{size\_t} size, \mbox{\hyperlink{classCatch_1_1Generators_1_1GeneratorWrapper}{GeneratorWrapper<T>}} generator) :}
\DoxyCodeLine{4304             m\_chunk\_size(size), m\_generator(std::move(generator))}
\DoxyCodeLine{4305         \{}
\DoxyCodeLine{4306             m\_chunk.reserve(m\_chunk\_size);}
\DoxyCodeLine{4307             \textcolor{keywordflow}{if} (m\_chunk\_size != 0) \{}
\DoxyCodeLine{4308                 m\_chunk.push\_back(m\_generator.get());}
\DoxyCodeLine{4309                 \textcolor{keywordflow}{for} (\textcolor{keywordtype}{size\_t} i = 1; i < m\_chunk\_size; ++i) \{}
\DoxyCodeLine{4310                     \textcolor{keywordflow}{if} (!m\_generator.next()) \{}
\DoxyCodeLine{4311                         Catch::throw\_exception(\mbox{\hyperlink{classCatch_1_1GeneratorException}{GeneratorException}}(\textcolor{stringliteral}{"{}Not enough values to initialize the first chunk"{}}));}
\DoxyCodeLine{4312                     \}}
\DoxyCodeLine{4313                     m\_chunk.push\_back(m\_generator.get());}
\DoxyCodeLine{4314                 \}}
\DoxyCodeLine{4315             \}}
\DoxyCodeLine{4316         \}}
\DoxyCodeLine{4317         std::vector<T> \textcolor{keyword}{const}\& get()\textcolor{keyword}{ const override }\{}
\DoxyCodeLine{4318             \textcolor{keywordflow}{return} m\_chunk;}
\DoxyCodeLine{4319         \}}
\DoxyCodeLine{4320         \textcolor{keywordtype}{bool} next()\textcolor{keyword}{ override }\{}
\DoxyCodeLine{4321             m\_chunk.clear();}
\DoxyCodeLine{4322             \textcolor{keywordflow}{for} (\textcolor{keywordtype}{size\_t} idx = 0; idx < m\_chunk\_size; ++idx) \{}
\DoxyCodeLine{4323                 \textcolor{keywordflow}{if} (!m\_generator.next()) \{}
\DoxyCodeLine{4324                     \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{4325                 \}}
\DoxyCodeLine{4326                 m\_chunk.push\_back(m\_generator.get());}
\DoxyCodeLine{4327             \}}
\DoxyCodeLine{4328             \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{4329         \}}
\DoxyCodeLine{4330     \};}
\DoxyCodeLine{4331 }
\DoxyCodeLine{4332     \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{4333     \mbox{\hyperlink{classCatch_1_1Generators_1_1GeneratorWrapper}{GeneratorWrapper<std::vector<T>}}> chunk(\textcolor{keywordtype}{size\_t} size, \mbox{\hyperlink{classCatch_1_1Generators_1_1GeneratorWrapper}{GeneratorWrapper<T>}}\&\& generator) \{}
\DoxyCodeLine{4334         \textcolor{keywordflow}{return} \mbox{\hyperlink{classCatch_1_1Generators_1_1GeneratorWrapper}{GeneratorWrapper<std::vector<T>}}>(}
\DoxyCodeLine{4335             pf::make\_unique<ChunkGenerator<T>>(size, std::move(generator))}
\DoxyCodeLine{4336         );}
\DoxyCodeLine{4337     \}}
\DoxyCodeLine{4338 }
\DoxyCodeLine{4339 \} \textcolor{comment}{// namespace Generators}}
\DoxyCodeLine{4340 \} \textcolor{comment}{// namespace Catch}}
\DoxyCodeLine{4341 }
\DoxyCodeLine{4342 \textcolor{comment}{// end catch\_generators\_generic.hpp}}
\DoxyCodeLine{4343 \textcolor{comment}{// start catch\_generators\_specific.hpp}}
\DoxyCodeLine{4344 }
\DoxyCodeLine{4345 \textcolor{comment}{// start catch\_context.h}}
\DoxyCodeLine{4346 }
\DoxyCodeLine{4347 \textcolor{preprocessor}{\#include <memory>}}
\DoxyCodeLine{4348 }
\DoxyCodeLine{4349 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{4350 }
\DoxyCodeLine{4351     \textcolor{keyword}{struct }IResultCapture;}
\DoxyCodeLine{4352     \textcolor{keyword}{struct }IRunner;}
\DoxyCodeLine{4353     \textcolor{keyword}{struct }IConfig;}
\DoxyCodeLine{4354     \textcolor{keyword}{struct }IMutableContext;}
\DoxyCodeLine{4355 }
\DoxyCodeLine{4356     \textcolor{keyword}{using }IConfigPtr = std::shared\_ptr<IConfig const>;}
\DoxyCodeLine{4357 }
\DoxyCodeLine{4358     \textcolor{keyword}{struct }\mbox{\hyperlink{structCatch_1_1IContext}{IContext}}}
\DoxyCodeLine{4359     \{}
\DoxyCodeLine{4360         \textcolor{keyword}{virtual} \mbox{\hyperlink{structCatch_1_1IContext}{\string~IContext}}();}
\DoxyCodeLine{4361 }
\DoxyCodeLine{4362         \textcolor{keyword}{virtual} \mbox{\hyperlink{structCatch_1_1IResultCapture}{IResultCapture}}* getResultCapture() = 0;}
\DoxyCodeLine{4363         \textcolor{keyword}{virtual} \mbox{\hyperlink{structCatch_1_1IRunner}{IRunner}}* getRunner() = 0;}
\DoxyCodeLine{4364         \textcolor{keyword}{virtual} IConfigPtr \textcolor{keyword}{const}\& getConfig() \textcolor{keyword}{const} = 0;}
\DoxyCodeLine{4365     \};}
\DoxyCodeLine{4366 }
\DoxyCodeLine{4367     \textcolor{keyword}{struct }\mbox{\hyperlink{structCatch_1_1IMutableContext}{IMutableContext}} : \mbox{\hyperlink{structCatch_1_1IContext}{IContext}}}
\DoxyCodeLine{4368     \{}
\DoxyCodeLine{4369         \textcolor{keyword}{virtual} \mbox{\hyperlink{structCatch_1_1IMutableContext}{\string~IMutableContext}}();}
\DoxyCodeLine{4370         \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} setResultCapture( \mbox{\hyperlink{structCatch_1_1IResultCapture}{IResultCapture}}* resultCapture ) = 0;}
\DoxyCodeLine{4371         \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} setRunner( \mbox{\hyperlink{structCatch_1_1IRunner}{IRunner}}* runner ) = 0;}
\DoxyCodeLine{4372         \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} setConfig( IConfigPtr \textcolor{keyword}{const}\& config ) = 0;}
\DoxyCodeLine{4373 }
\DoxyCodeLine{4374     \textcolor{keyword}{private}:}
\DoxyCodeLine{4375         \textcolor{keyword}{static} \mbox{\hyperlink{structCatch_1_1IMutableContext}{IMutableContext}} *currentContext;}
\DoxyCodeLine{4376         \textcolor{keyword}{friend} \mbox{\hyperlink{structCatch_1_1IMutableContext}{IMutableContext}}\& getCurrentMutableContext();}
\DoxyCodeLine{4377         \textcolor{keyword}{friend} \textcolor{keywordtype}{void} cleanUpContext();}
\DoxyCodeLine{4378         \textcolor{keyword}{static} \textcolor{keywordtype}{void} createContext();}
\DoxyCodeLine{4379     \};}
\DoxyCodeLine{4380 }
\DoxyCodeLine{4381     \textcolor{keyword}{inline} \mbox{\hyperlink{structCatch_1_1IMutableContext}{IMutableContext}}\& getCurrentMutableContext()}
\DoxyCodeLine{4382     \{}
\DoxyCodeLine{4383         \textcolor{keywordflow}{if}( !IMutableContext::currentContext )}
\DoxyCodeLine{4384             IMutableContext::createContext();}
\DoxyCodeLine{4385         \textcolor{comment}{// NOLINTNEXTLINE(clang-\/analyzer-\/core.uninitialized.UndefReturn)}}
\DoxyCodeLine{4386         \textcolor{keywordflow}{return} *IMutableContext::currentContext;}
\DoxyCodeLine{4387     \}}
\DoxyCodeLine{4388 }
\DoxyCodeLine{4389     \textcolor{keyword}{inline} IContext\& getCurrentContext()}
\DoxyCodeLine{4390     \{}
\DoxyCodeLine{4391         \textcolor{keywordflow}{return} getCurrentMutableContext();}
\DoxyCodeLine{4392     \}}
\DoxyCodeLine{4393 }
\DoxyCodeLine{4394     \textcolor{keywordtype}{void} cleanUpContext();}
\DoxyCodeLine{4395 }
\DoxyCodeLine{4396     \textcolor{keyword}{class }SimplePcg32;}
\DoxyCodeLine{4397     SimplePcg32\& rng();}
\DoxyCodeLine{4398 \}}
\DoxyCodeLine{4399 }
\DoxyCodeLine{4400 \textcolor{comment}{// end catch\_context.h}}
\DoxyCodeLine{4401 \textcolor{comment}{// start catch\_interfaces\_config.h}}
\DoxyCodeLine{4402 }
\DoxyCodeLine{4403 \textcolor{comment}{// start catch\_option.hpp}}
\DoxyCodeLine{4404 }
\DoxyCodeLine{4405 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{4406 }
\DoxyCodeLine{4407     \textcolor{comment}{// An optional type}}
\DoxyCodeLine{4408     \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{4409     \textcolor{keyword}{class }\mbox{\hyperlink{classCatch_1_1Option}{Option}} \{}
\DoxyCodeLine{4410     \textcolor{keyword}{public}:}
\DoxyCodeLine{4411         \mbox{\hyperlink{classCatch_1_1Option}{Option}}() : nullableValue( \textcolor{keyword}{nullptr} ) \{\}}
\DoxyCodeLine{4412         \mbox{\hyperlink{classCatch_1_1Option}{Option}}( T \textcolor{keyword}{const}\& \_value )}
\DoxyCodeLine{4413         : nullableValue( \textcolor{keyword}{new}( storage ) T( \_value ) )}
\DoxyCodeLine{4414         \{\}}
\DoxyCodeLine{4415         \mbox{\hyperlink{classCatch_1_1Option}{Option}}( \mbox{\hyperlink{classCatch_1_1Option}{Option}} \textcolor{keyword}{const}\& \_other )}
\DoxyCodeLine{4416         : nullableValue( \_other ? \textcolor{keyword}{new}( storage ) T( *\_other ) : \textcolor{keyword}{nullptr} )}
\DoxyCodeLine{4417         \{\}}
\DoxyCodeLine{4418 }
\DoxyCodeLine{4419         \mbox{\hyperlink{classCatch_1_1Option}{\string~Option}}() \{}
\DoxyCodeLine{4420             reset();}
\DoxyCodeLine{4421         \}}
\DoxyCodeLine{4422 }
\DoxyCodeLine{4423         \mbox{\hyperlink{classCatch_1_1Option}{Option}}\& operator= ( \mbox{\hyperlink{classCatch_1_1Option}{Option}} \textcolor{keyword}{const}\& \_other ) \{}
\DoxyCodeLine{4424             \textcolor{keywordflow}{if}( \&\_other != \textcolor{keyword}{this} ) \{}
\DoxyCodeLine{4425                 reset();}
\DoxyCodeLine{4426                 \textcolor{keywordflow}{if}( \_other )}
\DoxyCodeLine{4427                     nullableValue = \textcolor{keyword}{new}( storage ) T( *\_other );}
\DoxyCodeLine{4428             \}}
\DoxyCodeLine{4429             \textcolor{keywordflow}{return} *\textcolor{keyword}{this};}
\DoxyCodeLine{4430         \}}
\DoxyCodeLine{4431         \mbox{\hyperlink{classCatch_1_1Option}{Option}}\& operator = ( T \textcolor{keyword}{const}\& \_value ) \{}
\DoxyCodeLine{4432             reset();}
\DoxyCodeLine{4433             nullableValue = \textcolor{keyword}{new}( storage ) T( \_value );}
\DoxyCodeLine{4434             \textcolor{keywordflow}{return} *\textcolor{keyword}{this};}
\DoxyCodeLine{4435         \}}
\DoxyCodeLine{4436 }
\DoxyCodeLine{4437         \textcolor{keywordtype}{void} reset() \{}
\DoxyCodeLine{4438             \textcolor{keywordflow}{if}( nullableValue )}
\DoxyCodeLine{4439                 nullableValue-\/>\string~T();}
\DoxyCodeLine{4440             nullableValue = \textcolor{keyword}{nullptr};}
\DoxyCodeLine{4441         \}}
\DoxyCodeLine{4442 }
\DoxyCodeLine{4443         T\& operator*() \{ \textcolor{keywordflow}{return} *nullableValue; \}}
\DoxyCodeLine{4444         T \textcolor{keyword}{const}\& operator*()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} *nullableValue; \}}
\DoxyCodeLine{4445         T* operator-\/>() \{ \textcolor{keywordflow}{return} nullableValue; \}}
\DoxyCodeLine{4446         \textcolor{keyword}{const} T* operator-\/>()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} nullableValue; \}}
\DoxyCodeLine{4447 }
\DoxyCodeLine{4448         T valueOr( T \textcolor{keyword}{const}\& defaultValue )\textcolor{keyword}{ const }\{}
\DoxyCodeLine{4449             \textcolor{keywordflow}{return} nullableValue ? *nullableValue : defaultValue;}
\DoxyCodeLine{4450         \}}
\DoxyCodeLine{4451 }
\DoxyCodeLine{4452         \textcolor{keywordtype}{bool} some()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} nullableValue != \textcolor{keyword}{nullptr}; \}}
\DoxyCodeLine{4453         \textcolor{keywordtype}{bool} none()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} nullableValue == \textcolor{keyword}{nullptr}; \}}
\DoxyCodeLine{4454 }
\DoxyCodeLine{4455         \textcolor{keywordtype}{bool} operator !()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} nullableValue == \textcolor{keyword}{nullptr}; \}}
\DoxyCodeLine{4456         \textcolor{keyword}{explicit} \textcolor{keyword}{operator} bool()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{4457             \textcolor{keywordflow}{return} some();}
\DoxyCodeLine{4458         \}}
\DoxyCodeLine{4459 }
\DoxyCodeLine{4460     \textcolor{keyword}{private}:}
\DoxyCodeLine{4461         T *nullableValue;}
\DoxyCodeLine{4462         \textcolor{keyword}{alignas}(\textcolor{keyword}{alignof}(T)) \textcolor{keywordtype}{char} storage[\textcolor{keyword}{sizeof}(T)];}
\DoxyCodeLine{4463     \};}
\DoxyCodeLine{4464 }
\DoxyCodeLine{4465 \} \textcolor{comment}{// end namespace Catch}}
\DoxyCodeLine{4466 }
\DoxyCodeLine{4467 \textcolor{comment}{// end catch\_option.hpp}}
\DoxyCodeLine{4468 \textcolor{preprocessor}{\#include <chrono>}}
\DoxyCodeLine{4469 \textcolor{preprocessor}{\#include <iosfwd>}}
\DoxyCodeLine{4470 \textcolor{preprocessor}{\#include <string>}}
\DoxyCodeLine{4471 \textcolor{preprocessor}{\#include <vector>}}
\DoxyCodeLine{4472 \textcolor{preprocessor}{\#include <memory>}}
\DoxyCodeLine{4473 }
\DoxyCodeLine{4474 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{4475 }
\DoxyCodeLine{4476     \textcolor{keyword}{enum class} Verbosity \{}
\DoxyCodeLine{4477         Quiet = 0,}
\DoxyCodeLine{4478         Normal,}
\DoxyCodeLine{4479         High}
\DoxyCodeLine{4480     \};}
\DoxyCodeLine{4481 }
\DoxyCodeLine{4482     \textcolor{keyword}{struct }\mbox{\hyperlink{structCatch_1_1WarnAbout}{WarnAbout}} \{ \textcolor{keyword}{enum} What \{}
\DoxyCodeLine{4483         Nothing = 0x00,}
\DoxyCodeLine{4484         NoAssertions = 0x01,}
\DoxyCodeLine{4485         NoTests = 0x02}
\DoxyCodeLine{4486     \}; \};}
\DoxyCodeLine{4487 }
\DoxyCodeLine{4488     \textcolor{keyword}{struct }\mbox{\hyperlink{structCatch_1_1ShowDurations}{ShowDurations}} \{ \textcolor{keyword}{enum} OrNot \{}
\DoxyCodeLine{4489         DefaultForReporter,}
\DoxyCodeLine{4490         Always,}
\DoxyCodeLine{4491         Never}
\DoxyCodeLine{4492     \}; \};}
\DoxyCodeLine{4493     \textcolor{keyword}{struct }\mbox{\hyperlink{structCatch_1_1RunTests}{RunTests}} \{ \textcolor{keyword}{enum} InWhatOrder \{}
\DoxyCodeLine{4494         InDeclarationOrder,}
\DoxyCodeLine{4495         InLexicographicalOrder,}
\DoxyCodeLine{4496         InRandomOrder}
\DoxyCodeLine{4497     \}; \};}
\DoxyCodeLine{4498     \textcolor{keyword}{struct }\mbox{\hyperlink{structCatch_1_1UseColour}{UseColour}} \{ \textcolor{keyword}{enum} YesOrNo \{}
\DoxyCodeLine{4499         Auto,}
\DoxyCodeLine{4500         Yes,}
\DoxyCodeLine{4501         No}
\DoxyCodeLine{4502     \}; \};}
\DoxyCodeLine{4503     \textcolor{keyword}{struct }\mbox{\hyperlink{structCatch_1_1WaitForKeypress}{WaitForKeypress}} \{ \textcolor{keyword}{enum} When \{}
\DoxyCodeLine{4504         Never,}
\DoxyCodeLine{4505         BeforeStart = 1,}
\DoxyCodeLine{4506         BeforeExit = 2,}
\DoxyCodeLine{4507         BeforeStartAndExit = BeforeStart | BeforeExit}
\DoxyCodeLine{4508     \}; \};}
\DoxyCodeLine{4509 }
\DoxyCodeLine{4510     \textcolor{keyword}{class }TestSpec;}
\DoxyCodeLine{4511 }
\DoxyCodeLine{4512     \textcolor{keyword}{struct }\mbox{\hyperlink{structCatch_1_1IConfig}{IConfig}} : \mbox{\hyperlink{classCatch_1_1NonCopyable}{NonCopyable}} \{}
\DoxyCodeLine{4513 }
\DoxyCodeLine{4514         \textcolor{keyword}{virtual} \mbox{\hyperlink{structCatch_1_1IConfig}{\string~IConfig}}();}
\DoxyCodeLine{4515 }
\DoxyCodeLine{4516         \textcolor{keyword}{virtual} \textcolor{keywordtype}{bool} allowThrows() \textcolor{keyword}{const} = 0;}
\DoxyCodeLine{4517         \textcolor{keyword}{virtual} std::ostream\& stream() \textcolor{keyword}{const} = 0;}
\DoxyCodeLine{4518         \textcolor{keyword}{virtual} std::string name() \textcolor{keyword}{const} = 0;}
\DoxyCodeLine{4519         \textcolor{keyword}{virtual} \textcolor{keywordtype}{bool} includeSuccessfulResults() \textcolor{keyword}{const} = 0;}
\DoxyCodeLine{4520         \textcolor{keyword}{virtual} \textcolor{keywordtype}{bool} shouldDebugBreak() \textcolor{keyword}{const} = 0;}
\DoxyCodeLine{4521         \textcolor{keyword}{virtual} \textcolor{keywordtype}{bool} warnAboutMissingAssertions() \textcolor{keyword}{const} = 0;}
\DoxyCodeLine{4522         \textcolor{keyword}{virtual} \textcolor{keywordtype}{bool} warnAboutNoTests() \textcolor{keyword}{const} = 0;}
\DoxyCodeLine{4523         \textcolor{keyword}{virtual} \textcolor{keywordtype}{int} abortAfter() \textcolor{keyword}{const} = 0;}
\DoxyCodeLine{4524         \textcolor{keyword}{virtual} \textcolor{keywordtype}{bool} showInvisibles() \textcolor{keyword}{const} = 0;}
\DoxyCodeLine{4525         \textcolor{keyword}{virtual} ShowDurations::OrNot showDurations() \textcolor{keyword}{const} = 0;}
\DoxyCodeLine{4526         \textcolor{keyword}{virtual} \textcolor{keywordtype}{double} minDuration() \textcolor{keyword}{const} = 0;}
\DoxyCodeLine{4527         \textcolor{keyword}{virtual} TestSpec \textcolor{keyword}{const}\& testSpec() \textcolor{keyword}{const} = 0;}
\DoxyCodeLine{4528         \textcolor{keyword}{virtual} \textcolor{keywordtype}{bool} hasTestFilters() \textcolor{keyword}{const} = 0;}
\DoxyCodeLine{4529         \textcolor{keyword}{virtual} std::vector<std::string> \textcolor{keyword}{const}\& getTestsOrTags() \textcolor{keyword}{const} = 0;}
\DoxyCodeLine{4530         \textcolor{keyword}{virtual} RunTests::InWhatOrder runOrder() \textcolor{keyword}{const} = 0;}
\DoxyCodeLine{4531         \textcolor{keyword}{virtual} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} rngSeed() \textcolor{keyword}{const} = 0;}
\DoxyCodeLine{4532         \textcolor{keyword}{virtual} UseColour::YesOrNo useColour() \textcolor{keyword}{const} = 0;}
\DoxyCodeLine{4533         \textcolor{keyword}{virtual} std::vector<std::string> \textcolor{keyword}{const}\& getSectionsToRun() \textcolor{keyword}{const} = 0;}
\DoxyCodeLine{4534         \textcolor{keyword}{virtual} Verbosity verbosity() \textcolor{keyword}{const} = 0;}
\DoxyCodeLine{4535 }
\DoxyCodeLine{4536         \textcolor{keyword}{virtual} \textcolor{keywordtype}{bool} benchmarkNoAnalysis() \textcolor{keyword}{const} = 0;}
\DoxyCodeLine{4537         \textcolor{keyword}{virtual} \textcolor{keywordtype}{int} benchmarkSamples() \textcolor{keyword}{const} = 0;}
\DoxyCodeLine{4538         \textcolor{keyword}{virtual} \textcolor{keywordtype}{double} benchmarkConfidenceInterval() \textcolor{keyword}{const} = 0;}
\DoxyCodeLine{4539         \textcolor{keyword}{virtual} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} benchmarkResamples() \textcolor{keyword}{const} = 0;}
\DoxyCodeLine{4540         \textcolor{keyword}{virtual} std::chrono::milliseconds benchmarkWarmupTime() \textcolor{keyword}{const} = 0;}
\DoxyCodeLine{4541     \};}
\DoxyCodeLine{4542 }
\DoxyCodeLine{4543     \textcolor{keyword}{using }IConfigPtr = std::shared\_ptr<IConfig const>;}
\DoxyCodeLine{4544 \}}
\DoxyCodeLine{4545 }
\DoxyCodeLine{4546 \textcolor{comment}{// end catch\_interfaces\_config.h}}
\DoxyCodeLine{4547 \textcolor{comment}{// start catch\_random\_number\_generator.h}}
\DoxyCodeLine{4548 }
\DoxyCodeLine{4549 \textcolor{preprocessor}{\#include <cstdint>}}
\DoxyCodeLine{4550 }
\DoxyCodeLine{4551 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{4552 }
\DoxyCodeLine{4553     \textcolor{comment}{// This is a simple implementation of C++11 Uniform Random Number}}
\DoxyCodeLine{4554     \textcolor{comment}{// Generator. It does not provide all operators, because Catch2}}
\DoxyCodeLine{4555     \textcolor{comment}{// does not use it, but it should behave as expected inside stdlib's}}
\DoxyCodeLine{4556     \textcolor{comment}{// distributions.}}
\DoxyCodeLine{4557     \textcolor{comment}{// The implementation is based on the PCG family (http://pcg-\/random.org)}}
\DoxyCodeLine{4558     \textcolor{keyword}{class }\mbox{\hyperlink{classCatch_1_1SimplePcg32}{SimplePcg32}} \{}
\DoxyCodeLine{4559         \textcolor{keyword}{using }state\_type = std::uint64\_t;}
\DoxyCodeLine{4560     \textcolor{keyword}{public}:}
\DoxyCodeLine{4561         \textcolor{keyword}{using }result\_type = std::uint32\_t;}
\DoxyCodeLine{4562         \textcolor{keyword}{static} \textcolor{keyword}{constexpr} result\_type (min)() \{}
\DoxyCodeLine{4563             \textcolor{keywordflow}{return} 0;}
\DoxyCodeLine{4564         \}}
\DoxyCodeLine{4565         \textcolor{keyword}{static} \textcolor{keyword}{constexpr} result\_type (max)() \{}
\DoxyCodeLine{4566             \textcolor{keywordflow}{return} \textcolor{keyword}{static\_cast<}result\_type\textcolor{keyword}{>}(-\/1);}
\DoxyCodeLine{4567         \}}
\DoxyCodeLine{4568 }
\DoxyCodeLine{4569         \textcolor{comment}{// Provide some default initial state for the default constructor}}
\DoxyCodeLine{4570         \mbox{\hyperlink{classCatch_1_1SimplePcg32}{SimplePcg32}}():\mbox{\hyperlink{classCatch_1_1SimplePcg32}{SimplePcg32}}(0xed743cc4U) \{\}}
\DoxyCodeLine{4571 }
\DoxyCodeLine{4572         \textcolor{keyword}{explicit} \mbox{\hyperlink{classCatch_1_1SimplePcg32}{SimplePcg32}}(result\_type seed\_);}
\DoxyCodeLine{4573 }
\DoxyCodeLine{4574         \textcolor{keywordtype}{void} seed(result\_type seed\_);}
\DoxyCodeLine{4575         \textcolor{keywordtype}{void} discard(uint64\_t skip);}
\DoxyCodeLine{4576 }
\DoxyCodeLine{4577         result\_type operator()();}
\DoxyCodeLine{4578 }
\DoxyCodeLine{4579     \textcolor{keyword}{private}:}
\DoxyCodeLine{4580         \textcolor{keyword}{friend} \textcolor{keywordtype}{bool} operator==(\mbox{\hyperlink{classCatch_1_1SimplePcg32}{SimplePcg32}} \textcolor{keyword}{const}\& lhs, \mbox{\hyperlink{classCatch_1_1SimplePcg32}{SimplePcg32}} \textcolor{keyword}{const}\& rhs);}
\DoxyCodeLine{4581         \textcolor{keyword}{friend} \textcolor{keywordtype}{bool} operator!=(\mbox{\hyperlink{classCatch_1_1SimplePcg32}{SimplePcg32}} \textcolor{keyword}{const}\& lhs, \mbox{\hyperlink{classCatch_1_1SimplePcg32}{SimplePcg32}} \textcolor{keyword}{const}\& rhs);}
\DoxyCodeLine{4582 }
\DoxyCodeLine{4583         \textcolor{comment}{// In theory we also need operator<< and operator>>}}
\DoxyCodeLine{4584         \textcolor{comment}{// In practice we do not use them, so we will skip them for now}}
\DoxyCodeLine{4585 }
\DoxyCodeLine{4586         std::uint64\_t m\_state;}
\DoxyCodeLine{4587         \textcolor{comment}{// This part of the state determines which "{}stream"{} of the numbers}}
\DoxyCodeLine{4588         \textcolor{comment}{// is chosen -\/-\/ we take it as a constant for Catch2, so we only}}
\DoxyCodeLine{4589         \textcolor{comment}{// need to deal with seeding the main state.}}
\DoxyCodeLine{4590         \textcolor{comment}{// Picked by reading 8 bytes from `/dev/random` :-\/)}}
\DoxyCodeLine{4591         \textcolor{keyword}{static} \textcolor{keyword}{const} std::uint64\_t s\_inc = (0x13ed0cc53f939476ULL << 1ULL) | 1ULL;}
\DoxyCodeLine{4592     \};}
\DoxyCodeLine{4593 }
\DoxyCodeLine{4594 \} \textcolor{comment}{// end namespace Catch}}
\DoxyCodeLine{4595 }
\DoxyCodeLine{4596 \textcolor{comment}{// end catch\_random\_number\_generator.h}}
\DoxyCodeLine{4597 \textcolor{preprocessor}{\#include <random>}}
\DoxyCodeLine{4598 }
\DoxyCodeLine{4599 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{4600 \textcolor{keyword}{namespace }Generators \{}
\DoxyCodeLine{4601 }
\DoxyCodeLine{4602 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Float>}
\DoxyCodeLine{4603 \textcolor{keyword}{class }\mbox{\hyperlink{classCatch_1_1Generators_1_1RandomFloatingGenerator}{RandomFloatingGenerator}} final : \textcolor{keyword}{public} \mbox{\hyperlink{structCatch_1_1Generators_1_1IGenerator}{IGenerator}}<Float> \{}
\DoxyCodeLine{4604     \mbox{\hyperlink{classCatch_1_1SimplePcg32}{Catch::SimplePcg32}}\& m\_rng;}
\DoxyCodeLine{4605     std::uniform\_real\_distribution<Float> m\_dist;}
\DoxyCodeLine{4606     Float m\_current\_number;}
\DoxyCodeLine{4607 \textcolor{keyword}{public}:}
\DoxyCodeLine{4608 }
\DoxyCodeLine{4609     \mbox{\hyperlink{classCatch_1_1Generators_1_1RandomFloatingGenerator}{RandomFloatingGenerator}}(Float a, Float b):}
\DoxyCodeLine{4610         m\_rng(rng()),}
\DoxyCodeLine{4611         m\_dist(a, b) \{}
\DoxyCodeLine{4612         \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{void}\textcolor{keyword}{>}(next());}
\DoxyCodeLine{4613     \}}
\DoxyCodeLine{4614 }
\DoxyCodeLine{4615     Float \textcolor{keyword}{const}\& get()\textcolor{keyword}{ const override }\{}
\DoxyCodeLine{4616         \textcolor{keywordflow}{return} m\_current\_number;}
\DoxyCodeLine{4617     \}}
\DoxyCodeLine{4618     \textcolor{keywordtype}{bool} next()\textcolor{keyword}{ override }\{}
\DoxyCodeLine{4619         m\_current\_number = m\_dist(m\_rng);}
\DoxyCodeLine{4620         \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{4621     \}}
\DoxyCodeLine{4622 \};}
\DoxyCodeLine{4623 }
\DoxyCodeLine{4624 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Integer>}
\DoxyCodeLine{4625 \textcolor{keyword}{class }\mbox{\hyperlink{classCatch_1_1Generators_1_1RandomIntegerGenerator}{RandomIntegerGenerator}} final : \textcolor{keyword}{public} \mbox{\hyperlink{structCatch_1_1Generators_1_1IGenerator}{IGenerator}}<Integer> \{}
\DoxyCodeLine{4626     \mbox{\hyperlink{classCatch_1_1SimplePcg32}{Catch::SimplePcg32}}\& m\_rng;}
\DoxyCodeLine{4627     std::uniform\_int\_distribution<Integer> m\_dist;}
\DoxyCodeLine{4628     Integer m\_current\_number;}
\DoxyCodeLine{4629 \textcolor{keyword}{public}:}
\DoxyCodeLine{4630 }
\DoxyCodeLine{4631     \mbox{\hyperlink{classCatch_1_1Generators_1_1RandomIntegerGenerator}{RandomIntegerGenerator}}(Integer a, Integer b):}
\DoxyCodeLine{4632         m\_rng(rng()),}
\DoxyCodeLine{4633         m\_dist(a, b) \{}
\DoxyCodeLine{4634         \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{void}\textcolor{keyword}{>}(next());}
\DoxyCodeLine{4635     \}}
\DoxyCodeLine{4636 }
\DoxyCodeLine{4637     Integer \textcolor{keyword}{const}\& get()\textcolor{keyword}{ const override }\{}
\DoxyCodeLine{4638         \textcolor{keywordflow}{return} m\_current\_number;}
\DoxyCodeLine{4639     \}}
\DoxyCodeLine{4640     \textcolor{keywordtype}{bool} next()\textcolor{keyword}{ override }\{}
\DoxyCodeLine{4641         m\_current\_number = m\_dist(m\_rng);}
\DoxyCodeLine{4642         \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{4643     \}}
\DoxyCodeLine{4644 \};}
\DoxyCodeLine{4645 }
\DoxyCodeLine{4646 \textcolor{comment}{// TODO: Ideally this would be also constrained against the various char types,}}
\DoxyCodeLine{4647 \textcolor{comment}{//       but I don't expect users to run into that in practice.}}
\DoxyCodeLine{4648 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{4649 \textcolor{keyword}{typename} std::enable\_if<std::is\_integral<T>::value \&\& !std::is\_same<T, bool>::value,}
\DoxyCodeLine{4650 \mbox{\hyperlink{classCatch_1_1Generators_1_1GeneratorWrapper}{GeneratorWrapper<T>}}>::type}
\DoxyCodeLine{4651 random(T a, T b) \{}
\DoxyCodeLine{4652     \textcolor{keywordflow}{return} \mbox{\hyperlink{classCatch_1_1Generators_1_1GeneratorWrapper}{GeneratorWrapper<T>}}(}
\DoxyCodeLine{4653         pf::make\_unique<\mbox{\hyperlink{classCatch_1_1Generators_1_1RandomIntegerGenerator}{RandomIntegerGenerator<T>}}>(a, b)}
\DoxyCodeLine{4654     );}
\DoxyCodeLine{4655 \}}
\DoxyCodeLine{4656 }
\DoxyCodeLine{4657 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{4658 \textcolor{keyword}{typename} std::enable\_if<std::is\_floating\_point<T>::value,}
\DoxyCodeLine{4659 GeneratorWrapper<T>>::type}
\DoxyCodeLine{4660 random(T a, T b) \{}
\DoxyCodeLine{4661     \textcolor{keywordflow}{return} GeneratorWrapper<T>(}
\DoxyCodeLine{4662         pf::make\_unique<RandomFloatingGenerator<T>>(a, b)}
\DoxyCodeLine{4663     );}
\DoxyCodeLine{4664 \}}
\DoxyCodeLine{4665 }
\DoxyCodeLine{4666 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{4667 \textcolor{keyword}{class }\mbox{\hyperlink{classCatch_1_1Generators_1_1RangeGenerator}{RangeGenerator}} final : \textcolor{keyword}{public} \mbox{\hyperlink{structCatch_1_1Generators_1_1IGenerator}{IGenerator}}<T> \{}
\DoxyCodeLine{4668     T m\_current;}
\DoxyCodeLine{4669     T m\_end;}
\DoxyCodeLine{4670     T m\_step;}
\DoxyCodeLine{4671     \textcolor{keywordtype}{bool} m\_positive;}
\DoxyCodeLine{4672 }
\DoxyCodeLine{4673 \textcolor{keyword}{public}:}
\DoxyCodeLine{4674     \mbox{\hyperlink{classCatch_1_1Generators_1_1RangeGenerator}{RangeGenerator}}(T \textcolor{keyword}{const}\& start, T \textcolor{keyword}{const}\& end, T \textcolor{keyword}{const}\& step):}
\DoxyCodeLine{4675         m\_current(start),}
\DoxyCodeLine{4676         m\_end(end),}
\DoxyCodeLine{4677         m\_step(step),}
\DoxyCodeLine{4678         m\_positive(m\_step > T(0))}
\DoxyCodeLine{4679     \{}
\DoxyCodeLine{4680         assert(m\_current != m\_end \&\& \textcolor{stringliteral}{"{}Range start and end cannot be equal"{}});}
\DoxyCodeLine{4681         assert(m\_step != T(0) \&\& \textcolor{stringliteral}{"{}Step size cannot be zero"{}});}
\DoxyCodeLine{4682         assert(((m\_positive \&\& m\_current <= m\_end) || (!m\_positive \&\& m\_current >= m\_end)) \&\& \textcolor{stringliteral}{"{}Step moves away from end"{}});}
\DoxyCodeLine{4683     \}}
\DoxyCodeLine{4684 }
\DoxyCodeLine{4685     \mbox{\hyperlink{classCatch_1_1Generators_1_1RangeGenerator}{RangeGenerator}}(T \textcolor{keyword}{const}\& start, T \textcolor{keyword}{const}\& end):}
\DoxyCodeLine{4686         \mbox{\hyperlink{classCatch_1_1Generators_1_1RangeGenerator}{RangeGenerator}}(start, end, (start < end) ? T(1) : T(-\/1))}
\DoxyCodeLine{4687     \{\}}
\DoxyCodeLine{4688 }
\DoxyCodeLine{4689     T \textcolor{keyword}{const}\& get()\textcolor{keyword}{ const override }\{}
\DoxyCodeLine{4690         \textcolor{keywordflow}{return} m\_current;}
\DoxyCodeLine{4691     \}}
\DoxyCodeLine{4692 }
\DoxyCodeLine{4693     \textcolor{keywordtype}{bool} next()\textcolor{keyword}{ override }\{}
\DoxyCodeLine{4694         m\_current += m\_step;}
\DoxyCodeLine{4695         \textcolor{keywordflow}{return} (m\_positive) ? (m\_current < m\_end) : (m\_current > m\_end);}
\DoxyCodeLine{4696     \}}
\DoxyCodeLine{4697 \};}
\DoxyCodeLine{4698 }
\DoxyCodeLine{4699 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{4700 \mbox{\hyperlink{classCatch_1_1Generators_1_1GeneratorWrapper}{GeneratorWrapper<T>}} range(T \textcolor{keyword}{const}\& start, T \textcolor{keyword}{const}\& end, T \textcolor{keyword}{const}\& step) \{}
\DoxyCodeLine{4701     \textcolor{keyword}{static\_assert}(std::is\_arithmetic<T>::value \&\& !std::is\_same<T, bool>::value, \textcolor{stringliteral}{"{}Type must be numeric"{}});}
\DoxyCodeLine{4702     \textcolor{keywordflow}{return} \mbox{\hyperlink{classCatch_1_1Generators_1_1GeneratorWrapper}{GeneratorWrapper<T>}}(pf::make\_unique<\mbox{\hyperlink{classCatch_1_1Generators_1_1RangeGenerator}{RangeGenerator<T>}}>(start, end, step));}
\DoxyCodeLine{4703 \}}
\DoxyCodeLine{4704 }
\DoxyCodeLine{4705 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{4706 GeneratorWrapper<T> range(T \textcolor{keyword}{const}\& start, T \textcolor{keyword}{const}\& end) \{}
\DoxyCodeLine{4707     \textcolor{keyword}{static\_assert}(std::is\_integral<T>::value \&\& !std::is\_same<T, bool>::value, \textcolor{stringliteral}{"{}Type must be an integer"{}});}
\DoxyCodeLine{4708     \textcolor{keywordflow}{return} GeneratorWrapper<T>(pf::make\_unique<RangeGenerator<T>>(start, end));}
\DoxyCodeLine{4709 \}}
\DoxyCodeLine{4710 }
\DoxyCodeLine{4711 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{4712 \textcolor{keyword}{class }\mbox{\hyperlink{classCatch_1_1Generators_1_1IteratorGenerator}{IteratorGenerator}} final : \textcolor{keyword}{public} \mbox{\hyperlink{structCatch_1_1Generators_1_1IGenerator}{IGenerator}}<T> \{}
\DoxyCodeLine{4713     \textcolor{keyword}{static\_assert}(!std::is\_same<T, bool>::value,}
\DoxyCodeLine{4714         \textcolor{stringliteral}{"{}IteratorGenerator currently does not support bools"{}}}
\DoxyCodeLine{4715         \textcolor{stringliteral}{"{}because of std::vector<bool> specialization"{}});}
\DoxyCodeLine{4716 }
\DoxyCodeLine{4717     std::vector<T> m\_elems;}
\DoxyCodeLine{4718     \textcolor{keywordtype}{size\_t} m\_current = 0;}
\DoxyCodeLine{4719 \textcolor{keyword}{public}:}
\DoxyCodeLine{4720     \textcolor{keyword}{template} <\textcolor{keyword}{typename} InputIterator, \textcolor{keyword}{typename} InputSentinel>}
\DoxyCodeLine{4721     \mbox{\hyperlink{classCatch_1_1Generators_1_1IteratorGenerator}{IteratorGenerator}}(InputIterator first, InputSentinel last):m\_elems(first, last) \{}
\DoxyCodeLine{4722         \textcolor{keywordflow}{if} (m\_elems.empty()) \{}
\DoxyCodeLine{4723             Catch::throw\_exception(\mbox{\hyperlink{classCatch_1_1GeneratorException}{GeneratorException}}(\textcolor{stringliteral}{"{}IteratorGenerator received no valid values"{}}));}
\DoxyCodeLine{4724         \}}
\DoxyCodeLine{4725     \}}
\DoxyCodeLine{4726 }
\DoxyCodeLine{4727     T \textcolor{keyword}{const}\& get()\textcolor{keyword}{ const override }\{}
\DoxyCodeLine{4728         \textcolor{keywordflow}{return} m\_elems[m\_current];}
\DoxyCodeLine{4729     \}}
\DoxyCodeLine{4730 }
\DoxyCodeLine{4731     \textcolor{keywordtype}{bool} next()\textcolor{keyword}{ override }\{}
\DoxyCodeLine{4732         ++m\_current;}
\DoxyCodeLine{4733         \textcolor{keywordflow}{return} m\_current != m\_elems.size();}
\DoxyCodeLine{4734     \}}
\DoxyCodeLine{4735 \};}
\DoxyCodeLine{4736 }
\DoxyCodeLine{4737 \textcolor{keyword}{template} <\textcolor{keyword}{typename} InputIterator,}
\DoxyCodeLine{4738           \textcolor{keyword}{typename} InputSentinel,}
\DoxyCodeLine{4739           \textcolor{keyword}{typename} ResultType = \textcolor{keyword}{typename} std::iterator\_traits<InputIterator>::value\_type>}
\DoxyCodeLine{4740 \mbox{\hyperlink{classCatch_1_1Generators_1_1GeneratorWrapper}{GeneratorWrapper<ResultType>}} from\_range(InputIterator from, InputSentinel to) \{}
\DoxyCodeLine{4741     \textcolor{keywordflow}{return} \mbox{\hyperlink{classCatch_1_1Generators_1_1GeneratorWrapper}{GeneratorWrapper<ResultType>}}(pf::make\_unique<\mbox{\hyperlink{classCatch_1_1Generators_1_1IteratorGenerator}{IteratorGenerator<ResultType>}}>(from, to));}
\DoxyCodeLine{4742 \}}
\DoxyCodeLine{4743 }
\DoxyCodeLine{4744 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Container,}
\DoxyCodeLine{4745           \textcolor{keyword}{typename} ResultType = \textcolor{keyword}{typename} Container::value\_type>}
\DoxyCodeLine{4746 GeneratorWrapper<ResultType> from\_range(Container \textcolor{keyword}{const}\& cnt) \{}
\DoxyCodeLine{4747     \textcolor{keywordflow}{return} GeneratorWrapper<ResultType>(pf::make\_unique<IteratorGenerator<ResultType>>(cnt.begin(), cnt.end()));}
\DoxyCodeLine{4748 \}}
\DoxyCodeLine{4749 }
\DoxyCodeLine{4750 \} \textcolor{comment}{// namespace Generators}}
\DoxyCodeLine{4751 \} \textcolor{comment}{// namespace Catch}}
\DoxyCodeLine{4752 }
\DoxyCodeLine{4753 \textcolor{comment}{// end catch\_generators\_specific.hpp}}
\DoxyCodeLine{4754 }
\DoxyCodeLine{4755 \textcolor{comment}{// These files are included here so the single\_include script doesn't put them}}
\DoxyCodeLine{4756 \textcolor{comment}{// in the conditionally compiled sections}}
\DoxyCodeLine{4757 \textcolor{comment}{// start catch\_test\_case\_info.h}}
\DoxyCodeLine{4758 }
\DoxyCodeLine{4759 \textcolor{preprocessor}{\#include <string>}}
\DoxyCodeLine{4760 \textcolor{preprocessor}{\#include <vector>}}
\DoxyCodeLine{4761 \textcolor{preprocessor}{\#include <memory>}}
\DoxyCodeLine{4762 }
\DoxyCodeLine{4763 \textcolor{preprocessor}{\#ifdef \_\_clang\_\_}}
\DoxyCodeLine{4764 \textcolor{preprocessor}{\#pragma clang diagnostic push}}
\DoxyCodeLine{4765 \textcolor{preprocessor}{\#pragma clang diagnostic ignored "{}-\/Wpadded"{}}}
\DoxyCodeLine{4766 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{4767 }
\DoxyCodeLine{4768 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{4769 }
\DoxyCodeLine{4770     \textcolor{keyword}{struct }ITestInvoker;}
\DoxyCodeLine{4771 }
\DoxyCodeLine{4772     \textcolor{keyword}{struct }\mbox{\hyperlink{structCatch_1_1TestCaseInfo}{TestCaseInfo}} \{}
\DoxyCodeLine{4773         \textcolor{keyword}{enum} SpecialProperties\{}
\DoxyCodeLine{4774             None = 0,}
\DoxyCodeLine{4775             IsHidden = 1 << 1,}
\DoxyCodeLine{4776             ShouldFail = 1 << 2,}
\DoxyCodeLine{4777             MayFail = 1 << 3,}
\DoxyCodeLine{4778             Throws = 1 << 4,}
\DoxyCodeLine{4779             NonPortable = 1 << 5,}
\DoxyCodeLine{4780             Benchmark = 1 << 6}
\DoxyCodeLine{4781         \};}
\DoxyCodeLine{4782 }
\DoxyCodeLine{4783         \mbox{\hyperlink{structCatch_1_1TestCaseInfo}{TestCaseInfo}}(   std::string \textcolor{keyword}{const}\& \_name,}
\DoxyCodeLine{4784                         std::string \textcolor{keyword}{const}\& \_className,}
\DoxyCodeLine{4785                         std::string \textcolor{keyword}{const}\& \_description,}
\DoxyCodeLine{4786                         std::vector<std::string> \textcolor{keyword}{const}\& \_tags,}
\DoxyCodeLine{4787                         \mbox{\hyperlink{structCatch_1_1SourceLineInfo}{SourceLineInfo}} \textcolor{keyword}{const}\& \_lineInfo );}
\DoxyCodeLine{4788 }
\DoxyCodeLine{4789         \textcolor{keyword}{friend} \textcolor{keywordtype}{void} setTags( \mbox{\hyperlink{structCatch_1_1TestCaseInfo}{TestCaseInfo}}\& testCaseInfo, std::vector<std::string> tags );}
\DoxyCodeLine{4790 }
\DoxyCodeLine{4791         \textcolor{keywordtype}{bool} isHidden() \textcolor{keyword}{const};}
\DoxyCodeLine{4792         \textcolor{keywordtype}{bool} \textcolor{keywordflow}{throws}() \textcolor{keyword}{const};}
\DoxyCodeLine{4793         \textcolor{keywordtype}{bool} okToFail() \textcolor{keyword}{const};}
\DoxyCodeLine{4794         \textcolor{keywordtype}{bool} expectedToFail() \textcolor{keyword}{const};}
\DoxyCodeLine{4795 }
\DoxyCodeLine{4796         std::string tagsAsString() \textcolor{keyword}{const};}
\DoxyCodeLine{4797 }
\DoxyCodeLine{4798         std::string name;}
\DoxyCodeLine{4799         std::string className;}
\DoxyCodeLine{4800         std::string description;}
\DoxyCodeLine{4801         std::vector<std::string> tags;}
\DoxyCodeLine{4802         std::vector<std::string> lcaseTags;}
\DoxyCodeLine{4803         \mbox{\hyperlink{structCatch_1_1SourceLineInfo}{SourceLineInfo}} lineInfo;}
\DoxyCodeLine{4804         SpecialProperties properties;}
\DoxyCodeLine{4805     \};}
\DoxyCodeLine{4806 }
\DoxyCodeLine{4807     \textcolor{keyword}{class }\mbox{\hyperlink{classCatch_1_1TestCase}{TestCase}} : \textcolor{keyword}{public} \mbox{\hyperlink{structCatch_1_1TestCaseInfo}{TestCaseInfo}} \{}
\DoxyCodeLine{4808     \textcolor{keyword}{public}:}
\DoxyCodeLine{4809 }
\DoxyCodeLine{4810         \mbox{\hyperlink{classCatch_1_1TestCase}{TestCase}}( \mbox{\hyperlink{structCatch_1_1ITestInvoker}{ITestInvoker}}* testCase, \mbox{\hyperlink{structCatch_1_1TestCaseInfo}{TestCaseInfo}}\&\& info );}
\DoxyCodeLine{4811 }
\DoxyCodeLine{4812         \mbox{\hyperlink{classCatch_1_1TestCase}{TestCase}} withName( std::string \textcolor{keyword}{const}\& \_newName ) \textcolor{keyword}{const};}
\DoxyCodeLine{4813 }
\DoxyCodeLine{4814         \textcolor{keywordtype}{void} invoke() \textcolor{keyword}{const};}
\DoxyCodeLine{4815 }
\DoxyCodeLine{4816         \mbox{\hyperlink{structCatch_1_1TestCaseInfo}{TestCaseInfo}} \textcolor{keyword}{const}\& getTestCaseInfo() \textcolor{keyword}{const};}
\DoxyCodeLine{4817 }
\DoxyCodeLine{4818         \textcolor{keywordtype}{bool} operator == ( \mbox{\hyperlink{classCatch_1_1TestCase}{TestCase}} \textcolor{keyword}{const}\& other ) \textcolor{keyword}{const};}
\DoxyCodeLine{4819         \textcolor{keywordtype}{bool} operator < ( \mbox{\hyperlink{classCatch_1_1TestCase}{TestCase}} \textcolor{keyword}{const}\& other ) \textcolor{keyword}{const};}
\DoxyCodeLine{4820 }
\DoxyCodeLine{4821     \textcolor{keyword}{private}:}
\DoxyCodeLine{4822         std::shared\_ptr<ITestInvoker> test;}
\DoxyCodeLine{4823     \};}
\DoxyCodeLine{4824 }
\DoxyCodeLine{4825     \mbox{\hyperlink{classCatch_1_1TestCase}{TestCase}} makeTestCase(  \mbox{\hyperlink{structCatch_1_1ITestInvoker}{ITestInvoker}}* testCase,}
\DoxyCodeLine{4826                             std::string \textcolor{keyword}{const}\& className,}
\DoxyCodeLine{4827                             \mbox{\hyperlink{structCatch_1_1NameAndTags}{NameAndTags}} \textcolor{keyword}{const}\& nameAndTags,}
\DoxyCodeLine{4828                             \mbox{\hyperlink{structCatch_1_1SourceLineInfo}{SourceLineInfo}} \textcolor{keyword}{const}\& lineInfo );}
\DoxyCodeLine{4829 \}}
\DoxyCodeLine{4830 }
\DoxyCodeLine{4831 \textcolor{preprocessor}{\#ifdef \_\_clang\_\_}}
\DoxyCodeLine{4832 \textcolor{preprocessor}{\#pragma clang diagnostic pop}}
\DoxyCodeLine{4833 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{4834 }
\DoxyCodeLine{4835 \textcolor{comment}{// end catch\_test\_case\_info.h}}
\DoxyCodeLine{4836 \textcolor{comment}{// start catch\_interfaces\_runner.h}}
\DoxyCodeLine{4837 }
\DoxyCodeLine{4838 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{4839 }
\DoxyCodeLine{4840     \textcolor{keyword}{struct }\mbox{\hyperlink{structCatch_1_1IRunner}{IRunner}} \{}
\DoxyCodeLine{4841         \textcolor{keyword}{virtual} \mbox{\hyperlink{structCatch_1_1IRunner}{\string~IRunner}}();}
\DoxyCodeLine{4842         \textcolor{keyword}{virtual} \textcolor{keywordtype}{bool} aborting() \textcolor{keyword}{const} = 0;}
\DoxyCodeLine{4843     \};}
\DoxyCodeLine{4844 \}}
\DoxyCodeLine{4845 }
\DoxyCodeLine{4846 \textcolor{comment}{// end catch\_interfaces\_runner.h}}
\DoxyCodeLine{4847 }
\DoxyCodeLine{4848 \textcolor{preprocessor}{\#ifdef \_\_OBJC\_\_}}
\DoxyCodeLine{4849 \textcolor{comment}{// start catch\_objc.hpp}}
\DoxyCodeLine{4850 }
\DoxyCodeLine{4851 \textcolor{preprocessor}{\#import <objc/runtime.h>}}
\DoxyCodeLine{4852 }
\DoxyCodeLine{4853 \textcolor{preprocessor}{\#include <string>}}
\DoxyCodeLine{4854 }
\DoxyCodeLine{4855 \textcolor{comment}{// NB. Any general catch headers included here must be included}}
\DoxyCodeLine{4856 \textcolor{comment}{// in catch.hpp first to make sure they are included by the single}}
\DoxyCodeLine{4857 \textcolor{comment}{// header for non obj-\/usage}}
\DoxyCodeLine{4858 }
\DoxyCodeLine{4860 \textcolor{comment}{// This protocol is really only here for (self) documenting purposes, since}}
\DoxyCodeLine{4861 \textcolor{comment}{// all its methods are optional.}}
\DoxyCodeLine{4862 \textcolor{keyword}{@protocol }OcFixture}
\DoxyCodeLine{4863 }
\DoxyCodeLine{4864 \textcolor{keyword}{@optional}}
\DoxyCodeLine{4865 }
\DoxyCodeLine{4866 -\/(void) setUp;}
\DoxyCodeLine{4867 -\/(void) tearDown;}
\DoxyCodeLine{4868 }
\DoxyCodeLine{4869 \textcolor{keyword}{@end}}
\DoxyCodeLine{4870 }
\DoxyCodeLine{4871 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{4872 }
\DoxyCodeLine{4873     \textcolor{keyword}{class }OcMethod : \textcolor{keyword}{public} ITestInvoker \{}
\DoxyCodeLine{4874 }
\DoxyCodeLine{4875     \textcolor{keyword}{public}:}
\DoxyCodeLine{4876         OcMethod( Class cls, \textcolor{keywordtype}{SEL} sel ) : m\_cls( cls ), m\_sel( sel ) \{\}}
\DoxyCodeLine{4877 }
\DoxyCodeLine{4878         \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} invoke()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{4879             \textcolor{keywordtype}{id} obj = [[m\_cls alloc] init];}
\DoxyCodeLine{4880 }
\DoxyCodeLine{4881             performOptionalSelector( obj, \textcolor{keyword}{@selector}(setUp)  );}
\DoxyCodeLine{4882             performOptionalSelector( obj, m\_sel );}
\DoxyCodeLine{4883             performOptionalSelector( obj, \textcolor{keyword}{@selector}(tearDown)  );}
\DoxyCodeLine{4884 }
\DoxyCodeLine{4885             arcSafeRelease( obj );}
\DoxyCodeLine{4886         \}}
\DoxyCodeLine{4887     \textcolor{keyword}{private}:}
\DoxyCodeLine{4888         \textcolor{keyword}{virtual} \string~OcMethod() \{\}}
\DoxyCodeLine{4889 }
\DoxyCodeLine{4890         Class m\_cls;}
\DoxyCodeLine{4891         \textcolor{keywordtype}{SEL} m\_sel;}
\DoxyCodeLine{4892     \};}
\DoxyCodeLine{4893 }
\DoxyCodeLine{4894     \textcolor{keyword}{namespace }Detail\{}
\DoxyCodeLine{4895 }
\DoxyCodeLine{4896         \textcolor{keyword}{inline} std::string getAnnotation(   Class cls,}
\DoxyCodeLine{4897                                             std::string \textcolor{keyword}{const}\& annotationName,}
\DoxyCodeLine{4898                                             std::string \textcolor{keyword}{const}\& testCaseName ) \{}
\DoxyCodeLine{4899             NSString* selStr = [[NSString alloc] initWithFormat:@"{}Catch\_\%s\_\%s"{}, annotationName.c\_str(), testCaseName.c\_str()];}
\DoxyCodeLine{4900             \textcolor{keywordtype}{SEL} sel = NSSelectorFromString( selStr );}
\DoxyCodeLine{4901             arcSafeRelease( selStr );}
\DoxyCodeLine{4902             \textcolor{keywordtype}{id} value = performOptionalSelector( cls, sel );}
\DoxyCodeLine{4903             \textcolor{keywordflow}{if}( value )}
\DoxyCodeLine{4904                 \textcolor{keywordflow}{return} [(NSString*)value UTF8String];}
\DoxyCodeLine{4905             \textcolor{keywordflow}{return} \textcolor{stringliteral}{"{}"{}};}
\DoxyCodeLine{4906         \}}
\DoxyCodeLine{4907     \}}
\DoxyCodeLine{4908 }
\DoxyCodeLine{4909     \textcolor{keyword}{inline} std::size\_t registerTestMethods() \{}
\DoxyCodeLine{4910         std::size\_t noTestMethods = 0;}
\DoxyCodeLine{4911         \textcolor{keywordtype}{int} noClasses = objc\_getClassList( \textcolor{keyword}{nullptr}, 0 );}
\DoxyCodeLine{4912 }
\DoxyCodeLine{4913         Class* classes = (CATCH\_UNSAFE\_UNRETAINED Class *)malloc( \textcolor{keyword}{sizeof}(Class) * noClasses);}
\DoxyCodeLine{4914         objc\_getClassList( classes, noClasses );}
\DoxyCodeLine{4915 }
\DoxyCodeLine{4916         \textcolor{keywordflow}{for}( \textcolor{keywordtype}{int} c = 0; c < noClasses; c++ ) \{}
\DoxyCodeLine{4917             Class cls = classes[c];}
\DoxyCodeLine{4918             \{}
\DoxyCodeLine{4919                 u\_int count;}
\DoxyCodeLine{4920                 Method* methods = class\_copyMethodList( cls, \&count );}
\DoxyCodeLine{4921                 \textcolor{keywordflow}{for}( u\_int m = 0; m < count ; m++ ) \{}
\DoxyCodeLine{4922                     \textcolor{keywordtype}{SEL} selector = method\_getName(methods[m]);}
\DoxyCodeLine{4923                     std::string methodName = sel\_getName(selector);}
\DoxyCodeLine{4924                     \textcolor{keywordflow}{if}( startsWith( methodName, \textcolor{stringliteral}{"{}Catch\_TestCase\_"{}} ) ) \{}
\DoxyCodeLine{4925                         std::string testCaseName = methodName.substr( 15 );}
\DoxyCodeLine{4926                         std::string name = Detail::getAnnotation( cls, \textcolor{stringliteral}{"{}Name"{}}, testCaseName );}
\DoxyCodeLine{4927                         std::string desc = Detail::getAnnotation( cls, \textcolor{stringliteral}{"{}Description"{}}, testCaseName );}
\DoxyCodeLine{4928                         \textcolor{keyword}{const} \textcolor{keywordtype}{char}* className = class\_getName( cls );}
\DoxyCodeLine{4929 }
\DoxyCodeLine{4930                         getMutableRegistryHub().registerTest( makeTestCase( \textcolor{keyword}{new} OcMethod( cls, selector ), className, NameAndTags( name.c\_str(), desc.c\_str() ), SourceLineInfo(\textcolor{stringliteral}{"{}"{}},0) ) );}
\DoxyCodeLine{4931                         noTestMethods++;}
\DoxyCodeLine{4932                     \}}
\DoxyCodeLine{4933                 \}}
\DoxyCodeLine{4934                 free(methods);}
\DoxyCodeLine{4935             \}}
\DoxyCodeLine{4936         \}}
\DoxyCodeLine{4937         \textcolor{keywordflow}{return} noTestMethods;}
\DoxyCodeLine{4938     \}}
\DoxyCodeLine{4939 }
\DoxyCodeLine{4940 \textcolor{preprocessor}{\#if !defined(CATCH\_CONFIG\_DISABLE\_MATCHERS)}}
\DoxyCodeLine{4941 }
\DoxyCodeLine{4942     \textcolor{keyword}{namespace }Matchers \{}
\DoxyCodeLine{4943         \textcolor{keyword}{namespace }Impl \{}
\DoxyCodeLine{4944         \textcolor{keyword}{namespace }NSStringMatchers \{}
\DoxyCodeLine{4945 }
\DoxyCodeLine{4946             \textcolor{keyword}{struct }StringHolder : MatcherBase<NSString*>\{}
\DoxyCodeLine{4947                 StringHolder( NSString* substr ) : m\_substr( [substr copy] )\{\}}
\DoxyCodeLine{4948                 StringHolder( StringHolder \textcolor{keyword}{const}\& other ) : m\_substr( [other.m\_substr copy] )\{\}}
\DoxyCodeLine{4949                 StringHolder() \{}
\DoxyCodeLine{4950                     arcSafeRelease( m\_substr );}
\DoxyCodeLine{4951                 \}}
\DoxyCodeLine{4952 }
\DoxyCodeLine{4953                 \textcolor{keywordtype}{bool} match( NSString* str )\textcolor{keyword}{ const override }\{}
\DoxyCodeLine{4954                     \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{4955                 \}}
\DoxyCodeLine{4956 }
\DoxyCodeLine{4957                 NSString* CATCH\_ARC\_STRONG m\_substr;}
\DoxyCodeLine{4958             \};}
\DoxyCodeLine{4959 }
\DoxyCodeLine{4960             \textcolor{keyword}{struct }Equals : StringHolder \{}
\DoxyCodeLine{4961                 Equals( NSString* substr ) : StringHolder( substr )\{\}}
\DoxyCodeLine{4962 }
\DoxyCodeLine{4963                 \textcolor{keywordtype}{bool} match( NSString* str )\textcolor{keyword}{ const override }\{}
\DoxyCodeLine{4964                     \textcolor{keywordflow}{return}  (str != nil || m\_substr == nil ) \&\&}
\DoxyCodeLine{4965                             [str isEqualToString:m\_substr];}
\DoxyCodeLine{4966                 \}}
\DoxyCodeLine{4967 }
\DoxyCodeLine{4968                 std::string describe()\textcolor{keyword}{ const override }\{}
\DoxyCodeLine{4969                     \textcolor{keywordflow}{return} \textcolor{stringliteral}{"{}equals string: "{}} + Catch::Detail::stringify( m\_substr );}
\DoxyCodeLine{4970                 \}}
\DoxyCodeLine{4971             \};}
\DoxyCodeLine{4972 }
\DoxyCodeLine{4973             \textcolor{keyword}{struct }Contains : StringHolder \{}
\DoxyCodeLine{4974                 Contains( NSString* substr ) : StringHolder( substr )\{\}}
\DoxyCodeLine{4975 }
\DoxyCodeLine{4976                 \textcolor{keywordtype}{bool} match( NSString* str )\textcolor{keyword}{ const override }\{}
\DoxyCodeLine{4977                     \textcolor{keywordflow}{return}  (str != nil || m\_substr == nil ) \&\&}
\DoxyCodeLine{4978                             [str rangeOfString:m\_substr].location != NSNotFound;}
\DoxyCodeLine{4979                 \}}
\DoxyCodeLine{4980 }
\DoxyCodeLine{4981                 std::string describe()\textcolor{keyword}{ const override }\{}
\DoxyCodeLine{4982                     \textcolor{keywordflow}{return} \textcolor{stringliteral}{"{}contains string: "{}} + Catch::Detail::stringify( m\_substr );}
\DoxyCodeLine{4983                 \}}
\DoxyCodeLine{4984             \};}
\DoxyCodeLine{4985 }
\DoxyCodeLine{4986             \textcolor{keyword}{struct }StartsWith : StringHolder \{}
\DoxyCodeLine{4987                 StartsWith( NSString* substr ) : StringHolder( substr )\{\}}
\DoxyCodeLine{4988 }
\DoxyCodeLine{4989                 \textcolor{keywordtype}{bool} match( NSString* str )\textcolor{keyword}{ const override }\{}
\DoxyCodeLine{4990                     \textcolor{keywordflow}{return}  (str != nil || m\_substr == nil ) \&\&}
\DoxyCodeLine{4991                             [str rangeOfString:m\_substr].location == 0;}
\DoxyCodeLine{4992                 \}}
\DoxyCodeLine{4993 }
\DoxyCodeLine{4994                 std::string describe()\textcolor{keyword}{ const override }\{}
\DoxyCodeLine{4995                     \textcolor{keywordflow}{return} \textcolor{stringliteral}{"{}starts with: "{}} + Catch::Detail::stringify( m\_substr );}
\DoxyCodeLine{4996                 \}}
\DoxyCodeLine{4997             \};}
\DoxyCodeLine{4998             \textcolor{keyword}{struct }EndsWith : StringHolder \{}
\DoxyCodeLine{4999                 EndsWith( NSString* substr ) : StringHolder( substr )\{\}}
\DoxyCodeLine{5000 }
\DoxyCodeLine{5001                 \textcolor{keywordtype}{bool} match( NSString* str )\textcolor{keyword}{ const override }\{}
\DoxyCodeLine{5002                     \textcolor{keywordflow}{return}  (str != nil || m\_substr == nil ) \&\&}
\DoxyCodeLine{5003                             [str rangeOfString:m\_substr].location == [str length] -\/ [m\_substr length];}
\DoxyCodeLine{5004                 \}}
\DoxyCodeLine{5005 }
\DoxyCodeLine{5006                 std::string describe()\textcolor{keyword}{ const override }\{}
\DoxyCodeLine{5007                     \textcolor{keywordflow}{return} \textcolor{stringliteral}{"{}ends with: "{}} + Catch::Detail::stringify( m\_substr );}
\DoxyCodeLine{5008                 \}}
\DoxyCodeLine{5009             \};}
\DoxyCodeLine{5010 }
\DoxyCodeLine{5011         \} \textcolor{comment}{// namespace NSStringMatchers}}
\DoxyCodeLine{5012         \} \textcolor{comment}{// namespace Impl}}
\DoxyCodeLine{5013 }
\DoxyCodeLine{5014         \textcolor{keyword}{inline} Impl::NSStringMatchers::Equals}
\DoxyCodeLine{5015             Equals( NSString* substr )\{ \textcolor{keywordflow}{return} Impl::NSStringMatchers::Equals( substr ); \}}
\DoxyCodeLine{5016 }
\DoxyCodeLine{5017         \textcolor{keyword}{inline} Impl::NSStringMatchers::Contains}
\DoxyCodeLine{5018             Contains( NSString* substr )\{ \textcolor{keywordflow}{return} Impl::NSStringMatchers::Contains( substr ); \}}
\DoxyCodeLine{5019 }
\DoxyCodeLine{5020         \textcolor{keyword}{inline} Impl::NSStringMatchers::StartsWith}
\DoxyCodeLine{5021             StartsWith( NSString* substr )\{ \textcolor{keywordflow}{return} Impl::NSStringMatchers::StartsWith( substr ); \}}
\DoxyCodeLine{5022 }
\DoxyCodeLine{5023         \textcolor{keyword}{inline} Impl::NSStringMatchers::EndsWith}
\DoxyCodeLine{5024             EndsWith( NSString* substr )\{ \textcolor{keywordflow}{return} Impl::NSStringMatchers::EndsWith( substr ); \}}
\DoxyCodeLine{5025 }
\DoxyCodeLine{5026     \} \textcolor{comment}{// namespace Matchers}}
\DoxyCodeLine{5027 }
\DoxyCodeLine{5028     \textcolor{keyword}{using namespace }Matchers;}
\DoxyCodeLine{5029 }
\DoxyCodeLine{5030 \textcolor{preprocessor}{\#endif }\textcolor{comment}{// CATCH\_CONFIG\_DISABLE\_MATCHERS}}
\DoxyCodeLine{5031 }
\DoxyCodeLine{5032 \} \textcolor{comment}{// namespace Catch}}
\DoxyCodeLine{5033 }
\DoxyCodeLine{5035 \textcolor{preprocessor}{\#define OC\_MAKE\_UNIQUE\_NAME( root, uniqueSuffix ) root\#\#uniqueSuffix}}
\DoxyCodeLine{5036 \textcolor{preprocessor}{\#define OC\_TEST\_CASE2( name, desc, uniqueSuffix ) \(\backslash\)}}
\DoxyCodeLine{5037 \textcolor{preprocessor}{+(NSString*) OC\_MAKE\_UNIQUE\_NAME( Catch\_Name\_test\_, uniqueSuffix ) \(\backslash\)}}
\DoxyCodeLine{5038 \textcolor{preprocessor}{\{ \(\backslash\)}}
\DoxyCodeLine{5039 \textcolor{preprocessor}{return @ name; \(\backslash\)}}
\DoxyCodeLine{5040 \textcolor{preprocessor}{\} \(\backslash\)}}
\DoxyCodeLine{5041 \textcolor{preprocessor}{+(NSString*) OC\_MAKE\_UNIQUE\_NAME( Catch\_Description\_test\_, uniqueSuffix ) \(\backslash\)}}
\DoxyCodeLine{5042 \textcolor{preprocessor}{\{ \(\backslash\)}}
\DoxyCodeLine{5043 \textcolor{preprocessor}{return @ desc; \(\backslash\)}}
\DoxyCodeLine{5044 \textcolor{preprocessor}{\} \(\backslash\)}}
\DoxyCodeLine{5045 \textcolor{preprocessor}{-\/(void) OC\_MAKE\_UNIQUE\_NAME( Catch\_TestCase\_test\_, uniqueSuffix )}}
\DoxyCodeLine{5046 }
\DoxyCodeLine{5047 \textcolor{preprocessor}{\#define OC\_TEST\_CASE( name, desc ) OC\_TEST\_CASE2( name, desc, \_\_LINE\_\_ )}}
\DoxyCodeLine{5048 }
\DoxyCodeLine{5049 \textcolor{comment}{// end catch\_objc.hpp}}
\DoxyCodeLine{5050 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{5051 }
\DoxyCodeLine{5052 \textcolor{comment}{// Benchmarking needs the externally-\/facing parts of reporters to work}}
\DoxyCodeLine{5053 \textcolor{preprocessor}{\#if defined(CATCH\_CONFIG\_EXTERNAL\_INTERFACES) || defined(CATCH\_CONFIG\_ENABLE\_BENCHMARKING)}}
\DoxyCodeLine{5054 \textcolor{comment}{// start catch\_external\_interfaces.h}}
\DoxyCodeLine{5055 }
\DoxyCodeLine{5056 \textcolor{comment}{// start catch\_reporter\_bases.hpp}}
\DoxyCodeLine{5057 }
\DoxyCodeLine{5058 \textcolor{comment}{// start catch\_interfaces\_reporter.h}}
\DoxyCodeLine{5059 }
\DoxyCodeLine{5060 \textcolor{comment}{// start catch\_config.hpp}}
\DoxyCodeLine{5061 }
\DoxyCodeLine{5062 \textcolor{comment}{// start catch\_test\_spec\_parser.h}}
\DoxyCodeLine{5063 }
\DoxyCodeLine{5064 \textcolor{preprocessor}{\#ifdef \_\_clang\_\_}}
\DoxyCodeLine{5065 \textcolor{preprocessor}{\#pragma clang diagnostic push}}
\DoxyCodeLine{5066 \textcolor{preprocessor}{\#pragma clang diagnostic ignored "{}-\/Wpadded"{}}}
\DoxyCodeLine{5067 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{5068 }
\DoxyCodeLine{5069 \textcolor{comment}{// start catch\_test\_spec.h}}
\DoxyCodeLine{5070 }
\DoxyCodeLine{5071 \textcolor{preprocessor}{\#ifdef \_\_clang\_\_}}
\DoxyCodeLine{5072 \textcolor{preprocessor}{\#pragma clang diagnostic push}}
\DoxyCodeLine{5073 \textcolor{preprocessor}{\#pragma clang diagnostic ignored "{}-\/Wpadded"{}}}
\DoxyCodeLine{5074 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{5075 }
\DoxyCodeLine{5076 \textcolor{comment}{// start catch\_wildcard\_pattern.h}}
\DoxyCodeLine{5077 }
\DoxyCodeLine{5078 \textcolor{keyword}{namespace }Catch}
\DoxyCodeLine{5079 \{}
\DoxyCodeLine{5080     \textcolor{keyword}{class }WildcardPattern \{}
\DoxyCodeLine{5081         \textcolor{keyword}{enum} WildcardPosition \{}
\DoxyCodeLine{5082             NoWildcard = 0,}
\DoxyCodeLine{5083             WildcardAtStart = 1,}
\DoxyCodeLine{5084             WildcardAtEnd = 2,}
\DoxyCodeLine{5085             WildcardAtBothEnds = WildcardAtStart | WildcardAtEnd}
\DoxyCodeLine{5086         \};}
\DoxyCodeLine{5087 }
\DoxyCodeLine{5088     \textcolor{keyword}{public}:}
\DoxyCodeLine{5089 }
\DoxyCodeLine{5090         WildcardPattern( std::string \textcolor{keyword}{const}\& pattern, CaseSensitive::Choice caseSensitivity );}
\DoxyCodeLine{5091         \textcolor{keyword}{virtual} \string~WildcardPattern() = \textcolor{keywordflow}{default};}
\DoxyCodeLine{5092         \textcolor{keyword}{virtual} \textcolor{keywordtype}{bool} matches( std::string \textcolor{keyword}{const}\& str ) \textcolor{keyword}{const};}
\DoxyCodeLine{5093 }
\DoxyCodeLine{5094     \textcolor{keyword}{private}:}
\DoxyCodeLine{5095         std::string normaliseString( std::string \textcolor{keyword}{const}\& str ) \textcolor{keyword}{const};}
\DoxyCodeLine{5096         CaseSensitive::Choice m\_caseSensitivity;}
\DoxyCodeLine{5097         WildcardPosition m\_wildcard = NoWildcard;}
\DoxyCodeLine{5098         std::string m\_pattern;}
\DoxyCodeLine{5099     \};}
\DoxyCodeLine{5100 \}}
\DoxyCodeLine{5101 }
\DoxyCodeLine{5102 \textcolor{comment}{// end catch\_wildcard\_pattern.h}}
\DoxyCodeLine{5103 \textcolor{preprocessor}{\#include <string>}}
\DoxyCodeLine{5104 \textcolor{preprocessor}{\#include <vector>}}
\DoxyCodeLine{5105 \textcolor{preprocessor}{\#include <memory>}}
\DoxyCodeLine{5106 }
\DoxyCodeLine{5107 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{5108 }
\DoxyCodeLine{5109     \textcolor{keyword}{struct }IConfig;}
\DoxyCodeLine{5110 }
\DoxyCodeLine{5111     \textcolor{keyword}{class }TestSpec \{}
\DoxyCodeLine{5112         \textcolor{keyword}{class }Pattern \{}
\DoxyCodeLine{5113         \textcolor{keyword}{public}:}
\DoxyCodeLine{5114             \textcolor{keyword}{explicit} Pattern( std::string \textcolor{keyword}{const}\& name );}
\DoxyCodeLine{5115             \textcolor{keyword}{virtual} \string~Pattern();}
\DoxyCodeLine{5116             \textcolor{keyword}{virtual} \textcolor{keywordtype}{bool} matches( TestCaseInfo \textcolor{keyword}{const}\& testCase ) \textcolor{keyword}{const} = 0;}
\DoxyCodeLine{5117             std::string \textcolor{keyword}{const}\& name() \textcolor{keyword}{const};}
\DoxyCodeLine{5118         \textcolor{keyword}{private}:}
\DoxyCodeLine{5119             std::string \textcolor{keyword}{const} m\_name;}
\DoxyCodeLine{5120         \};}
\DoxyCodeLine{5121         \textcolor{keyword}{using }PatternPtr = std::shared\_ptr<Pattern>;}
\DoxyCodeLine{5122 }
\DoxyCodeLine{5123         \textcolor{keyword}{class }NamePattern : \textcolor{keyword}{public} Pattern \{}
\DoxyCodeLine{5124         \textcolor{keyword}{public}:}
\DoxyCodeLine{5125             \textcolor{keyword}{explicit} NamePattern( std::string \textcolor{keyword}{const}\& name, std::string \textcolor{keyword}{const}\& filterString );}
\DoxyCodeLine{5126             \textcolor{keywordtype}{bool} matches( TestCaseInfo \textcolor{keyword}{const}\& testCase ) \textcolor{keyword}{const override};}
\DoxyCodeLine{5127         \textcolor{keyword}{private}:}
\DoxyCodeLine{5128             WildcardPattern m\_wildcardPattern;}
\DoxyCodeLine{5129         \};}
\DoxyCodeLine{5130 }
\DoxyCodeLine{5131         \textcolor{keyword}{class }TagPattern : \textcolor{keyword}{public} Pattern \{}
\DoxyCodeLine{5132         \textcolor{keyword}{public}:}
\DoxyCodeLine{5133             \textcolor{keyword}{explicit} TagPattern( std::string \textcolor{keyword}{const}\& tag, std::string \textcolor{keyword}{const}\& filterString );}
\DoxyCodeLine{5134             \textcolor{keywordtype}{bool} matches( TestCaseInfo \textcolor{keyword}{const}\& testCase ) \textcolor{keyword}{const override};}
\DoxyCodeLine{5135         \textcolor{keyword}{private}:}
\DoxyCodeLine{5136             std::string m\_tag;}
\DoxyCodeLine{5137         \};}
\DoxyCodeLine{5138 }
\DoxyCodeLine{5139         \textcolor{keyword}{class }ExcludedPattern : \textcolor{keyword}{public} Pattern \{}
\DoxyCodeLine{5140         \textcolor{keyword}{public}:}
\DoxyCodeLine{5141             \textcolor{keyword}{explicit} ExcludedPattern( PatternPtr \textcolor{keyword}{const}\& underlyingPattern );}
\DoxyCodeLine{5142             \textcolor{keywordtype}{bool} matches( TestCaseInfo \textcolor{keyword}{const}\& testCase ) \textcolor{keyword}{const override};}
\DoxyCodeLine{5143         \textcolor{keyword}{private}:}
\DoxyCodeLine{5144             PatternPtr m\_underlyingPattern;}
\DoxyCodeLine{5145         \};}
\DoxyCodeLine{5146 }
\DoxyCodeLine{5147         \textcolor{keyword}{struct }Filter \{}
\DoxyCodeLine{5148             std::vector<PatternPtr> m\_patterns;}
\DoxyCodeLine{5149 }
\DoxyCodeLine{5150             \textcolor{keywordtype}{bool} matches( TestCaseInfo \textcolor{keyword}{const}\& testCase ) \textcolor{keyword}{const};}
\DoxyCodeLine{5151             std::string name() \textcolor{keyword}{const};}
\DoxyCodeLine{5152         \};}
\DoxyCodeLine{5153 }
\DoxyCodeLine{5154     \textcolor{keyword}{public}:}
\DoxyCodeLine{5155         \textcolor{keyword}{struct }FilterMatch \{}
\DoxyCodeLine{5156             std::string name;}
\DoxyCodeLine{5157             std::vector<TestCase const*> tests;}
\DoxyCodeLine{5158         \};}
\DoxyCodeLine{5159         \textcolor{keyword}{using }Matches = std::vector<FilterMatch>;}
\DoxyCodeLine{5160         \textcolor{keyword}{using }vectorStrings = std::vector<std::string>;}
\DoxyCodeLine{5161 }
\DoxyCodeLine{5162         \textcolor{keywordtype}{bool} hasFilters() \textcolor{keyword}{const};}
\DoxyCodeLine{5163         \textcolor{keywordtype}{bool} matches( TestCaseInfo \textcolor{keyword}{const}\& testCase ) \textcolor{keyword}{const};}
\DoxyCodeLine{5164         Matches matchesByFilter( std::vector<TestCase> \textcolor{keyword}{const}\& testCases, IConfig \textcolor{keyword}{const}\& config ) \textcolor{keyword}{const};}
\DoxyCodeLine{5165         \textcolor{keyword}{const} vectorStrings \& getInvalidArgs() \textcolor{keyword}{const};}
\DoxyCodeLine{5166 }
\DoxyCodeLine{5167     \textcolor{keyword}{private}:}
\DoxyCodeLine{5168         std::vector<Filter> m\_filters;}
\DoxyCodeLine{5169         std::vector<std::string> m\_invalidArgs;}
\DoxyCodeLine{5170         \textcolor{keyword}{friend} \textcolor{keyword}{class }TestSpecParser;}
\DoxyCodeLine{5171     \};}
\DoxyCodeLine{5172 \}}
\DoxyCodeLine{5173 }
\DoxyCodeLine{5174 \textcolor{preprocessor}{\#ifdef \_\_clang\_\_}}
\DoxyCodeLine{5175 \textcolor{preprocessor}{\#pragma clang diagnostic pop}}
\DoxyCodeLine{5176 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{5177 }
\DoxyCodeLine{5178 \textcolor{comment}{// end catch\_test\_spec.h}}
\DoxyCodeLine{5179 \textcolor{comment}{// start catch\_interfaces\_tag\_alias\_registry.h}}
\DoxyCodeLine{5180 }
\DoxyCodeLine{5181 \textcolor{preprocessor}{\#include <string>}}
\DoxyCodeLine{5182 }
\DoxyCodeLine{5183 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{5184 }
\DoxyCodeLine{5185     \textcolor{keyword}{struct }TagAlias;}
\DoxyCodeLine{5186 }
\DoxyCodeLine{5187     \textcolor{keyword}{struct }ITagAliasRegistry \{}
\DoxyCodeLine{5188         \textcolor{keyword}{virtual} \string~ITagAliasRegistry();}
\DoxyCodeLine{5189         \textcolor{comment}{// Nullptr if not present}}
\DoxyCodeLine{5190         \textcolor{keyword}{virtual} TagAlias \textcolor{keyword}{const}* find( std::string \textcolor{keyword}{const}\& alias ) \textcolor{keyword}{const} = 0;}
\DoxyCodeLine{5191         \textcolor{keyword}{virtual} std::string expandAliases( std::string \textcolor{keyword}{const}\& unexpandedTestSpec ) \textcolor{keyword}{const} = 0;}
\DoxyCodeLine{5192 }
\DoxyCodeLine{5193         \textcolor{keyword}{static} ITagAliasRegistry \textcolor{keyword}{const}\& get();}
\DoxyCodeLine{5194     \};}
\DoxyCodeLine{5195 }
\DoxyCodeLine{5196 \} \textcolor{comment}{// end namespace Catch}}
\DoxyCodeLine{5197 }
\DoxyCodeLine{5198 \textcolor{comment}{// end catch\_interfaces\_tag\_alias\_registry.h}}
\DoxyCodeLine{5199 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{5200 }
\DoxyCodeLine{5201     \textcolor{keyword}{class }TestSpecParser \{}
\DoxyCodeLine{5202         \textcolor{keyword}{enum} Mode\{ None, Name, QuotedName, Tag, EscapedName \};}
\DoxyCodeLine{5203         Mode m\_mode = None;}
\DoxyCodeLine{5204         Mode lastMode = None;}
\DoxyCodeLine{5205         \textcolor{keywordtype}{bool} m\_exclusion = \textcolor{keyword}{false};}
\DoxyCodeLine{5206         std::size\_t m\_pos = 0;}
\DoxyCodeLine{5207         std::size\_t m\_realPatternPos = 0;}
\DoxyCodeLine{5208         std::string m\_arg;}
\DoxyCodeLine{5209         std::string m\_substring;}
\DoxyCodeLine{5210         std::string m\_patternName;}
\DoxyCodeLine{5211         std::vector<std::size\_t> m\_escapeChars;}
\DoxyCodeLine{5212         TestSpec::Filter m\_currentFilter;}
\DoxyCodeLine{5213         TestSpec m\_testSpec;}
\DoxyCodeLine{5214         ITagAliasRegistry \textcolor{keyword}{const}* m\_tagAliases = \textcolor{keyword}{nullptr};}
\DoxyCodeLine{5215 }
\DoxyCodeLine{5216     \textcolor{keyword}{public}:}
\DoxyCodeLine{5217         TestSpecParser( ITagAliasRegistry \textcolor{keyword}{const}\& tagAliases );}
\DoxyCodeLine{5218 }
\DoxyCodeLine{5219         TestSpecParser\& parse( std::string \textcolor{keyword}{const}\& arg );}
\DoxyCodeLine{5220         TestSpec testSpec();}
\DoxyCodeLine{5221 }
\DoxyCodeLine{5222     \textcolor{keyword}{private}:}
\DoxyCodeLine{5223         \textcolor{keywordtype}{bool} visitChar( \textcolor{keywordtype}{char} c );}
\DoxyCodeLine{5224         \textcolor{keywordtype}{void} startNewMode( Mode mode );}
\DoxyCodeLine{5225         \textcolor{keywordtype}{bool} processNoneChar( \textcolor{keywordtype}{char} c );}
\DoxyCodeLine{5226         \textcolor{keywordtype}{void} processNameChar( \textcolor{keywordtype}{char} c );}
\DoxyCodeLine{5227         \textcolor{keywordtype}{bool} processOtherChar( \textcolor{keywordtype}{char} c );}
\DoxyCodeLine{5228         \textcolor{keywordtype}{void} endMode();}
\DoxyCodeLine{5229         \textcolor{keywordtype}{void} escape();}
\DoxyCodeLine{5230         \textcolor{keywordtype}{bool} isControlChar( \textcolor{keywordtype}{char} c ) \textcolor{keyword}{const};}
\DoxyCodeLine{5231         \textcolor{keywordtype}{void} saveLastMode();}
\DoxyCodeLine{5232         \textcolor{keywordtype}{void} revertBackToLastMode();}
\DoxyCodeLine{5233         \textcolor{keywordtype}{void} addFilter();}
\DoxyCodeLine{5234         \textcolor{keywordtype}{bool} separate();}
\DoxyCodeLine{5235 }
\DoxyCodeLine{5236         \textcolor{comment}{// Handles common preprocessing of the pattern for name/tag patterns}}
\DoxyCodeLine{5237         std::string preprocessPattern();}
\DoxyCodeLine{5238         \textcolor{comment}{// Adds the current pattern as a test name}}
\DoxyCodeLine{5239         \textcolor{keywordtype}{void} addNamePattern();}
\DoxyCodeLine{5240         \textcolor{comment}{// Adds the current pattern as a tag}}
\DoxyCodeLine{5241         \textcolor{keywordtype}{void} addTagPattern();}
\DoxyCodeLine{5242 }
\DoxyCodeLine{5243         \textcolor{keyword}{inline} \textcolor{keywordtype}{void} addCharToPattern(\textcolor{keywordtype}{char} c) \{}
\DoxyCodeLine{5244             m\_substring += c;}
\DoxyCodeLine{5245             m\_patternName += c;}
\DoxyCodeLine{5246             m\_realPatternPos++;}
\DoxyCodeLine{5247         \}}
\DoxyCodeLine{5248 }
\DoxyCodeLine{5249     \};}
\DoxyCodeLine{5250     TestSpec parseTestSpec( std::string \textcolor{keyword}{const}\& arg );}
\DoxyCodeLine{5251 }
\DoxyCodeLine{5252 \} \textcolor{comment}{// namespace Catch}}
\DoxyCodeLine{5253 }
\DoxyCodeLine{5254 \textcolor{preprocessor}{\#ifdef \_\_clang\_\_}}
\DoxyCodeLine{5255 \textcolor{preprocessor}{\#pragma clang diagnostic pop}}
\DoxyCodeLine{5256 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{5257 }
\DoxyCodeLine{5258 \textcolor{comment}{// end catch\_test\_spec\_parser.h}}
\DoxyCodeLine{5259 \textcolor{comment}{// Libstdc++ doesn't like incomplete classes for unique\_ptr}}
\DoxyCodeLine{5260 }
\DoxyCodeLine{5261 \textcolor{preprocessor}{\#include <memory>}}
\DoxyCodeLine{5262 \textcolor{preprocessor}{\#include <vector>}}
\DoxyCodeLine{5263 \textcolor{preprocessor}{\#include <string>}}
\DoxyCodeLine{5264 }
\DoxyCodeLine{5265 \textcolor{preprocessor}{\#ifndef CATCH\_CONFIG\_CONSOLE\_WIDTH}}
\DoxyCodeLine{5266 \textcolor{preprocessor}{\#define CATCH\_CONFIG\_CONSOLE\_WIDTH 80}}
\DoxyCodeLine{5267 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{5268 }
\DoxyCodeLine{5269 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{5270 }
\DoxyCodeLine{5271     \textcolor{keyword}{struct }IStream;}
\DoxyCodeLine{5272 }
\DoxyCodeLine{5273     \textcolor{keyword}{struct }ConfigData \{}
\DoxyCodeLine{5274         \textcolor{keywordtype}{bool} listTests = \textcolor{keyword}{false};}
\DoxyCodeLine{5275         \textcolor{keywordtype}{bool} listTags = \textcolor{keyword}{false};}
\DoxyCodeLine{5276         \textcolor{keywordtype}{bool} listReporters = \textcolor{keyword}{false};}
\DoxyCodeLine{5277         \textcolor{keywordtype}{bool} listTestNamesOnly = \textcolor{keyword}{false};}
\DoxyCodeLine{5278 }
\DoxyCodeLine{5279         \textcolor{keywordtype}{bool} showSuccessfulTests = \textcolor{keyword}{false};}
\DoxyCodeLine{5280         \textcolor{keywordtype}{bool} shouldDebugBreak = \textcolor{keyword}{false};}
\DoxyCodeLine{5281         \textcolor{keywordtype}{bool} noThrow = \textcolor{keyword}{false};}
\DoxyCodeLine{5282         \textcolor{keywordtype}{bool} showHelp = \textcolor{keyword}{false};}
\DoxyCodeLine{5283         \textcolor{keywordtype}{bool} showInvisibles = \textcolor{keyword}{false};}
\DoxyCodeLine{5284         \textcolor{keywordtype}{bool} filenamesAsTags = \textcolor{keyword}{false};}
\DoxyCodeLine{5285         \textcolor{keywordtype}{bool} libIdentify = \textcolor{keyword}{false};}
\DoxyCodeLine{5286 }
\DoxyCodeLine{5287         \textcolor{keywordtype}{int} abortAfter = -\/1;}
\DoxyCodeLine{5288         \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} rngSeed = 0;}
\DoxyCodeLine{5289 }
\DoxyCodeLine{5290         \textcolor{keywordtype}{bool} benchmarkNoAnalysis = \textcolor{keyword}{false};}
\DoxyCodeLine{5291         \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} benchmarkSamples = 100;}
\DoxyCodeLine{5292         \textcolor{keywordtype}{double} benchmarkConfidenceInterval = 0.95;}
\DoxyCodeLine{5293         \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} benchmarkResamples = 100000;}
\DoxyCodeLine{5294         std::chrono::milliseconds::rep benchmarkWarmupTime = 100;}
\DoxyCodeLine{5295 }
\DoxyCodeLine{5296         Verbosity verbosity = Verbosity::Normal;}
\DoxyCodeLine{5297         WarnAbout::What warnings = WarnAbout::Nothing;}
\DoxyCodeLine{5298         ShowDurations::OrNot showDurations = ShowDurations::DefaultForReporter;}
\DoxyCodeLine{5299         \textcolor{keywordtype}{double} minDuration = -\/1;}
\DoxyCodeLine{5300         RunTests::InWhatOrder runOrder = RunTests::InDeclarationOrder;}
\DoxyCodeLine{5301         UseColour::YesOrNo useColour = UseColour::Auto;}
\DoxyCodeLine{5302         WaitForKeypress::When waitForKeypress = WaitForKeypress::Never;}
\DoxyCodeLine{5303 }
\DoxyCodeLine{5304         std::string outputFilename;}
\DoxyCodeLine{5305         std::string name;}
\DoxyCodeLine{5306         std::string processName;}
\DoxyCodeLine{5307 \textcolor{preprocessor}{\#ifndef CATCH\_CONFIG\_DEFAULT\_REPORTER}}
\DoxyCodeLine{5308 \textcolor{preprocessor}{\#define CATCH\_CONFIG\_DEFAULT\_REPORTER "{}console"{}}}
\DoxyCodeLine{5309 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{5310         std::string reporterName = CATCH\_CONFIG\_DEFAULT\_REPORTER;}
\DoxyCodeLine{5311 \textcolor{preprocessor}{\#undef CATCH\_CONFIG\_DEFAULT\_REPORTER}}
\DoxyCodeLine{5312 }
\DoxyCodeLine{5313         std::vector<std::string> testsOrTags;}
\DoxyCodeLine{5314         std::vector<std::string> sectionsToRun;}
\DoxyCodeLine{5315     \};}
\DoxyCodeLine{5316 }
\DoxyCodeLine{5317     \textcolor{keyword}{class }Config : \textcolor{keyword}{public} IConfig \{}
\DoxyCodeLine{5318     \textcolor{keyword}{public}:}
\DoxyCodeLine{5319 }
\DoxyCodeLine{5320         Config() = \textcolor{keywordflow}{default};}
\DoxyCodeLine{5321         Config( ConfigData \textcolor{keyword}{const}\& data );}
\DoxyCodeLine{5322         \textcolor{keyword}{virtual} \string~Config() = \textcolor{keywordflow}{default};}
\DoxyCodeLine{5323 }
\DoxyCodeLine{5324         std::string \textcolor{keyword}{const}\& getFilename() \textcolor{keyword}{const};}
\DoxyCodeLine{5325 }
\DoxyCodeLine{5326         \textcolor{keywordtype}{bool} listTests() \textcolor{keyword}{const};}
\DoxyCodeLine{5327         \textcolor{keywordtype}{bool} listTestNamesOnly() \textcolor{keyword}{const};}
\DoxyCodeLine{5328         \textcolor{keywordtype}{bool} listTags() \textcolor{keyword}{const};}
\DoxyCodeLine{5329         \textcolor{keywordtype}{bool} listReporters() \textcolor{keyword}{const};}
\DoxyCodeLine{5330 }
\DoxyCodeLine{5331         std::string getProcessName() \textcolor{keyword}{const};}
\DoxyCodeLine{5332         std::string \textcolor{keyword}{const}\& getReporterName() \textcolor{keyword}{const};}
\DoxyCodeLine{5333 }
\DoxyCodeLine{5334         std::vector<std::string> \textcolor{keyword}{const}\& getTestsOrTags() \textcolor{keyword}{const override};}
\DoxyCodeLine{5335         std::vector<std::string> \textcolor{keyword}{const}\& getSectionsToRun() \textcolor{keyword}{const override};}
\DoxyCodeLine{5336 }
\DoxyCodeLine{5337         TestSpec \textcolor{keyword}{const}\& testSpec() \textcolor{keyword}{const override};}
\DoxyCodeLine{5338         \textcolor{keywordtype}{bool} hasTestFilters() \textcolor{keyword}{const override};}
\DoxyCodeLine{5339 }
\DoxyCodeLine{5340         \textcolor{keywordtype}{bool} showHelp() \textcolor{keyword}{const};}
\DoxyCodeLine{5341 }
\DoxyCodeLine{5342         \textcolor{comment}{// IConfig interface}}
\DoxyCodeLine{5343         \textcolor{keywordtype}{bool} allowThrows() \textcolor{keyword}{const override};}
\DoxyCodeLine{5344         std::ostream\& stream() \textcolor{keyword}{const override};}
\DoxyCodeLine{5345         std::string name() \textcolor{keyword}{const override};}
\DoxyCodeLine{5346         \textcolor{keywordtype}{bool} includeSuccessfulResults() \textcolor{keyword}{const override};}
\DoxyCodeLine{5347         \textcolor{keywordtype}{bool} warnAboutMissingAssertions() \textcolor{keyword}{const override};}
\DoxyCodeLine{5348         \textcolor{keywordtype}{bool} warnAboutNoTests() \textcolor{keyword}{const override};}
\DoxyCodeLine{5349         ShowDurations::OrNot showDurations() \textcolor{keyword}{const override};}
\DoxyCodeLine{5350         \textcolor{keywordtype}{double} minDuration() \textcolor{keyword}{const override};}
\DoxyCodeLine{5351         RunTests::InWhatOrder runOrder() \textcolor{keyword}{const override};}
\DoxyCodeLine{5352         \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} rngSeed() \textcolor{keyword}{const override};}
\DoxyCodeLine{5353         UseColour::YesOrNo useColour() \textcolor{keyword}{const override};}
\DoxyCodeLine{5354         \textcolor{keywordtype}{bool} shouldDebugBreak() \textcolor{keyword}{const override};}
\DoxyCodeLine{5355         \textcolor{keywordtype}{int} abortAfter() \textcolor{keyword}{const override};}
\DoxyCodeLine{5356         \textcolor{keywordtype}{bool} showInvisibles() \textcolor{keyword}{const override};}
\DoxyCodeLine{5357         Verbosity verbosity() \textcolor{keyword}{const override};}
\DoxyCodeLine{5358         \textcolor{keywordtype}{bool} benchmarkNoAnalysis() \textcolor{keyword}{const override};}
\DoxyCodeLine{5359         \textcolor{keywordtype}{int} benchmarkSamples() \textcolor{keyword}{const override};}
\DoxyCodeLine{5360         \textcolor{keywordtype}{double} benchmarkConfidenceInterval() \textcolor{keyword}{const override};}
\DoxyCodeLine{5361         \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} benchmarkResamples() \textcolor{keyword}{const override};}
\DoxyCodeLine{5362         std::chrono::milliseconds benchmarkWarmupTime() \textcolor{keyword}{const override};}
\DoxyCodeLine{5363 }
\DoxyCodeLine{5364     \textcolor{keyword}{private}:}
\DoxyCodeLine{5365 }
\DoxyCodeLine{5366         IStream \textcolor{keyword}{const}* openStream();}
\DoxyCodeLine{5367         ConfigData m\_data;}
\DoxyCodeLine{5368 }
\DoxyCodeLine{5369         std::unique\_ptr<IStream const> m\_stream;}
\DoxyCodeLine{5370         TestSpec m\_testSpec;}
\DoxyCodeLine{5371         \textcolor{keywordtype}{bool} m\_hasTestFilters = \textcolor{keyword}{false};}
\DoxyCodeLine{5372     \};}
\DoxyCodeLine{5373 }
\DoxyCodeLine{5374 \} \textcolor{comment}{// end namespace Catch}}
\DoxyCodeLine{5375 }
\DoxyCodeLine{5376 \textcolor{comment}{// end catch\_config.hpp}}
\DoxyCodeLine{5377 \textcolor{comment}{// start catch\_assertionresult.h}}
\DoxyCodeLine{5378 }
\DoxyCodeLine{5379 \textcolor{preprocessor}{\#include <string>}}
\DoxyCodeLine{5380 }
\DoxyCodeLine{5381 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{5382 }
\DoxyCodeLine{5383     \textcolor{keyword}{struct }AssertionResultData}
\DoxyCodeLine{5384     \{}
\DoxyCodeLine{5385         AssertionResultData() = \textcolor{keyword}{delete};}
\DoxyCodeLine{5386 }
\DoxyCodeLine{5387         AssertionResultData( ResultWas::OfType \_resultType, LazyExpression \textcolor{keyword}{const}\& \_lazyExpression );}
\DoxyCodeLine{5388 }
\DoxyCodeLine{5389         std::string message;}
\DoxyCodeLine{5390         \textcolor{keyword}{mutable} std::string reconstructedExpression;}
\DoxyCodeLine{5391         LazyExpression lazyExpression;}
\DoxyCodeLine{5392         ResultWas::OfType resultType;}
\DoxyCodeLine{5393 }
\DoxyCodeLine{5394         std::string reconstructExpression() \textcolor{keyword}{const};}
\DoxyCodeLine{5395     \};}
\DoxyCodeLine{5396 }
\DoxyCodeLine{5397     \textcolor{keyword}{class }AssertionResult \{}
\DoxyCodeLine{5398     \textcolor{keyword}{public}:}
\DoxyCodeLine{5399         AssertionResult() = \textcolor{keyword}{delete};}
\DoxyCodeLine{5400         AssertionResult( AssertionInfo \textcolor{keyword}{const}\& info, AssertionResultData \textcolor{keyword}{const}\& data );}
\DoxyCodeLine{5401 }
\DoxyCodeLine{5402         \textcolor{keywordtype}{bool} isOk() \textcolor{keyword}{const};}
\DoxyCodeLine{5403         \textcolor{keywordtype}{bool} succeeded() \textcolor{keyword}{const};}
\DoxyCodeLine{5404         ResultWas::OfType getResultType() \textcolor{keyword}{const};}
\DoxyCodeLine{5405         \textcolor{keywordtype}{bool} hasExpression() \textcolor{keyword}{const};}
\DoxyCodeLine{5406         \textcolor{keywordtype}{bool} hasMessage() \textcolor{keyword}{const};}
\DoxyCodeLine{5407         std::string getExpression() \textcolor{keyword}{const};}
\DoxyCodeLine{5408         std::string getExpressionInMacro() \textcolor{keyword}{const};}
\DoxyCodeLine{5409         \textcolor{keywordtype}{bool} hasExpandedExpression() \textcolor{keyword}{const};}
\DoxyCodeLine{5410         std::string getExpandedExpression() \textcolor{keyword}{const};}
\DoxyCodeLine{5411         std::string getMessage() \textcolor{keyword}{const};}
\DoxyCodeLine{5412         SourceLineInfo getSourceInfo() \textcolor{keyword}{const};}
\DoxyCodeLine{5413         StringRef getTestMacroName() \textcolor{keyword}{const};}
\DoxyCodeLine{5414 }
\DoxyCodeLine{5415     \textcolor{comment}{//protected:}}
\DoxyCodeLine{5416         AssertionInfo m\_info;}
\DoxyCodeLine{5417         AssertionResultData m\_resultData;}
\DoxyCodeLine{5418     \};}
\DoxyCodeLine{5419 }
\DoxyCodeLine{5420 \} \textcolor{comment}{// end namespace Catch}}
\DoxyCodeLine{5421 }
\DoxyCodeLine{5422 \textcolor{comment}{// end catch\_assertionresult.h}}
\DoxyCodeLine{5423 \textcolor{preprocessor}{\#if defined(CATCH\_CONFIG\_ENABLE\_BENCHMARKING)}}
\DoxyCodeLine{5424 \textcolor{comment}{// start catch\_estimate.hpp}}
\DoxyCodeLine{5425 }
\DoxyCodeLine{5426  \textcolor{comment}{// Statistics estimates}}
\DoxyCodeLine{5427 }
\DoxyCodeLine{5428 }
\DoxyCodeLine{5429 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{5430     \textcolor{keyword}{namespace }Benchmark \{}
\DoxyCodeLine{5431         \textcolor{keyword}{template} <\textcolor{keyword}{typename} Duration>}
\DoxyCodeLine{5432         \textcolor{keyword}{struct }Estimate \{}
\DoxyCodeLine{5433             Duration point;}
\DoxyCodeLine{5434             Duration lower\_bound;}
\DoxyCodeLine{5435             Duration upper\_bound;}
\DoxyCodeLine{5436             \textcolor{keywordtype}{double} confidence\_interval;}
\DoxyCodeLine{5437 }
\DoxyCodeLine{5438             \textcolor{keyword}{template} <\textcolor{keyword}{typename} Duration2>}
\DoxyCodeLine{5439             \textcolor{keyword}{operator} Estimate<Duration2>()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{5440                 \textcolor{keywordflow}{return} \{ point, lower\_bound, upper\_bound, confidence\_interval \};}
\DoxyCodeLine{5441             \}}
\DoxyCodeLine{5442         \};}
\DoxyCodeLine{5443     \} \textcolor{comment}{// namespace Benchmark}}
\DoxyCodeLine{5444 \} \textcolor{comment}{// namespace Catch}}
\DoxyCodeLine{5445 }
\DoxyCodeLine{5446 \textcolor{comment}{// end catch\_estimate.hpp}}
\DoxyCodeLine{5447 \textcolor{comment}{// start catch\_outlier\_classification.hpp}}
\DoxyCodeLine{5448 }
\DoxyCodeLine{5449 \textcolor{comment}{// Outlier information}}
\DoxyCodeLine{5450 }
\DoxyCodeLine{5451 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{5452     \textcolor{keyword}{namespace }Benchmark \{}
\DoxyCodeLine{5453         \textcolor{keyword}{struct }OutlierClassification \{}
\DoxyCodeLine{5454             \textcolor{keywordtype}{int} samples\_seen = 0;}
\DoxyCodeLine{5455             \textcolor{keywordtype}{int} low\_severe = 0;     \textcolor{comment}{// more than 3 times IQR below Q1}}
\DoxyCodeLine{5456             \textcolor{keywordtype}{int} low\_mild = 0;       \textcolor{comment}{// 1.5 to 3 times IQR below Q1}}
\DoxyCodeLine{5457             \textcolor{keywordtype}{int} high\_mild = 0;      \textcolor{comment}{// 1.5 to 3 times IQR above Q3}}
\DoxyCodeLine{5458             \textcolor{keywordtype}{int} high\_severe = 0;    \textcolor{comment}{// more than 3 times IQR above Q3}}
\DoxyCodeLine{5459 }
\DoxyCodeLine{5460             \textcolor{keywordtype}{int} total()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{5461                 \textcolor{keywordflow}{return} low\_severe + low\_mild + high\_mild + high\_severe;}
\DoxyCodeLine{5462             \}}
\DoxyCodeLine{5463         \};}
\DoxyCodeLine{5464     \} \textcolor{comment}{// namespace Benchmark}}
\DoxyCodeLine{5465 \} \textcolor{comment}{// namespace Catch}}
\DoxyCodeLine{5466 }
\DoxyCodeLine{5467 \textcolor{comment}{// end catch\_outlier\_classification.hpp}}
\DoxyCodeLine{5468 }
\DoxyCodeLine{5469 \textcolor{preprocessor}{\#include <iterator>}}
\DoxyCodeLine{5470 \textcolor{preprocessor}{\#endif }\textcolor{comment}{// CATCH\_CONFIG\_ENABLE\_BENCHMARKING}}
\DoxyCodeLine{5471 }
\DoxyCodeLine{5472 \textcolor{preprocessor}{\#include <string>}}
\DoxyCodeLine{5473 \textcolor{preprocessor}{\#include <iosfwd>}}
\DoxyCodeLine{5474 \textcolor{preprocessor}{\#include <map>}}
\DoxyCodeLine{5475 \textcolor{preprocessor}{\#include <set>}}
\DoxyCodeLine{5476 \textcolor{preprocessor}{\#include <memory>}}
\DoxyCodeLine{5477 \textcolor{preprocessor}{\#include <algorithm>}}
\DoxyCodeLine{5478 }
\DoxyCodeLine{5479 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{5480 }
\DoxyCodeLine{5481     \textcolor{keyword}{struct }ReporterConfig \{}
\DoxyCodeLine{5482         \textcolor{keyword}{explicit} ReporterConfig( IConfigPtr \textcolor{keyword}{const}\& \_fullConfig );}
\DoxyCodeLine{5483 }
\DoxyCodeLine{5484         ReporterConfig( IConfigPtr \textcolor{keyword}{const}\& \_fullConfig, std::ostream\& \_stream );}
\DoxyCodeLine{5485 }
\DoxyCodeLine{5486         std::ostream\& stream() \textcolor{keyword}{const};}
\DoxyCodeLine{5487         IConfigPtr fullConfig() \textcolor{keyword}{const};}
\DoxyCodeLine{5488 }
\DoxyCodeLine{5489     \textcolor{keyword}{private}:}
\DoxyCodeLine{5490         std::ostream* m\_stream;}
\DoxyCodeLine{5491         IConfigPtr m\_fullConfig;}
\DoxyCodeLine{5492     \};}
\DoxyCodeLine{5493 }
\DoxyCodeLine{5494     \textcolor{keyword}{struct }ReporterPreferences \{}
\DoxyCodeLine{5495         \textcolor{keywordtype}{bool} shouldRedirectStdOut = \textcolor{keyword}{false};}
\DoxyCodeLine{5496         \textcolor{keywordtype}{bool} shouldReportAllAssertions = \textcolor{keyword}{false};}
\DoxyCodeLine{5497     \};}
\DoxyCodeLine{5498 }
\DoxyCodeLine{5499     \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{5500     \textcolor{keyword}{struct }LazyStat : Option<T> \{}
\DoxyCodeLine{5501         LazyStat\& operator=( T \textcolor{keyword}{const}\& \_value ) \{}
\DoxyCodeLine{5502             Option<T>::operator=( \_value );}
\DoxyCodeLine{5503             used = \textcolor{keyword}{false};}
\DoxyCodeLine{5504             \textcolor{keywordflow}{return} *\textcolor{keyword}{this};}
\DoxyCodeLine{5505         \}}
\DoxyCodeLine{5506         \textcolor{keywordtype}{void} reset() \{}
\DoxyCodeLine{5507             Option<T>::reset();}
\DoxyCodeLine{5508             used = \textcolor{keyword}{false};}
\DoxyCodeLine{5509         \}}
\DoxyCodeLine{5510         \textcolor{keywordtype}{bool} used = \textcolor{keyword}{false};}
\DoxyCodeLine{5511     \};}
\DoxyCodeLine{5512 }
\DoxyCodeLine{5513     \textcolor{keyword}{struct }TestRunInfo \{}
\DoxyCodeLine{5514         TestRunInfo( std::string \textcolor{keyword}{const}\& \_name );}
\DoxyCodeLine{5515         std::string name;}
\DoxyCodeLine{5516     \};}
\DoxyCodeLine{5517     \textcolor{keyword}{struct }GroupInfo \{}
\DoxyCodeLine{5518         GroupInfo(  std::string \textcolor{keyword}{const}\& \_name,}
\DoxyCodeLine{5519                     std::size\_t \_groupIndex,}
\DoxyCodeLine{5520                     std::size\_t \_groupsCount );}
\DoxyCodeLine{5521 }
\DoxyCodeLine{5522         std::string name;}
\DoxyCodeLine{5523         std::size\_t groupIndex;}
\DoxyCodeLine{5524         std::size\_t groupsCounts;}
\DoxyCodeLine{5525     \};}
\DoxyCodeLine{5526 }
\DoxyCodeLine{5527     \textcolor{keyword}{struct }AssertionStats \{}
\DoxyCodeLine{5528         AssertionStats( AssertionResult \textcolor{keyword}{const}\& \_assertionResult,}
\DoxyCodeLine{5529                         std::vector<MessageInfo> \textcolor{keyword}{const}\& \_infoMessages,}
\DoxyCodeLine{5530                         Totals \textcolor{keyword}{const}\& \_totals );}
\DoxyCodeLine{5531 }
\DoxyCodeLine{5532         AssertionStats( AssertionStats \textcolor{keyword}{const}\& )              = \textcolor{keywordflow}{default};}
\DoxyCodeLine{5533         AssertionStats( AssertionStats \&\& )                  = \textcolor{keywordflow}{default};}
\DoxyCodeLine{5534         AssertionStats\& operator = ( AssertionStats \textcolor{keyword}{const}\& ) = \textcolor{keyword}{delete};}
\DoxyCodeLine{5535         AssertionStats\& operator = ( AssertionStats \&\& )     = \textcolor{keyword}{delete};}
\DoxyCodeLine{5536         \textcolor{keyword}{virtual} \string~AssertionStats();}
\DoxyCodeLine{5537 }
\DoxyCodeLine{5538         AssertionResult assertionResult;}
\DoxyCodeLine{5539         std::vector<MessageInfo> infoMessages;}
\DoxyCodeLine{5540         Totals totals;}
\DoxyCodeLine{5541     \};}
\DoxyCodeLine{5542 }
\DoxyCodeLine{5543     \textcolor{keyword}{struct }SectionStats \{}
\DoxyCodeLine{5544         SectionStats(   SectionInfo \textcolor{keyword}{const}\& \_sectionInfo,}
\DoxyCodeLine{5545                         Counts \textcolor{keyword}{const}\& \_assertions,}
\DoxyCodeLine{5546                         \textcolor{keywordtype}{double} \_durationInSeconds,}
\DoxyCodeLine{5547                         \textcolor{keywordtype}{bool} \_missingAssertions );}
\DoxyCodeLine{5548         SectionStats( SectionStats \textcolor{keyword}{const}\& )              = \textcolor{keywordflow}{default};}
\DoxyCodeLine{5549         SectionStats( SectionStats \&\& )                  = \textcolor{keywordflow}{default};}
\DoxyCodeLine{5550         SectionStats\& operator = ( SectionStats \textcolor{keyword}{const}\& ) = \textcolor{keywordflow}{default};}
\DoxyCodeLine{5551         SectionStats\& operator = ( SectionStats \&\& )     = \textcolor{keywordflow}{default};}
\DoxyCodeLine{5552         \textcolor{keyword}{virtual} \string~SectionStats();}
\DoxyCodeLine{5553 }
\DoxyCodeLine{5554         SectionInfo sectionInfo;}
\DoxyCodeLine{5555         Counts assertions;}
\DoxyCodeLine{5556         \textcolor{keywordtype}{double} durationInSeconds;}
\DoxyCodeLine{5557         \textcolor{keywordtype}{bool} missingAssertions;}
\DoxyCodeLine{5558     \};}
\DoxyCodeLine{5559 }
\DoxyCodeLine{5560     \textcolor{keyword}{struct }TestCaseStats \{}
\DoxyCodeLine{5561         TestCaseStats(  TestCaseInfo \textcolor{keyword}{const}\& \_testInfo,}
\DoxyCodeLine{5562                         Totals \textcolor{keyword}{const}\& \_totals,}
\DoxyCodeLine{5563                         std::string \textcolor{keyword}{const}\& \_stdOut,}
\DoxyCodeLine{5564                         std::string \textcolor{keyword}{const}\& \_stdErr,}
\DoxyCodeLine{5565                         \textcolor{keywordtype}{bool} \_aborting );}
\DoxyCodeLine{5566 }
\DoxyCodeLine{5567         TestCaseStats( TestCaseStats \textcolor{keyword}{const}\& )              = \textcolor{keywordflow}{default};}
\DoxyCodeLine{5568         TestCaseStats( TestCaseStats \&\& )                  = \textcolor{keywordflow}{default};}
\DoxyCodeLine{5569         TestCaseStats\& operator = ( TestCaseStats \textcolor{keyword}{const}\& ) = \textcolor{keywordflow}{default};}
\DoxyCodeLine{5570         TestCaseStats\& operator = ( TestCaseStats \&\& )     = \textcolor{keywordflow}{default};}
\DoxyCodeLine{5571         \textcolor{keyword}{virtual} \string~TestCaseStats();}
\DoxyCodeLine{5572 }
\DoxyCodeLine{5573         TestCaseInfo testInfo;}
\DoxyCodeLine{5574         Totals totals;}
\DoxyCodeLine{5575         std::string stdOut;}
\DoxyCodeLine{5576         std::string stdErr;}
\DoxyCodeLine{5577         \textcolor{keywordtype}{bool} aborting;}
\DoxyCodeLine{5578     \};}
\DoxyCodeLine{5579 }
\DoxyCodeLine{5580     \textcolor{keyword}{struct }TestGroupStats \{}
\DoxyCodeLine{5581         TestGroupStats( GroupInfo \textcolor{keyword}{const}\& \_groupInfo,}
\DoxyCodeLine{5582                         Totals \textcolor{keyword}{const}\& \_totals,}
\DoxyCodeLine{5583                         \textcolor{keywordtype}{bool} \_aborting );}
\DoxyCodeLine{5584         TestGroupStats( GroupInfo \textcolor{keyword}{const}\& \_groupInfo );}
\DoxyCodeLine{5585 }
\DoxyCodeLine{5586         TestGroupStats( TestGroupStats \textcolor{keyword}{const}\& )              = \textcolor{keywordflow}{default};}
\DoxyCodeLine{5587         TestGroupStats( TestGroupStats \&\& )                  = \textcolor{keywordflow}{default};}
\DoxyCodeLine{5588         TestGroupStats\& operator = ( TestGroupStats \textcolor{keyword}{const}\& ) = \textcolor{keywordflow}{default};}
\DoxyCodeLine{5589         TestGroupStats\& operator = ( TestGroupStats \&\& )     = \textcolor{keywordflow}{default};}
\DoxyCodeLine{5590         \textcolor{keyword}{virtual} \string~TestGroupStats();}
\DoxyCodeLine{5591 }
\DoxyCodeLine{5592         GroupInfo groupInfo;}
\DoxyCodeLine{5593         Totals totals;}
\DoxyCodeLine{5594         \textcolor{keywordtype}{bool} aborting;}
\DoxyCodeLine{5595     \};}
\DoxyCodeLine{5596 }
\DoxyCodeLine{5597     \textcolor{keyword}{struct }TestRunStats \{}
\DoxyCodeLine{5598         TestRunStats(   TestRunInfo \textcolor{keyword}{const}\& \_runInfo,}
\DoxyCodeLine{5599                         Totals \textcolor{keyword}{const}\& \_totals,}
\DoxyCodeLine{5600                         \textcolor{keywordtype}{bool} \_aborting );}
\DoxyCodeLine{5601 }
\DoxyCodeLine{5602         TestRunStats( TestRunStats \textcolor{keyword}{const}\& )              = \textcolor{keywordflow}{default};}
\DoxyCodeLine{5603         TestRunStats( TestRunStats \&\& )                  = \textcolor{keywordflow}{default};}
\DoxyCodeLine{5604         TestRunStats\& operator = ( TestRunStats \textcolor{keyword}{const}\& ) = \textcolor{keywordflow}{default};}
\DoxyCodeLine{5605         TestRunStats\& operator = ( TestRunStats \&\& )     = \textcolor{keywordflow}{default};}
\DoxyCodeLine{5606         \textcolor{keyword}{virtual} \string~TestRunStats();}
\DoxyCodeLine{5607 }
\DoxyCodeLine{5608         TestRunInfo runInfo;}
\DoxyCodeLine{5609         Totals totals;}
\DoxyCodeLine{5610         \textcolor{keywordtype}{bool} aborting;}
\DoxyCodeLine{5611     \};}
\DoxyCodeLine{5612 }
\DoxyCodeLine{5613 \textcolor{preprocessor}{\#if defined(CATCH\_CONFIG\_ENABLE\_BENCHMARKING)}}
\DoxyCodeLine{5614     \textcolor{keyword}{struct }BenchmarkInfo \{}
\DoxyCodeLine{5615         std::string name;}
\DoxyCodeLine{5616         \textcolor{keywordtype}{double} estimatedDuration;}
\DoxyCodeLine{5617         \textcolor{keywordtype}{int} iterations;}
\DoxyCodeLine{5618         \textcolor{keywordtype}{int} samples;}
\DoxyCodeLine{5619         \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} resamples;}
\DoxyCodeLine{5620         \textcolor{keywordtype}{double} clockResolution;}
\DoxyCodeLine{5621         \textcolor{keywordtype}{double} clockCost;}
\DoxyCodeLine{5622     \};}
\DoxyCodeLine{5623 }
\DoxyCodeLine{5624     \textcolor{keyword}{template} <\textcolor{keyword}{class} Duration>}
\DoxyCodeLine{5625     \textcolor{keyword}{struct }BenchmarkStats \{}
\DoxyCodeLine{5626         BenchmarkInfo info;}
\DoxyCodeLine{5627 }
\DoxyCodeLine{5628         std::vector<Duration> samples;}
\DoxyCodeLine{5629         Benchmark::Estimate<Duration> mean;}
\DoxyCodeLine{5630         Benchmark::Estimate<Duration> standardDeviation;}
\DoxyCodeLine{5631         Benchmark::OutlierClassification outliers;}
\DoxyCodeLine{5632         \textcolor{keywordtype}{double} outlierVariance;}
\DoxyCodeLine{5633 }
\DoxyCodeLine{5634         \textcolor{keyword}{template} <\textcolor{keyword}{typename} Duration2>}
\DoxyCodeLine{5635         \textcolor{keyword}{operator} BenchmarkStats<Duration2>()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{5636             std::vector<Duration2> samples2;}
\DoxyCodeLine{5637             samples2.reserve(samples.size());}
\DoxyCodeLine{5638             std::transform(samples.begin(), samples.end(), std::back\_inserter(samples2), [](Duration d) \{ return Duration2(d); \});}
\DoxyCodeLine{5639             \textcolor{keywordflow}{return} \{}
\DoxyCodeLine{5640                 info,}
\DoxyCodeLine{5641                 std::move(samples2),}
\DoxyCodeLine{5642                 mean,}
\DoxyCodeLine{5643                 standardDeviation,}
\DoxyCodeLine{5644                 outliers,}
\DoxyCodeLine{5645                 outlierVariance,}
\DoxyCodeLine{5646             \};}
\DoxyCodeLine{5647         \}}
\DoxyCodeLine{5648     \};}
\DoxyCodeLine{5649 \textcolor{preprocessor}{\#endif }\textcolor{comment}{// CATCH\_CONFIG\_ENABLE\_BENCHMARKING}}
\DoxyCodeLine{5650 }
\DoxyCodeLine{5651     \textcolor{keyword}{struct }IStreamingReporter \{}
\DoxyCodeLine{5652         \textcolor{keyword}{virtual} \string~IStreamingReporter() = \textcolor{keywordflow}{default};}
\DoxyCodeLine{5653 }
\DoxyCodeLine{5654         \textcolor{comment}{// Implementing class must also provide the following static methods:}}
\DoxyCodeLine{5655         \textcolor{comment}{// static std::string getDescription();}}
\DoxyCodeLine{5656         \textcolor{comment}{// static std::set<Verbosity> getSupportedVerbosities()}}
\DoxyCodeLine{5657 }
\DoxyCodeLine{5658         \textcolor{keyword}{virtual} ReporterPreferences getPreferences() \textcolor{keyword}{const} = 0;}
\DoxyCodeLine{5659 }
\DoxyCodeLine{5660         \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} noMatchingTestCases( std::string \textcolor{keyword}{const}\& spec ) = 0;}
\DoxyCodeLine{5661 }
\DoxyCodeLine{5662         \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} reportInvalidArguments(std::string \textcolor{keyword}{const}\&) \{\}}
\DoxyCodeLine{5663 }
\DoxyCodeLine{5664         \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} testRunStarting( TestRunInfo \textcolor{keyword}{const}\& testRunInfo ) = 0;}
\DoxyCodeLine{5665         \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} testGroupStarting( GroupInfo \textcolor{keyword}{const}\& groupInfo ) = 0;}
\DoxyCodeLine{5666 }
\DoxyCodeLine{5667         \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} testCaseStarting( TestCaseInfo \textcolor{keyword}{const}\& testInfo ) = 0;}
\DoxyCodeLine{5668         \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} sectionStarting( SectionInfo \textcolor{keyword}{const}\& sectionInfo ) = 0;}
\DoxyCodeLine{5669 }
\DoxyCodeLine{5670 \textcolor{preprocessor}{\#if defined(CATCH\_CONFIG\_ENABLE\_BENCHMARKING)}}
\DoxyCodeLine{5671         \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} benchmarkPreparing( std::string \textcolor{keyword}{const}\& ) \{\}}
\DoxyCodeLine{5672         \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} benchmarkStarting( BenchmarkInfo \textcolor{keyword}{const}\& ) \{\}}
\DoxyCodeLine{5673         \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} benchmarkEnded( BenchmarkStats<> \textcolor{keyword}{const}\& ) \{\}}
\DoxyCodeLine{5674         \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} benchmarkFailed( std::string \textcolor{keyword}{const}\& ) \{\}}
\DoxyCodeLine{5675 \textcolor{preprocessor}{\#endif }\textcolor{comment}{// CATCH\_CONFIG\_ENABLE\_BENCHMARKING}}
\DoxyCodeLine{5676 }
\DoxyCodeLine{5677         \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} assertionStarting( AssertionInfo \textcolor{keyword}{const}\& assertionInfo ) = 0;}
\DoxyCodeLine{5678 }
\DoxyCodeLine{5679         \textcolor{comment}{// The return value indicates if the messages buffer should be cleared:}}
\DoxyCodeLine{5680         \textcolor{keyword}{virtual} \textcolor{keywordtype}{bool} assertionEnded( AssertionStats \textcolor{keyword}{const}\& assertionStats ) = 0;}
\DoxyCodeLine{5681 }
\DoxyCodeLine{5682         \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} sectionEnded( SectionStats \textcolor{keyword}{const}\& sectionStats ) = 0;}
\DoxyCodeLine{5683         \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} testCaseEnded( TestCaseStats \textcolor{keyword}{const}\& testCaseStats ) = 0;}
\DoxyCodeLine{5684         \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} testGroupEnded( TestGroupStats \textcolor{keyword}{const}\& testGroupStats ) = 0;}
\DoxyCodeLine{5685         \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} testRunEnded( TestRunStats \textcolor{keyword}{const}\& testRunStats ) = 0;}
\DoxyCodeLine{5686 }
\DoxyCodeLine{5687         \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} skipTest( TestCaseInfo \textcolor{keyword}{const}\& testInfo ) = 0;}
\DoxyCodeLine{5688 }
\DoxyCodeLine{5689         \textcolor{comment}{// Default empty implementation provided}}
\DoxyCodeLine{5690         \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} fatalErrorEncountered( StringRef name );}
\DoxyCodeLine{5691 }
\DoxyCodeLine{5692         \textcolor{keyword}{virtual} \textcolor{keywordtype}{bool} isMulti() \textcolor{keyword}{const};}
\DoxyCodeLine{5693     \};}
\DoxyCodeLine{5694     \textcolor{keyword}{using }IStreamingReporterPtr = std::unique\_ptr<IStreamingReporter>;}
\DoxyCodeLine{5695 }
\DoxyCodeLine{5696     \textcolor{keyword}{struct }IReporterFactory \{}
\DoxyCodeLine{5697         \textcolor{keyword}{virtual} \string~IReporterFactory();}
\DoxyCodeLine{5698         \textcolor{keyword}{virtual} IStreamingReporterPtr create( ReporterConfig \textcolor{keyword}{const}\& config ) \textcolor{keyword}{const} = 0;}
\DoxyCodeLine{5699         \textcolor{keyword}{virtual} std::string getDescription() \textcolor{keyword}{const} = 0;}
\DoxyCodeLine{5700     \};}
\DoxyCodeLine{5701     \textcolor{keyword}{using }IReporterFactoryPtr = std::shared\_ptr<IReporterFactory>;}
\DoxyCodeLine{5702 }
\DoxyCodeLine{5703     \textcolor{keyword}{struct }IReporterRegistry \{}
\DoxyCodeLine{5704         \textcolor{keyword}{using }FactoryMap = std::map<std::string, IReporterFactoryPtr>;}
\DoxyCodeLine{5705         \textcolor{keyword}{using }Listeners = std::vector<IReporterFactoryPtr>;}
\DoxyCodeLine{5706 }
\DoxyCodeLine{5707         \textcolor{keyword}{virtual} \string~IReporterRegistry();}
\DoxyCodeLine{5708         \textcolor{keyword}{virtual} IStreamingReporterPtr create( std::string \textcolor{keyword}{const}\& name, IConfigPtr \textcolor{keyword}{const}\& config ) \textcolor{keyword}{const} = 0;}
\DoxyCodeLine{5709         \textcolor{keyword}{virtual} FactoryMap \textcolor{keyword}{const}\& getFactories() \textcolor{keyword}{const} = 0;}
\DoxyCodeLine{5710         \textcolor{keyword}{virtual} Listeners \textcolor{keyword}{const}\& getListeners() \textcolor{keyword}{const} = 0;}
\DoxyCodeLine{5711     \};}
\DoxyCodeLine{5712 }
\DoxyCodeLine{5713 \} \textcolor{comment}{// end namespace Catch}}
\DoxyCodeLine{5714 }
\DoxyCodeLine{5715 \textcolor{comment}{// end catch\_interfaces\_reporter.h}}
\DoxyCodeLine{5716 \textcolor{preprocessor}{\#include <algorithm>}}
\DoxyCodeLine{5717 \textcolor{preprocessor}{\#include <cstring>}}
\DoxyCodeLine{5718 \textcolor{preprocessor}{\#include <cfloat>}}
\DoxyCodeLine{5719 \textcolor{preprocessor}{\#include <cstdio>}}
\DoxyCodeLine{5720 \textcolor{preprocessor}{\#include <cassert>}}
\DoxyCodeLine{5721 \textcolor{preprocessor}{\#include <memory>}}
\DoxyCodeLine{5722 \textcolor{preprocessor}{\#include <ostream>}}
\DoxyCodeLine{5723 }
\DoxyCodeLine{5724 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{5725     \textcolor{keywordtype}{void} prepareExpandedExpression(AssertionResult\& result);}
\DoxyCodeLine{5726 }
\DoxyCodeLine{5727     \textcolor{comment}{// Returns double formatted as \%.3f (format expected on output)}}
\DoxyCodeLine{5728     std::string getFormattedDuration( \textcolor{keywordtype}{double} duration );}
\DoxyCodeLine{5729 }
\DoxyCodeLine{5731     \textcolor{keywordtype}{bool} shouldShowDuration( IConfig \textcolor{keyword}{const}\& config, \textcolor{keywordtype}{double} duration );}
\DoxyCodeLine{5732 }
\DoxyCodeLine{5733     std::string serializeFilters( std::vector<std::string> \textcolor{keyword}{const}\& container );}
\DoxyCodeLine{5734 }
\DoxyCodeLine{5735     \textcolor{keyword}{template}<\textcolor{keyword}{typename} DerivedT>}
\DoxyCodeLine{5736     \textcolor{keyword}{struct }StreamingReporterBase : IStreamingReporter \{}
\DoxyCodeLine{5737 }
\DoxyCodeLine{5738         StreamingReporterBase( ReporterConfig \textcolor{keyword}{const}\& \_config )}
\DoxyCodeLine{5739         :   m\_config( \_config.fullConfig() ),}
\DoxyCodeLine{5740             stream( \_config.stream() )}
\DoxyCodeLine{5741         \{}
\DoxyCodeLine{5742             m\_reporterPrefs.shouldRedirectStdOut = \textcolor{keyword}{false};}
\DoxyCodeLine{5743             \textcolor{keywordflow}{if}( !DerivedT::getSupportedVerbosities().count( m\_config-\/>verbosity() ) )}
\DoxyCodeLine{5744                 CATCH\_ERROR( \textcolor{stringliteral}{"{}Verbosity level not supported by this reporter"{}} );}
\DoxyCodeLine{5745         \}}
\DoxyCodeLine{5746 }
\DoxyCodeLine{5747         ReporterPreferences getPreferences()\textcolor{keyword}{ const override }\{}
\DoxyCodeLine{5748             \textcolor{keywordflow}{return} m\_reporterPrefs;}
\DoxyCodeLine{5749         \}}
\DoxyCodeLine{5750 }
\DoxyCodeLine{5751         \textcolor{keyword}{static} std::set<Verbosity> getSupportedVerbosities() \{}
\DoxyCodeLine{5752             \textcolor{keywordflow}{return} \{ Verbosity::Normal \};}
\DoxyCodeLine{5753         \}}
\DoxyCodeLine{5754 }
\DoxyCodeLine{5755         \string~StreamingReporterBase() \textcolor{keyword}{override} = \textcolor{keywordflow}{default};}
\DoxyCodeLine{5756 }
\DoxyCodeLine{5757         \textcolor{keywordtype}{void} noMatchingTestCases(std::string \textcolor{keyword}{const}\&)\textcolor{keyword}{ override }\{\}}
\DoxyCodeLine{5758 }
\DoxyCodeLine{5759         \textcolor{keywordtype}{void} reportInvalidArguments(std::string \textcolor{keyword}{const}\&)\textcolor{keyword}{ override }\{\}}
\DoxyCodeLine{5760 }
\DoxyCodeLine{5761         \textcolor{keywordtype}{void} testRunStarting(TestRunInfo \textcolor{keyword}{const}\& \_testRunInfo)\textcolor{keyword}{ override }\{}
\DoxyCodeLine{5762             currentTestRunInfo = \_testRunInfo;}
\DoxyCodeLine{5763         \}}
\DoxyCodeLine{5764 }
\DoxyCodeLine{5765         \textcolor{keywordtype}{void} testGroupStarting(GroupInfo \textcolor{keyword}{const}\& \_groupInfo)\textcolor{keyword}{ override }\{}
\DoxyCodeLine{5766             currentGroupInfo = \_groupInfo;}
\DoxyCodeLine{5767         \}}
\DoxyCodeLine{5768 }
\DoxyCodeLine{5769         \textcolor{keywordtype}{void} testCaseStarting(TestCaseInfo \textcolor{keyword}{const}\& \_testInfo)\textcolor{keyword}{ override  }\{}
\DoxyCodeLine{5770             currentTestCaseInfo = \_testInfo;}
\DoxyCodeLine{5771         \}}
\DoxyCodeLine{5772         \textcolor{keywordtype}{void} sectionStarting(SectionInfo \textcolor{keyword}{const}\& \_sectionInfo)\textcolor{keyword}{ override }\{}
\DoxyCodeLine{5773             m\_sectionStack.push\_back(\_sectionInfo);}
\DoxyCodeLine{5774         \}}
\DoxyCodeLine{5775 }
\DoxyCodeLine{5776         \textcolor{keywordtype}{void} sectionEnded(SectionStats \textcolor{keyword}{const}\& \textcolor{comment}{/* \_sectionStats */})\textcolor{keyword}{ override }\{}
\DoxyCodeLine{5777             m\_sectionStack.pop\_back();}
\DoxyCodeLine{5778         \}}
\DoxyCodeLine{5779         \textcolor{keywordtype}{void} testCaseEnded(TestCaseStats \textcolor{keyword}{const}\& \textcolor{comment}{/* \_testCaseStats */})\textcolor{keyword}{ override }\{}
\DoxyCodeLine{5780             currentTestCaseInfo.reset();}
\DoxyCodeLine{5781         \}}
\DoxyCodeLine{5782         \textcolor{keywordtype}{void} testGroupEnded(TestGroupStats \textcolor{keyword}{const}\& \textcolor{comment}{/* \_testGroupStats */})\textcolor{keyword}{ override }\{}
\DoxyCodeLine{5783             currentGroupInfo.reset();}
\DoxyCodeLine{5784         \}}
\DoxyCodeLine{5785         \textcolor{keywordtype}{void} testRunEnded(TestRunStats \textcolor{keyword}{const}\& \textcolor{comment}{/* \_testRunStats */})\textcolor{keyword}{ override }\{}
\DoxyCodeLine{5786             currentTestCaseInfo.reset();}
\DoxyCodeLine{5787             currentGroupInfo.reset();}
\DoxyCodeLine{5788             currentTestRunInfo.reset();}
\DoxyCodeLine{5789         \}}
\DoxyCodeLine{5790 }
\DoxyCodeLine{5791         \textcolor{keywordtype}{void} skipTest(TestCaseInfo \textcolor{keyword}{const}\&)\textcolor{keyword}{ override }\{}
\DoxyCodeLine{5792             \textcolor{comment}{// Don't do anything with this by default.}}
\DoxyCodeLine{5793             \textcolor{comment}{// It can optionally be overridden in the derived class.}}
\DoxyCodeLine{5794         \}}
\DoxyCodeLine{5795 }
\DoxyCodeLine{5796         IConfigPtr m\_config;}
\DoxyCodeLine{5797         std::ostream\& stream;}
\DoxyCodeLine{5798 }
\DoxyCodeLine{5799         LazyStat<TestRunInfo> currentTestRunInfo;}
\DoxyCodeLine{5800         LazyStat<GroupInfo> currentGroupInfo;}
\DoxyCodeLine{5801         LazyStat<TestCaseInfo> currentTestCaseInfo;}
\DoxyCodeLine{5802 }
\DoxyCodeLine{5803         std::vector<SectionInfo> m\_sectionStack;}
\DoxyCodeLine{5804         ReporterPreferences m\_reporterPrefs;}
\DoxyCodeLine{5805     \};}
\DoxyCodeLine{5806 }
\DoxyCodeLine{5807     \textcolor{keyword}{template}<\textcolor{keyword}{typename} DerivedT>}
\DoxyCodeLine{5808     \textcolor{keyword}{struct }CumulativeReporterBase : IStreamingReporter \{}
\DoxyCodeLine{5809         \textcolor{keyword}{template}<\textcolor{keyword}{typename} T, \textcolor{keyword}{typename} ChildNodeT>}
\DoxyCodeLine{5810         \textcolor{keyword}{struct }\mbox{\hyperlink{classNode}{Node}} \{}
\DoxyCodeLine{5811             \textcolor{keyword}{explicit} \mbox{\hyperlink{classNode}{Node}}( T \textcolor{keyword}{const}\& \_value ) : value( \_value ) \{\}}
\DoxyCodeLine{5812             \textcolor{keyword}{virtual} \mbox{\hyperlink{classNode}{\string~Node}}() \{\}}
\DoxyCodeLine{5813 }
\DoxyCodeLine{5814             \textcolor{keyword}{using }ChildNodes = std::vector<std::shared\_ptr<ChildNodeT>>;}
\DoxyCodeLine{5815             T value;}
\DoxyCodeLine{5816             ChildNodes children;}
\DoxyCodeLine{5817         \};}
\DoxyCodeLine{5818         \textcolor{keyword}{struct }SectionNode \{}
\DoxyCodeLine{5819             \textcolor{keyword}{explicit} SectionNode(SectionStats \textcolor{keyword}{const}\& \_stats) : stats(\_stats) \{\}}
\DoxyCodeLine{5820             \textcolor{keyword}{virtual} \string~SectionNode() = \textcolor{keywordflow}{default};}
\DoxyCodeLine{5821 }
\DoxyCodeLine{5822             \textcolor{keywordtype}{bool} operator == (SectionNode \textcolor{keyword}{const}\& other)\textcolor{keyword}{ const }\{}
\DoxyCodeLine{5823                 \textcolor{keywordflow}{return} stats.sectionInfo.lineInfo == other.stats.sectionInfo.lineInfo;}
\DoxyCodeLine{5824             \}}
\DoxyCodeLine{5825             \textcolor{keywordtype}{bool} operator == (std::shared\_ptr<SectionNode> \textcolor{keyword}{const}\& other)\textcolor{keyword}{ const }\{}
\DoxyCodeLine{5826                 \textcolor{keywordflow}{return} operator==(*other);}
\DoxyCodeLine{5827             \}}
\DoxyCodeLine{5828 }
\DoxyCodeLine{5829             SectionStats stats;}
\DoxyCodeLine{5830             \textcolor{keyword}{using }ChildSections = std::vector<std::shared\_ptr<SectionNode>>;}
\DoxyCodeLine{5831             \textcolor{keyword}{using }Assertions = std::vector<AssertionStats>;}
\DoxyCodeLine{5832             ChildSections childSections;}
\DoxyCodeLine{5833             Assertions assertions;}
\DoxyCodeLine{5834             std::string stdOut;}
\DoxyCodeLine{5835             std::string stdErr;}
\DoxyCodeLine{5836         \};}
\DoxyCodeLine{5837 }
\DoxyCodeLine{5838         \textcolor{keyword}{struct }BySectionInfo \{}
\DoxyCodeLine{5839             BySectionInfo( SectionInfo \textcolor{keyword}{const}\& other ) : m\_other( other ) \{\}}
\DoxyCodeLine{5840             BySectionInfo( BySectionInfo \textcolor{keyword}{const}\& other ) : m\_other( other.m\_other ) \{\}}
\DoxyCodeLine{5841             \textcolor{keywordtype}{bool} operator() (std::shared\_ptr<SectionNode> \textcolor{keyword}{const}\& node)\textcolor{keyword}{ const }\{}
\DoxyCodeLine{5842                 \textcolor{keywordflow}{return} ((node-\/>stats.sectionInfo.name == m\_other.name) \&\&}
\DoxyCodeLine{5843                         (node-\/>stats.sectionInfo.lineInfo == m\_other.lineInfo));}
\DoxyCodeLine{5844             \}}
\DoxyCodeLine{5845             \textcolor{keywordtype}{void} operator=(BySectionInfo \textcolor{keyword}{const}\&) = \textcolor{keyword}{delete};}
\DoxyCodeLine{5846 }
\DoxyCodeLine{5847         \textcolor{keyword}{private}:}
\DoxyCodeLine{5848             SectionInfo \textcolor{keyword}{const}\& m\_other;}
\DoxyCodeLine{5849         \};}
\DoxyCodeLine{5850 }
\DoxyCodeLine{5851         \textcolor{keyword}{using }TestCaseNode = \mbox{\hyperlink{classNode}{Node<TestCaseStats, SectionNode>}};}
\DoxyCodeLine{5852         \textcolor{keyword}{using }TestGroupNode = \mbox{\hyperlink{classNode}{Node<TestGroupStats, TestCaseNode>}};}
\DoxyCodeLine{5853         \textcolor{keyword}{using }TestRunNode = \mbox{\hyperlink{classNode}{Node<TestRunStats, TestGroupNode>}};}
\DoxyCodeLine{5854 }
\DoxyCodeLine{5855         CumulativeReporterBase( ReporterConfig \textcolor{keyword}{const}\& \_config )}
\DoxyCodeLine{5856         :   m\_config( \_config.fullConfig() ),}
\DoxyCodeLine{5857             stream( \_config.stream() )}
\DoxyCodeLine{5858         \{}
\DoxyCodeLine{5859             m\_reporterPrefs.shouldRedirectStdOut = \textcolor{keyword}{false};}
\DoxyCodeLine{5860             \textcolor{keywordflow}{if}( !DerivedT::getSupportedVerbosities().count( m\_config-\/>verbosity() ) )}
\DoxyCodeLine{5861                 CATCH\_ERROR( \textcolor{stringliteral}{"{}Verbosity level not supported by this reporter"{}} );}
\DoxyCodeLine{5862         \}}
\DoxyCodeLine{5863         \string~CumulativeReporterBase() \textcolor{keyword}{override} = \textcolor{keywordflow}{default};}
\DoxyCodeLine{5864 }
\DoxyCodeLine{5865         ReporterPreferences getPreferences()\textcolor{keyword}{ const override }\{}
\DoxyCodeLine{5866             \textcolor{keywordflow}{return} m\_reporterPrefs;}
\DoxyCodeLine{5867         \}}
\DoxyCodeLine{5868 }
\DoxyCodeLine{5869         \textcolor{keyword}{static} std::set<Verbosity> getSupportedVerbosities() \{}
\DoxyCodeLine{5870             \textcolor{keywordflow}{return} \{ Verbosity::Normal \};}
\DoxyCodeLine{5871         \}}
\DoxyCodeLine{5872 }
\DoxyCodeLine{5873         \textcolor{keywordtype}{void} testRunStarting( TestRunInfo \textcolor{keyword}{const}\& )\textcolor{keyword}{ override }\{\}}
\DoxyCodeLine{5874         \textcolor{keywordtype}{void} testGroupStarting( GroupInfo \textcolor{keyword}{const}\& )\textcolor{keyword}{ override }\{\}}
\DoxyCodeLine{5875 }
\DoxyCodeLine{5876         \textcolor{keywordtype}{void} testCaseStarting( TestCaseInfo \textcolor{keyword}{const}\& )\textcolor{keyword}{ override }\{\}}
\DoxyCodeLine{5877 }
\DoxyCodeLine{5878         \textcolor{keywordtype}{void} sectionStarting( SectionInfo \textcolor{keyword}{const}\& sectionInfo )\textcolor{keyword}{ override }\{}
\DoxyCodeLine{5879             SectionStats incompleteStats( sectionInfo, Counts(), 0, \textcolor{keyword}{false} );}
\DoxyCodeLine{5880             std::shared\_ptr<SectionNode> node;}
\DoxyCodeLine{5881             \textcolor{keywordflow}{if}( m\_sectionStack.empty() ) \{}
\DoxyCodeLine{5882                 \textcolor{keywordflow}{if}( !m\_rootSection )}
\DoxyCodeLine{5883                     m\_rootSection = std::make\_shared<SectionNode>( incompleteStats );}
\DoxyCodeLine{5884                 node = m\_rootSection;}
\DoxyCodeLine{5885             \}}
\DoxyCodeLine{5886             \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{5887                 SectionNode\& parentNode = *m\_sectionStack.back();}
\DoxyCodeLine{5888                 \textcolor{keyword}{auto} it =}
\DoxyCodeLine{5889                     std::find\_if(   parentNode.childSections.begin(),}
\DoxyCodeLine{5890                                     parentNode.childSections.end(),}
\DoxyCodeLine{5891                                     BySectionInfo( sectionInfo ) );}
\DoxyCodeLine{5892                 \textcolor{keywordflow}{if}( it == parentNode.childSections.end() ) \{}
\DoxyCodeLine{5893                     node = std::make\_shared<SectionNode>( incompleteStats );}
\DoxyCodeLine{5894                     parentNode.childSections.push\_back( node );}
\DoxyCodeLine{5895                 \}}
\DoxyCodeLine{5896                 \textcolor{keywordflow}{else}}
\DoxyCodeLine{5897                     node = *it;}
\DoxyCodeLine{5898             \}}
\DoxyCodeLine{5899             m\_sectionStack.push\_back( node );}
\DoxyCodeLine{5900             m\_deepestSection = std::move(node);}
\DoxyCodeLine{5901         \}}
\DoxyCodeLine{5902 }
\DoxyCodeLine{5903         \textcolor{keywordtype}{void} assertionStarting(AssertionInfo \textcolor{keyword}{const}\&)\textcolor{keyword}{ override }\{\}}
\DoxyCodeLine{5904 }
\DoxyCodeLine{5905         \textcolor{keywordtype}{bool} assertionEnded(AssertionStats \textcolor{keyword}{const}\& assertionStats)\textcolor{keyword}{ override }\{}
\DoxyCodeLine{5906             assert(!m\_sectionStack.empty());}
\DoxyCodeLine{5907             \textcolor{comment}{// AssertionResult holds a pointer to a temporary DecomposedExpression,}}
\DoxyCodeLine{5908             \textcolor{comment}{// which getExpandedExpression() calls to build the expression string.}}
\DoxyCodeLine{5909             \textcolor{comment}{// Our section stack copy of the assertionResult will likely outlive the}}
\DoxyCodeLine{5910             \textcolor{comment}{// temporary, so it must be expanded or discarded now to avoid calling}}
\DoxyCodeLine{5911             \textcolor{comment}{// a destroyed object later.}}
\DoxyCodeLine{5912             prepareExpandedExpression(\textcolor{keyword}{const\_cast<}AssertionResult\&\textcolor{keyword}{>}( assertionStats.assertionResult ) );}
\DoxyCodeLine{5913             SectionNode\& sectionNode = *m\_sectionStack.back();}
\DoxyCodeLine{5914             sectionNode.assertions.push\_back(assertionStats);}
\DoxyCodeLine{5915             \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{5916         \}}
\DoxyCodeLine{5917         \textcolor{keywordtype}{void} sectionEnded(SectionStats \textcolor{keyword}{const}\& sectionStats)\textcolor{keyword}{ override }\{}
\DoxyCodeLine{5918             assert(!m\_sectionStack.empty());}
\DoxyCodeLine{5919             SectionNode\& node = *m\_sectionStack.back();}
\DoxyCodeLine{5920             node.stats = sectionStats;}
\DoxyCodeLine{5921             m\_sectionStack.pop\_back();}
\DoxyCodeLine{5922         \}}
\DoxyCodeLine{5923         \textcolor{keywordtype}{void} testCaseEnded(TestCaseStats \textcolor{keyword}{const}\& testCaseStats)\textcolor{keyword}{ override }\{}
\DoxyCodeLine{5924             \textcolor{keyword}{auto} node = std::make\_shared<TestCaseNode>(testCaseStats);}
\DoxyCodeLine{5925             assert(m\_sectionStack.size() == 0);}
\DoxyCodeLine{5926             node-\/>children.push\_back(m\_rootSection);}
\DoxyCodeLine{5927             m\_testCases.push\_back(node);}
\DoxyCodeLine{5928             m\_rootSection.reset();}
\DoxyCodeLine{5929 }
\DoxyCodeLine{5930             assert(m\_deepestSection);}
\DoxyCodeLine{5931             m\_deepestSection-\/>stdOut = testCaseStats.stdOut;}
\DoxyCodeLine{5932             m\_deepestSection-\/>stdErr = testCaseStats.stdErr;}
\DoxyCodeLine{5933         \}}
\DoxyCodeLine{5934         \textcolor{keywordtype}{void} testGroupEnded(TestGroupStats \textcolor{keyword}{const}\& testGroupStats)\textcolor{keyword}{ override }\{}
\DoxyCodeLine{5935             \textcolor{keyword}{auto} node = std::make\_shared<TestGroupNode>(testGroupStats);}
\DoxyCodeLine{5936             node-\/>children.swap(m\_testCases);}
\DoxyCodeLine{5937             m\_testGroups.push\_back(node);}
\DoxyCodeLine{5938         \}}
\DoxyCodeLine{5939         \textcolor{keywordtype}{void} testRunEnded(TestRunStats \textcolor{keyword}{const}\& testRunStats)\textcolor{keyword}{ override }\{}
\DoxyCodeLine{5940             \textcolor{keyword}{auto} node = std::make\_shared<TestRunNode>(testRunStats);}
\DoxyCodeLine{5941             node-\/>children.swap(m\_testGroups);}
\DoxyCodeLine{5942             m\_testRuns.push\_back(node);}
\DoxyCodeLine{5943             testRunEndedCumulative();}
\DoxyCodeLine{5944         \}}
\DoxyCodeLine{5945         \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} testRunEndedCumulative() = 0;}
\DoxyCodeLine{5946 }
\DoxyCodeLine{5947         \textcolor{keywordtype}{void} skipTest(TestCaseInfo \textcolor{keyword}{const}\&)\textcolor{keyword}{ override }\{\}}
\DoxyCodeLine{5948 }
\DoxyCodeLine{5949         IConfigPtr m\_config;}
\DoxyCodeLine{5950         std::ostream\& stream;}
\DoxyCodeLine{5951         std::vector<AssertionStats> m\_assertions;}
\DoxyCodeLine{5952         std::vector<std::vector<std::shared\_ptr<SectionNode>>> m\_sections;}
\DoxyCodeLine{5953         std::vector<std::shared\_ptr<TestCaseNode>> m\_testCases;}
\DoxyCodeLine{5954         std::vector<std::shared\_ptr<TestGroupNode>> m\_testGroups;}
\DoxyCodeLine{5955 }
\DoxyCodeLine{5956         std::vector<std::shared\_ptr<TestRunNode>> m\_testRuns;}
\DoxyCodeLine{5957 }
\DoxyCodeLine{5958         std::shared\_ptr<SectionNode> m\_rootSection;}
\DoxyCodeLine{5959         std::shared\_ptr<SectionNode> m\_deepestSection;}
\DoxyCodeLine{5960         std::vector<std::shared\_ptr<SectionNode>> m\_sectionStack;}
\DoxyCodeLine{5961         ReporterPreferences m\_reporterPrefs;}
\DoxyCodeLine{5962     \};}
\DoxyCodeLine{5963 }
\DoxyCodeLine{5964     \textcolor{keyword}{template}<\textcolor{keywordtype}{char} C>}
\DoxyCodeLine{5965     \textcolor{keywordtype}{char} \textcolor{keyword}{const}* getLineOfChars() \{}
\DoxyCodeLine{5966         \textcolor{keyword}{static} \textcolor{keywordtype}{char} line[CATCH\_CONFIG\_CONSOLE\_WIDTH] = \{0\};}
\DoxyCodeLine{5967         \textcolor{keywordflow}{if}( !*line ) \{}
\DoxyCodeLine{5968             std::memset( line, C, CATCH\_CONFIG\_CONSOLE\_WIDTH-\/1 );}
\DoxyCodeLine{5969             line[CATCH\_CONFIG\_CONSOLE\_WIDTH-\/1] = 0;}
\DoxyCodeLine{5970         \}}
\DoxyCodeLine{5971         \textcolor{keywordflow}{return} line;}
\DoxyCodeLine{5972     \}}
\DoxyCodeLine{5973 }
\DoxyCodeLine{5974     \textcolor{keyword}{struct }TestEventListenerBase : StreamingReporterBase<TestEventListenerBase> \{}
\DoxyCodeLine{5975         TestEventListenerBase( ReporterConfig \textcolor{keyword}{const}\& \_config );}
\DoxyCodeLine{5976 }
\DoxyCodeLine{5977         \textcolor{keyword}{static} std::set<Verbosity> getSupportedVerbosities();}
\DoxyCodeLine{5978 }
\DoxyCodeLine{5979         \textcolor{keywordtype}{void} assertionStarting(AssertionInfo \textcolor{keyword}{const}\&) \textcolor{keyword}{override};}
\DoxyCodeLine{5980         \textcolor{keywordtype}{bool} assertionEnded(AssertionStats \textcolor{keyword}{const}\&) \textcolor{keyword}{override};}
\DoxyCodeLine{5981     \};}
\DoxyCodeLine{5982 }
\DoxyCodeLine{5983 \} \textcolor{comment}{// end namespace Catch}}
\DoxyCodeLine{5984 }
\DoxyCodeLine{5985 \textcolor{comment}{// end catch\_reporter\_bases.hpp}}
\DoxyCodeLine{5986 \textcolor{comment}{// start catch\_console\_colour.h}}
\DoxyCodeLine{5987 }
\DoxyCodeLine{5988 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{5989 }
\DoxyCodeLine{5990     \textcolor{keyword}{struct }Colour \{}
\DoxyCodeLine{5991         \textcolor{keyword}{enum} Code \{}
\DoxyCodeLine{5992             None = 0,}
\DoxyCodeLine{5993 }
\DoxyCodeLine{5994             White,}
\DoxyCodeLine{5995             Red,}
\DoxyCodeLine{5996             Green,}
\DoxyCodeLine{5997             Blue,}
\DoxyCodeLine{5998             Cyan,}
\DoxyCodeLine{5999             Yellow,}
\DoxyCodeLine{6000             Grey,}
\DoxyCodeLine{6001 }
\DoxyCodeLine{6002             Bright = 0x10,}
\DoxyCodeLine{6003 }
\DoxyCodeLine{6004             BrightRed = Bright | Red,}
\DoxyCodeLine{6005             BrightGreen = Bright | Green,}
\DoxyCodeLine{6006             LightGrey = Bright | Grey,}
\DoxyCodeLine{6007             BrightWhite = Bright | White,}
\DoxyCodeLine{6008             BrightYellow = Bright | Yellow,}
\DoxyCodeLine{6009 }
\DoxyCodeLine{6010             \textcolor{comment}{// By intention}}
\DoxyCodeLine{6011             FileName = LightGrey,}
\DoxyCodeLine{6012             Warning = BrightYellow,}
\DoxyCodeLine{6013             ResultError = BrightRed,}
\DoxyCodeLine{6014             ResultSuccess = BrightGreen,}
\DoxyCodeLine{6015             ResultExpectedFailure = Warning,}
\DoxyCodeLine{6016 }
\DoxyCodeLine{6017             Error = BrightRed,}
\DoxyCodeLine{6018             Success = Green,}
\DoxyCodeLine{6019 }
\DoxyCodeLine{6020             OriginalExpression = Cyan,}
\DoxyCodeLine{6021             ReconstructedExpression = BrightYellow,}
\DoxyCodeLine{6022 }
\DoxyCodeLine{6023             SecondaryText = LightGrey,}
\DoxyCodeLine{6024             Headers = White}
\DoxyCodeLine{6025         \};}
\DoxyCodeLine{6026 }
\DoxyCodeLine{6027         \textcolor{comment}{// Use constructed object for RAII guard}}
\DoxyCodeLine{6028         Colour( Code \_colourCode );}
\DoxyCodeLine{6029         Colour( Colour\&\& other ) \textcolor{keyword}{noexcept};}
\DoxyCodeLine{6030         Colour\& operator=( Colour\&\& other ) \textcolor{keyword}{noexcept};}
\DoxyCodeLine{6031         \string~Colour();}
\DoxyCodeLine{6032 }
\DoxyCodeLine{6033         \textcolor{comment}{// Use static method for one-\/shot changes}}
\DoxyCodeLine{6034         \textcolor{keyword}{static} \textcolor{keywordtype}{void} use( Code \_colourCode );}
\DoxyCodeLine{6035 }
\DoxyCodeLine{6036     \textcolor{keyword}{private}:}
\DoxyCodeLine{6037         \textcolor{keywordtype}{bool} m\_moved = \textcolor{keyword}{false};}
\DoxyCodeLine{6038     \};}
\DoxyCodeLine{6039 }
\DoxyCodeLine{6040     std::ostream\& operator << ( std::ostream\& os, Colour \textcolor{keyword}{const}\& );}
\DoxyCodeLine{6041 }
\DoxyCodeLine{6042 \} \textcolor{comment}{// end namespace Catch}}
\DoxyCodeLine{6043 }
\DoxyCodeLine{6044 \textcolor{comment}{// end catch\_console\_colour.h}}
\DoxyCodeLine{6045 \textcolor{comment}{// start catch\_reporter\_registrars.hpp}}
\DoxyCodeLine{6046 }
\DoxyCodeLine{6047 }
\DoxyCodeLine{6048 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{6049 }
\DoxyCodeLine{6050     \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{6051     \textcolor{keyword}{class }ReporterRegistrar \{}
\DoxyCodeLine{6052 }
\DoxyCodeLine{6053         \textcolor{keyword}{class }ReporterFactory : \textcolor{keyword}{public} IReporterFactory \{}
\DoxyCodeLine{6054 }
\DoxyCodeLine{6055             IStreamingReporterPtr create( ReporterConfig \textcolor{keyword}{const}\& config )\textcolor{keyword}{ const override }\{}
\DoxyCodeLine{6056                 \textcolor{keywordflow}{return} std::unique\_ptr<T>( \textcolor{keyword}{new} T( config ) );}
\DoxyCodeLine{6057             \}}
\DoxyCodeLine{6058 }
\DoxyCodeLine{6059             std::string getDescription()\textcolor{keyword}{ const override }\{}
\DoxyCodeLine{6060                 \textcolor{keywordflow}{return} T::getDescription();}
\DoxyCodeLine{6061             \}}
\DoxyCodeLine{6062         \};}
\DoxyCodeLine{6063 }
\DoxyCodeLine{6064     \textcolor{keyword}{public}:}
\DoxyCodeLine{6065 }
\DoxyCodeLine{6066         \textcolor{keyword}{explicit} ReporterRegistrar( std::string \textcolor{keyword}{const}\& name ) \{}
\DoxyCodeLine{6067             getMutableRegistryHub().registerReporter( name, std::make\_shared<ReporterFactory>() );}
\DoxyCodeLine{6068         \}}
\DoxyCodeLine{6069     \};}
\DoxyCodeLine{6070 }
\DoxyCodeLine{6071     \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{6072     \textcolor{keyword}{class }ListenerRegistrar \{}
\DoxyCodeLine{6073 }
\DoxyCodeLine{6074         \textcolor{keyword}{class }ListenerFactory : \textcolor{keyword}{public} IReporterFactory \{}
\DoxyCodeLine{6075 }
\DoxyCodeLine{6076             IStreamingReporterPtr create( ReporterConfig \textcolor{keyword}{const}\& config )\textcolor{keyword}{ const override }\{}
\DoxyCodeLine{6077                 \textcolor{keywordflow}{return} std::unique\_ptr<T>( \textcolor{keyword}{new} T( config ) );}
\DoxyCodeLine{6078             \}}
\DoxyCodeLine{6079             std::string getDescription()\textcolor{keyword}{ const override }\{}
\DoxyCodeLine{6080                 \textcolor{keywordflow}{return} std::string();}
\DoxyCodeLine{6081             \}}
\DoxyCodeLine{6082         \};}
\DoxyCodeLine{6083 }
\DoxyCodeLine{6084     \textcolor{keyword}{public}:}
\DoxyCodeLine{6085 }
\DoxyCodeLine{6086         ListenerRegistrar() \{}
\DoxyCodeLine{6087             getMutableRegistryHub().registerListener( std::make\_shared<ListenerFactory>() );}
\DoxyCodeLine{6088         \}}
\DoxyCodeLine{6089     \};}
\DoxyCodeLine{6090 \}}
\DoxyCodeLine{6091 }
\DoxyCodeLine{6092 \textcolor{preprocessor}{\#if !defined(CATCH\_CONFIG\_DISABLE)}}
\DoxyCodeLine{6093 }
\DoxyCodeLine{6094 \textcolor{preprocessor}{\#define CATCH\_REGISTER\_REPORTER( name, reporterType ) \(\backslash\)}}
\DoxyCodeLine{6095 \textcolor{preprocessor}{    CATCH\_INTERNAL\_START\_WARNINGS\_SUPPRESSION         \(\backslash\)}}
\DoxyCodeLine{6096 \textcolor{preprocessor}{    CATCH\_INTERNAL\_SUPPRESS\_GLOBALS\_WARNINGS          \(\backslash\)}}
\DoxyCodeLine{6097 \textcolor{preprocessor}{    namespace\{ Catch::ReporterRegistrar<reporterType> catch\_internal\_RegistrarFor\#\#reporterType( name ); \} \(\backslash\)}}
\DoxyCodeLine{6098 \textcolor{preprocessor}{    CATCH\_INTERNAL\_STOP\_WARNINGS\_SUPPRESSION}}
\DoxyCodeLine{6099 }
\DoxyCodeLine{6100 \textcolor{preprocessor}{\#define CATCH\_REGISTER\_LISTENER( listenerType ) \(\backslash\)}}
\DoxyCodeLine{6101 \textcolor{preprocessor}{    CATCH\_INTERNAL\_START\_WARNINGS\_SUPPRESSION   \(\backslash\)}}
\DoxyCodeLine{6102 \textcolor{preprocessor}{    CATCH\_INTERNAL\_SUPPRESS\_GLOBALS\_WARNINGS    \(\backslash\)}}
\DoxyCodeLine{6103 \textcolor{preprocessor}{    namespace\{ Catch::ListenerRegistrar<listenerType> catch\_internal\_RegistrarFor\#\#listenerType; \} \(\backslash\)}}
\DoxyCodeLine{6104 \textcolor{preprocessor}{    CATCH\_INTERNAL\_STOP\_WARNINGS\_SUPPRESSION}}
\DoxyCodeLine{6105 \textcolor{preprocessor}{\#else }\textcolor{comment}{// CATCH\_CONFIG\_DISABLE}}
\DoxyCodeLine{6106 }
\DoxyCodeLine{6107 \textcolor{preprocessor}{\#define CATCH\_REGISTER\_REPORTER(name, reporterType)}}
\DoxyCodeLine{6108 \textcolor{preprocessor}{\#define CATCH\_REGISTER\_LISTENER(listenerType)}}
\DoxyCodeLine{6109 }
\DoxyCodeLine{6110 \textcolor{preprocessor}{\#endif }\textcolor{comment}{// CATCH\_CONFIG\_DISABLE}}
\DoxyCodeLine{6111 }
\DoxyCodeLine{6112 \textcolor{comment}{// end catch\_reporter\_registrars.hpp}}
\DoxyCodeLine{6113 \textcolor{comment}{// Allow users to base their work off existing reporters}}
\DoxyCodeLine{6114 \textcolor{comment}{// start catch\_reporter\_compact.h}}
\DoxyCodeLine{6115 }
\DoxyCodeLine{6116 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{6117 }
\DoxyCodeLine{6118     \textcolor{keyword}{struct }CompactReporter : StreamingReporterBase<CompactReporter> \{}
\DoxyCodeLine{6119 }
\DoxyCodeLine{6120         \textcolor{keyword}{using }StreamingReporterBase::StreamingReporterBase;}
\DoxyCodeLine{6121 }
\DoxyCodeLine{6122         \string~CompactReporter() \textcolor{keyword}{override};}
\DoxyCodeLine{6123 }
\DoxyCodeLine{6124         \textcolor{keyword}{static} std::string getDescription();}
\DoxyCodeLine{6125 }
\DoxyCodeLine{6126         \textcolor{keywordtype}{void} noMatchingTestCases(std::string \textcolor{keyword}{const}\& spec) \textcolor{keyword}{override};}
\DoxyCodeLine{6127 }
\DoxyCodeLine{6128         \textcolor{keywordtype}{void} assertionStarting(AssertionInfo \textcolor{keyword}{const}\&) \textcolor{keyword}{override};}
\DoxyCodeLine{6129 }
\DoxyCodeLine{6130         \textcolor{keywordtype}{bool} assertionEnded(AssertionStats \textcolor{keyword}{const}\& \_assertionStats) \textcolor{keyword}{override};}
\DoxyCodeLine{6131 }
\DoxyCodeLine{6132         \textcolor{keywordtype}{void} sectionEnded(SectionStats \textcolor{keyword}{const}\& \_sectionStats) \textcolor{keyword}{override};}
\DoxyCodeLine{6133 }
\DoxyCodeLine{6134         \textcolor{keywordtype}{void} testRunEnded(TestRunStats \textcolor{keyword}{const}\& \_testRunStats) \textcolor{keyword}{override};}
\DoxyCodeLine{6135 }
\DoxyCodeLine{6136     \};}
\DoxyCodeLine{6137 }
\DoxyCodeLine{6138 \} \textcolor{comment}{// end namespace Catch}}
\DoxyCodeLine{6139 }
\DoxyCodeLine{6140 \textcolor{comment}{// end catch\_reporter\_compact.h}}
\DoxyCodeLine{6141 \textcolor{comment}{// start catch\_reporter\_console.h}}
\DoxyCodeLine{6142 }
\DoxyCodeLine{6143 \textcolor{preprocessor}{\#if defined(\_MSC\_VER)}}
\DoxyCodeLine{6144 \textcolor{preprocessor}{\#pragma warning(push)}}
\DoxyCodeLine{6145 \textcolor{preprocessor}{\#pragma warning(disable:4061) }\textcolor{comment}{// Not all labels are EXPLICITLY handled in switch}}
\DoxyCodeLine{6146                               \textcolor{comment}{// Note that 4062 (not all labels are handled}}
\DoxyCodeLine{6147                               \textcolor{comment}{// and default is missing) is enabled}}
\DoxyCodeLine{6148 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{6149 }
\DoxyCodeLine{6150 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{6151     \textcolor{comment}{// Fwd decls}}
\DoxyCodeLine{6152     \textcolor{keyword}{struct }SummaryColumn;}
\DoxyCodeLine{6153     \textcolor{keyword}{class }TablePrinter;}
\DoxyCodeLine{6154 }
\DoxyCodeLine{6155     \textcolor{keyword}{struct }ConsoleReporter : StreamingReporterBase<ConsoleReporter> \{}
\DoxyCodeLine{6156         std::unique\_ptr<TablePrinter> m\_tablePrinter;}
\DoxyCodeLine{6157 }
\DoxyCodeLine{6158         ConsoleReporter(ReporterConfig \textcolor{keyword}{const}\& config);}
\DoxyCodeLine{6159         \string~ConsoleReporter() \textcolor{keyword}{override};}
\DoxyCodeLine{6160         \textcolor{keyword}{static} std::string getDescription();}
\DoxyCodeLine{6161 }
\DoxyCodeLine{6162         \textcolor{keywordtype}{void} noMatchingTestCases(std::string \textcolor{keyword}{const}\& spec) \textcolor{keyword}{override};}
\DoxyCodeLine{6163 }
\DoxyCodeLine{6164         \textcolor{keywordtype}{void} reportInvalidArguments(std::string \textcolor{keyword}{const}\&arg) \textcolor{keyword}{override};}
\DoxyCodeLine{6165 }
\DoxyCodeLine{6166         \textcolor{keywordtype}{void} assertionStarting(AssertionInfo \textcolor{keyword}{const}\&) \textcolor{keyword}{override};}
\DoxyCodeLine{6167 }
\DoxyCodeLine{6168         \textcolor{keywordtype}{bool} assertionEnded(AssertionStats \textcolor{keyword}{const}\& \_assertionStats) \textcolor{keyword}{override};}
\DoxyCodeLine{6169 }
\DoxyCodeLine{6170         \textcolor{keywordtype}{void} sectionStarting(SectionInfo \textcolor{keyword}{const}\& \_sectionInfo) \textcolor{keyword}{override};}
\DoxyCodeLine{6171         \textcolor{keywordtype}{void} sectionEnded(SectionStats \textcolor{keyword}{const}\& \_sectionStats) \textcolor{keyword}{override};}
\DoxyCodeLine{6172 }
\DoxyCodeLine{6173 \textcolor{preprocessor}{\#if defined(CATCH\_CONFIG\_ENABLE\_BENCHMARKING)}}
\DoxyCodeLine{6174         \textcolor{keywordtype}{void} benchmarkPreparing(std::string \textcolor{keyword}{const}\& name) \textcolor{keyword}{override};}
\DoxyCodeLine{6175         \textcolor{keywordtype}{void} benchmarkStarting(BenchmarkInfo \textcolor{keyword}{const}\& info) \textcolor{keyword}{override};}
\DoxyCodeLine{6176         \textcolor{keywordtype}{void} benchmarkEnded(BenchmarkStats<> \textcolor{keyword}{const}\& stats) \textcolor{keyword}{override};}
\DoxyCodeLine{6177         \textcolor{keywordtype}{void} benchmarkFailed(std::string \textcolor{keyword}{const}\& error) \textcolor{keyword}{override};}
\DoxyCodeLine{6178 \textcolor{preprocessor}{\#endif }\textcolor{comment}{// CATCH\_CONFIG\_ENABLE\_BENCHMARKING}}
\DoxyCodeLine{6179 }
\DoxyCodeLine{6180         \textcolor{keywordtype}{void} testCaseEnded(TestCaseStats \textcolor{keyword}{const}\& \_testCaseStats) \textcolor{keyword}{override};}
\DoxyCodeLine{6181         \textcolor{keywordtype}{void} testGroupEnded(TestGroupStats \textcolor{keyword}{const}\& \_testGroupStats) \textcolor{keyword}{override};}
\DoxyCodeLine{6182         \textcolor{keywordtype}{void} testRunEnded(TestRunStats \textcolor{keyword}{const}\& \_testRunStats) \textcolor{keyword}{override};}
\DoxyCodeLine{6183         \textcolor{keywordtype}{void} testRunStarting(TestRunInfo \textcolor{keyword}{const}\& \_testRunInfo) \textcolor{keyword}{override};}
\DoxyCodeLine{6184     \textcolor{keyword}{private}:}
\DoxyCodeLine{6185 }
\DoxyCodeLine{6186         \textcolor{keywordtype}{void} lazyPrint();}
\DoxyCodeLine{6187 }
\DoxyCodeLine{6188         \textcolor{keywordtype}{void} lazyPrintWithoutClosingBenchmarkTable();}
\DoxyCodeLine{6189         \textcolor{keywordtype}{void} lazyPrintRunInfo();}
\DoxyCodeLine{6190         \textcolor{keywordtype}{void} lazyPrintGroupInfo();}
\DoxyCodeLine{6191         \textcolor{keywordtype}{void} printTestCaseAndSectionHeader();}
\DoxyCodeLine{6192 }
\DoxyCodeLine{6193         \textcolor{keywordtype}{void} printClosedHeader(std::string \textcolor{keyword}{const}\& \_name);}
\DoxyCodeLine{6194         \textcolor{keywordtype}{void} printOpenHeader(std::string \textcolor{keyword}{const}\& \_name);}
\DoxyCodeLine{6195 }
\DoxyCodeLine{6196         \textcolor{comment}{// if string has a : in first line will set indent to follow it on}}
\DoxyCodeLine{6197         \textcolor{comment}{// subsequent lines}}
\DoxyCodeLine{6198         \textcolor{keywordtype}{void} printHeaderString(std::string \textcolor{keyword}{const}\& \_string, std::size\_t indent = 0);}
\DoxyCodeLine{6199 }
\DoxyCodeLine{6200         \textcolor{keywordtype}{void} printTotals(Totals \textcolor{keyword}{const}\& totals);}
\DoxyCodeLine{6201         \textcolor{keywordtype}{void} printSummaryRow(std::string \textcolor{keyword}{const}\& label, std::vector<SummaryColumn> \textcolor{keyword}{const}\& cols, std::size\_t row);}
\DoxyCodeLine{6202 }
\DoxyCodeLine{6203         \textcolor{keywordtype}{void} printTotalsDivider(Totals \textcolor{keyword}{const}\& totals);}
\DoxyCodeLine{6204         \textcolor{keywordtype}{void} printSummaryDivider();}
\DoxyCodeLine{6205         \textcolor{keywordtype}{void} printTestFilters();}
\DoxyCodeLine{6206 }
\DoxyCodeLine{6207     \textcolor{keyword}{private}:}
\DoxyCodeLine{6208         \textcolor{keywordtype}{bool} m\_headerPrinted = \textcolor{keyword}{false};}
\DoxyCodeLine{6209     \};}
\DoxyCodeLine{6210 }
\DoxyCodeLine{6211 \} \textcolor{comment}{// end namespace Catch}}
\DoxyCodeLine{6212 }
\DoxyCodeLine{6213 \textcolor{preprocessor}{\#if defined(\_MSC\_VER)}}
\DoxyCodeLine{6214 \textcolor{preprocessor}{\#pragma warning(pop)}}
\DoxyCodeLine{6215 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{6216 }
\DoxyCodeLine{6217 \textcolor{comment}{// end catch\_reporter\_console.h}}
\DoxyCodeLine{6218 \textcolor{comment}{// start catch\_reporter\_junit.h}}
\DoxyCodeLine{6219 }
\DoxyCodeLine{6220 \textcolor{comment}{// start catch\_xmlwriter.h}}
\DoxyCodeLine{6221 }
\DoxyCodeLine{6222 \textcolor{preprocessor}{\#include <vector>}}
\DoxyCodeLine{6223 }
\DoxyCodeLine{6224 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{6225     \textcolor{keyword}{enum class} XmlFormatting \{}
\DoxyCodeLine{6226         None = 0x00,}
\DoxyCodeLine{6227         Indent = 0x01,}
\DoxyCodeLine{6228         Newline = 0x02,}
\DoxyCodeLine{6229     \};}
\DoxyCodeLine{6230 }
\DoxyCodeLine{6231     XmlFormatting operator | (XmlFormatting lhs, XmlFormatting rhs);}
\DoxyCodeLine{6232     XmlFormatting operator \& (XmlFormatting lhs, XmlFormatting rhs);}
\DoxyCodeLine{6233 }
\DoxyCodeLine{6234     \textcolor{keyword}{class }XmlEncode \{}
\DoxyCodeLine{6235     \textcolor{keyword}{public}:}
\DoxyCodeLine{6236         \textcolor{keyword}{enum} ForWhat \{ ForTextNodes, ForAttributes \};}
\DoxyCodeLine{6237 }
\DoxyCodeLine{6238         XmlEncode( std::string \textcolor{keyword}{const}\& str, ForWhat forWhat = ForTextNodes );}
\DoxyCodeLine{6239 }
\DoxyCodeLine{6240         \textcolor{keywordtype}{void} encodeTo( std::ostream\& os ) \textcolor{keyword}{const};}
\DoxyCodeLine{6241 }
\DoxyCodeLine{6242         \textcolor{keyword}{friend} std::ostream\& operator << ( std::ostream\& os, XmlEncode \textcolor{keyword}{const}\& xmlEncode );}
\DoxyCodeLine{6243 }
\DoxyCodeLine{6244     \textcolor{keyword}{private}:}
\DoxyCodeLine{6245         std::string m\_str;}
\DoxyCodeLine{6246         ForWhat m\_forWhat;}
\DoxyCodeLine{6247     \};}
\DoxyCodeLine{6248 }
\DoxyCodeLine{6249     \textcolor{keyword}{class }XmlWriter \{}
\DoxyCodeLine{6250     \textcolor{keyword}{public}:}
\DoxyCodeLine{6251 }
\DoxyCodeLine{6252         \textcolor{keyword}{class }ScopedElement \{}
\DoxyCodeLine{6253         \textcolor{keyword}{public}:}
\DoxyCodeLine{6254             ScopedElement( XmlWriter* writer, XmlFormatting fmt );}
\DoxyCodeLine{6255 }
\DoxyCodeLine{6256             ScopedElement( ScopedElement\&\& other ) \textcolor{keyword}{noexcept};}
\DoxyCodeLine{6257             ScopedElement\& operator=( ScopedElement\&\& other ) \textcolor{keyword}{noexcept};}
\DoxyCodeLine{6258 }
\DoxyCodeLine{6259             \string~ScopedElement();}
\DoxyCodeLine{6260 }
\DoxyCodeLine{6261             ScopedElement\& writeText( std::string \textcolor{keyword}{const}\& text, XmlFormatting fmt = XmlFormatting::Newline | XmlFormatting::Indent );}
\DoxyCodeLine{6262 }
\DoxyCodeLine{6263             \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{6264             ScopedElement\& writeAttribute( std::string \textcolor{keyword}{const}\& name, T \textcolor{keyword}{const}\& attribute ) \{}
\DoxyCodeLine{6265                 m\_writer-\/>writeAttribute( name, attribute );}
\DoxyCodeLine{6266                 \textcolor{keywordflow}{return} *\textcolor{keyword}{this};}
\DoxyCodeLine{6267             \}}
\DoxyCodeLine{6268 }
\DoxyCodeLine{6269         \textcolor{keyword}{private}:}
\DoxyCodeLine{6270             \textcolor{keyword}{mutable} XmlWriter* m\_writer = \textcolor{keyword}{nullptr};}
\DoxyCodeLine{6271             XmlFormatting m\_fmt;}
\DoxyCodeLine{6272         \};}
\DoxyCodeLine{6273 }
\DoxyCodeLine{6274         XmlWriter( std::ostream\& os = Catch::cout() );}
\DoxyCodeLine{6275         \string~XmlWriter();}
\DoxyCodeLine{6276 }
\DoxyCodeLine{6277         XmlWriter( XmlWriter \textcolor{keyword}{const}\& ) = \textcolor{keyword}{delete};}
\DoxyCodeLine{6278         XmlWriter\& operator=( XmlWriter \textcolor{keyword}{const}\& ) = \textcolor{keyword}{delete};}
\DoxyCodeLine{6279 }
\DoxyCodeLine{6280         XmlWriter\& startElement( std::string \textcolor{keyword}{const}\& name, XmlFormatting fmt = XmlFormatting::Newline | XmlFormatting::Indent);}
\DoxyCodeLine{6281 }
\DoxyCodeLine{6282         ScopedElement scopedElement( std::string \textcolor{keyword}{const}\& name, XmlFormatting fmt = XmlFormatting::Newline | XmlFormatting::Indent);}
\DoxyCodeLine{6283 }
\DoxyCodeLine{6284         XmlWriter\& endElement(XmlFormatting fmt = XmlFormatting::Newline | XmlFormatting::Indent);}
\DoxyCodeLine{6285 }
\DoxyCodeLine{6286         XmlWriter\& writeAttribute( std::string \textcolor{keyword}{const}\& name, std::string \textcolor{keyword}{const}\& attribute );}
\DoxyCodeLine{6287 }
\DoxyCodeLine{6288         XmlWriter\& writeAttribute( std::string \textcolor{keyword}{const}\& name, \textcolor{keywordtype}{bool} attribute );}
\DoxyCodeLine{6289 }
\DoxyCodeLine{6290         \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{6291         XmlWriter\& writeAttribute( std::string \textcolor{keyword}{const}\& name, T \textcolor{keyword}{const}\& attribute ) \{}
\DoxyCodeLine{6292             ReusableStringStream rss;}
\DoxyCodeLine{6293             rss << attribute;}
\DoxyCodeLine{6294             \textcolor{keywordflow}{return} writeAttribute( name, rss.str() );}
\DoxyCodeLine{6295         \}}
\DoxyCodeLine{6296 }
\DoxyCodeLine{6297         XmlWriter\& writeText( std::string \textcolor{keyword}{const}\& text, XmlFormatting fmt = XmlFormatting::Newline | XmlFormatting::Indent);}
\DoxyCodeLine{6298 }
\DoxyCodeLine{6299         XmlWriter\& writeComment(std::string \textcolor{keyword}{const}\& text, XmlFormatting fmt = XmlFormatting::Newline | XmlFormatting::Indent);}
\DoxyCodeLine{6300 }
\DoxyCodeLine{6301         \textcolor{keywordtype}{void} writeStylesheetRef( std::string \textcolor{keyword}{const}\& url );}
\DoxyCodeLine{6302 }
\DoxyCodeLine{6303         XmlWriter\& writeBlankLine();}
\DoxyCodeLine{6304 }
\DoxyCodeLine{6305         \textcolor{keywordtype}{void} ensureTagClosed();}
\DoxyCodeLine{6306 }
\DoxyCodeLine{6307     \textcolor{keyword}{private}:}
\DoxyCodeLine{6308 }
\DoxyCodeLine{6309         \textcolor{keywordtype}{void} applyFormatting(XmlFormatting fmt);}
\DoxyCodeLine{6310 }
\DoxyCodeLine{6311         \textcolor{keywordtype}{void} writeDeclaration();}
\DoxyCodeLine{6312 }
\DoxyCodeLine{6313         \textcolor{keywordtype}{void} newlineIfNecessary();}
\DoxyCodeLine{6314 }
\DoxyCodeLine{6315         \textcolor{keywordtype}{bool} m\_tagIsOpen = \textcolor{keyword}{false};}
\DoxyCodeLine{6316         \textcolor{keywordtype}{bool} m\_needsNewline = \textcolor{keyword}{false};}
\DoxyCodeLine{6317         std::vector<std::string> m\_tags;}
\DoxyCodeLine{6318         std::string m\_indent;}
\DoxyCodeLine{6319         std::ostream\& m\_os;}
\DoxyCodeLine{6320     \};}
\DoxyCodeLine{6321 }
\DoxyCodeLine{6322 \}}
\DoxyCodeLine{6323 }
\DoxyCodeLine{6324 \textcolor{comment}{// end catch\_xmlwriter.h}}
\DoxyCodeLine{6325 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{6326 }
\DoxyCodeLine{6327     \textcolor{keyword}{class }JunitReporter : \textcolor{keyword}{public} CumulativeReporterBase<JunitReporter> \{}
\DoxyCodeLine{6328     \textcolor{keyword}{public}:}
\DoxyCodeLine{6329         JunitReporter(ReporterConfig \textcolor{keyword}{const}\& \_config);}
\DoxyCodeLine{6330 }
\DoxyCodeLine{6331         \string~JunitReporter() \textcolor{keyword}{override};}
\DoxyCodeLine{6332 }
\DoxyCodeLine{6333         \textcolor{keyword}{static} std::string getDescription();}
\DoxyCodeLine{6334 }
\DoxyCodeLine{6335         \textcolor{keywordtype}{void} noMatchingTestCases(std::string \textcolor{keyword}{const}\& \textcolor{comment}{/*spec*/}) \textcolor{keyword}{override};}
\DoxyCodeLine{6336 }
\DoxyCodeLine{6337         \textcolor{keywordtype}{void} testRunStarting(TestRunInfo \textcolor{keyword}{const}\& runInfo) \textcolor{keyword}{override};}
\DoxyCodeLine{6338 }
\DoxyCodeLine{6339         \textcolor{keywordtype}{void} testGroupStarting(GroupInfo \textcolor{keyword}{const}\& groupInfo) \textcolor{keyword}{override};}
\DoxyCodeLine{6340 }
\DoxyCodeLine{6341         \textcolor{keywordtype}{void} testCaseStarting(TestCaseInfo \textcolor{keyword}{const}\& testCaseInfo) \textcolor{keyword}{override};}
\DoxyCodeLine{6342         \textcolor{keywordtype}{bool} assertionEnded(AssertionStats \textcolor{keyword}{const}\& assertionStats) \textcolor{keyword}{override};}
\DoxyCodeLine{6343 }
\DoxyCodeLine{6344         \textcolor{keywordtype}{void} testCaseEnded(TestCaseStats \textcolor{keyword}{const}\& testCaseStats) \textcolor{keyword}{override};}
\DoxyCodeLine{6345 }
\DoxyCodeLine{6346         \textcolor{keywordtype}{void} testGroupEnded(TestGroupStats \textcolor{keyword}{const}\& testGroupStats) \textcolor{keyword}{override};}
\DoxyCodeLine{6347 }
\DoxyCodeLine{6348         \textcolor{keywordtype}{void} testRunEndedCumulative() \textcolor{keyword}{override};}
\DoxyCodeLine{6349 }
\DoxyCodeLine{6350         \textcolor{keywordtype}{void} writeGroup(TestGroupNode \textcolor{keyword}{const}\& groupNode, \textcolor{keywordtype}{double} suiteTime);}
\DoxyCodeLine{6351 }
\DoxyCodeLine{6352         \textcolor{keywordtype}{void} writeTestCase(TestCaseNode \textcolor{keyword}{const}\& testCaseNode);}
\DoxyCodeLine{6353 }
\DoxyCodeLine{6354         \textcolor{keywordtype}{void} writeSection( std::string \textcolor{keyword}{const}\& className,}
\DoxyCodeLine{6355                            std::string \textcolor{keyword}{const}\& rootName,}
\DoxyCodeLine{6356                            SectionNode \textcolor{keyword}{const}\& sectionNode,}
\DoxyCodeLine{6357                            \textcolor{keywordtype}{bool} testOkToFail );}
\DoxyCodeLine{6358 }
\DoxyCodeLine{6359         \textcolor{keywordtype}{void} writeAssertions(SectionNode \textcolor{keyword}{const}\& sectionNode);}
\DoxyCodeLine{6360         \textcolor{keywordtype}{void} writeAssertion(AssertionStats \textcolor{keyword}{const}\& stats);}
\DoxyCodeLine{6361 }
\DoxyCodeLine{6362         XmlWriter xml;}
\DoxyCodeLine{6363         Timer suiteTimer;}
\DoxyCodeLine{6364         std::string stdOutForSuite;}
\DoxyCodeLine{6365         std::string stdErrForSuite;}
\DoxyCodeLine{6366         \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} unexpectedExceptions = 0;}
\DoxyCodeLine{6367         \textcolor{keywordtype}{bool} m\_okToFail = \textcolor{keyword}{false};}
\DoxyCodeLine{6368     \};}
\DoxyCodeLine{6369 }
\DoxyCodeLine{6370 \} \textcolor{comment}{// end namespace Catch}}
\DoxyCodeLine{6371 }
\DoxyCodeLine{6372 \textcolor{comment}{// end catch\_reporter\_junit.h}}
\DoxyCodeLine{6373 \textcolor{comment}{// start catch\_reporter\_xml.h}}
\DoxyCodeLine{6374 }
\DoxyCodeLine{6375 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{6376     \textcolor{keyword}{class }XmlReporter : \textcolor{keyword}{public} StreamingReporterBase<XmlReporter> \{}
\DoxyCodeLine{6377     \textcolor{keyword}{public}:}
\DoxyCodeLine{6378         XmlReporter(ReporterConfig \textcolor{keyword}{const}\& \_config);}
\DoxyCodeLine{6379 }
\DoxyCodeLine{6380         \string~XmlReporter() \textcolor{keyword}{override};}
\DoxyCodeLine{6381 }
\DoxyCodeLine{6382         \textcolor{keyword}{static} std::string getDescription();}
\DoxyCodeLine{6383 }
\DoxyCodeLine{6384         \textcolor{keyword}{virtual} std::string getStylesheetRef() \textcolor{keyword}{const};}
\DoxyCodeLine{6385 }
\DoxyCodeLine{6386         \textcolor{keywordtype}{void} writeSourceInfo(SourceLineInfo \textcolor{keyword}{const}\& sourceInfo);}
\DoxyCodeLine{6387 }
\DoxyCodeLine{6388     \textcolor{keyword}{public}: \textcolor{comment}{// StreamingReporterBase}}
\DoxyCodeLine{6389 }
\DoxyCodeLine{6390         \textcolor{keywordtype}{void} noMatchingTestCases(std::string \textcolor{keyword}{const}\& s) \textcolor{keyword}{override};}
\DoxyCodeLine{6391 }
\DoxyCodeLine{6392         \textcolor{keywordtype}{void} testRunStarting(TestRunInfo \textcolor{keyword}{const}\& testInfo) \textcolor{keyword}{override};}
\DoxyCodeLine{6393 }
\DoxyCodeLine{6394         \textcolor{keywordtype}{void} testGroupStarting(GroupInfo \textcolor{keyword}{const}\& groupInfo) \textcolor{keyword}{override};}
\DoxyCodeLine{6395 }
\DoxyCodeLine{6396         \textcolor{keywordtype}{void} testCaseStarting(TestCaseInfo \textcolor{keyword}{const}\& testInfo) \textcolor{keyword}{override};}
\DoxyCodeLine{6397 }
\DoxyCodeLine{6398         \textcolor{keywordtype}{void} sectionStarting(SectionInfo \textcolor{keyword}{const}\& sectionInfo) \textcolor{keyword}{override};}
\DoxyCodeLine{6399 }
\DoxyCodeLine{6400         \textcolor{keywordtype}{void} assertionStarting(AssertionInfo \textcolor{keyword}{const}\&) \textcolor{keyword}{override};}
\DoxyCodeLine{6401 }
\DoxyCodeLine{6402         \textcolor{keywordtype}{bool} assertionEnded(AssertionStats \textcolor{keyword}{const}\& assertionStats) \textcolor{keyword}{override};}
\DoxyCodeLine{6403 }
\DoxyCodeLine{6404         \textcolor{keywordtype}{void} sectionEnded(SectionStats \textcolor{keyword}{const}\& sectionStats) \textcolor{keyword}{override};}
\DoxyCodeLine{6405 }
\DoxyCodeLine{6406         \textcolor{keywordtype}{void} testCaseEnded(TestCaseStats \textcolor{keyword}{const}\& testCaseStats) \textcolor{keyword}{override};}
\DoxyCodeLine{6407 }
\DoxyCodeLine{6408         \textcolor{keywordtype}{void} testGroupEnded(TestGroupStats \textcolor{keyword}{const}\& testGroupStats) \textcolor{keyword}{override};}
\DoxyCodeLine{6409 }
\DoxyCodeLine{6410         \textcolor{keywordtype}{void} testRunEnded(TestRunStats \textcolor{keyword}{const}\& testRunStats) \textcolor{keyword}{override};}
\DoxyCodeLine{6411 }
\DoxyCodeLine{6412 \textcolor{preprocessor}{\#if defined(CATCH\_CONFIG\_ENABLE\_BENCHMARKING)}}
\DoxyCodeLine{6413         \textcolor{keywordtype}{void} benchmarkPreparing(std::string \textcolor{keyword}{const}\& name) \textcolor{keyword}{override};}
\DoxyCodeLine{6414         \textcolor{keywordtype}{void} benchmarkStarting(BenchmarkInfo \textcolor{keyword}{const}\&) \textcolor{keyword}{override};}
\DoxyCodeLine{6415         \textcolor{keywordtype}{void} benchmarkEnded(BenchmarkStats<> \textcolor{keyword}{const}\&) \textcolor{keyword}{override};}
\DoxyCodeLine{6416         \textcolor{keywordtype}{void} benchmarkFailed(std::string \textcolor{keyword}{const}\&) \textcolor{keyword}{override};}
\DoxyCodeLine{6417 \textcolor{preprocessor}{\#endif }\textcolor{comment}{// CATCH\_CONFIG\_ENABLE\_BENCHMARKING}}
\DoxyCodeLine{6418 }
\DoxyCodeLine{6419     \textcolor{keyword}{private}:}
\DoxyCodeLine{6420         Timer m\_testCaseTimer;}
\DoxyCodeLine{6421         XmlWriter m\_xml;}
\DoxyCodeLine{6422         \textcolor{keywordtype}{int} m\_sectionDepth = 0;}
\DoxyCodeLine{6423     \};}
\DoxyCodeLine{6424 }
\DoxyCodeLine{6425 \} \textcolor{comment}{// end namespace Catch}}
\DoxyCodeLine{6426 }
\DoxyCodeLine{6427 \textcolor{comment}{// end catch\_reporter\_xml.h}}
\DoxyCodeLine{6428 }
\DoxyCodeLine{6429 \textcolor{comment}{// end catch\_external\_interfaces.h}}
\DoxyCodeLine{6430 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{6431 }
\DoxyCodeLine{6432 \textcolor{preprocessor}{\#if defined(CATCH\_CONFIG\_ENABLE\_BENCHMARKING)}}
\DoxyCodeLine{6433 \textcolor{comment}{// start catch\_benchmarking\_all.hpp}}
\DoxyCodeLine{6434 }
\DoxyCodeLine{6435 \textcolor{comment}{// A proxy header that includes all of the benchmarking headers to allow}}
\DoxyCodeLine{6436 \textcolor{comment}{// concise include of the benchmarking features. You should prefer the}}
\DoxyCodeLine{6437 \textcolor{comment}{// individual includes in standard use.}}
\DoxyCodeLine{6438 }
\DoxyCodeLine{6439 \textcolor{comment}{// start catch\_benchmark.hpp}}
\DoxyCodeLine{6440 }
\DoxyCodeLine{6441  \textcolor{comment}{// Benchmark}}
\DoxyCodeLine{6442 }
\DoxyCodeLine{6443 \textcolor{comment}{// start catch\_chronometer.hpp}}
\DoxyCodeLine{6444 }
\DoxyCodeLine{6445 \textcolor{comment}{// User-\/facing chronometer}}
\DoxyCodeLine{6446 }
\DoxyCodeLine{6447 }
\DoxyCodeLine{6448 \textcolor{comment}{// start catch\_clock.hpp}}
\DoxyCodeLine{6449 }
\DoxyCodeLine{6450 \textcolor{comment}{// Clocks}}
\DoxyCodeLine{6451 }
\DoxyCodeLine{6452 }
\DoxyCodeLine{6453 \textcolor{preprocessor}{\#include <chrono>}}
\DoxyCodeLine{6454 \textcolor{preprocessor}{\#include <ratio>}}
\DoxyCodeLine{6455 }
\DoxyCodeLine{6456 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{6457     \textcolor{keyword}{namespace }Benchmark \{}
\DoxyCodeLine{6458         \textcolor{keyword}{template} <\textcolor{keyword}{typename} Clock>}
\DoxyCodeLine{6459         \textcolor{keyword}{using }ClockDuration = \textcolor{keyword}{typename} Clock::duration;}
\DoxyCodeLine{6460         \textcolor{keyword}{template} <\textcolor{keyword}{typename} Clock>}
\DoxyCodeLine{6461         \textcolor{keyword}{using }FloatDuration = std::chrono::duration<double, typename Clock::period>;}
\DoxyCodeLine{6462 }
\DoxyCodeLine{6463         \textcolor{keyword}{template} <\textcolor{keyword}{typename} Clock>}
\DoxyCodeLine{6464         \textcolor{keyword}{using }TimePoint = \textcolor{keyword}{typename} Clock::time\_point;}
\DoxyCodeLine{6465 }
\DoxyCodeLine{6466         \textcolor{keyword}{using }default\_clock = std::chrono::steady\_clock;}
\DoxyCodeLine{6467 }
\DoxyCodeLine{6468         \textcolor{keyword}{template} <\textcolor{keyword}{typename} Clock>}
\DoxyCodeLine{6469         \textcolor{keyword}{struct }now \{}
\DoxyCodeLine{6470             TimePoint<Clock> operator()()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{6471                 \textcolor{keywordflow}{return} Clock::now();}
\DoxyCodeLine{6472             \}}
\DoxyCodeLine{6473         \};}
\DoxyCodeLine{6474 }
\DoxyCodeLine{6475         \textcolor{keyword}{using }fp\_seconds = std::chrono::duration<double, std::ratio<1>>;}
\DoxyCodeLine{6476     \} \textcolor{comment}{// namespace Benchmark}}
\DoxyCodeLine{6477 \} \textcolor{comment}{// namespace Catch}}
\DoxyCodeLine{6478 }
\DoxyCodeLine{6479 \textcolor{comment}{// end catch\_clock.hpp}}
\DoxyCodeLine{6480 \textcolor{comment}{// start catch\_optimizer.hpp}}
\DoxyCodeLine{6481 }
\DoxyCodeLine{6482  \textcolor{comment}{// Hinting the optimizer}}
\DoxyCodeLine{6483 }
\DoxyCodeLine{6484 }
\DoxyCodeLine{6485 \textcolor{preprocessor}{\#if defined(\_MSC\_VER)}}
\DoxyCodeLine{6486 \textcolor{preprocessor}{\#   include <atomic>} \textcolor{comment}{// atomic\_thread\_fence}}
\DoxyCodeLine{6487 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{6488 }
\DoxyCodeLine{6489 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{6490     \textcolor{keyword}{namespace }Benchmark \{}
\DoxyCodeLine{6491 \textcolor{preprocessor}{\#if defined(\_\_GNUC\_\_) || defined(\_\_clang\_\_)}}
\DoxyCodeLine{6492         \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{6493         \textcolor{keyword}{inline} \textcolor{keywordtype}{void} keep\_memory(T* p) \{}
\DoxyCodeLine{6494             \textcolor{keyword}{asm} \textcolor{keyword}{volatile}(\textcolor{stringliteral}{"{}"{}} : : \textcolor{stringliteral}{"{}g"{}}(p) : \textcolor{stringliteral}{"{}memory"{}});}
\DoxyCodeLine{6495         \}}
\DoxyCodeLine{6496         \textcolor{keyword}{inline} \textcolor{keywordtype}{void} keep\_memory() \{}
\DoxyCodeLine{6497             \textcolor{keyword}{asm} \textcolor{keyword}{volatile}(\textcolor{stringliteral}{"{}"{}} : : : \textcolor{stringliteral}{"{}memory"{}});}
\DoxyCodeLine{6498         \}}
\DoxyCodeLine{6499 }
\DoxyCodeLine{6500         \textcolor{keyword}{namespace }Detail \{}
\DoxyCodeLine{6501             \textcolor{keyword}{inline} \textcolor{keywordtype}{void} optimizer\_barrier() \{ keep\_memory(); \}}
\DoxyCodeLine{6502         \} \textcolor{comment}{// namespace Detail}}
\DoxyCodeLine{6503 \textcolor{preprocessor}{\#elif defined(\_MSC\_VER)}}
\DoxyCodeLine{6504 }
\DoxyCodeLine{6505 \textcolor{preprocessor}{\#pragma optimize("{}"{}}, off)}
\DoxyCodeLine{6506         \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{6507         \textcolor{keyword}{inline} \textcolor{keywordtype}{void} keep\_memory(T* p) \{}
\DoxyCodeLine{6508             \textcolor{comment}{// thanks @milleniumbug}}
\DoxyCodeLine{6509             *\textcolor{keyword}{reinterpret\_cast<}\textcolor{keywordtype}{char} volatile*\textcolor{keyword}{>}(p) = *\textcolor{keyword}{reinterpret\_cast<}\textcolor{keywordtype}{char} \textcolor{keyword}{const }volatile*\textcolor{keyword}{>}(p);}
\DoxyCodeLine{6510         \}}
\DoxyCodeLine{6511         \textcolor{comment}{// TODO equivalent keep\_memory()}}
\DoxyCodeLine{6512 \textcolor{preprocessor}{\#pragma optimize("{}"{}}, on)}
\DoxyCodeLine{6513 }
\DoxyCodeLine{6514         \textcolor{keyword}{namespace }Detail \{}
\DoxyCodeLine{6515             \textcolor{keyword}{inline} \textcolor{keywordtype}{void} optimizer\_barrier() \{}
\DoxyCodeLine{6516                 std::atomic\_thread\_fence(std::memory\_order\_seq\_cst);}
\DoxyCodeLine{6517             \}}
\DoxyCodeLine{6518         \} \textcolor{comment}{// namespace Detail}}
\DoxyCodeLine{6519 }
\DoxyCodeLine{6520 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{6521 }
\DoxyCodeLine{6522         \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{6523         \textcolor{keyword}{inline} \textcolor{keywordtype}{void} deoptimize\_value(T\&\& x) \{}
\DoxyCodeLine{6524             keep\_memory(\&x);}
\DoxyCodeLine{6525         \}}
\DoxyCodeLine{6526 }
\DoxyCodeLine{6527         \textcolor{keyword}{template} <\textcolor{keyword}{typename} Fn, \textcolor{keyword}{typename}... Args>}
\DoxyCodeLine{6528         \textcolor{keyword}{inline} \textcolor{keyword}{auto} invoke\_deoptimized(Fn\&\& fn, Args\&\&... args) -\/> \textcolor{keyword}{typename} std::enable\_if<!std::is\_same<void, \textcolor{keyword}{decltype}(fn(args...))>::value>::type \{}
\DoxyCodeLine{6529             deoptimize\_value(std::forward<Fn>(fn) (std::forward<Args...>(args...)));}
\DoxyCodeLine{6530         \}}
\DoxyCodeLine{6531 }
\DoxyCodeLine{6532         \textcolor{keyword}{template} <\textcolor{keyword}{typename} Fn, \textcolor{keyword}{typename}... Args>}
\DoxyCodeLine{6533         \textcolor{keyword}{inline} \textcolor{keyword}{auto} invoke\_deoptimized(Fn\&\& fn, Args\&\&... args) -\/> \textcolor{keyword}{typename} std::enable\_if<std::is\_same<void, \textcolor{keyword}{decltype}(fn(args...))>::value>::type \{}
\DoxyCodeLine{6534             std::forward<Fn>(fn) (std::forward<Args...>(args...));}
\DoxyCodeLine{6535         \}}
\DoxyCodeLine{6536     \} \textcolor{comment}{// namespace Benchmark}}
\DoxyCodeLine{6537 \} \textcolor{comment}{// namespace Catch}}
\DoxyCodeLine{6538 }
\DoxyCodeLine{6539 \textcolor{comment}{// end catch\_optimizer.hpp}}
\DoxyCodeLine{6540 \textcolor{comment}{// start catch\_complete\_invoke.hpp}}
\DoxyCodeLine{6541 }
\DoxyCodeLine{6542 \textcolor{comment}{// Invoke with a special case for void}}
\DoxyCodeLine{6543 }
\DoxyCodeLine{6544 }
\DoxyCodeLine{6545 \textcolor{preprocessor}{\#include <type\_traits>}}
\DoxyCodeLine{6546 \textcolor{preprocessor}{\#include <utility>}}
\DoxyCodeLine{6547 }
\DoxyCodeLine{6548 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{6549     \textcolor{keyword}{namespace }Benchmark \{}
\DoxyCodeLine{6550         \textcolor{keyword}{namespace }Detail \{}
\DoxyCodeLine{6551             \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{6552             \textcolor{keyword}{struct }CompleteType \{ \textcolor{keyword}{using }type = T; \};}
\DoxyCodeLine{6553             \textcolor{keyword}{template} <>}
\DoxyCodeLine{6554             \textcolor{keyword}{struct }CompleteType<void> \{ \textcolor{keyword}{struct }type \{\}; \};}
\DoxyCodeLine{6555 }
\DoxyCodeLine{6556             \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{6557             \textcolor{keyword}{using }CompleteType\_t = \textcolor{keyword}{typename} CompleteType<T>::type;}
\DoxyCodeLine{6558 }
\DoxyCodeLine{6559             \textcolor{keyword}{template} <\textcolor{keyword}{typename} Result>}
\DoxyCodeLine{6560             \textcolor{keyword}{struct }CompleteInvoker \{}
\DoxyCodeLine{6561                 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Fun, \textcolor{keyword}{typename}... Args>}
\DoxyCodeLine{6562                 \textcolor{keyword}{static} Result invoke(Fun\&\& fun, Args\&\&... args) \{}
\DoxyCodeLine{6563                     \textcolor{keywordflow}{return} std::forward<Fun>(fun)(std::forward<Args>(args)...);}
\DoxyCodeLine{6564                 \}}
\DoxyCodeLine{6565             \};}
\DoxyCodeLine{6566             \textcolor{keyword}{template} <>}
\DoxyCodeLine{6567             \textcolor{keyword}{struct }CompleteInvoker<void> \{}
\DoxyCodeLine{6568                 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Fun, \textcolor{keyword}{typename}... Args>}
\DoxyCodeLine{6569                 \textcolor{keyword}{static} CompleteType\_t<void> invoke(Fun\&\& fun, Args\&\&... args) \{}
\DoxyCodeLine{6570                     std::forward<Fun>(fun)(std::forward<Args>(args)...);}
\DoxyCodeLine{6571                     \textcolor{keywordflow}{return} \{\};}
\DoxyCodeLine{6572                 \}}
\DoxyCodeLine{6573             \};}
\DoxyCodeLine{6574 }
\DoxyCodeLine{6575             \textcolor{comment}{// invoke and not return void :(}}
\DoxyCodeLine{6576             \textcolor{keyword}{template} <\textcolor{keyword}{typename} Fun, \textcolor{keyword}{typename}... Args>}
\DoxyCodeLine{6577             CompleteType\_t<FunctionReturnType<Fun, Args...>> complete\_invoke(Fun\&\& fun, Args\&\&... args) \{}
\DoxyCodeLine{6578                 \textcolor{keywordflow}{return} CompleteInvoker<FunctionReturnType<Fun, Args...>>::invoke(std::forward<Fun>(fun), std::forward<Args>(args)...);}
\DoxyCodeLine{6579             \}}
\DoxyCodeLine{6580 }
\DoxyCodeLine{6581             \textcolor{keyword}{const} std::string benchmarkErrorMsg = \textcolor{stringliteral}{"{}a benchmark failed to run successfully"{}};}
\DoxyCodeLine{6582         \} \textcolor{comment}{// namespace Detail}}
\DoxyCodeLine{6583 }
\DoxyCodeLine{6584         \textcolor{keyword}{template} <\textcolor{keyword}{typename} Fun>}
\DoxyCodeLine{6585         Detail::CompleteType\_t<FunctionReturnType<Fun>> user\_code(Fun\&\& fun) \{}
\DoxyCodeLine{6586             CATCH\_TRY\{}
\DoxyCodeLine{6587                 \textcolor{keywordflow}{return} Detail::complete\_invoke(std::forward<Fun>(fun));}
\DoxyCodeLine{6588             \} CATCH\_CATCH\_ALL\{}
\DoxyCodeLine{6589                 getResultCapture().benchmarkFailed(translateActiveException());}
\DoxyCodeLine{6590                 CATCH\_RUNTIME\_ERROR(Detail::benchmarkErrorMsg);}
\DoxyCodeLine{6591             \}}
\DoxyCodeLine{6592         \}}
\DoxyCodeLine{6593     \} \textcolor{comment}{// namespace Benchmark}}
\DoxyCodeLine{6594 \} \textcolor{comment}{// namespace Catch}}
\DoxyCodeLine{6595 }
\DoxyCodeLine{6596 \textcolor{comment}{// end catch\_complete\_invoke.hpp}}
\DoxyCodeLine{6597 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{6598     \textcolor{keyword}{namespace }Benchmark \{}
\DoxyCodeLine{6599         \textcolor{keyword}{namespace }Detail \{}
\DoxyCodeLine{6600             \textcolor{keyword}{struct }ChronometerConcept \{}
\DoxyCodeLine{6601                 \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} start() = 0;}
\DoxyCodeLine{6602                 \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} finish() = 0;}
\DoxyCodeLine{6603                 \textcolor{keyword}{virtual} \string~ChronometerConcept() = \textcolor{keywordflow}{default};}
\DoxyCodeLine{6604             \};}
\DoxyCodeLine{6605             \textcolor{keyword}{template} <\textcolor{keyword}{typename} Clock>}
\DoxyCodeLine{6606             \textcolor{keyword}{struct }ChronometerModel final : \textcolor{keyword}{public} ChronometerConcept \{}
\DoxyCodeLine{6607                 \textcolor{keywordtype}{void} start()\textcolor{keyword}{ override }\{ started = Clock::now(); \}}
\DoxyCodeLine{6608                 \textcolor{keywordtype}{void} finish()\textcolor{keyword}{ override }\{ finished = Clock::now(); \}}
\DoxyCodeLine{6609 }
\DoxyCodeLine{6610                 ClockDuration<Clock> elapsed()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} finished -\/ started; \}}
\DoxyCodeLine{6611 }
\DoxyCodeLine{6612                 TimePoint<Clock> started;}
\DoxyCodeLine{6613                 TimePoint<Clock> finished;}
\DoxyCodeLine{6614             \};}
\DoxyCodeLine{6615         \} \textcolor{comment}{// namespace Detail}}
\DoxyCodeLine{6616 }
\DoxyCodeLine{6617         \textcolor{keyword}{struct }Chronometer \{}
\DoxyCodeLine{6618         \textcolor{keyword}{public}:}
\DoxyCodeLine{6619             \textcolor{keyword}{template} <\textcolor{keyword}{typename} Fun>}
\DoxyCodeLine{6620             \textcolor{keywordtype}{void} measure(Fun\&\& fun) \{ measure(std::forward<Fun>(fun), is\_callable<Fun(\textcolor{keywordtype}{int})>()); \}}
\DoxyCodeLine{6621 }
\DoxyCodeLine{6622             \textcolor{keywordtype}{int} runs()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} k; \}}
\DoxyCodeLine{6623 }
\DoxyCodeLine{6624             Chronometer(Detail::ChronometerConcept\& meter, \textcolor{keywordtype}{int} k)}
\DoxyCodeLine{6625                 : impl(\&meter)}
\DoxyCodeLine{6626                 , k(k) \{\}}
\DoxyCodeLine{6627 }
\DoxyCodeLine{6628         \textcolor{keyword}{private}:}
\DoxyCodeLine{6629             \textcolor{keyword}{template} <\textcolor{keyword}{typename} Fun>}
\DoxyCodeLine{6630             \textcolor{keywordtype}{void} measure(Fun\&\& fun, std::false\_type) \{}
\DoxyCodeLine{6631                 measure([\&fun](\textcolor{keywordtype}{int}) \{ \textcolor{keywordflow}{return} fun(); \}, std::true\_type());}
\DoxyCodeLine{6632             \}}
\DoxyCodeLine{6633 }
\DoxyCodeLine{6634             \textcolor{keyword}{template} <\textcolor{keyword}{typename} Fun>}
\DoxyCodeLine{6635             \textcolor{keywordtype}{void} measure(Fun\&\& fun, std::true\_type) \{}
\DoxyCodeLine{6636                 Detail::optimizer\_barrier();}
\DoxyCodeLine{6637                 impl-\/>start();}
\DoxyCodeLine{6638                 \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = 0; i < k; ++i) invoke\_deoptimized(fun, i);}
\DoxyCodeLine{6639                 impl-\/>finish();}
\DoxyCodeLine{6640                 Detail::optimizer\_barrier();}
\DoxyCodeLine{6641             \}}
\DoxyCodeLine{6642 }
\DoxyCodeLine{6643             Detail::ChronometerConcept* impl;}
\DoxyCodeLine{6644             \textcolor{keywordtype}{int} k;}
\DoxyCodeLine{6645         \};}
\DoxyCodeLine{6646     \} \textcolor{comment}{// namespace Benchmark}}
\DoxyCodeLine{6647 \} \textcolor{comment}{// namespace Catch}}
\DoxyCodeLine{6648 }
\DoxyCodeLine{6649 \textcolor{comment}{// end catch\_chronometer.hpp}}
\DoxyCodeLine{6650 \textcolor{comment}{// start catch\_environment.hpp}}
\DoxyCodeLine{6651 }
\DoxyCodeLine{6652 \textcolor{comment}{// Environment information}}
\DoxyCodeLine{6653 }
\DoxyCodeLine{6654 }
\DoxyCodeLine{6655 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{6656     \textcolor{keyword}{namespace }Benchmark \{}
\DoxyCodeLine{6657         \textcolor{keyword}{template} <\textcolor{keyword}{typename} Duration>}
\DoxyCodeLine{6658         \textcolor{keyword}{struct }EnvironmentEstimate \{}
\DoxyCodeLine{6659             Duration mean;}
\DoxyCodeLine{6660             OutlierClassification outliers;}
\DoxyCodeLine{6661 }
\DoxyCodeLine{6662             \textcolor{keyword}{template} <\textcolor{keyword}{typename} Duration2>}
\DoxyCodeLine{6663             \textcolor{keyword}{operator} EnvironmentEstimate<Duration2>()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{6664                 \textcolor{keywordflow}{return} \{ mean, outliers \};}
\DoxyCodeLine{6665             \}}
\DoxyCodeLine{6666         \};}
\DoxyCodeLine{6667         \textcolor{keyword}{template} <\textcolor{keyword}{typename} Clock>}
\DoxyCodeLine{6668         \textcolor{keyword}{struct }Environment \{}
\DoxyCodeLine{6669             \textcolor{keyword}{using }clock\_type = Clock;}
\DoxyCodeLine{6670             EnvironmentEstimate<FloatDuration<Clock>> clock\_resolution;}
\DoxyCodeLine{6671             EnvironmentEstimate<FloatDuration<Clock>> clock\_cost;}
\DoxyCodeLine{6672         \};}
\DoxyCodeLine{6673     \} \textcolor{comment}{// namespace Benchmark}}
\DoxyCodeLine{6674 \} \textcolor{comment}{// namespace Catch}}
\DoxyCodeLine{6675 }
\DoxyCodeLine{6676 \textcolor{comment}{// end catch\_environment.hpp}}
\DoxyCodeLine{6677 \textcolor{comment}{// start catch\_execution\_plan.hpp}}
\DoxyCodeLine{6678 }
\DoxyCodeLine{6679  \textcolor{comment}{// Execution plan}}
\DoxyCodeLine{6680 }
\DoxyCodeLine{6681 }
\DoxyCodeLine{6682 \textcolor{comment}{// start catch\_benchmark\_function.hpp}}
\DoxyCodeLine{6683 }
\DoxyCodeLine{6684  \textcolor{comment}{// Dumb std::function implementation for consistent call overhead}}
\DoxyCodeLine{6685 }
\DoxyCodeLine{6686 }
\DoxyCodeLine{6687 \textcolor{preprocessor}{\#include <cassert>}}
\DoxyCodeLine{6688 \textcolor{preprocessor}{\#include <type\_traits>}}
\DoxyCodeLine{6689 \textcolor{preprocessor}{\#include <utility>}}
\DoxyCodeLine{6690 \textcolor{preprocessor}{\#include <memory>}}
\DoxyCodeLine{6691 }
\DoxyCodeLine{6692 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{6693     \textcolor{keyword}{namespace }Benchmark \{}
\DoxyCodeLine{6694         \textcolor{keyword}{namespace }Detail \{}
\DoxyCodeLine{6695             \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{6696             \textcolor{keyword}{using }Decay = \textcolor{keyword}{typename} std::decay<T>::type;}
\DoxyCodeLine{6697             \textcolor{keyword}{template} <\textcolor{keyword}{typename} T, \textcolor{keyword}{typename} U>}
\DoxyCodeLine{6698             \textcolor{keyword}{struct }is\_related}
\DoxyCodeLine{6699                 : std::is\_same<Decay<T>, Decay<U>> \{\};}
\DoxyCodeLine{6700 }
\DoxyCodeLine{6708             \textcolor{keyword}{struct }BenchmarkFunction \{}
\DoxyCodeLine{6709             \textcolor{keyword}{private}:}
\DoxyCodeLine{6710                 \textcolor{keyword}{struct }callable \{}
\DoxyCodeLine{6711                     \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} call(Chronometer meter) \textcolor{keyword}{const} = 0;}
\DoxyCodeLine{6712                     \textcolor{keyword}{virtual} callable* clone() \textcolor{keyword}{const} = 0;}
\DoxyCodeLine{6713                     \textcolor{keyword}{virtual} \string~callable() = \textcolor{keywordflow}{default};}
\DoxyCodeLine{6714                 \};}
\DoxyCodeLine{6715                 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Fun>}
\DoxyCodeLine{6716                 \textcolor{keyword}{struct }model : \textcolor{keyword}{public} callable \{}
\DoxyCodeLine{6717                     model(Fun\&\& fun) : fun(std::move(fun)) \{\}}
\DoxyCodeLine{6718                     model(Fun \textcolor{keyword}{const}\& fun) : fun(fun) \{\}}
\DoxyCodeLine{6719 }
\DoxyCodeLine{6720                     model<Fun>* clone()\textcolor{keyword}{ const override }\{ \textcolor{keywordflow}{return} \textcolor{keyword}{new} model<Fun>(*\textcolor{keyword}{this}); \}}
\DoxyCodeLine{6721 }
\DoxyCodeLine{6722                     \textcolor{keywordtype}{void} call(Chronometer meter)\textcolor{keyword}{ const override }\{}
\DoxyCodeLine{6723                         call(meter, is\_callable<Fun(Chronometer)>());}
\DoxyCodeLine{6724                     \}}
\DoxyCodeLine{6725                     \textcolor{keywordtype}{void} call(Chronometer meter, std::true\_type)\textcolor{keyword}{ const }\{}
\DoxyCodeLine{6726                         fun(meter);}
\DoxyCodeLine{6727                     \}}
\DoxyCodeLine{6728                     \textcolor{keywordtype}{void} call(Chronometer meter, std::false\_type)\textcolor{keyword}{ const }\{}
\DoxyCodeLine{6729                         meter.measure(fun);}
\DoxyCodeLine{6730                     \}}
\DoxyCodeLine{6731 }
\DoxyCodeLine{6732                     Fun fun;}
\DoxyCodeLine{6733                 \};}
\DoxyCodeLine{6734 }
\DoxyCodeLine{6735                 \textcolor{keyword}{struct }do\_nothing \{ \textcolor{keywordtype}{void} operator()()\textcolor{keyword}{ const }\{\} \};}
\DoxyCodeLine{6736 }
\DoxyCodeLine{6737                 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{6738                 BenchmarkFunction(model<T>* c) : f(c) \{\}}
\DoxyCodeLine{6739 }
\DoxyCodeLine{6740             \textcolor{keyword}{public}:}
\DoxyCodeLine{6741                 BenchmarkFunction()}
\DoxyCodeLine{6742                     : f(new model<do\_nothing>\{ \{\} \}) \{\}}
\DoxyCodeLine{6743 }
\DoxyCodeLine{6744                 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Fun,}
\DoxyCodeLine{6745                     \textcolor{keyword}{typename} std::enable\_if<!is\_related<Fun, BenchmarkFunction>::value, \textcolor{keywordtype}{int}>::type = 0>}
\DoxyCodeLine{6746                     BenchmarkFunction(Fun\&\& fun)}
\DoxyCodeLine{6747                     : f(new model<typename std::decay<Fun>::type>(std::forward<Fun>(fun))) \{\}}
\DoxyCodeLine{6748 }
\DoxyCodeLine{6749                 BenchmarkFunction(BenchmarkFunction\&\& that)}
\DoxyCodeLine{6750                     : f(std::move(that.f)) \{\}}
\DoxyCodeLine{6751 }
\DoxyCodeLine{6752                 BenchmarkFunction(BenchmarkFunction \textcolor{keyword}{const}\& that)}
\DoxyCodeLine{6753                     : f(that.f-\/>clone()) \{\}}
\DoxyCodeLine{6754 }
\DoxyCodeLine{6755                 BenchmarkFunction\& operator=(BenchmarkFunction\&\& that) \{}
\DoxyCodeLine{6756                     f = std::move(that.f);}
\DoxyCodeLine{6757                     \textcolor{keywordflow}{return} *\textcolor{keyword}{this};}
\DoxyCodeLine{6758                 \}}
\DoxyCodeLine{6759 }
\DoxyCodeLine{6760                 BenchmarkFunction\& operator=(BenchmarkFunction \textcolor{keyword}{const}\& that) \{}
\DoxyCodeLine{6761                     f.reset(that.f-\/>clone());}
\DoxyCodeLine{6762                     \textcolor{keywordflow}{return} *\textcolor{keyword}{this};}
\DoxyCodeLine{6763                 \}}
\DoxyCodeLine{6764 }
\DoxyCodeLine{6765                 \textcolor{keywordtype}{void} operator()(Chronometer meter)\textcolor{keyword}{ const }\{ f-\/>call(meter); \}}
\DoxyCodeLine{6766 }
\DoxyCodeLine{6767             \textcolor{keyword}{private}:}
\DoxyCodeLine{6768                 std::unique\_ptr<callable> f;}
\DoxyCodeLine{6769             \};}
\DoxyCodeLine{6770         \} \textcolor{comment}{// namespace Detail}}
\DoxyCodeLine{6771     \} \textcolor{comment}{// namespace Benchmark}}
\DoxyCodeLine{6772 \} \textcolor{comment}{// namespace Catch}}
\DoxyCodeLine{6773 }
\DoxyCodeLine{6774 \textcolor{comment}{// end catch\_benchmark\_function.hpp}}
\DoxyCodeLine{6775 \textcolor{comment}{// start catch\_repeat.hpp}}
\DoxyCodeLine{6776 }
\DoxyCodeLine{6777 \textcolor{comment}{// repeat algorithm}}
\DoxyCodeLine{6778 }
\DoxyCodeLine{6779 }
\DoxyCodeLine{6780 \textcolor{preprocessor}{\#include <type\_traits>}}
\DoxyCodeLine{6781 \textcolor{preprocessor}{\#include <utility>}}
\DoxyCodeLine{6782 }
\DoxyCodeLine{6783 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{6784     \textcolor{keyword}{namespace }Benchmark \{}
\DoxyCodeLine{6785         \textcolor{keyword}{namespace }Detail \{}
\DoxyCodeLine{6786             \textcolor{keyword}{template} <\textcolor{keyword}{typename} Fun>}
\DoxyCodeLine{6787             \textcolor{keyword}{struct }repeater \{}
\DoxyCodeLine{6788                 \textcolor{keywordtype}{void} operator()(\textcolor{keywordtype}{int} k)\textcolor{keyword}{ const }\{}
\DoxyCodeLine{6789                     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = 0; i < k; ++i) \{}
\DoxyCodeLine{6790                         fun();}
\DoxyCodeLine{6791                     \}}
\DoxyCodeLine{6792                 \}}
\DoxyCodeLine{6793                 Fun fun;}
\DoxyCodeLine{6794             \};}
\DoxyCodeLine{6795             \textcolor{keyword}{template} <\textcolor{keyword}{typename} Fun>}
\DoxyCodeLine{6796             repeater<typename std::decay<Fun>::type> repeat(Fun\&\& fun) \{}
\DoxyCodeLine{6797                 \textcolor{keywordflow}{return} \{ std::forward<Fun>(fun) \};}
\DoxyCodeLine{6798             \}}
\DoxyCodeLine{6799         \} \textcolor{comment}{// namespace Detail}}
\DoxyCodeLine{6800     \} \textcolor{comment}{// namespace Benchmark}}
\DoxyCodeLine{6801 \} \textcolor{comment}{// namespace Catch}}
\DoxyCodeLine{6802 }
\DoxyCodeLine{6803 \textcolor{comment}{// end catch\_repeat.hpp}}
\DoxyCodeLine{6804 \textcolor{comment}{// start catch\_run\_for\_at\_least.hpp}}
\DoxyCodeLine{6805 }
\DoxyCodeLine{6806 \textcolor{comment}{// Run a function for a minimum amount of time}}
\DoxyCodeLine{6807 }
\DoxyCodeLine{6808 }
\DoxyCodeLine{6809 \textcolor{comment}{// start catch\_measure.hpp}}
\DoxyCodeLine{6810 }
\DoxyCodeLine{6811 \textcolor{comment}{// Measure}}
\DoxyCodeLine{6812 }
\DoxyCodeLine{6813 }
\DoxyCodeLine{6814 \textcolor{comment}{// start catch\_timing.hpp}}
\DoxyCodeLine{6815 }
\DoxyCodeLine{6816 \textcolor{comment}{// Timing}}
\DoxyCodeLine{6817 }
\DoxyCodeLine{6818 }
\DoxyCodeLine{6819 \textcolor{preprocessor}{\#include <tuple>}}
\DoxyCodeLine{6820 \textcolor{preprocessor}{\#include <type\_traits>}}
\DoxyCodeLine{6821 }
\DoxyCodeLine{6822 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{6823     \textcolor{keyword}{namespace }Benchmark \{}
\DoxyCodeLine{6824         \textcolor{keyword}{template} <\textcolor{keyword}{typename} Duration, \textcolor{keyword}{typename} Result>}
\DoxyCodeLine{6825         \textcolor{keyword}{struct }Timing \{}
\DoxyCodeLine{6826             Duration elapsed;}
\DoxyCodeLine{6827             Result result;}
\DoxyCodeLine{6828             \textcolor{keywordtype}{int} iterations;}
\DoxyCodeLine{6829         \};}
\DoxyCodeLine{6830         \textcolor{keyword}{template} <\textcolor{keyword}{typename} Clock, \textcolor{keyword}{typename} Func, \textcolor{keyword}{typename}... Args>}
\DoxyCodeLine{6831         \textcolor{keyword}{using }TimingOf = Timing<ClockDuration<Clock>, Detail::CompleteType\_t<FunctionReturnType<Func, Args...>>>;}
\DoxyCodeLine{6832     \} \textcolor{comment}{// namespace Benchmark}}
\DoxyCodeLine{6833 \} \textcolor{comment}{// namespace Catch}}
\DoxyCodeLine{6834 }
\DoxyCodeLine{6835 \textcolor{comment}{// end catch\_timing.hpp}}
\DoxyCodeLine{6836 \textcolor{preprocessor}{\#include <utility>}}
\DoxyCodeLine{6837 }
\DoxyCodeLine{6838 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{6839     \textcolor{keyword}{namespace }Benchmark \{}
\DoxyCodeLine{6840         \textcolor{keyword}{namespace }Detail \{}
\DoxyCodeLine{6841             \textcolor{keyword}{template} <\textcolor{keyword}{typename} Clock, \textcolor{keyword}{typename} Fun, \textcolor{keyword}{typename}... Args>}
\DoxyCodeLine{6842             TimingOf<Clock, Fun, Args...> measure(Fun\&\& fun, Args\&\&... args) \{}
\DoxyCodeLine{6843                 \textcolor{keyword}{auto} start = Clock::now();}
\DoxyCodeLine{6844                 \textcolor{keyword}{auto}\&\& r = Detail::complete\_invoke(fun, std::forward<Args>(args)...);}
\DoxyCodeLine{6845                 \textcolor{keyword}{auto} end = Clock::now();}
\DoxyCodeLine{6846                 \textcolor{keyword}{auto} delta = end -\/ start;}
\DoxyCodeLine{6847                 \textcolor{keywordflow}{return} \{ delta, std::forward<decltype(r)>(r), 1 \};}
\DoxyCodeLine{6848             \}}
\DoxyCodeLine{6849         \} \textcolor{comment}{// namespace Detail}}
\DoxyCodeLine{6850     \} \textcolor{comment}{// namespace Benchmark}}
\DoxyCodeLine{6851 \} \textcolor{comment}{// namespace Catch}}
\DoxyCodeLine{6852 }
\DoxyCodeLine{6853 \textcolor{comment}{// end catch\_measure.hpp}}
\DoxyCodeLine{6854 \textcolor{preprocessor}{\#include <utility>}}
\DoxyCodeLine{6855 \textcolor{preprocessor}{\#include <type\_traits>}}
\DoxyCodeLine{6856 }
\DoxyCodeLine{6857 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{6858     \textcolor{keyword}{namespace }Benchmark \{}
\DoxyCodeLine{6859         \textcolor{keyword}{namespace }Detail \{}
\DoxyCodeLine{6860             \textcolor{keyword}{template} <\textcolor{keyword}{typename} Clock, \textcolor{keyword}{typename} Fun>}
\DoxyCodeLine{6861             TimingOf<Clock, Fun, int> measure\_one(Fun\&\& fun, \textcolor{keywordtype}{int} iters, std::false\_type) \{}
\DoxyCodeLine{6862                 \textcolor{keywordflow}{return} Detail::measure<Clock>(fun, iters);}
\DoxyCodeLine{6863             \}}
\DoxyCodeLine{6864             \textcolor{keyword}{template} <\textcolor{keyword}{typename} Clock, \textcolor{keyword}{typename} Fun>}
\DoxyCodeLine{6865             TimingOf<Clock, Fun, Chronometer> measure\_one(Fun\&\& fun, \textcolor{keywordtype}{int} iters, std::true\_type) \{}
\DoxyCodeLine{6866                 Detail::ChronometerModel<Clock> meter;}
\DoxyCodeLine{6867                 \textcolor{keyword}{auto}\&\& result = Detail::complete\_invoke(fun, Chronometer(meter, iters));}
\DoxyCodeLine{6868 }
\DoxyCodeLine{6869                 \textcolor{keywordflow}{return} \{ meter.elapsed(), std::move(result), iters \};}
\DoxyCodeLine{6870             \}}
\DoxyCodeLine{6871 }
\DoxyCodeLine{6872             \textcolor{keyword}{template} <\textcolor{keyword}{typename} Clock, \textcolor{keyword}{typename} Fun>}
\DoxyCodeLine{6873             \textcolor{keyword}{using }run\_for\_at\_least\_argument\_t = \textcolor{keyword}{typename} std::conditional<is\_callable<Fun(Chronometer)>::value, Chronometer, \textcolor{keywordtype}{int}>::type;}
\DoxyCodeLine{6874 }
\DoxyCodeLine{6875             \textcolor{keyword}{struct }optimized\_away\_error : std::exception \{}
\DoxyCodeLine{6876                 \textcolor{keyword}{const} \textcolor{keywordtype}{char}* what() const noexcept\textcolor{keyword}{ override }\{}
\DoxyCodeLine{6877                     \textcolor{keywordflow}{return} \textcolor{stringliteral}{"{}could not measure benchmark, maybe it was optimized away"{}};}
\DoxyCodeLine{6878                 \}}
\DoxyCodeLine{6879             \};}
\DoxyCodeLine{6880 }
\DoxyCodeLine{6881             \textcolor{keyword}{template} <\textcolor{keyword}{typename} Clock, \textcolor{keyword}{typename} Fun>}
\DoxyCodeLine{6882             TimingOf<Clock, Fun, run\_for\_at\_least\_argument\_t<Clock, Fun>> run\_for\_at\_least(ClockDuration<Clock> how\_long, \textcolor{keywordtype}{int} seed, Fun\&\& fun) \{}
\DoxyCodeLine{6883                 \textcolor{keyword}{auto} iters = seed;}
\DoxyCodeLine{6884                 \textcolor{keywordflow}{while} (iters < (1 << 30)) \{}
\DoxyCodeLine{6885                     \textcolor{keyword}{auto}\&\& Timing = measure\_one<Clock>(fun, iters, is\_callable<Fun(Chronometer)>());}
\DoxyCodeLine{6886 }
\DoxyCodeLine{6887                     \textcolor{keywordflow}{if} (Timing.elapsed >= how\_long) \{}
\DoxyCodeLine{6888                         \textcolor{keywordflow}{return} \{ Timing.elapsed, std::move(Timing.result), iters \};}
\DoxyCodeLine{6889                     \}}
\DoxyCodeLine{6890                     iters *= 2;}
\DoxyCodeLine{6891                 \}}
\DoxyCodeLine{6892                 Catch::throw\_exception(optimized\_away\_error\{\});}
\DoxyCodeLine{6893             \}}
\DoxyCodeLine{6894         \} \textcolor{comment}{// namespace Detail}}
\DoxyCodeLine{6895     \} \textcolor{comment}{// namespace Benchmark}}
\DoxyCodeLine{6896 \} \textcolor{comment}{// namespace Catch}}
\DoxyCodeLine{6897 }
\DoxyCodeLine{6898 \textcolor{comment}{// end catch\_run\_for\_at\_least.hpp}}
\DoxyCodeLine{6899 \textcolor{preprocessor}{\#include <algorithm>}}
\DoxyCodeLine{6900 \textcolor{preprocessor}{\#include <iterator>}}
\DoxyCodeLine{6901 }
\DoxyCodeLine{6902 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{6903     \textcolor{keyword}{namespace }Benchmark \{}
\DoxyCodeLine{6904         \textcolor{keyword}{template} <\textcolor{keyword}{typename} Duration>}
\DoxyCodeLine{6905         \textcolor{keyword}{struct }ExecutionPlan \{}
\DoxyCodeLine{6906             \textcolor{keywordtype}{int} iterations\_per\_sample;}
\DoxyCodeLine{6907             Duration estimated\_duration;}
\DoxyCodeLine{6908             Detail::BenchmarkFunction benchmark;}
\DoxyCodeLine{6909             Duration warmup\_time;}
\DoxyCodeLine{6910             \textcolor{keywordtype}{int} warmup\_iterations;}
\DoxyCodeLine{6911 }
\DoxyCodeLine{6912             \textcolor{keyword}{template} <\textcolor{keyword}{typename} Duration2>}
\DoxyCodeLine{6913             \textcolor{keyword}{operator} ExecutionPlan<Duration2>()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{6914                 \textcolor{keywordflow}{return} \{ iterations\_per\_sample, estimated\_duration, benchmark, warmup\_time, warmup\_iterations \};}
\DoxyCodeLine{6915             \}}
\DoxyCodeLine{6916 }
\DoxyCodeLine{6917             \textcolor{keyword}{template} <\textcolor{keyword}{typename} Clock>}
\DoxyCodeLine{6918             std::vector<FloatDuration<Clock>> run(\textcolor{keyword}{const} IConfig \&cfg, Environment<FloatDuration<Clock>> env)\textcolor{keyword}{ const }\{}
\DoxyCodeLine{6919                 \textcolor{comment}{// warmup a bit}}
\DoxyCodeLine{6920                 Detail::run\_for\_at\_least<Clock>(std::chrono::duration\_cast<ClockDuration<Clock>>(warmup\_time), warmup\_iterations, Detail::repeat(now<Clock>\{\}));}
\DoxyCodeLine{6921 }
\DoxyCodeLine{6922                 std::vector<FloatDuration<Clock>> times;}
\DoxyCodeLine{6923                 times.reserve(cfg.benchmarkSamples());}
\DoxyCodeLine{6924                 std::generate\_n(std::back\_inserter(times), cfg.benchmarkSamples(), [\textcolor{keyword}{this}, env] \{}
\DoxyCodeLine{6925                     Detail::ChronometerModel<Clock> model;}
\DoxyCodeLine{6926                     this-\/>benchmark(Chronometer(model, iterations\_per\_sample));}
\DoxyCodeLine{6927                     auto sample\_time = model.elapsed() -\/ env.clock\_cost.mean;}
\DoxyCodeLine{6928                     if (sample\_time < FloatDuration<Clock>::zero()) sample\_time = FloatDuration<Clock>::zero();}
\DoxyCodeLine{6929                     return sample\_time / iterations\_per\_sample;}
\DoxyCodeLine{6930                 \});}
\DoxyCodeLine{6931                 \textcolor{keywordflow}{return} times;}
\DoxyCodeLine{6932             \}}
\DoxyCodeLine{6933         \};}
\DoxyCodeLine{6934     \} \textcolor{comment}{// namespace Benchmark}}
\DoxyCodeLine{6935 \} \textcolor{comment}{// namespace Catch}}
\DoxyCodeLine{6936 }
\DoxyCodeLine{6937 \textcolor{comment}{// end catch\_execution\_plan.hpp}}
\DoxyCodeLine{6938 \textcolor{comment}{// start catch\_estimate\_clock.hpp}}
\DoxyCodeLine{6939 }
\DoxyCodeLine{6940  \textcolor{comment}{// Environment measurement}}
\DoxyCodeLine{6941 }
\DoxyCodeLine{6942 }
\DoxyCodeLine{6943 \textcolor{comment}{// start catch\_stats.hpp}}
\DoxyCodeLine{6944 }
\DoxyCodeLine{6945 \textcolor{comment}{// Statistical analysis tools}}
\DoxyCodeLine{6946 }
\DoxyCodeLine{6947 }
\DoxyCodeLine{6948 \textcolor{preprocessor}{\#include <algorithm>}}
\DoxyCodeLine{6949 \textcolor{preprocessor}{\#include <functional>}}
\DoxyCodeLine{6950 \textcolor{preprocessor}{\#include <vector>}}
\DoxyCodeLine{6951 \textcolor{preprocessor}{\#include <iterator>}}
\DoxyCodeLine{6952 \textcolor{preprocessor}{\#include <numeric>}}
\DoxyCodeLine{6953 \textcolor{preprocessor}{\#include <tuple>}}
\DoxyCodeLine{6954 \textcolor{preprocessor}{\#include <cmath>}}
\DoxyCodeLine{6955 \textcolor{preprocessor}{\#include <utility>}}
\DoxyCodeLine{6956 \textcolor{preprocessor}{\#include <cstddef>}}
\DoxyCodeLine{6957 \textcolor{preprocessor}{\#include <random>}}
\DoxyCodeLine{6958 }
\DoxyCodeLine{6959 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{6960     \textcolor{keyword}{namespace }Benchmark \{}
\DoxyCodeLine{6961         \textcolor{keyword}{namespace }Detail \{}
\DoxyCodeLine{6962             \textcolor{keyword}{using }sample = std::vector<double>;}
\DoxyCodeLine{6963 }
\DoxyCodeLine{6964             \textcolor{keywordtype}{double} weighted\_average\_quantile(\textcolor{keywordtype}{int} k, \textcolor{keywordtype}{int} q, std::vector<double>::iterator first, std::vector<double>::iterator last);}
\DoxyCodeLine{6965 }
\DoxyCodeLine{6966             \textcolor{keyword}{template} <\textcolor{keyword}{typename} Iterator>}
\DoxyCodeLine{6967             OutlierClassification classify\_outliers(Iterator first, Iterator last) \{}
\DoxyCodeLine{6968                 std::vector<double> copy(first, last);}
\DoxyCodeLine{6969 }
\DoxyCodeLine{6970                 \textcolor{keyword}{auto} q1 = weighted\_average\_quantile(1, 4, copy.begin(), copy.end());}
\DoxyCodeLine{6971                 \textcolor{keyword}{auto} q3 = weighted\_average\_quantile(3, 4, copy.begin(), copy.end());}
\DoxyCodeLine{6972                 \textcolor{keyword}{auto} iqr = q3 -\/ q1;}
\DoxyCodeLine{6973                 \textcolor{keyword}{auto} los = q1 -\/ (iqr * 3.);}
\DoxyCodeLine{6974                 \textcolor{keyword}{auto} lom = q1 -\/ (iqr * 1.5);}
\DoxyCodeLine{6975                 \textcolor{keyword}{auto} him = q3 + (iqr * 1.5);}
\DoxyCodeLine{6976                 \textcolor{keyword}{auto} his = q3 + (iqr * 3.);}
\DoxyCodeLine{6977 }
\DoxyCodeLine{6978                 OutlierClassification o;}
\DoxyCodeLine{6979                 \textcolor{keywordflow}{for} (; first != last; ++first) \{}
\DoxyCodeLine{6980                     \textcolor{keyword}{auto}\&\& t = *first;}
\DoxyCodeLine{6981                     \textcolor{keywordflow}{if} (t < los) ++o.low\_severe;}
\DoxyCodeLine{6982                     \textcolor{keywordflow}{else} if (t < lom) ++o.low\_mild;}
\DoxyCodeLine{6983                     \textcolor{keywordflow}{else} if (t > his) ++o.high\_severe;}
\DoxyCodeLine{6984                     \textcolor{keywordflow}{else} if (t > him) ++o.high\_mild;}
\DoxyCodeLine{6985                     ++o.samples\_seen;}
\DoxyCodeLine{6986                 \}}
\DoxyCodeLine{6987                 \textcolor{keywordflow}{return} o;}
\DoxyCodeLine{6988             \}}
\DoxyCodeLine{6989 }
\DoxyCodeLine{6990             \textcolor{keyword}{template} <\textcolor{keyword}{typename} Iterator>}
\DoxyCodeLine{6991             \textcolor{keywordtype}{double} mean(Iterator first, Iterator last) \{}
\DoxyCodeLine{6992                 \textcolor{keyword}{auto} count = last -\/ first;}
\DoxyCodeLine{6993                 \textcolor{keywordtype}{double} sum = std::accumulate(first, last, 0.);}
\DoxyCodeLine{6994                 \textcolor{keywordflow}{return} sum / count;}
\DoxyCodeLine{6995             \}}
\DoxyCodeLine{6996 }
\DoxyCodeLine{6997             \textcolor{keyword}{template} <\textcolor{keyword}{typename} URng, \textcolor{keyword}{typename} Iterator, \textcolor{keyword}{typename} Estimator>}
\DoxyCodeLine{6998             sample resample(URng\& rng, \textcolor{keywordtype}{int} resamples, Iterator first, Iterator last, Estimator\& estimator) \{}
\DoxyCodeLine{6999                 \textcolor{keyword}{auto} n = last -\/ first;}
\DoxyCodeLine{7000                 std::uniform\_int\_distribution<\textcolor{keyword}{decltype}(n)> dist(0, n -\/ 1);}
\DoxyCodeLine{7001 }
\DoxyCodeLine{7002                 sample out;}
\DoxyCodeLine{7003                 out.reserve(resamples);}
\DoxyCodeLine{7004                 std::generate\_n(std::back\_inserter(out), resamples, [n, first, \&estimator, \&dist, \&rng] \{}
\DoxyCodeLine{7005                     std::vector<double> resampled;}
\DoxyCodeLine{7006                     resampled.reserve(n);}
\DoxyCodeLine{7007                     std::generate\_n(std::back\_inserter(resampled), n, [first, \&dist, \&rng] \{ \textcolor{keywordflow}{return} first[dist(rng)]; \});}
\DoxyCodeLine{7008                     \textcolor{keywordflow}{return} estimator(resampled.begin(), resampled.end());}
\DoxyCodeLine{7009                 \});}
\DoxyCodeLine{7010                 std::sort(out.begin(), out.end());}
\DoxyCodeLine{7011                 \textcolor{keywordflow}{return} out;}
\DoxyCodeLine{7012             \}}
\DoxyCodeLine{7013 }
\DoxyCodeLine{7014             \textcolor{keyword}{template} <\textcolor{keyword}{typename} Estimator, \textcolor{keyword}{typename} Iterator>}
\DoxyCodeLine{7015             sample jackknife(Estimator\&\& estimator, Iterator first, Iterator last) \{}
\DoxyCodeLine{7016                 \textcolor{keyword}{auto} n = last -\/ first;}
\DoxyCodeLine{7017                 \textcolor{keyword}{auto} second = std::next(first);}
\DoxyCodeLine{7018                 sample results;}
\DoxyCodeLine{7019                 results.reserve(n);}
\DoxyCodeLine{7020 }
\DoxyCodeLine{7021                 \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} it = first; it != last; ++it) \{}
\DoxyCodeLine{7022                     std::iter\_swap(it, first);}
\DoxyCodeLine{7023                     results.push\_back(estimator(second, last));}
\DoxyCodeLine{7024                 \}}
\DoxyCodeLine{7025 }
\DoxyCodeLine{7026                 \textcolor{keywordflow}{return} results;}
\DoxyCodeLine{7027             \}}
\DoxyCodeLine{7028 }
\DoxyCodeLine{7029             \textcolor{keyword}{inline} \textcolor{keywordtype}{double} normal\_cdf(\textcolor{keywordtype}{double} x) \{}
\DoxyCodeLine{7030                 \textcolor{keywordflow}{return} std::erfc(-\/x / std::sqrt(2.0)) / 2.0;}
\DoxyCodeLine{7031             \}}
\DoxyCodeLine{7032 }
\DoxyCodeLine{7033             \textcolor{keywordtype}{double} erfc\_inv(\textcolor{keywordtype}{double} x);}
\DoxyCodeLine{7034 }
\DoxyCodeLine{7035             \textcolor{keywordtype}{double} normal\_quantile(\textcolor{keywordtype}{double} p);}
\DoxyCodeLine{7036 }
\DoxyCodeLine{7037             \textcolor{keyword}{template} <\textcolor{keyword}{typename} Iterator, \textcolor{keyword}{typename} Estimator>}
\DoxyCodeLine{7038             Estimate<double> bootstrap(\textcolor{keywordtype}{double} confidence\_level, Iterator first, Iterator last, sample \textcolor{keyword}{const}\& resample, Estimator\&\& estimator) \{}
\DoxyCodeLine{7039                 \textcolor{keyword}{auto} n\_samples = last -\/ first;}
\DoxyCodeLine{7040 }
\DoxyCodeLine{7041                 \textcolor{keywordtype}{double} point = estimator(first, last);}
\DoxyCodeLine{7042                 \textcolor{comment}{// Degenerate case with a single sample}}
\DoxyCodeLine{7043                 \textcolor{keywordflow}{if} (n\_samples == 1) \textcolor{keywordflow}{return} \{ point, point, point, confidence\_level \};}
\DoxyCodeLine{7044 }
\DoxyCodeLine{7045                 sample jack = jackknife(estimator, first, last);}
\DoxyCodeLine{7046                 \textcolor{keywordtype}{double} jack\_mean = mean(jack.begin(), jack.end());}
\DoxyCodeLine{7047                 \textcolor{keywordtype}{double} sum\_squares, sum\_cubes;}
\DoxyCodeLine{7048                 std::tie(sum\_squares, sum\_cubes) = std::accumulate(jack.begin(), jack.end(), std::make\_pair(0., 0.), [jack\_mean](std::pair<double, double> sqcb, \textcolor{keywordtype}{double} x) -\/> std::pair<double, double> \{}
\DoxyCodeLine{7049                     auto d = jack\_mean -\/ x;}
\DoxyCodeLine{7050                     auto d2 = d * d;}
\DoxyCodeLine{7051                     auto d3 = d2 * d;}
\DoxyCodeLine{7052                     return \{ sqcb.first + d2, sqcb.second + d3 \};}
\DoxyCodeLine{7053                 \});}
\DoxyCodeLine{7054 }
\DoxyCodeLine{7055                 \textcolor{keywordtype}{double} accel = sum\_cubes / (6 * std::pow(sum\_squares, 1.5));}
\DoxyCodeLine{7056                 \textcolor{keywordtype}{int} n = \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{int}\textcolor{keyword}{>}(resample.size());}
\DoxyCodeLine{7057                 \textcolor{keywordtype}{double} prob\_n = std::count\_if(resample.begin(), resample.end(), [point](\textcolor{keywordtype}{double} x) \{ return x < point; \}) / (double)n;}
\DoxyCodeLine{7058                 \textcolor{comment}{// degenerate case with uniform samples}}
\DoxyCodeLine{7059                 \textcolor{keywordflow}{if} (prob\_n == 0) \textcolor{keywordflow}{return} \{ point, point, point, confidence\_level \};}
\DoxyCodeLine{7060 }
\DoxyCodeLine{7061                 \textcolor{keywordtype}{double} bias = normal\_quantile(prob\_n);}
\DoxyCodeLine{7062                 \textcolor{keywordtype}{double} z1 = normal\_quantile((1. -\/ confidence\_level) / 2.);}
\DoxyCodeLine{7063 }
\DoxyCodeLine{7064                 \textcolor{keyword}{auto} cumn = [n](\textcolor{keywordtype}{double} x) -\/> \textcolor{keywordtype}{int} \{}
\DoxyCodeLine{7065                     \textcolor{keywordflow}{return} std::lround(normal\_cdf(x) * n); \};}
\DoxyCodeLine{7066                 \textcolor{keyword}{auto} a = [bias, accel](\textcolor{keywordtype}{double} b) \{ \textcolor{keywordflow}{return} bias + b / (1. -\/ accel * b); \};}
\DoxyCodeLine{7067                 \textcolor{keywordtype}{double} b1 = bias + z1;}
\DoxyCodeLine{7068                 \textcolor{keywordtype}{double} b2 = bias -\/ z1;}
\DoxyCodeLine{7069                 \textcolor{keywordtype}{double} a1 = a(b1);}
\DoxyCodeLine{7070                 \textcolor{keywordtype}{double} a2 = a(b2);}
\DoxyCodeLine{7071                 \textcolor{keyword}{auto} lo = (std::max)(cumn(a1), 0);}
\DoxyCodeLine{7072                 \textcolor{keyword}{auto} hi = (std::min)(cumn(a2), n -\/ 1);}
\DoxyCodeLine{7073 }
\DoxyCodeLine{7074                 \textcolor{keywordflow}{return} \{ point, resample[lo], resample[hi], confidence\_level \};}
\DoxyCodeLine{7075             \}}
\DoxyCodeLine{7076 }
\DoxyCodeLine{7077             \textcolor{keywordtype}{double} outlier\_variance(Estimate<double> mean, Estimate<double> stddev, \textcolor{keywordtype}{int} n);}
\DoxyCodeLine{7078 }
\DoxyCodeLine{7079             \textcolor{keyword}{struct }bootstrap\_analysis \{}
\DoxyCodeLine{7080                 Estimate<double> mean;}
\DoxyCodeLine{7081                 Estimate<double> standard\_deviation;}
\DoxyCodeLine{7082                 \textcolor{keywordtype}{double} outlier\_variance;}
\DoxyCodeLine{7083             \};}
\DoxyCodeLine{7084 }
\DoxyCodeLine{7085             bootstrap\_analysis analyse\_samples(\textcolor{keywordtype}{double} confidence\_level, \textcolor{keywordtype}{int} n\_resamples, std::vector<double>::iterator first, std::vector<double>::iterator last);}
\DoxyCodeLine{7086         \} \textcolor{comment}{// namespace Detail}}
\DoxyCodeLine{7087     \} \textcolor{comment}{// namespace Benchmark}}
\DoxyCodeLine{7088 \} \textcolor{comment}{// namespace Catch}}
\DoxyCodeLine{7089 }
\DoxyCodeLine{7090 \textcolor{comment}{// end catch\_stats.hpp}}
\DoxyCodeLine{7091 \textcolor{preprocessor}{\#include <algorithm>}}
\DoxyCodeLine{7092 \textcolor{preprocessor}{\#include <iterator>}}
\DoxyCodeLine{7093 \textcolor{preprocessor}{\#include <tuple>}}
\DoxyCodeLine{7094 \textcolor{preprocessor}{\#include <vector>}}
\DoxyCodeLine{7095 \textcolor{preprocessor}{\#include <cmath>}}
\DoxyCodeLine{7096 }
\DoxyCodeLine{7097 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{7098     \textcolor{keyword}{namespace }Benchmark \{}
\DoxyCodeLine{7099         \textcolor{keyword}{namespace }Detail \{}
\DoxyCodeLine{7100             \textcolor{keyword}{template} <\textcolor{keyword}{typename} Clock>}
\DoxyCodeLine{7101             std::vector<double> resolution(\textcolor{keywordtype}{int} k) \{}
\DoxyCodeLine{7102                 std::vector<TimePoint<Clock>> times;}
\DoxyCodeLine{7103                 times.reserve(k + 1);}
\DoxyCodeLine{7104                 std::generate\_n(std::back\_inserter(times), k + 1, now<Clock>\{\});}
\DoxyCodeLine{7105 }
\DoxyCodeLine{7106                 std::vector<double> deltas;}
\DoxyCodeLine{7107                 deltas.reserve(k);}
\DoxyCodeLine{7108                 std::transform(std::next(times.begin()), times.end(), times.begin(),}
\DoxyCodeLine{7109                     std::back\_inserter(deltas),}
\DoxyCodeLine{7110                     [](TimePoint<Clock> a, TimePoint<Clock> b) \{ return static\_cast<double>((a -\/ b).count()); \});}
\DoxyCodeLine{7111 }
\DoxyCodeLine{7112                 \textcolor{keywordflow}{return} deltas;}
\DoxyCodeLine{7113             \}}
\DoxyCodeLine{7114 }
\DoxyCodeLine{7115             \textcolor{keyword}{const} \textcolor{keyword}{auto} warmup\_iterations = 10000;}
\DoxyCodeLine{7116             \textcolor{keyword}{const} \textcolor{keyword}{auto} warmup\_time = std::chrono::milliseconds(100);}
\DoxyCodeLine{7117             \textcolor{keyword}{const} \textcolor{keyword}{auto} minimum\_ticks = 1000;}
\DoxyCodeLine{7118             \textcolor{keyword}{const} \textcolor{keyword}{auto} warmup\_seed = 10000;}
\DoxyCodeLine{7119             \textcolor{keyword}{const} \textcolor{keyword}{auto} clock\_resolution\_estimation\_time = std::chrono::milliseconds(500);}
\DoxyCodeLine{7120             \textcolor{keyword}{const} \textcolor{keyword}{auto} clock\_cost\_estimation\_time\_limit = std::chrono::seconds(1);}
\DoxyCodeLine{7121             \textcolor{keyword}{const} \textcolor{keyword}{auto} clock\_cost\_estimation\_tick\_limit = 100000;}
\DoxyCodeLine{7122             \textcolor{keyword}{const} \textcolor{keyword}{auto} clock\_cost\_estimation\_time = std::chrono::milliseconds(10);}
\DoxyCodeLine{7123             \textcolor{keyword}{const} \textcolor{keyword}{auto} clock\_cost\_estimation\_iterations = 10000;}
\DoxyCodeLine{7124 }
\DoxyCodeLine{7125             \textcolor{keyword}{template} <\textcolor{keyword}{typename} Clock>}
\DoxyCodeLine{7126             \textcolor{keywordtype}{int} warmup() \{}
\DoxyCodeLine{7127                 \textcolor{keywordflow}{return} run\_for\_at\_least<Clock>(std::chrono::duration\_cast<ClockDuration<Clock>>(warmup\_time), warmup\_seed, \&resolution<Clock>)}
\DoxyCodeLine{7128                     .iterations;}
\DoxyCodeLine{7129             \}}
\DoxyCodeLine{7130             \textcolor{keyword}{template} <\textcolor{keyword}{typename} Clock>}
\DoxyCodeLine{7131             EnvironmentEstimate<FloatDuration<Clock>> estimate\_clock\_resolution(\textcolor{keywordtype}{int} iterations) \{}
\DoxyCodeLine{7132                 \textcolor{keyword}{auto} r = run\_for\_at\_least<Clock>(std::chrono::duration\_cast<ClockDuration<Clock>>(clock\_resolution\_estimation\_time), iterations, \&resolution<Clock>)}
\DoxyCodeLine{7133                     .result;}
\DoxyCodeLine{7134                 \textcolor{keywordflow}{return} \{}
\DoxyCodeLine{7135                     FloatDuration<Clock>(mean(r.begin(), r.end())),}
\DoxyCodeLine{7136                     classify\_outliers(r.begin(), r.end()),}
\DoxyCodeLine{7137                 \};}
\DoxyCodeLine{7138             \}}
\DoxyCodeLine{7139             \textcolor{keyword}{template} <\textcolor{keyword}{typename} Clock>}
\DoxyCodeLine{7140             EnvironmentEstimate<FloatDuration<Clock>> estimate\_clock\_cost(FloatDuration<Clock> resolution) \{}
\DoxyCodeLine{7141                 \textcolor{keyword}{auto} time\_limit = (std::min)(}
\DoxyCodeLine{7142                     resolution * clock\_cost\_estimation\_tick\_limit,}
\DoxyCodeLine{7143                     FloatDuration<Clock>(clock\_cost\_estimation\_time\_limit));}
\DoxyCodeLine{7144                 \textcolor{keyword}{auto} time\_clock = [](\textcolor{keywordtype}{int} k) \{}
\DoxyCodeLine{7145                     \textcolor{keywordflow}{return} Detail::measure<Clock>([k] \{}
\DoxyCodeLine{7146                         \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = 0; i < k; ++i) \{}
\DoxyCodeLine{7147                             \textcolor{keyword}{volatile} \textcolor{keyword}{auto} ignored = Clock::now();}
\DoxyCodeLine{7148                             (void)ignored;}
\DoxyCodeLine{7149                         \}}
\DoxyCodeLine{7150                     \}).elapsed;}
\DoxyCodeLine{7151                 \};}
\DoxyCodeLine{7152                 time\_clock(1);}
\DoxyCodeLine{7153                 \textcolor{keywordtype}{int} iters = clock\_cost\_estimation\_iterations;}
\DoxyCodeLine{7154                 \textcolor{keyword}{auto}\&\& r = run\_for\_at\_least<Clock>(std::chrono::duration\_cast<ClockDuration<Clock>>(clock\_cost\_estimation\_time), iters, time\_clock);}
\DoxyCodeLine{7155                 std::vector<double> times;}
\DoxyCodeLine{7156                 \textcolor{keywordtype}{int} nsamples = \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{int}\textcolor{keyword}{>}(std::ceil(time\_limit / r.elapsed));}
\DoxyCodeLine{7157                 times.reserve(nsamples);}
\DoxyCodeLine{7158                 std::generate\_n(std::back\_inserter(times), nsamples, [time\_clock, \&r] \{}
\DoxyCodeLine{7159                     \textcolor{keywordflow}{return} \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{double}\textcolor{keyword}{>}((time\_clock(r.iterations) / r.iterations).count());}
\DoxyCodeLine{7160                 \});}
\DoxyCodeLine{7161                 \textcolor{keywordflow}{return} \{}
\DoxyCodeLine{7162                     FloatDuration<Clock>(mean(times.begin(), times.end())),}
\DoxyCodeLine{7163                     classify\_outliers(times.begin(), times.end()),}
\DoxyCodeLine{7164                 \};}
\DoxyCodeLine{7165             \}}
\DoxyCodeLine{7166 }
\DoxyCodeLine{7167             \textcolor{keyword}{template} <\textcolor{keyword}{typename} Clock>}
\DoxyCodeLine{7168             Environment<FloatDuration<Clock>> measure\_environment() \{}
\DoxyCodeLine{7169                 \textcolor{keyword}{static} Environment<FloatDuration<Clock>>* env = \textcolor{keyword}{nullptr};}
\DoxyCodeLine{7170                 \textcolor{keywordflow}{if} (env) \{}
\DoxyCodeLine{7171                     \textcolor{keywordflow}{return} *env;}
\DoxyCodeLine{7172                 \}}
\DoxyCodeLine{7173 }
\DoxyCodeLine{7174                 \textcolor{keyword}{auto} iters = Detail::warmup<Clock>();}
\DoxyCodeLine{7175                 \textcolor{keyword}{auto} resolution = Detail::estimate\_clock\_resolution<Clock>(iters);}
\DoxyCodeLine{7176                 \textcolor{keyword}{auto} cost = Detail::estimate\_clock\_cost<Clock>(resolution.mean);}
\DoxyCodeLine{7177 }
\DoxyCodeLine{7178                 env = \textcolor{keyword}{new} Environment<FloatDuration<Clock>>\{ resolution, cost \};}
\DoxyCodeLine{7179                 \textcolor{keywordflow}{return} *env;}
\DoxyCodeLine{7180             \}}
\DoxyCodeLine{7181         \} \textcolor{comment}{// namespace Detail}}
\DoxyCodeLine{7182     \} \textcolor{comment}{// namespace Benchmark}}
\DoxyCodeLine{7183 \} \textcolor{comment}{// namespace Catch}}
\DoxyCodeLine{7184 }
\DoxyCodeLine{7185 \textcolor{comment}{// end catch\_estimate\_clock.hpp}}
\DoxyCodeLine{7186 \textcolor{comment}{// start catch\_analyse.hpp}}
\DoxyCodeLine{7187 }
\DoxyCodeLine{7188  \textcolor{comment}{// Run and analyse one benchmark}}
\DoxyCodeLine{7189 }
\DoxyCodeLine{7190 }
\DoxyCodeLine{7191 \textcolor{comment}{// start catch\_sample\_analysis.hpp}}
\DoxyCodeLine{7192 }
\DoxyCodeLine{7193 \textcolor{comment}{// Benchmark results}}
\DoxyCodeLine{7194 }
\DoxyCodeLine{7195 }
\DoxyCodeLine{7196 \textcolor{preprocessor}{\#include <algorithm>}}
\DoxyCodeLine{7197 \textcolor{preprocessor}{\#include <vector>}}
\DoxyCodeLine{7198 \textcolor{preprocessor}{\#include <string>}}
\DoxyCodeLine{7199 \textcolor{preprocessor}{\#include <iterator>}}
\DoxyCodeLine{7200 }
\DoxyCodeLine{7201 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{7202     \textcolor{keyword}{namespace }Benchmark \{}
\DoxyCodeLine{7203         \textcolor{keyword}{template} <\textcolor{keyword}{typename} Duration>}
\DoxyCodeLine{7204         \textcolor{keyword}{struct }SampleAnalysis \{}
\DoxyCodeLine{7205             std::vector<Duration> samples;}
\DoxyCodeLine{7206             Estimate<Duration> mean;}
\DoxyCodeLine{7207             Estimate<Duration> standard\_deviation;}
\DoxyCodeLine{7208             OutlierClassification outliers;}
\DoxyCodeLine{7209             \textcolor{keywordtype}{double} outlier\_variance;}
\DoxyCodeLine{7210 }
\DoxyCodeLine{7211             \textcolor{keyword}{template} <\textcolor{keyword}{typename} Duration2>}
\DoxyCodeLine{7212             \textcolor{keyword}{operator} SampleAnalysis<Duration2>()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{7213                 std::vector<Duration2> samples2;}
\DoxyCodeLine{7214                 samples2.reserve(samples.size());}
\DoxyCodeLine{7215                 std::transform(samples.begin(), samples.end(), std::back\_inserter(samples2), [](Duration d) \{ return Duration2(d); \});}
\DoxyCodeLine{7216                 \textcolor{keywordflow}{return} \{}
\DoxyCodeLine{7217                     std::move(samples2),}
\DoxyCodeLine{7218                     mean,}
\DoxyCodeLine{7219                     standard\_deviation,}
\DoxyCodeLine{7220                     outliers,}
\DoxyCodeLine{7221                     outlier\_variance,}
\DoxyCodeLine{7222                 \};}
\DoxyCodeLine{7223             \}}
\DoxyCodeLine{7224         \};}
\DoxyCodeLine{7225     \} \textcolor{comment}{// namespace Benchmark}}
\DoxyCodeLine{7226 \} \textcolor{comment}{// namespace Catch}}
\DoxyCodeLine{7227 }
\DoxyCodeLine{7228 \textcolor{comment}{// end catch\_sample\_analysis.hpp}}
\DoxyCodeLine{7229 \textcolor{preprocessor}{\#include <algorithm>}}
\DoxyCodeLine{7230 \textcolor{preprocessor}{\#include <iterator>}}
\DoxyCodeLine{7231 \textcolor{preprocessor}{\#include <vector>}}
\DoxyCodeLine{7232 }
\DoxyCodeLine{7233 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{7234     \textcolor{keyword}{namespace }Benchmark \{}
\DoxyCodeLine{7235         \textcolor{keyword}{namespace }Detail \{}
\DoxyCodeLine{7236             \textcolor{keyword}{template} <\textcolor{keyword}{typename} Duration, \textcolor{keyword}{typename} Iterator>}
\DoxyCodeLine{7237             SampleAnalysis<Duration> analyse(\textcolor{keyword}{const} IConfig \&cfg, Environment<Duration>, Iterator first, Iterator last) \{}
\DoxyCodeLine{7238                 \textcolor{keywordflow}{if} (!cfg.benchmarkNoAnalysis()) \{}
\DoxyCodeLine{7239                     std::vector<double> samples;}
\DoxyCodeLine{7240                     samples.reserve(last -\/ first);}
\DoxyCodeLine{7241                     std::transform(first, last, std::back\_inserter(samples), [](Duration d) \{ \textcolor{keywordflow}{return} d.count(); \});}
\DoxyCodeLine{7242 }
\DoxyCodeLine{7243                     \textcolor{keyword}{auto} analysis = Catch::Benchmark::Detail::analyse\_samples(cfg.benchmarkConfidenceInterval(), cfg.benchmarkResamples(), samples.begin(), samples.end());}
\DoxyCodeLine{7244                     \textcolor{keyword}{auto} outliers = Catch::Benchmark::Detail::classify\_outliers(samples.begin(), samples.end());}
\DoxyCodeLine{7245 }
\DoxyCodeLine{7246                     \textcolor{keyword}{auto} wrap\_estimate = [](Estimate<double> e) \{}
\DoxyCodeLine{7247                         \textcolor{keywordflow}{return} Estimate<Duration> \{}
\DoxyCodeLine{7248                             Duration(e.point),}
\DoxyCodeLine{7249                                 Duration(e.lower\_bound),}
\DoxyCodeLine{7250                                 Duration(e.upper\_bound),}
\DoxyCodeLine{7251                                 e.confidence\_interval,}
\DoxyCodeLine{7252                         \};}
\DoxyCodeLine{7253                     \};}
\DoxyCodeLine{7254                     std::vector<Duration> samples2;}
\DoxyCodeLine{7255                     samples2.reserve(samples.size());}
\DoxyCodeLine{7256                     std::transform(samples.begin(), samples.end(), std::back\_inserter(samples2), [](\textcolor{keywordtype}{double} d) \{ return Duration(d); \});}
\DoxyCodeLine{7257                     \textcolor{keywordflow}{return} \{}
\DoxyCodeLine{7258                         std::move(samples2),}
\DoxyCodeLine{7259                         wrap\_estimate(analysis.mean),}
\DoxyCodeLine{7260                         wrap\_estimate(analysis.standard\_deviation),}
\DoxyCodeLine{7261                         outliers,}
\DoxyCodeLine{7262                         analysis.outlier\_variance,}
\DoxyCodeLine{7263                     \};}
\DoxyCodeLine{7264                 \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{7265                     std::vector<Duration> samples;}
\DoxyCodeLine{7266                     samples.reserve(last -\/ first);}
\DoxyCodeLine{7267 }
\DoxyCodeLine{7268                     Duration mean = Duration(0);}
\DoxyCodeLine{7269                     \textcolor{keywordtype}{int} i = 0;}
\DoxyCodeLine{7270                     \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} it = first; it < last; ++it, ++i) \{}
\DoxyCodeLine{7271                         samples.push\_back(Duration(*it));}
\DoxyCodeLine{7272                         mean += Duration(*it);}
\DoxyCodeLine{7273                     \}}
\DoxyCodeLine{7274                     mean /= i;}
\DoxyCodeLine{7275 }
\DoxyCodeLine{7276                     \textcolor{keywordflow}{return} \{}
\DoxyCodeLine{7277                         std::move(samples),}
\DoxyCodeLine{7278                         Estimate<Duration>\{mean, mean, mean, 0.0\},}
\DoxyCodeLine{7279                         Estimate<Duration>\{Duration(0), Duration(0), Duration(0), 0.0\},}
\DoxyCodeLine{7280                         OutlierClassification\{\},}
\DoxyCodeLine{7281                         0.0}
\DoxyCodeLine{7282                     \};}
\DoxyCodeLine{7283                 \}}
\DoxyCodeLine{7284             \}}
\DoxyCodeLine{7285         \} \textcolor{comment}{// namespace Detail}}
\DoxyCodeLine{7286     \} \textcolor{comment}{// namespace Benchmark}}
\DoxyCodeLine{7287 \} \textcolor{comment}{// namespace Catch}}
\DoxyCodeLine{7288 }
\DoxyCodeLine{7289 \textcolor{comment}{// end catch\_analyse.hpp}}
\DoxyCodeLine{7290 \textcolor{preprocessor}{\#include <algorithm>}}
\DoxyCodeLine{7291 \textcolor{preprocessor}{\#include <functional>}}
\DoxyCodeLine{7292 \textcolor{preprocessor}{\#include <string>}}
\DoxyCodeLine{7293 \textcolor{preprocessor}{\#include <vector>}}
\DoxyCodeLine{7294 \textcolor{preprocessor}{\#include <cmath>}}
\DoxyCodeLine{7295 }
\DoxyCodeLine{7296 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{7297     \textcolor{keyword}{namespace }Benchmark \{}
\DoxyCodeLine{7298         \textcolor{keyword}{struct }Benchmark \{}
\DoxyCodeLine{7299             Benchmark(std::string \&\&name)}
\DoxyCodeLine{7300                 : name(std::move(name)) \{\}}
\DoxyCodeLine{7301 }
\DoxyCodeLine{7302             \textcolor{keyword}{template} <\textcolor{keyword}{class} FUN>}
\DoxyCodeLine{7303             Benchmark(std::string \&\&name, FUN \&\&func)}
\DoxyCodeLine{7304                 : fun(std::move(func)), name(std::move(name)) \{\}}
\DoxyCodeLine{7305 }
\DoxyCodeLine{7306             \textcolor{keyword}{template} <\textcolor{keyword}{typename} Clock>}
\DoxyCodeLine{7307             ExecutionPlan<FloatDuration<Clock>> prepare(\textcolor{keyword}{const} IConfig \&cfg, Environment<FloatDuration<Clock>> env)\textcolor{keyword}{ const }\{}
\DoxyCodeLine{7308                 \textcolor{keyword}{auto} min\_time = env.clock\_resolution.mean * Detail::minimum\_ticks;}
\DoxyCodeLine{7309                 \textcolor{keyword}{auto} run\_time = std::max(min\_time, std::chrono::duration\_cast<\textcolor{keyword}{decltype}(min\_time)>(cfg.benchmarkWarmupTime()));}
\DoxyCodeLine{7310                 \textcolor{keyword}{auto}\&\& test = Detail::run\_for\_at\_least<Clock>(std::chrono::duration\_cast<ClockDuration<Clock>>(run\_time), 1, fun);}
\DoxyCodeLine{7311                 \textcolor{keywordtype}{int} new\_iters = \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{int}\textcolor{keyword}{>}(std::ceil(min\_time * test.iterations / test.elapsed));}
\DoxyCodeLine{7312                 \textcolor{keywordflow}{return} \{ new\_iters, test.elapsed / test.iterations * new\_iters * cfg.benchmarkSamples(), fun, std::chrono::duration\_cast<FloatDuration<Clock>>(cfg.benchmarkWarmupTime()), Detail::warmup\_iterations \};}
\DoxyCodeLine{7313             \}}
\DoxyCodeLine{7314 }
\DoxyCodeLine{7315             \textcolor{keyword}{template} <\textcolor{keyword}{typename} Clock = default\_clock>}
\DoxyCodeLine{7316             \textcolor{keywordtype}{void} run() \{}
\DoxyCodeLine{7317                 IConfigPtr cfg = getCurrentContext().getConfig();}
\DoxyCodeLine{7318 }
\DoxyCodeLine{7319                 \textcolor{keyword}{auto} env = Detail::measure\_environment<Clock>();}
\DoxyCodeLine{7320 }
\DoxyCodeLine{7321                 getResultCapture().benchmarkPreparing(name);}
\DoxyCodeLine{7322                 CATCH\_TRY\{}
\DoxyCodeLine{7323                     \textcolor{keyword}{auto} plan = user\_code([\&] \{}
\DoxyCodeLine{7324                         \textcolor{keywordflow}{return} prepare<Clock>(*cfg, env);}
\DoxyCodeLine{7325                     \});}
\DoxyCodeLine{7326 }
\DoxyCodeLine{7327                     BenchmarkInfo info \{}
\DoxyCodeLine{7328                         name,}
\DoxyCodeLine{7329                         plan.estimated\_duration.count(),}
\DoxyCodeLine{7330                         plan.iterations\_per\_sample,}
\DoxyCodeLine{7331                         cfg-\/>benchmarkSamples(),}
\DoxyCodeLine{7332                         cfg-\/>benchmarkResamples(),}
\DoxyCodeLine{7333                         env.clock\_resolution.mean.count(),}
\DoxyCodeLine{7334                         env.clock\_cost.mean.count()}
\DoxyCodeLine{7335                     \};}
\DoxyCodeLine{7336 }
\DoxyCodeLine{7337                     getResultCapture().benchmarkStarting(info);}
\DoxyCodeLine{7338 }
\DoxyCodeLine{7339                     \textcolor{keyword}{auto} samples = user\_code([\&] \{}
\DoxyCodeLine{7340                         \textcolor{keywordflow}{return} plan.template run<Clock>(*cfg, env);}
\DoxyCodeLine{7341                     \});}
\DoxyCodeLine{7342 }
\DoxyCodeLine{7343                     \textcolor{keyword}{auto} analysis = Detail::analyse(*cfg, env, samples.begin(), samples.end());}
\DoxyCodeLine{7344                     BenchmarkStats<FloatDuration<Clock>> stats\{ info, analysis.samples, analysis.mean, analysis.standard\_deviation, analysis.outliers, analysis.outlier\_variance \};}
\DoxyCodeLine{7345                     getResultCapture().benchmarkEnded(stats);}
\DoxyCodeLine{7346 }
\DoxyCodeLine{7347                 \} CATCH\_CATCH\_ALL\{}
\DoxyCodeLine{7348                     \textcolor{keywordflow}{if} (translateActiveException() != Detail::benchmarkErrorMsg) \textcolor{comment}{// benchmark errors have been reported, otherwise rethrow.}}
\DoxyCodeLine{7349                         std::rethrow\_exception(std::current\_exception());}
\DoxyCodeLine{7350                 \}}
\DoxyCodeLine{7351             \}}
\DoxyCodeLine{7352 }
\DoxyCodeLine{7353             \textcolor{comment}{// sets lambda to be used in fun *and* executes benchmark!}}
\DoxyCodeLine{7354             \textcolor{keyword}{template} <\textcolor{keyword}{typename} Fun,}
\DoxyCodeLine{7355                 \textcolor{keyword}{typename} std::enable\_if<!Detail::is\_related<Fun, Benchmark>::value, \textcolor{keywordtype}{int}>::type = 0>}
\DoxyCodeLine{7356                 Benchmark \& operator=(Fun func) \{}
\DoxyCodeLine{7357                 fun = Detail::BenchmarkFunction(func);}
\DoxyCodeLine{7358                 run();}
\DoxyCodeLine{7359                 \textcolor{keywordflow}{return} *\textcolor{keyword}{this};}
\DoxyCodeLine{7360             \}}
\DoxyCodeLine{7361 }
\DoxyCodeLine{7362             \textcolor{keyword}{explicit} \textcolor{keyword}{operator} bool() \{}
\DoxyCodeLine{7363                 \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{7364             \}}
\DoxyCodeLine{7365 }
\DoxyCodeLine{7366         \textcolor{keyword}{private}:}
\DoxyCodeLine{7367             Detail::BenchmarkFunction fun;}
\DoxyCodeLine{7368             std::string name;}
\DoxyCodeLine{7369         \};}
\DoxyCodeLine{7370     \}}
\DoxyCodeLine{7371 \} \textcolor{comment}{// namespace Catch}}
\DoxyCodeLine{7372 }
\DoxyCodeLine{7373 \textcolor{preprocessor}{\#define INTERNAL\_CATCH\_GET\_1\_ARG(arg1, arg2, ...) arg1}}
\DoxyCodeLine{7374 \textcolor{preprocessor}{\#define INTERNAL\_CATCH\_GET\_2\_ARG(arg1, arg2, ...) arg2}}
\DoxyCodeLine{7375 }
\DoxyCodeLine{7376 \textcolor{preprocessor}{\#define INTERNAL\_CATCH\_BENCHMARK(BenchmarkName, name, benchmarkIndex)\(\backslash\)}}
\DoxyCodeLine{7377 \textcolor{preprocessor}{    if( Catch::Benchmark::Benchmark BenchmarkName\{name\} ) \(\backslash\)}}
\DoxyCodeLine{7378 \textcolor{preprocessor}{        BenchmarkName = [\&](int benchmarkIndex)}}
\DoxyCodeLine{7379 }
\DoxyCodeLine{7380 \textcolor{preprocessor}{\#define INTERNAL\_CATCH\_BENCHMARK\_ADVANCED(BenchmarkName, name)\(\backslash\)}}
\DoxyCodeLine{7381 \textcolor{preprocessor}{    if( Catch::Benchmark::Benchmark BenchmarkName\{name\} ) \(\backslash\)}}
\DoxyCodeLine{7382 \textcolor{preprocessor}{        BenchmarkName = [\&]}}
\DoxyCodeLine{7383 }
\DoxyCodeLine{7384 \textcolor{comment}{// end catch\_benchmark.hpp}}
\DoxyCodeLine{7385 \textcolor{comment}{// start catch\_constructor.hpp}}
\DoxyCodeLine{7386 }
\DoxyCodeLine{7387 \textcolor{comment}{// Constructor and destructor helpers}}
\DoxyCodeLine{7388 }
\DoxyCodeLine{7389 }
\DoxyCodeLine{7390 \textcolor{preprocessor}{\#include <type\_traits>}}
\DoxyCodeLine{7391 }
\DoxyCodeLine{7392 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{7393     \textcolor{keyword}{namespace }Benchmark \{}
\DoxyCodeLine{7394         \textcolor{keyword}{namespace }Detail \{}
\DoxyCodeLine{7395             \textcolor{keyword}{template} <\textcolor{keyword}{typename} T, \textcolor{keywordtype}{bool} Destruct>}
\DoxyCodeLine{7396             \textcolor{keyword}{struct }ObjectStorage}
\DoxyCodeLine{7397             \{}
\DoxyCodeLine{7398                 ObjectStorage() : data() \{\}}
\DoxyCodeLine{7399 }
\DoxyCodeLine{7400                 ObjectStorage(\textcolor{keyword}{const} ObjectStorage\& other)}
\DoxyCodeLine{7401                 \{}
\DoxyCodeLine{7402                     \textcolor{keyword}{new}(\&data) T(other.stored\_object());}
\DoxyCodeLine{7403                 \}}
\DoxyCodeLine{7404 }
\DoxyCodeLine{7405                 ObjectStorage(ObjectStorage\&\& other)}
\DoxyCodeLine{7406                 \{}
\DoxyCodeLine{7407                     \textcolor{keyword}{new}(\&data) T(std::move(other.stored\_object()));}
\DoxyCodeLine{7408                 \}}
\DoxyCodeLine{7409 }
\DoxyCodeLine{7410                 \string~ObjectStorage() \{ destruct\_on\_exit<T>(); \}}
\DoxyCodeLine{7411 }
\DoxyCodeLine{7412                 \textcolor{keyword}{template} <\textcolor{keyword}{typename}... Args>}
\DoxyCodeLine{7413                 \textcolor{keywordtype}{void} construct(Args\&\&... args)}
\DoxyCodeLine{7414                 \{}
\DoxyCodeLine{7415                     \textcolor{keyword}{new} (\&data) T(std::forward<Args>(args)...);}
\DoxyCodeLine{7416                 \}}
\DoxyCodeLine{7417 }
\DoxyCodeLine{7418                 \textcolor{keyword}{template} <\textcolor{keywordtype}{bool} AllowManualDestruction = !Destruct>}
\DoxyCodeLine{7419                 \textcolor{keyword}{typename} std::enable\_if<AllowManualDestruction>::type destruct()}
\DoxyCodeLine{7420                 \{}
\DoxyCodeLine{7421                     stored\_object().\string~T();}
\DoxyCodeLine{7422                 \}}
\DoxyCodeLine{7423 }
\DoxyCodeLine{7424             \textcolor{keyword}{private}:}
\DoxyCodeLine{7425                 \textcolor{comment}{// If this is a constructor benchmark, destruct the underlying object}}
\DoxyCodeLine{7426                 \textcolor{keyword}{template} <\textcolor{keyword}{typename} U>}
\DoxyCodeLine{7427                 \textcolor{keywordtype}{void} destruct\_on\_exit(\textcolor{keyword}{typename} std::enable\_if<Destruct, U>::type* = 0) \{ destruct<true>(); \}}
\DoxyCodeLine{7428                 \textcolor{comment}{// Otherwise, don't}}
\DoxyCodeLine{7429                 \textcolor{keyword}{template} <\textcolor{keyword}{typename} U>}
\DoxyCodeLine{7430                 \textcolor{keywordtype}{void} destruct\_on\_exit(\textcolor{keyword}{typename} std::enable\_if<!Destruct, U>::type* = 0) \{ \}}
\DoxyCodeLine{7431 }
\DoxyCodeLine{7432                 T\& stored\_object() \{}
\DoxyCodeLine{7433                     \textcolor{keywordflow}{return} *\textcolor{keyword}{static\_cast<}T*\textcolor{keyword}{>}(\textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{void}*\textcolor{keyword}{>}(\&data));}
\DoxyCodeLine{7434                 \}}
\DoxyCodeLine{7435 }
\DoxyCodeLine{7436                 T \textcolor{keyword}{const}\& stored\_object()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{7437                     \textcolor{keywordflow}{return} *\textcolor{keyword}{static\_cast<}T*\textcolor{keyword}{>}(\textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{void}*\textcolor{keyword}{>}(\&data));}
\DoxyCodeLine{7438                 \}}
\DoxyCodeLine{7439 }
\DoxyCodeLine{7440                 \textcolor{keyword}{struct }\{ \textcolor{keyword}{alignas}(T) \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} data[\textcolor{keyword}{sizeof}(T)]; \}  data;}
\DoxyCodeLine{7441             \};}
\DoxyCodeLine{7442         \}}
\DoxyCodeLine{7443 }
\DoxyCodeLine{7444         \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{7445         \textcolor{keyword}{using }storage\_for = Detail::ObjectStorage<T, true>;}
\DoxyCodeLine{7446 }
\DoxyCodeLine{7447         \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{7448         \textcolor{keyword}{using }destructable\_object = Detail::ObjectStorage<T, false>;}
\DoxyCodeLine{7449     \}}
\DoxyCodeLine{7450 \}}
\DoxyCodeLine{7451 }
\DoxyCodeLine{7452 \textcolor{comment}{// end catch\_constructor.hpp}}
\DoxyCodeLine{7453 \textcolor{comment}{// end catch\_benchmarking\_all.hpp}}
\DoxyCodeLine{7454 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{7455 }
\DoxyCodeLine{7456 \textcolor{preprocessor}{\#endif }\textcolor{comment}{// ! CATCH\_CONFIG\_IMPL\_ONLY}}
\DoxyCodeLine{7457 }
\DoxyCodeLine{7458 \textcolor{preprocessor}{\#ifdef CATCH\_IMPL}}
\DoxyCodeLine{7459 \textcolor{comment}{// start catch\_impl.hpp}}
\DoxyCodeLine{7460 }
\DoxyCodeLine{7461 \textcolor{preprocessor}{\#ifdef \_\_clang\_\_}}
\DoxyCodeLine{7462 \textcolor{preprocessor}{\#pragma clang diagnostic push}}
\DoxyCodeLine{7463 \textcolor{preprocessor}{\#pragma clang diagnostic ignored "{}-\/Wweak-\/vtables"{}}}
\DoxyCodeLine{7464 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{7465 }
\DoxyCodeLine{7466 \textcolor{comment}{// Keep these here for external reporters}}
\DoxyCodeLine{7467 \textcolor{comment}{// start catch\_test\_case\_tracker.h}}
\DoxyCodeLine{7468 }
\DoxyCodeLine{7469 \textcolor{preprocessor}{\#include <string>}}
\DoxyCodeLine{7470 \textcolor{preprocessor}{\#include <vector>}}
\DoxyCodeLine{7471 \textcolor{preprocessor}{\#include <memory>}}
\DoxyCodeLine{7472 }
\DoxyCodeLine{7473 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{7474 \textcolor{keyword}{namespace }TestCaseTracking \{}
\DoxyCodeLine{7475 }
\DoxyCodeLine{7476     \textcolor{keyword}{struct }NameAndLocation \{}
\DoxyCodeLine{7477         std::string name;}
\DoxyCodeLine{7478         SourceLineInfo location;}
\DoxyCodeLine{7479 }
\DoxyCodeLine{7480         NameAndLocation( std::string \textcolor{keyword}{const}\& \_name, SourceLineInfo \textcolor{keyword}{const}\& \_location );}
\DoxyCodeLine{7481         \textcolor{keyword}{friend} \textcolor{keywordtype}{bool} operator==(NameAndLocation \textcolor{keyword}{const}\& lhs, NameAndLocation \textcolor{keyword}{const}\& rhs) \{}
\DoxyCodeLine{7482             \textcolor{keywordflow}{return} lhs.name == rhs.name}
\DoxyCodeLine{7483                 \&\& lhs.location == rhs.location;}
\DoxyCodeLine{7484         \}}
\DoxyCodeLine{7485     \};}
\DoxyCodeLine{7486 }
\DoxyCodeLine{7487     \textcolor{keyword}{class }ITracker;}
\DoxyCodeLine{7488 }
\DoxyCodeLine{7489     \textcolor{keyword}{using }ITrackerPtr = std::shared\_ptr<ITracker>;}
\DoxyCodeLine{7490 }
\DoxyCodeLine{7491     \textcolor{keyword}{class  }ITracker \{}
\DoxyCodeLine{7492         NameAndLocation m\_nameAndLocation;}
\DoxyCodeLine{7493 }
\DoxyCodeLine{7494     \textcolor{keyword}{public}:}
\DoxyCodeLine{7495         ITracker(NameAndLocation \textcolor{keyword}{const}\& nameAndLoc) :}
\DoxyCodeLine{7496             m\_nameAndLocation(nameAndLoc)}
\DoxyCodeLine{7497         \{\}}
\DoxyCodeLine{7498 }
\DoxyCodeLine{7499         \textcolor{comment}{// static queries}}
\DoxyCodeLine{7500         NameAndLocation \textcolor{keyword}{const}\& nameAndLocation()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{7501             \textcolor{keywordflow}{return} m\_nameAndLocation;}
\DoxyCodeLine{7502         \}}
\DoxyCodeLine{7503 }
\DoxyCodeLine{7504         \textcolor{keyword}{virtual} \string~ITracker();}
\DoxyCodeLine{7505 }
\DoxyCodeLine{7506         \textcolor{comment}{// dynamic queries}}
\DoxyCodeLine{7507         \textcolor{keyword}{virtual} \textcolor{keywordtype}{bool} isComplete() \textcolor{keyword}{const} = 0; \textcolor{comment}{// Successfully completed or failed}}
\DoxyCodeLine{7508         \textcolor{keyword}{virtual} \textcolor{keywordtype}{bool} isSuccessfullyCompleted() \textcolor{keyword}{const} = 0;}
\DoxyCodeLine{7509         \textcolor{keyword}{virtual} \textcolor{keywordtype}{bool} isOpen() \textcolor{keyword}{const} = 0; \textcolor{comment}{// Started but not complete}}
\DoxyCodeLine{7510         \textcolor{keyword}{virtual} \textcolor{keywordtype}{bool} hasChildren() \textcolor{keyword}{const} = 0;}
\DoxyCodeLine{7511         \textcolor{keyword}{virtual} \textcolor{keywordtype}{bool} hasStarted() \textcolor{keyword}{const} = 0;}
\DoxyCodeLine{7512 }
\DoxyCodeLine{7513         \textcolor{keyword}{virtual} ITracker\& parent() = 0;}
\DoxyCodeLine{7514 }
\DoxyCodeLine{7515         \textcolor{comment}{// actions}}
\DoxyCodeLine{7516         \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} close() = 0; \textcolor{comment}{// Successfully complete}}
\DoxyCodeLine{7517         \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} fail() = 0;}
\DoxyCodeLine{7518         \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} markAsNeedingAnotherRun() = 0;}
\DoxyCodeLine{7519 }
\DoxyCodeLine{7520         \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} addChild( ITrackerPtr \textcolor{keyword}{const}\& child ) = 0;}
\DoxyCodeLine{7521         \textcolor{keyword}{virtual} ITrackerPtr findChild( NameAndLocation \textcolor{keyword}{const}\& nameAndLocation ) = 0;}
\DoxyCodeLine{7522         \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} openChild() = 0;}
\DoxyCodeLine{7523 }
\DoxyCodeLine{7524         \textcolor{comment}{// Debug/ checking}}
\DoxyCodeLine{7525         \textcolor{keyword}{virtual} \textcolor{keywordtype}{bool} isSectionTracker() \textcolor{keyword}{const} = 0;}
\DoxyCodeLine{7526         \textcolor{keyword}{virtual} \textcolor{keywordtype}{bool} isGeneratorTracker() \textcolor{keyword}{const} = 0;}
\DoxyCodeLine{7527     \};}
\DoxyCodeLine{7528 }
\DoxyCodeLine{7529     \textcolor{keyword}{class }TrackerContext \{}
\DoxyCodeLine{7530 }
\DoxyCodeLine{7531         \textcolor{keyword}{enum} RunState \{}
\DoxyCodeLine{7532             NotStarted,}
\DoxyCodeLine{7533             Executing,}
\DoxyCodeLine{7534             CompletedCycle}
\DoxyCodeLine{7535         \};}
\DoxyCodeLine{7536 }
\DoxyCodeLine{7537         ITrackerPtr m\_rootTracker;}
\DoxyCodeLine{7538         ITracker* m\_currentTracker = \textcolor{keyword}{nullptr};}
\DoxyCodeLine{7539         RunState m\_runState = NotStarted;}
\DoxyCodeLine{7540 }
\DoxyCodeLine{7541     \textcolor{keyword}{public}:}
\DoxyCodeLine{7542 }
\DoxyCodeLine{7543         ITracker\& startRun();}
\DoxyCodeLine{7544         \textcolor{keywordtype}{void} endRun();}
\DoxyCodeLine{7545 }
\DoxyCodeLine{7546         \textcolor{keywordtype}{void} startCycle();}
\DoxyCodeLine{7547         \textcolor{keywordtype}{void} completeCycle();}
\DoxyCodeLine{7548 }
\DoxyCodeLine{7549         \textcolor{keywordtype}{bool} completedCycle() \textcolor{keyword}{const};}
\DoxyCodeLine{7550         ITracker\& currentTracker();}
\DoxyCodeLine{7551         \textcolor{keywordtype}{void} setCurrentTracker( ITracker* tracker );}
\DoxyCodeLine{7552     \};}
\DoxyCodeLine{7553 }
\DoxyCodeLine{7554     \textcolor{keyword}{class }TrackerBase : \textcolor{keyword}{public} ITracker \{}
\DoxyCodeLine{7555     \textcolor{keyword}{protected}:}
\DoxyCodeLine{7556         \textcolor{keyword}{enum} CycleState \{}
\DoxyCodeLine{7557             NotStarted,}
\DoxyCodeLine{7558             Executing,}
\DoxyCodeLine{7559             ExecutingChildren,}
\DoxyCodeLine{7560             NeedsAnotherRun,}
\DoxyCodeLine{7561             CompletedSuccessfully,}
\DoxyCodeLine{7562             Failed}
\DoxyCodeLine{7563         \};}
\DoxyCodeLine{7564 }
\DoxyCodeLine{7565         \textcolor{keyword}{using }Children = std::vector<ITrackerPtr>;}
\DoxyCodeLine{7566         TrackerContext\& m\_ctx;}
\DoxyCodeLine{7567         ITracker* m\_parent;}
\DoxyCodeLine{7568         Children m\_children;}
\DoxyCodeLine{7569         CycleState m\_runState = NotStarted;}
\DoxyCodeLine{7570 }
\DoxyCodeLine{7571     \textcolor{keyword}{public}:}
\DoxyCodeLine{7572         TrackerBase( NameAndLocation \textcolor{keyword}{const}\& nameAndLocation, TrackerContext\& ctx, ITracker* parent );}
\DoxyCodeLine{7573 }
\DoxyCodeLine{7574         \textcolor{keywordtype}{bool} isComplete() \textcolor{keyword}{const override};}
\DoxyCodeLine{7575         \textcolor{keywordtype}{bool} isSuccessfullyCompleted() \textcolor{keyword}{const override};}
\DoxyCodeLine{7576         \textcolor{keywordtype}{bool} isOpen() \textcolor{keyword}{const override};}
\DoxyCodeLine{7577         \textcolor{keywordtype}{bool} hasChildren() \textcolor{keyword}{const override};}
\DoxyCodeLine{7578         \textcolor{keywordtype}{bool} hasStarted()\textcolor{keyword}{ const override }\{}
\DoxyCodeLine{7579             \textcolor{keywordflow}{return} m\_runState != NotStarted;}
\DoxyCodeLine{7580         \}}
\DoxyCodeLine{7581 }
\DoxyCodeLine{7582         \textcolor{keywordtype}{void} addChild( ITrackerPtr \textcolor{keyword}{const}\& child ) \textcolor{keyword}{override};}
\DoxyCodeLine{7583 }
\DoxyCodeLine{7584         ITrackerPtr findChild( NameAndLocation \textcolor{keyword}{const}\& nameAndLocation ) \textcolor{keyword}{override};}
\DoxyCodeLine{7585         ITracker\& parent() \textcolor{keyword}{override};}
\DoxyCodeLine{7586 }
\DoxyCodeLine{7587         \textcolor{keywordtype}{void} openChild() \textcolor{keyword}{override};}
\DoxyCodeLine{7588 }
\DoxyCodeLine{7589         \textcolor{keywordtype}{bool} isSectionTracker() \textcolor{keyword}{const override};}
\DoxyCodeLine{7590         \textcolor{keywordtype}{bool} isGeneratorTracker() \textcolor{keyword}{const override};}
\DoxyCodeLine{7591 }
\DoxyCodeLine{7592         \textcolor{keywordtype}{void} open();}
\DoxyCodeLine{7593 }
\DoxyCodeLine{7594         \textcolor{keywordtype}{void} close() \textcolor{keyword}{override};}
\DoxyCodeLine{7595         \textcolor{keywordtype}{void} fail() \textcolor{keyword}{override};}
\DoxyCodeLine{7596         \textcolor{keywordtype}{void} markAsNeedingAnotherRun() \textcolor{keyword}{override};}
\DoxyCodeLine{7597 }
\DoxyCodeLine{7598     \textcolor{keyword}{private}:}
\DoxyCodeLine{7599         \textcolor{keywordtype}{void} moveToParent();}
\DoxyCodeLine{7600         \textcolor{keywordtype}{void} moveToThis();}
\DoxyCodeLine{7601     \};}
\DoxyCodeLine{7602 }
\DoxyCodeLine{7603     \textcolor{keyword}{class }SectionTracker : \textcolor{keyword}{public} TrackerBase \{}
\DoxyCodeLine{7604         std::vector<std::string> m\_filters;}
\DoxyCodeLine{7605         std::string m\_trimmed\_name;}
\DoxyCodeLine{7606     \textcolor{keyword}{public}:}
\DoxyCodeLine{7607         SectionTracker( NameAndLocation \textcolor{keyword}{const}\& nameAndLocation, TrackerContext\& ctx, ITracker* parent );}
\DoxyCodeLine{7608 }
\DoxyCodeLine{7609         \textcolor{keywordtype}{bool} isSectionTracker() \textcolor{keyword}{const override};}
\DoxyCodeLine{7610 }
\DoxyCodeLine{7611         \textcolor{keywordtype}{bool} isComplete() \textcolor{keyword}{const override};}
\DoxyCodeLine{7612 }
\DoxyCodeLine{7613         \textcolor{keyword}{static} SectionTracker\& acquire( TrackerContext\& ctx, NameAndLocation \textcolor{keyword}{const}\& nameAndLocation );}
\DoxyCodeLine{7614 }
\DoxyCodeLine{7615         \textcolor{keywordtype}{void} tryOpen();}
\DoxyCodeLine{7616 }
\DoxyCodeLine{7617         \textcolor{keywordtype}{void} addInitialFilters( std::vector<std::string> \textcolor{keyword}{const}\& filters );}
\DoxyCodeLine{7618         \textcolor{keywordtype}{void} addNextFilters( std::vector<std::string> \textcolor{keyword}{const}\& filters );}
\DoxyCodeLine{7620         std::vector<std::string> \textcolor{keyword}{const}\& getFilters() \textcolor{keyword}{const};}
\DoxyCodeLine{7622         std::string \textcolor{keyword}{const}\& trimmedName() \textcolor{keyword}{const};}
\DoxyCodeLine{7623     \};}
\DoxyCodeLine{7624 }
\DoxyCodeLine{7625 \} \textcolor{comment}{// namespace TestCaseTracking}}
\DoxyCodeLine{7626 }
\DoxyCodeLine{7627 \textcolor{keyword}{using }TestCaseTracking::ITracker;}
\DoxyCodeLine{7628 \textcolor{keyword}{using }TestCaseTracking::TrackerContext;}
\DoxyCodeLine{7629 \textcolor{keyword}{using }TestCaseTracking::SectionTracker;}
\DoxyCodeLine{7630 }
\DoxyCodeLine{7631 \} \textcolor{comment}{// namespace Catch}}
\DoxyCodeLine{7632 }
\DoxyCodeLine{7633 \textcolor{comment}{// end catch\_test\_case\_tracker.h}}
\DoxyCodeLine{7634 }
\DoxyCodeLine{7635 \textcolor{comment}{// start catch\_leak\_detector.h}}
\DoxyCodeLine{7636 }
\DoxyCodeLine{7637 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{7638 }
\DoxyCodeLine{7639     \textcolor{keyword}{struct }LeakDetector \{}
\DoxyCodeLine{7640         LeakDetector();}
\DoxyCodeLine{7641         \string~LeakDetector();}
\DoxyCodeLine{7642     \};}
\DoxyCodeLine{7643 }
\DoxyCodeLine{7644 \}}
\DoxyCodeLine{7645 \textcolor{comment}{// end catch\_leak\_detector.h}}
\DoxyCodeLine{7646 \textcolor{comment}{// Cpp files will be included in the single-\/header file here}}
\DoxyCodeLine{7647 \textcolor{comment}{// start catch\_stats.cpp}}
\DoxyCodeLine{7648 }
\DoxyCodeLine{7649 \textcolor{comment}{// Statistical analysis tools}}
\DoxyCodeLine{7650 }
\DoxyCodeLine{7651 \textcolor{preprocessor}{\#if defined(CATCH\_CONFIG\_ENABLE\_BENCHMARKING)}}
\DoxyCodeLine{7652 }
\DoxyCodeLine{7653 \textcolor{preprocessor}{\#include <cassert>}}
\DoxyCodeLine{7654 \textcolor{preprocessor}{\#include <random>}}
\DoxyCodeLine{7655 }
\DoxyCodeLine{7656 \textcolor{preprocessor}{\#if defined(CATCH\_CONFIG\_USE\_ASYNC)}}
\DoxyCodeLine{7657 \textcolor{preprocessor}{\#include <future>}}
\DoxyCodeLine{7658 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{7659 }
\DoxyCodeLine{7660 \textcolor{keyword}{namespace }\{}
\DoxyCodeLine{7661     \textcolor{keywordtype}{double} erf\_inv(\textcolor{keywordtype}{double} x) \{}
\DoxyCodeLine{7662         \textcolor{comment}{// Code accompanying the article "{}Approximating the erfinv function"{} in GPU Computing Gems, Volume 2}}
\DoxyCodeLine{7663         \textcolor{keywordtype}{double} w, p;}
\DoxyCodeLine{7664 }
\DoxyCodeLine{7665         w = -\/log((1.0 -\/ x) * (1.0 + x));}
\DoxyCodeLine{7666 }
\DoxyCodeLine{7667         \textcolor{keywordflow}{if} (w < 6.250000) \{}
\DoxyCodeLine{7668             w = w -\/ 3.125000;}
\DoxyCodeLine{7669             p = -\/3.6444120640178196996e-\/21;}
\DoxyCodeLine{7670             p = -\/1.685059138182016589e-\/19 + p * w;}
\DoxyCodeLine{7671             p = 1.2858480715256400167e-\/18 + p * w;}
\DoxyCodeLine{7672             p = 1.115787767802518096e-\/17 + p * w;}
\DoxyCodeLine{7673             p = -\/1.333171662854620906e-\/16 + p * w;}
\DoxyCodeLine{7674             p = 2.0972767875968561637e-\/17 + p * w;}
\DoxyCodeLine{7675             p = 6.6376381343583238325e-\/15 + p * w;}
\DoxyCodeLine{7676             p = -\/4.0545662729752068639e-\/14 + p * w;}
\DoxyCodeLine{7677             p = -\/8.1519341976054721522e-\/14 + p * w;}
\DoxyCodeLine{7678             p = 2.6335093153082322977e-\/12 + p * w;}
\DoxyCodeLine{7679             p = -\/1.2975133253453532498e-\/11 + p * w;}
\DoxyCodeLine{7680             p = -\/5.4154120542946279317e-\/11 + p * w;}
\DoxyCodeLine{7681             p = 1.051212273321532285e-\/09 + p * w;}
\DoxyCodeLine{7682             p = -\/4.1126339803469836976e-\/09 + p * w;}
\DoxyCodeLine{7683             p = -\/2.9070369957882005086e-\/08 + p * w;}
\DoxyCodeLine{7684             p = 4.2347877827932403518e-\/07 + p * w;}
\DoxyCodeLine{7685             p = -\/1.3654692000834678645e-\/06 + p * w;}
\DoxyCodeLine{7686             p = -\/1.3882523362786468719e-\/05 + p * w;}
\DoxyCodeLine{7687             p = 0.0001867342080340571352 + p * w;}
\DoxyCodeLine{7688             p = -\/0.00074070253416626697512 + p * w;}
\DoxyCodeLine{7689             p = -\/0.0060336708714301490533 + p * w;}
\DoxyCodeLine{7690             p = 0.24015818242558961693 + p * w;}
\DoxyCodeLine{7691             p = 1.6536545626831027356 + p * w;}
\DoxyCodeLine{7692         \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (w < 16.000000) \{}
\DoxyCodeLine{7693             w = sqrt(w) -\/ 3.250000;}
\DoxyCodeLine{7694             p = 2.2137376921775787049e-\/09;}
\DoxyCodeLine{7695             p = 9.0756561938885390979e-\/08 + p * w;}
\DoxyCodeLine{7696             p = -\/2.7517406297064545428e-\/07 + p * w;}
\DoxyCodeLine{7697             p = 1.8239629214389227755e-\/08 + p * w;}
\DoxyCodeLine{7698             p = 1.5027403968909827627e-\/06 + p * w;}
\DoxyCodeLine{7699             p = -\/4.013867526981545969e-\/06 + p * w;}
\DoxyCodeLine{7700             p = 2.9234449089955446044e-\/06 + p * w;}
\DoxyCodeLine{7701             p = 1.2475304481671778723e-\/05 + p * w;}
\DoxyCodeLine{7702             p = -\/4.7318229009055733981e-\/05 + p * w;}
\DoxyCodeLine{7703             p = 6.8284851459573175448e-\/05 + p * w;}
\DoxyCodeLine{7704             p = 2.4031110387097893999e-\/05 + p * w;}
\DoxyCodeLine{7705             p = -\/0.0003550375203628474796 + p * w;}
\DoxyCodeLine{7706             p = 0.00095328937973738049703 + p * w;}
\DoxyCodeLine{7707             p = -\/0.0016882755560235047313 + p * w;}
\DoxyCodeLine{7708             p = 0.0024914420961078508066 + p * w;}
\DoxyCodeLine{7709             p = -\/0.0037512085075692412107 + p * w;}
\DoxyCodeLine{7710             p = 0.005370914553590063617 + p * w;}
\DoxyCodeLine{7711             p = 1.0052589676941592334 + p * w;}
\DoxyCodeLine{7712             p = 3.0838856104922207635 + p * w;}
\DoxyCodeLine{7713         \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{7714             w = sqrt(w) -\/ 5.000000;}
\DoxyCodeLine{7715             p = -\/2.7109920616438573243e-\/11;}
\DoxyCodeLine{7716             p = -\/2.5556418169965252055e-\/10 + p * w;}
\DoxyCodeLine{7717             p = 1.5076572693500548083e-\/09 + p * w;}
\DoxyCodeLine{7718             p = -\/3.7894654401267369937e-\/09 + p * w;}
\DoxyCodeLine{7719             p = 7.6157012080783393804e-\/09 + p * w;}
\DoxyCodeLine{7720             p = -\/1.4960026627149240478e-\/08 + p * w;}
\DoxyCodeLine{7721             p = 2.9147953450901080826e-\/08 + p * w;}
\DoxyCodeLine{7722             p = -\/6.7711997758452339498e-\/08 + p * w;}
\DoxyCodeLine{7723             p = 2.2900482228026654717e-\/07 + p * w;}
\DoxyCodeLine{7724             p = -\/9.9298272942317002539e-\/07 + p * w;}
\DoxyCodeLine{7725             p = 4.5260625972231537039e-\/06 + p * w;}
\DoxyCodeLine{7726             p = -\/1.9681778105531670567e-\/05 + p * w;}
\DoxyCodeLine{7727             p = 7.5995277030017761139e-\/05 + p * w;}
\DoxyCodeLine{7728             p = -\/0.00021503011930044477347 + p * w;}
\DoxyCodeLine{7729             p = -\/0.00013871931833623122026 + p * w;}
\DoxyCodeLine{7730             p = 1.0103004648645343977 + p * w;}
\DoxyCodeLine{7731             p = 4.8499064014085844221 + p * w;}
\DoxyCodeLine{7732         \}}
\DoxyCodeLine{7733         \textcolor{keywordflow}{return} p * x;}
\DoxyCodeLine{7734     \}}
\DoxyCodeLine{7735 }
\DoxyCodeLine{7736     \textcolor{keywordtype}{double} standard\_deviation(std::vector<double>::iterator first, std::vector<double>::iterator last) \{}
\DoxyCodeLine{7737         \textcolor{keyword}{auto} m = Catch::Benchmark::Detail::mean(first, last);}
\DoxyCodeLine{7738         \textcolor{keywordtype}{double} variance = std::accumulate(first, last, 0., [m](\textcolor{keywordtype}{double} a, \textcolor{keywordtype}{double} b) \{}
\DoxyCodeLine{7739             \textcolor{keywordtype}{double} diff = b -\/ m;}
\DoxyCodeLine{7740             \textcolor{keywordflow}{return} a + diff * diff;}
\DoxyCodeLine{7741             \}) / (last -\/ first);}
\DoxyCodeLine{7742             \textcolor{keywordflow}{return} std::sqrt(variance);}
\DoxyCodeLine{7743     \}}
\DoxyCodeLine{7744 }
\DoxyCodeLine{7745 \}}
\DoxyCodeLine{7746 }
\DoxyCodeLine{7747 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{7748     \textcolor{keyword}{namespace }Benchmark \{}
\DoxyCodeLine{7749         \textcolor{keyword}{namespace }Detail \{}
\DoxyCodeLine{7750 }
\DoxyCodeLine{7751             \textcolor{keywordtype}{double} weighted\_average\_quantile(\textcolor{keywordtype}{int} k, \textcolor{keywordtype}{int} q, std::vector<double>::iterator first, std::vector<double>::iterator last) \{}
\DoxyCodeLine{7752                 \textcolor{keyword}{auto} count = last -\/ first;}
\DoxyCodeLine{7753                 \textcolor{keywordtype}{double} idx = (count -\/ 1) * k / static\_cast<double>(q);}
\DoxyCodeLine{7754                 \textcolor{keywordtype}{int} j = \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{int}\textcolor{keyword}{>}(idx);}
\DoxyCodeLine{7755                 \textcolor{keywordtype}{double} g = idx -\/ j;}
\DoxyCodeLine{7756                 std::nth\_element(first, first + j, last);}
\DoxyCodeLine{7757                 \textcolor{keyword}{auto} xj = first[j];}
\DoxyCodeLine{7758                 \textcolor{keywordflow}{if} (g == 0) \textcolor{keywordflow}{return} xj;}
\DoxyCodeLine{7759 }
\DoxyCodeLine{7760                 \textcolor{keyword}{auto} xj1 = *std::min\_element(first + (j + 1), last);}
\DoxyCodeLine{7761                 \textcolor{keywordflow}{return} xj + g * (xj1 -\/ xj);}
\DoxyCodeLine{7762             \}}
\DoxyCodeLine{7763 }
\DoxyCodeLine{7764             \textcolor{keywordtype}{double} erfc\_inv(\textcolor{keywordtype}{double} x) \{}
\DoxyCodeLine{7765                 \textcolor{keywordflow}{return} erf\_inv(1.0 -\/ x);}
\DoxyCodeLine{7766             \}}
\DoxyCodeLine{7767 }
\DoxyCodeLine{7768             \textcolor{keywordtype}{double} normal\_quantile(\textcolor{keywordtype}{double} p) \{}
\DoxyCodeLine{7769                 \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{double} ROOT\_TWO = std::sqrt(2.0);}
\DoxyCodeLine{7770 }
\DoxyCodeLine{7771                 \textcolor{keywordtype}{double} result = 0.0;}
\DoxyCodeLine{7772                 assert(p >= 0 \&\& p <= 1);}
\DoxyCodeLine{7773                 \textcolor{keywordflow}{if} (p < 0 || p > 1) \{}
\DoxyCodeLine{7774                     \textcolor{keywordflow}{return} result;}
\DoxyCodeLine{7775                 \}}
\DoxyCodeLine{7776 }
\DoxyCodeLine{7777                 result = -\/erfc\_inv(2.0 * p);}
\DoxyCodeLine{7778                 \textcolor{comment}{// result *= normal distribution standard deviation (1.0) * sqrt(2)}}
\DoxyCodeLine{7779                 result *= \textcolor{comment}{/*sd * */} ROOT\_TWO;}
\DoxyCodeLine{7780                 \textcolor{comment}{// result += normal disttribution mean (0)}}
\DoxyCodeLine{7781                 \textcolor{keywordflow}{return} result;}
\DoxyCodeLine{7782             \}}
\DoxyCodeLine{7783 }
\DoxyCodeLine{7784             \textcolor{keywordtype}{double} outlier\_variance(Estimate<double> mean, Estimate<double> stddev, \textcolor{keywordtype}{int} n) \{}
\DoxyCodeLine{7785                 \textcolor{keywordtype}{double} sb = stddev.point;}
\DoxyCodeLine{7786                 \textcolor{keywordtype}{double} mn = mean.point / n;}
\DoxyCodeLine{7787                 \textcolor{keywordtype}{double} mg\_min = mn / 2.;}
\DoxyCodeLine{7788                 \textcolor{keywordtype}{double} sg = (std::min)(mg\_min / 4., sb / std::sqrt(n));}
\DoxyCodeLine{7789                 \textcolor{keywordtype}{double} sg2 = sg * sg;}
\DoxyCodeLine{7790                 \textcolor{keywordtype}{double} sb2 = sb * sb;}
\DoxyCodeLine{7791 }
\DoxyCodeLine{7792                 \textcolor{keyword}{auto} c\_max = [n, mn, sb2, sg2](\textcolor{keywordtype}{double} x) -\/> \textcolor{keywordtype}{double} \{}
\DoxyCodeLine{7793                     \textcolor{keywordtype}{double} k = mn -\/ x;}
\DoxyCodeLine{7794                     \textcolor{keywordtype}{double} d = k * k;}
\DoxyCodeLine{7795                     \textcolor{keywordtype}{double} nd = n * d;}
\DoxyCodeLine{7796                     \textcolor{keywordtype}{double} k0 = -\/n * nd;}
\DoxyCodeLine{7797                     \textcolor{keywordtype}{double} k1 = sb2 -\/ n * sg2 + nd;}
\DoxyCodeLine{7798                     \textcolor{keywordtype}{double} det = k1 * k1 -\/ 4 * sg2 * k0;}
\DoxyCodeLine{7799                     \textcolor{keywordflow}{return} (\textcolor{keywordtype}{int})(-\/2. * k0 / (k1 + std::sqrt(det)));}
\DoxyCodeLine{7800                 \};}
\DoxyCodeLine{7801 }
\DoxyCodeLine{7802                 \textcolor{keyword}{auto} var\_out = [n, sb2, sg2](\textcolor{keywordtype}{double} c) \{}
\DoxyCodeLine{7803                     \textcolor{keywordtype}{double} nc = n -\/ c;}
\DoxyCodeLine{7804                     \textcolor{keywordflow}{return} (nc / n) * (sb2 -\/ nc * sg2);}
\DoxyCodeLine{7805                 \};}
\DoxyCodeLine{7806 }
\DoxyCodeLine{7807                 \textcolor{keywordflow}{return} (std::min)(var\_out(1), var\_out((std::min)(c\_max(0.), c\_max(mg\_min)))) / sb2;}
\DoxyCodeLine{7808             \}}
\DoxyCodeLine{7809 }
\DoxyCodeLine{7810             bootstrap\_analysis analyse\_samples(\textcolor{keywordtype}{double} confidence\_level, \textcolor{keywordtype}{int} n\_resamples, std::vector<double>::iterator first, std::vector<double>::iterator last) \{}
\DoxyCodeLine{7811                 CATCH\_INTERNAL\_START\_WARNINGS\_SUPPRESSION}
\DoxyCodeLine{7812                 CATCH\_INTERNAL\_SUPPRESS\_GLOBALS\_WARNINGS}
\DoxyCodeLine{7813                 \textcolor{keyword}{static} std::random\_device entropy;}
\DoxyCodeLine{7814                 CATCH\_INTERNAL\_STOP\_WARNINGS\_SUPPRESSION}
\DoxyCodeLine{7815 }
\DoxyCodeLine{7816                 \textcolor{keyword}{auto} n = \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{int}\textcolor{keyword}{>}(last -\/ first); \textcolor{comment}{// seriously, one can't use integral types without hell in C++}}
\DoxyCodeLine{7817 }
\DoxyCodeLine{7818                 \textcolor{keyword}{auto} mean = \&Detail::mean<std::vector<double>::iterator>;}
\DoxyCodeLine{7819                 \textcolor{keyword}{auto} stddev = \&standard\_deviation;}
\DoxyCodeLine{7820 }
\DoxyCodeLine{7821 \textcolor{preprocessor}{\#if defined(CATCH\_CONFIG\_USE\_ASYNC)}}
\DoxyCodeLine{7822                 \textcolor{keyword}{auto} Estimate = [=](double(*f)(std::vector<double>::iterator, std::vector<double>::iterator)) \{}
\DoxyCodeLine{7823                     \textcolor{keyword}{auto} seed = entropy();}
\DoxyCodeLine{7824                     \textcolor{keywordflow}{return} std::async(std::launch::async, [=] \{}
\DoxyCodeLine{7825                         std::mt19937 rng(seed);}
\DoxyCodeLine{7826                         \textcolor{keyword}{auto} resampled = resample(rng, n\_resamples, first, last, f);}
\DoxyCodeLine{7827                         \textcolor{keywordflow}{return} bootstrap(confidence\_level, first, last, resampled, f);}
\DoxyCodeLine{7828                     \});}
\DoxyCodeLine{7829                 \};}
\DoxyCodeLine{7830 }
\DoxyCodeLine{7831                 \textcolor{keyword}{auto} mean\_future = Estimate(mean);}
\DoxyCodeLine{7832                 \textcolor{keyword}{auto} stddev\_future = Estimate(stddev);}
\DoxyCodeLine{7833 }
\DoxyCodeLine{7834                 \textcolor{keyword}{auto} mean\_estimate = mean\_future.get();}
\DoxyCodeLine{7835                 \textcolor{keyword}{auto} stddev\_estimate = stddev\_future.get();}
\DoxyCodeLine{7836 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{7837                 \textcolor{keyword}{auto} Estimate = [=](double(*f)(std::vector<double>::iterator, std::vector<double>::iterator)) \{}
\DoxyCodeLine{7838                     \textcolor{keyword}{auto} seed = entropy();}
\DoxyCodeLine{7839                     std::mt19937 rng(seed);}
\DoxyCodeLine{7840                     \textcolor{keyword}{auto} resampled = resample(rng, n\_resamples, first, last, f);}
\DoxyCodeLine{7841                     \textcolor{keywordflow}{return} bootstrap(confidence\_level, first, last, resampled, f);}
\DoxyCodeLine{7842                 \};}
\DoxyCodeLine{7843 }
\DoxyCodeLine{7844                 \textcolor{keyword}{auto} mean\_estimate = Estimate(mean);}
\DoxyCodeLine{7845                 \textcolor{keyword}{auto} stddev\_estimate = Estimate(stddev);}
\DoxyCodeLine{7846 \textcolor{preprocessor}{\#endif }\textcolor{comment}{// CATCH\_USE\_ASYNC}}
\DoxyCodeLine{7847 }
\DoxyCodeLine{7848                 \textcolor{keywordtype}{double} outlier\_variance = Detail::outlier\_variance(mean\_estimate, stddev\_estimate, n);}
\DoxyCodeLine{7849 }
\DoxyCodeLine{7850                 \textcolor{keywordflow}{return} \{ mean\_estimate, stddev\_estimate, outlier\_variance \};}
\DoxyCodeLine{7851             \}}
\DoxyCodeLine{7852         \} \textcolor{comment}{// namespace Detail}}
\DoxyCodeLine{7853     \} \textcolor{comment}{// namespace Benchmark}}
\DoxyCodeLine{7854 \} \textcolor{comment}{// namespace Catch}}
\DoxyCodeLine{7855 }
\DoxyCodeLine{7856 \textcolor{preprocessor}{\#endif }\textcolor{comment}{// CATCH\_CONFIG\_ENABLE\_BENCHMARKING}}
\DoxyCodeLine{7857 \textcolor{comment}{// end catch\_stats.cpp}}
\DoxyCodeLine{7858 \textcolor{comment}{// start catch\_approx.cpp}}
\DoxyCodeLine{7859 }
\DoxyCodeLine{7860 \textcolor{preprocessor}{\#include <cmath>}}
\DoxyCodeLine{7861 \textcolor{preprocessor}{\#include <limits>}}
\DoxyCodeLine{7862 }
\DoxyCodeLine{7863 \textcolor{keyword}{namespace }\{}
\DoxyCodeLine{7864 }
\DoxyCodeLine{7865 \textcolor{comment}{// Performs equivalent check of std::fabs(lhs -\/ rhs) <= margin}}
\DoxyCodeLine{7866 \textcolor{comment}{// But without the subtraction to allow for INFINITY in comparison}}
\DoxyCodeLine{7867 \textcolor{keywordtype}{bool} marginComparison(\textcolor{keywordtype}{double} lhs, \textcolor{keywordtype}{double} rhs, \textcolor{keywordtype}{double} margin) \{}
\DoxyCodeLine{7868     \textcolor{keywordflow}{return} (lhs + margin >= rhs) \&\& (rhs + margin >= lhs);}
\DoxyCodeLine{7869 \}}
\DoxyCodeLine{7870 }
\DoxyCodeLine{7871 \}}
\DoxyCodeLine{7872 }
\DoxyCodeLine{7873 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{7874 \textcolor{keyword}{namespace }Detail \{}
\DoxyCodeLine{7875 }
\DoxyCodeLine{7876     Approx::Approx ( \textcolor{keywordtype}{double} value )}
\DoxyCodeLine{7877     :   m\_epsilon( std::numeric\_limits<float>::epsilon()*100 ),}
\DoxyCodeLine{7878         m\_margin( 0.0 ),}
\DoxyCodeLine{7879         m\_scale( 0.0 ),}
\DoxyCodeLine{7880         m\_value( value )}
\DoxyCodeLine{7881     \{\}}
\DoxyCodeLine{7882 }
\DoxyCodeLine{7883     \mbox{\hyperlink{classCatch_1_1Detail_1_1Approx}{Approx}} Approx::custom() \{}
\DoxyCodeLine{7884         \textcolor{keywordflow}{return} \mbox{\hyperlink{classCatch_1_1Detail_1_1Approx}{Approx}}( 0 );}
\DoxyCodeLine{7885     \}}
\DoxyCodeLine{7886 }
\DoxyCodeLine{7887     \mbox{\hyperlink{classCatch_1_1Detail_1_1Approx}{Approx}} Approx::operator-\/()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{7888         \textcolor{keyword}{auto} temp(*\textcolor{keyword}{this});}
\DoxyCodeLine{7889         temp.m\_value = -\/temp.m\_value;}
\DoxyCodeLine{7890         \textcolor{keywordflow}{return} temp;}
\DoxyCodeLine{7891     \}}
\DoxyCodeLine{7892 }
\DoxyCodeLine{7893     std::string Approx::toString()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{7894         ReusableStringStream rss;}
\DoxyCodeLine{7895         rss << \textcolor{stringliteral}{"{}Approx( "{}} << ::Catch::Detail::stringify( m\_value ) << \textcolor{stringliteral}{"{} )"{}};}
\DoxyCodeLine{7896         \textcolor{keywordflow}{return} rss.str();}
\DoxyCodeLine{7897     \}}
\DoxyCodeLine{7898 }
\DoxyCodeLine{7899     \textcolor{keywordtype}{bool} Approx::equalityComparisonImpl(\textcolor{keyword}{const} \textcolor{keywordtype}{double} other)\textcolor{keyword}{ const }\{}
\DoxyCodeLine{7900         \textcolor{comment}{// First try with fixed margin, then compute margin based on epsilon, scale and Approx's value}}
\DoxyCodeLine{7901         \textcolor{comment}{// Thanks to Richard Harris for his help refining the scaled margin value}}
\DoxyCodeLine{7902         \textcolor{keywordflow}{return} marginComparison(m\_value, other, m\_margin)}
\DoxyCodeLine{7903             || marginComparison(m\_value, other, m\_epsilon * (m\_scale + std::fabs(std::isinf(m\_value)? 0 : m\_value)));}
\DoxyCodeLine{7904     \}}
\DoxyCodeLine{7905 }
\DoxyCodeLine{7906     \textcolor{keywordtype}{void} Approx::setMargin(\textcolor{keywordtype}{double} newMargin) \{}
\DoxyCodeLine{7907         CATCH\_ENFORCE(newMargin >= 0,}
\DoxyCodeLine{7908             \textcolor{stringliteral}{"{}Invalid Approx::margin: "{}} << newMargin << \textcolor{charliteral}{'.'}}
\DoxyCodeLine{7909             << \textcolor{stringliteral}{"{} Approx::Margin has to be non-\/negative."{}});}
\DoxyCodeLine{7910         m\_margin = newMargin;}
\DoxyCodeLine{7911     \}}
\DoxyCodeLine{7912 }
\DoxyCodeLine{7913     \textcolor{keywordtype}{void} Approx::setEpsilon(\textcolor{keywordtype}{double} newEpsilon) \{}
\DoxyCodeLine{7914         CATCH\_ENFORCE(newEpsilon >= 0 \&\& newEpsilon <= 1.0,}
\DoxyCodeLine{7915             \textcolor{stringliteral}{"{}Invalid Approx::epsilon: "{}} << newEpsilon << \textcolor{charliteral}{'.'}}
\DoxyCodeLine{7916             << \textcolor{stringliteral}{"{} Approx::epsilon has to be in [0, 1]"{}});}
\DoxyCodeLine{7917         m\_epsilon = newEpsilon;}
\DoxyCodeLine{7918     \}}
\DoxyCodeLine{7919 }
\DoxyCodeLine{7920 \} \textcolor{comment}{// end namespace Detail}}
\DoxyCodeLine{7921 }
\DoxyCodeLine{7922 \textcolor{keyword}{namespace }literals \{}
\DoxyCodeLine{7923     Detail::Approx \textcolor{keyword}{operator} \textcolor{stringliteral}{"{}"{}} \_a(\textcolor{keywordtype}{long} \textcolor{keywordtype}{double} val) \{}
\DoxyCodeLine{7924         \textcolor{keywordflow}{return} Detail::Approx(val);}
\DoxyCodeLine{7925     \}}
\DoxyCodeLine{7926     Detail::Approx \textcolor{keyword}{operator} \textcolor{stringliteral}{"{}"{}} \_a(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} val) \{}
\DoxyCodeLine{7927         \textcolor{keywordflow}{return} Detail::Approx(val);}
\DoxyCodeLine{7928     \}}
\DoxyCodeLine{7929 \} \textcolor{comment}{// end namespace literals}}
\DoxyCodeLine{7930 }
\DoxyCodeLine{7931 std::string StringMaker<Catch::Detail::Approx>::convert(\mbox{\hyperlink{classCatch_1_1Detail_1_1Approx}{Catch::Detail::Approx}} \textcolor{keyword}{const}\& value) \{}
\DoxyCodeLine{7932     \textcolor{keywordflow}{return} value.toString();}
\DoxyCodeLine{7933 \}}
\DoxyCodeLine{7934 }
\DoxyCodeLine{7935 \} \textcolor{comment}{// end namespace Catch}}
\DoxyCodeLine{7936 \textcolor{comment}{// end catch\_approx.cpp}}
\DoxyCodeLine{7937 \textcolor{comment}{// start catch\_assertionhandler.cpp}}
\DoxyCodeLine{7938 }
\DoxyCodeLine{7939 \textcolor{comment}{// start catch\_debugger.h}}
\DoxyCodeLine{7940 }
\DoxyCodeLine{7941 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{7942     \textcolor{keywordtype}{bool} isDebuggerActive();}
\DoxyCodeLine{7943 \}}
\DoxyCodeLine{7944 }
\DoxyCodeLine{7945 \textcolor{preprocessor}{\#ifdef CATCH\_PLATFORM\_MAC}}
\DoxyCodeLine{7946 }
\DoxyCodeLine{7947 \textcolor{preprocessor}{    \#if defined(\_\_i386\_\_) || defined(\_\_x86\_64\_\_)}}
\DoxyCodeLine{7948 \textcolor{preprocessor}{        \#define CATCH\_TRAP() \_\_asm\_\_("{}int \$3\(\backslash\)n"{}} : : ) \textcolor{comment}{/* NOLINT */}\textcolor{preprocessor}{}}
\DoxyCodeLine{7949 \textcolor{preprocessor}{    \#elif defined(\_\_aarch64\_\_)}}
\DoxyCodeLine{7950 \textcolor{preprocessor}{        \#define CATCH\_TRAP()  \_\_asm\_\_("{}.inst 0xd43e0000"{}})}
\DoxyCodeLine{7951 \textcolor{preprocessor}{    \#endif}}
\DoxyCodeLine{7952 }
\DoxyCodeLine{7953 \textcolor{preprocessor}{\#elif defined(CATCH\_PLATFORM\_IPHONE)}}
\DoxyCodeLine{7954 }
\DoxyCodeLine{7955     \textcolor{comment}{// use inline assembler}}
\DoxyCodeLine{7956 \textcolor{preprocessor}{    \#if defined(\_\_i386\_\_) || defined(\_\_x86\_64\_\_)}}
\DoxyCodeLine{7957 \textcolor{preprocessor}{        \#define CATCH\_TRAP()  \_\_asm\_\_("{}int \$3"{}})}
\DoxyCodeLine{7958 \textcolor{preprocessor}{    \#elif defined(\_\_aarch64\_\_)}}
\DoxyCodeLine{7959 \textcolor{preprocessor}{        \#define CATCH\_TRAP()  \_\_asm\_\_("{}.inst 0xd4200000"{}})}
\DoxyCodeLine{7960 \textcolor{preprocessor}{    \#elif defined(\_\_arm\_\_) \&\& !defined(\_\_thumb\_\_)}}
\DoxyCodeLine{7961 \textcolor{preprocessor}{        \#define CATCH\_TRAP()  \_\_asm\_\_("{}.inst 0xe7f001f0"{}})}
\DoxyCodeLine{7962 \textcolor{preprocessor}{    \#elif defined(\_\_arm\_\_) \&\&  defined(\_\_thumb\_\_)}}
\DoxyCodeLine{7963 \textcolor{preprocessor}{        \#define CATCH\_TRAP()  \_\_asm\_\_("{}.inst 0xde01"{}})}
\DoxyCodeLine{7964 \textcolor{preprocessor}{    \#endif}}
\DoxyCodeLine{7965 }
\DoxyCodeLine{7966 \textcolor{preprocessor}{\#elif defined(CATCH\_PLATFORM\_LINUX)}}
\DoxyCodeLine{7967     \textcolor{comment}{// If we can use inline assembler, do it because this allows us to break}}
\DoxyCodeLine{7968     \textcolor{comment}{// directly at the location of the failing check instead of breaking inside}}
\DoxyCodeLine{7969     \textcolor{comment}{// raise() called from it, i.e. one stack frame below.}}
\DoxyCodeLine{7970 \textcolor{preprocessor}{    \#if defined(\_\_GNUC\_\_) \&\& (defined(\_\_i386) || defined(\_\_x86\_64))}}
\DoxyCodeLine{7971 \textcolor{preprocessor}{        \#define CATCH\_TRAP() asm volatile ("{}int \$3"{}}) \textcolor{comment}{/* NOLINT */}\textcolor{preprocessor}{}}
\DoxyCodeLine{7972 \textcolor{preprocessor}{    \#else }\textcolor{comment}{// Fall back to the generic way.}}
\DoxyCodeLine{7973 \textcolor{preprocessor}{        \#include <signal.h>}}
\DoxyCodeLine{7974 }
\DoxyCodeLine{7975 \textcolor{preprocessor}{        \#define CATCH\_TRAP() raise(SIGTRAP)}}
\DoxyCodeLine{7976 \textcolor{preprocessor}{    \#endif}}
\DoxyCodeLine{7977 \textcolor{preprocessor}{\#elif defined(\_MSC\_VER)}}
\DoxyCodeLine{7978 \textcolor{preprocessor}{    \#define CATCH\_TRAP() \_\_debugbreak()}}
\DoxyCodeLine{7979 \textcolor{preprocessor}{\#elif defined(\_\_MINGW32\_\_)}}
\DoxyCodeLine{7980     \textcolor{keyword}{extern} \textcolor{stringliteral}{"{}C"{}} \_\_declspec(dllimport) \textcolor{keywordtype}{void} \_\_stdcall DebugBreak();}
\DoxyCodeLine{7981 \textcolor{preprocessor}{    \#define CATCH\_TRAP() DebugBreak()}}
\DoxyCodeLine{7982 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{7983 }
\DoxyCodeLine{7984 \textcolor{preprocessor}{\#ifndef CATCH\_BREAK\_INTO\_DEBUGGER}}
\DoxyCodeLine{7985 \textcolor{preprocessor}{    \#ifdef CATCH\_TRAP}}
\DoxyCodeLine{7986 \textcolor{preprocessor}{        \#define CATCH\_BREAK\_INTO\_DEBUGGER() []\{ if( Catch::isDebuggerActive() ) \{ CATCH\_TRAP(); \} \}()}}
\DoxyCodeLine{7987 \textcolor{preprocessor}{    \#else}}
\DoxyCodeLine{7988 \textcolor{preprocessor}{        \#define CATCH\_BREAK\_INTO\_DEBUGGER() []\{\}()}}
\DoxyCodeLine{7989 \textcolor{preprocessor}{    \#endif}}
\DoxyCodeLine{7990 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{7991 }
\DoxyCodeLine{7992 \textcolor{comment}{// end catch\_debugger.h}}
\DoxyCodeLine{7993 \textcolor{comment}{// start catch\_run\_context.h}}
\DoxyCodeLine{7994 }
\DoxyCodeLine{7995 \textcolor{comment}{// start catch\_fatal\_condition.h}}
\DoxyCodeLine{7996 }
\DoxyCodeLine{7997 \textcolor{preprocessor}{\#include <cassert>}}
\DoxyCodeLine{7998 }
\DoxyCodeLine{7999 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{8000 }
\DoxyCodeLine{8001     \textcolor{comment}{// Wrapper for platform-\/specific fatal error (signals/SEH) handlers}}
\DoxyCodeLine{8002     \textcolor{comment}{//}}
\DoxyCodeLine{8003     \textcolor{comment}{// Tries to be cooperative with other handlers, and not step over}}
\DoxyCodeLine{8004     \textcolor{comment}{// other handlers. This means that unknown structured exceptions}}
\DoxyCodeLine{8005     \textcolor{comment}{// are passed on, previous signal handlers are called, and so on.}}
\DoxyCodeLine{8006     \textcolor{comment}{//}}
\DoxyCodeLine{8007     \textcolor{comment}{// Can only be instantiated once, and assumes that once a signal}}
\DoxyCodeLine{8008     \textcolor{comment}{// is caught, the binary will end up terminating. Thus, there}}
\DoxyCodeLine{8009     \textcolor{keyword}{class }FatalConditionHandler \{}
\DoxyCodeLine{8010         \textcolor{keywordtype}{bool} m\_started = \textcolor{keyword}{false};}
\DoxyCodeLine{8011 }
\DoxyCodeLine{8012         \textcolor{comment}{// Install/disengage implementation for specific platform.}}
\DoxyCodeLine{8013         \textcolor{comment}{// Should be if-\/defed to work on current platform, can assume}}
\DoxyCodeLine{8014         \textcolor{comment}{// engage-\/disengage 1:1 pairing.}}
\DoxyCodeLine{8015         \textcolor{keywordtype}{void} engage\_platform();}
\DoxyCodeLine{8016         \textcolor{keywordtype}{void} disengage\_platform();}
\DoxyCodeLine{8017     \textcolor{keyword}{public}:}
\DoxyCodeLine{8018         \textcolor{comment}{// Should also have platform-\/specific implementations as needed}}
\DoxyCodeLine{8019         FatalConditionHandler();}
\DoxyCodeLine{8020         \string~FatalConditionHandler();}
\DoxyCodeLine{8021 }
\DoxyCodeLine{8022         \textcolor{keywordtype}{void} engage() \{}
\DoxyCodeLine{8023             assert(!m\_started \&\& \textcolor{stringliteral}{"{}Handler cannot be installed twice."{}});}
\DoxyCodeLine{8024             m\_started = \textcolor{keyword}{true};}
\DoxyCodeLine{8025             engage\_platform();}
\DoxyCodeLine{8026         \}}
\DoxyCodeLine{8027 }
\DoxyCodeLine{8028         \textcolor{keywordtype}{void} disengage() \{}
\DoxyCodeLine{8029             assert(m\_started \&\& \textcolor{stringliteral}{"{}Handler cannot be uninstalled without being installed first"{}});}
\DoxyCodeLine{8030             m\_started = \textcolor{keyword}{false};}
\DoxyCodeLine{8031             disengage\_platform();}
\DoxyCodeLine{8032         \}}
\DoxyCodeLine{8033     \};}
\DoxyCodeLine{8034 }
\DoxyCodeLine{8036     \textcolor{keyword}{class }FatalConditionHandlerGuard \{}
\DoxyCodeLine{8037         FatalConditionHandler* m\_handler;}
\DoxyCodeLine{8038     \textcolor{keyword}{public}:}
\DoxyCodeLine{8039         FatalConditionHandlerGuard(FatalConditionHandler* handler):}
\DoxyCodeLine{8040             m\_handler(handler) \{}
\DoxyCodeLine{8041             m\_handler-\/>engage();}
\DoxyCodeLine{8042         \}}
\DoxyCodeLine{8043         \string~FatalConditionHandlerGuard() \{}
\DoxyCodeLine{8044             m\_handler-\/>disengage();}
\DoxyCodeLine{8045         \}}
\DoxyCodeLine{8046     \};}
\DoxyCodeLine{8047 }
\DoxyCodeLine{8048 \} \textcolor{comment}{// end namespace Catch}}
\DoxyCodeLine{8049 }
\DoxyCodeLine{8050 \textcolor{comment}{// end catch\_fatal\_condition.h}}
\DoxyCodeLine{8051 \textcolor{preprocessor}{\#include <string>}}
\DoxyCodeLine{8052 }
\DoxyCodeLine{8053 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{8054 }
\DoxyCodeLine{8055     \textcolor{keyword}{struct }IMutableContext;}
\DoxyCodeLine{8056 }
\DoxyCodeLine{8058 }
\DoxyCodeLine{8059     \textcolor{keyword}{class }RunContext : \textcolor{keyword}{public} IResultCapture, \textcolor{keyword}{public} IRunner \{}
\DoxyCodeLine{8060 }
\DoxyCodeLine{8061     \textcolor{keyword}{public}:}
\DoxyCodeLine{8062         RunContext( RunContext \textcolor{keyword}{const}\& ) = \textcolor{keyword}{delete};}
\DoxyCodeLine{8063         RunContext\& operator =( RunContext \textcolor{keyword}{const}\& ) = \textcolor{keyword}{delete};}
\DoxyCodeLine{8064 }
\DoxyCodeLine{8065         \textcolor{keyword}{explicit} RunContext( IConfigPtr \textcolor{keyword}{const}\& \_config, IStreamingReporterPtr\&\& reporter );}
\DoxyCodeLine{8066 }
\DoxyCodeLine{8067         \string~RunContext() \textcolor{keyword}{override};}
\DoxyCodeLine{8068 }
\DoxyCodeLine{8069         \textcolor{keywordtype}{void} testGroupStarting( std::string \textcolor{keyword}{const}\& testSpec, std::size\_t groupIndex, std::size\_t groupsCount );}
\DoxyCodeLine{8070         \textcolor{keywordtype}{void} testGroupEnded( std::string \textcolor{keyword}{const}\& testSpec, Totals \textcolor{keyword}{const}\& totals, std::size\_t groupIndex, std::size\_t groupsCount );}
\DoxyCodeLine{8071 }
\DoxyCodeLine{8072         Totals runTest(TestCase \textcolor{keyword}{const}\& testCase);}
\DoxyCodeLine{8073 }
\DoxyCodeLine{8074         IConfigPtr config() \textcolor{keyword}{const};}
\DoxyCodeLine{8075         IStreamingReporter\& reporter() \textcolor{keyword}{const};}
\DoxyCodeLine{8076 }
\DoxyCodeLine{8077     \textcolor{keyword}{public}: \textcolor{comment}{// IResultCapture}}
\DoxyCodeLine{8078 }
\DoxyCodeLine{8079         \textcolor{comment}{// Assertion handlers}}
\DoxyCodeLine{8080         \textcolor{keywordtype}{void} handleExpr}
\DoxyCodeLine{8081                 (   AssertionInfo \textcolor{keyword}{const}\& info,}
\DoxyCodeLine{8082                     ITransientExpression \textcolor{keyword}{const}\& expr,}
\DoxyCodeLine{8083                     AssertionReaction\& reaction ) \textcolor{keyword}{override};}
\DoxyCodeLine{8084         \textcolor{keywordtype}{void} handleMessage}
\DoxyCodeLine{8085                 (   AssertionInfo \textcolor{keyword}{const}\& info,}
\DoxyCodeLine{8086                     ResultWas::OfType resultType,}
\DoxyCodeLine{8087                     StringRef \textcolor{keyword}{const}\& message,}
\DoxyCodeLine{8088                     AssertionReaction\& reaction ) \textcolor{keyword}{override};}
\DoxyCodeLine{8089         \textcolor{keywordtype}{void} handleUnexpectedExceptionNotThrown}
\DoxyCodeLine{8090                 (   AssertionInfo \textcolor{keyword}{const}\& info,}
\DoxyCodeLine{8091                     AssertionReaction\& reaction ) \textcolor{keyword}{override};}
\DoxyCodeLine{8092         \textcolor{keywordtype}{void} handleUnexpectedInflightException}
\DoxyCodeLine{8093                 (   AssertionInfo \textcolor{keyword}{const}\& info,}
\DoxyCodeLine{8094                     std::string \textcolor{keyword}{const}\& message,}
\DoxyCodeLine{8095                     AssertionReaction\& reaction ) \textcolor{keyword}{override};}
\DoxyCodeLine{8096         \textcolor{keywordtype}{void} handleIncomplete}
\DoxyCodeLine{8097                 (   AssertionInfo \textcolor{keyword}{const}\& info ) \textcolor{keyword}{override};}
\DoxyCodeLine{8098         \textcolor{keywordtype}{void} handleNonExpr}
\DoxyCodeLine{8099                 (   AssertionInfo \textcolor{keyword}{const} \&info,}
\DoxyCodeLine{8100                     ResultWas::OfType resultType,}
\DoxyCodeLine{8101                     AssertionReaction \&reaction ) \textcolor{keyword}{override};}
\DoxyCodeLine{8102 }
\DoxyCodeLine{8103         \textcolor{keywordtype}{bool} sectionStarted( SectionInfo \textcolor{keyword}{const}\& sectionInfo, Counts\& assertions ) \textcolor{keyword}{override};}
\DoxyCodeLine{8104 }
\DoxyCodeLine{8105         \textcolor{keywordtype}{void} sectionEnded( SectionEndInfo \textcolor{keyword}{const}\& endInfo ) \textcolor{keyword}{override};}
\DoxyCodeLine{8106         \textcolor{keywordtype}{void} sectionEndedEarly( SectionEndInfo \textcolor{keyword}{const}\& endInfo ) \textcolor{keyword}{override};}
\DoxyCodeLine{8107 }
\DoxyCodeLine{8108         \textcolor{keyword}{auto} acquireGeneratorTracker( StringRef generatorName, SourceLineInfo \textcolor{keyword}{const}\& lineInfo ) -\/> IGeneratorTracker\& \textcolor{keyword}{override};}
\DoxyCodeLine{8109 }
\DoxyCodeLine{8110 \textcolor{preprocessor}{\#if defined(CATCH\_CONFIG\_ENABLE\_BENCHMARKING)}}
\DoxyCodeLine{8111         \textcolor{keywordtype}{void} benchmarkPreparing( std::string \textcolor{keyword}{const}\& name ) \textcolor{keyword}{override};}
\DoxyCodeLine{8112         \textcolor{keywordtype}{void} benchmarkStarting( BenchmarkInfo \textcolor{keyword}{const}\& info ) \textcolor{keyword}{override};}
\DoxyCodeLine{8113         \textcolor{keywordtype}{void} benchmarkEnded( BenchmarkStats<> \textcolor{keyword}{const}\& stats ) \textcolor{keyword}{override};}
\DoxyCodeLine{8114         \textcolor{keywordtype}{void} benchmarkFailed( std::string \textcolor{keyword}{const}\& error ) \textcolor{keyword}{override};}
\DoxyCodeLine{8115 \textcolor{preprocessor}{\#endif }\textcolor{comment}{// CATCH\_CONFIG\_ENABLE\_BENCHMARKING}}
\DoxyCodeLine{8116 }
\DoxyCodeLine{8117         \textcolor{keywordtype}{void} pushScopedMessage( MessageInfo \textcolor{keyword}{const}\& message ) \textcolor{keyword}{override};}
\DoxyCodeLine{8118         \textcolor{keywordtype}{void} popScopedMessage( MessageInfo \textcolor{keyword}{const}\& message ) \textcolor{keyword}{override};}
\DoxyCodeLine{8119 }
\DoxyCodeLine{8120         \textcolor{keywordtype}{void} emplaceUnscopedMessage( MessageBuilder \textcolor{keyword}{const}\& builder ) \textcolor{keyword}{override};}
\DoxyCodeLine{8121 }
\DoxyCodeLine{8122         std::string getCurrentTestName() \textcolor{keyword}{const override};}
\DoxyCodeLine{8123 }
\DoxyCodeLine{8124         \textcolor{keyword}{const} AssertionResult* getLastResult() \textcolor{keyword}{const override};}
\DoxyCodeLine{8125 }
\DoxyCodeLine{8126         \textcolor{keywordtype}{void} exceptionEarlyReported() \textcolor{keyword}{override};}
\DoxyCodeLine{8127 }
\DoxyCodeLine{8128         \textcolor{keywordtype}{void} handleFatalErrorCondition( StringRef message ) \textcolor{keyword}{override};}
\DoxyCodeLine{8129 }
\DoxyCodeLine{8130         \textcolor{keywordtype}{bool} lastAssertionPassed() \textcolor{keyword}{override};}
\DoxyCodeLine{8131 }
\DoxyCodeLine{8132         \textcolor{keywordtype}{void} assertionPassed() \textcolor{keyword}{override};}
\DoxyCodeLine{8133 }
\DoxyCodeLine{8134     \textcolor{keyword}{public}:}
\DoxyCodeLine{8135         \textcolor{comment}{// !TBD We need to do this another way!}}
\DoxyCodeLine{8136         \textcolor{keywordtype}{bool} aborting() const final;}
\DoxyCodeLine{8137 }
\DoxyCodeLine{8138     private:}
\DoxyCodeLine{8139 }
\DoxyCodeLine{8140         \textcolor{keywordtype}{void} runCurrentTest( std::\textcolor{keywordtype}{string}\& redirectedCout, std::\textcolor{keywordtype}{string}\& redirectedCerr );}
\DoxyCodeLine{8141         \textcolor{keywordtype}{void} invokeActiveTestCase();}
\DoxyCodeLine{8142 }
\DoxyCodeLine{8143         \textcolor{keywordtype}{void} resetAssertionInfo();}
\DoxyCodeLine{8144         \textcolor{keywordtype}{bool} testForMissingAssertions( Counts\& assertions );}
\DoxyCodeLine{8145 }
\DoxyCodeLine{8146         \textcolor{keywordtype}{void} assertionEnded( AssertionResult const\& result );}
\DoxyCodeLine{8147         \textcolor{keywordtype}{void} reportExpr}
\DoxyCodeLine{8148                 (   AssertionInfo const \&info,}
\DoxyCodeLine{8149                     ResultWas::OfType resultType,}
\DoxyCodeLine{8150                     ITransientExpression const *expr,}
\DoxyCodeLine{8151                     \textcolor{keywordtype}{bool} negated );}
\DoxyCodeLine{8152 }
\DoxyCodeLine{8153         \textcolor{keywordtype}{void} populateReaction( AssertionReaction\& reaction );}
\DoxyCodeLine{8154 }
\DoxyCodeLine{8155     private:}
\DoxyCodeLine{8156 }
\DoxyCodeLine{8157         \textcolor{keywordtype}{void} handleUnfinishedSections();}
\DoxyCodeLine{8158 }
\DoxyCodeLine{8159         TestRunInfo m\_runInfo;}
\DoxyCodeLine{8160         IMutableContext\& m\_context;}
\DoxyCodeLine{8161         TestCase const* m\_activeTestCase = \textcolor{keywordtype}{nullptr};}
\DoxyCodeLine{8162         ITracker* m\_testCaseTracker = \textcolor{keywordtype}{nullptr};}
\DoxyCodeLine{8163         Option<AssertionResult> m\_lastResult;}
\DoxyCodeLine{8164 }
\DoxyCodeLine{8165         IConfigPtr m\_config;}
\DoxyCodeLine{8166         Totals m\_totals;}
\DoxyCodeLine{8167         IStreamingReporterPtr m\_reporter;}
\DoxyCodeLine{8168         std::vector<MessageInfo> m\_messages;}
\DoxyCodeLine{8169         std::vector<ScopedMessage> m\_messageScopes; \textcolor{comment}{/* Keeps owners of so-\/called unscoped messages. */}}
\DoxyCodeLine{8170         AssertionInfo m\_lastAssertionInfo;}
\DoxyCodeLine{8171         std::vector<SectionEndInfo> m\_unfinishedSections;}
\DoxyCodeLine{8172         std::vector<ITracker*> m\_activeSections;}
\DoxyCodeLine{8173         TrackerContext m\_trackerContext;}
\DoxyCodeLine{8174         FatalConditionHandler m\_fatalConditionhandler;}
\DoxyCodeLine{8175         \textcolor{keywordtype}{bool} m\_lastAssertionPassed = false;}
\DoxyCodeLine{8176         \textcolor{keywordtype}{bool} m\_shouldReportUnexpected = true;}
\DoxyCodeLine{8177         \textcolor{keywordtype}{bool} m\_includeSuccessfulResults;}
\DoxyCodeLine{8178     \};}
\DoxyCodeLine{8179 }
\DoxyCodeLine{8180     \textcolor{keywordtype}{void} seedRng(IConfig const\& config);}
\DoxyCodeLine{8181     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} rngSeed();}
\DoxyCodeLine{8182 \} \textcolor{comment}{// end namespace Catch}}
\DoxyCodeLine{8183 }
\DoxyCodeLine{8184 \textcolor{comment}{// end catch\_run\_context.h}}
\DoxyCodeLine{8185 namespace Catch \{}
\DoxyCodeLine{8186 }
\DoxyCodeLine{8187     \textcolor{keyword}{namespace }\{}
\DoxyCodeLine{8188         \textcolor{keyword}{auto} operator <<( std::ostream\& os, ITransientExpression \textcolor{keyword}{const}\& expr ) -\/> std::ostream\& \{}
\DoxyCodeLine{8189             expr.streamReconstructedExpression( os );}
\DoxyCodeLine{8190             \textcolor{keywordflow}{return} os;}
\DoxyCodeLine{8191         \}}
\DoxyCodeLine{8192     \}}
\DoxyCodeLine{8193 }
\DoxyCodeLine{8194     LazyExpression::LazyExpression( \textcolor{keywordtype}{bool} isNegated )}
\DoxyCodeLine{8195     :   m\_isNegated( isNegated )}
\DoxyCodeLine{8196     \{\}}
\DoxyCodeLine{8197 }
\DoxyCodeLine{8198     LazyExpression::LazyExpression( LazyExpression \textcolor{keyword}{const}\& other ) : m\_isNegated( other.m\_isNegated ) \{\}}
\DoxyCodeLine{8199 }
\DoxyCodeLine{8200     LazyExpression::operator bool()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{8201         \textcolor{keywordflow}{return} m\_transientExpression != \textcolor{keyword}{nullptr};}
\DoxyCodeLine{8202     \}}
\DoxyCodeLine{8203 }
\DoxyCodeLine{8204     \textcolor{keyword}{auto} operator << ( std::ostream\& os, LazyExpression \textcolor{keyword}{const}\& lazyExpr ) -\/> std::ostream\& \{}
\DoxyCodeLine{8205         \textcolor{keywordflow}{if}( lazyExpr.m\_isNegated )}
\DoxyCodeLine{8206             os << \textcolor{stringliteral}{"{}!"{}};}
\DoxyCodeLine{8207 }
\DoxyCodeLine{8208         \textcolor{keywordflow}{if}( lazyExpr ) \{}
\DoxyCodeLine{8209             \textcolor{keywordflow}{if}( lazyExpr.m\_isNegated \&\& lazyExpr.m\_transientExpression-\/>isBinaryExpression() )}
\DoxyCodeLine{8210                 os << \textcolor{stringliteral}{"{}("{}} << *lazyExpr.m\_transientExpression << \textcolor{stringliteral}{"{})"{}};}
\DoxyCodeLine{8211             \textcolor{keywordflow}{else}}
\DoxyCodeLine{8212                 os << *lazyExpr.m\_transientExpression;}
\DoxyCodeLine{8213         \}}
\DoxyCodeLine{8214         \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{8215             os << \textcolor{stringliteral}{"{}\{** error -\/ unchecked empty expression requested **\}"{}};}
\DoxyCodeLine{8216         \}}
\DoxyCodeLine{8217         \textcolor{keywordflow}{return} os;}
\DoxyCodeLine{8218     \}}
\DoxyCodeLine{8219 }
\DoxyCodeLine{8220     AssertionHandler::AssertionHandler}
\DoxyCodeLine{8221         (   StringRef \textcolor{keyword}{const}\& macroName,}
\DoxyCodeLine{8222             SourceLineInfo \textcolor{keyword}{const}\& lineInfo,}
\DoxyCodeLine{8223             StringRef capturedExpression,}
\DoxyCodeLine{8224             ResultDisposition::Flags resultDisposition )}
\DoxyCodeLine{8225     :   m\_assertionInfo\{ macroName, lineInfo, capturedExpression, resultDisposition \},}
\DoxyCodeLine{8226         m\_resultCapture( getResultCapture() )}
\DoxyCodeLine{8227     \{\}}
\DoxyCodeLine{8228 }
\DoxyCodeLine{8229     \textcolor{keywordtype}{void} AssertionHandler::handleExpr( ITransientExpression \textcolor{keyword}{const}\& expr ) \{}
\DoxyCodeLine{8230         m\_resultCapture.handleExpr( m\_assertionInfo, expr, m\_reaction );}
\DoxyCodeLine{8231     \}}
\DoxyCodeLine{8232     \textcolor{keywordtype}{void} AssertionHandler::handleMessage(ResultWas::OfType resultType, StringRef \textcolor{keyword}{const}\& message) \{}
\DoxyCodeLine{8233         m\_resultCapture.handleMessage( m\_assertionInfo, resultType, message, m\_reaction );}
\DoxyCodeLine{8234     \}}
\DoxyCodeLine{8235 }
\DoxyCodeLine{8236     \textcolor{keyword}{auto} AssertionHandler::allowThrows() const -\/> \textcolor{keywordtype}{bool} \{}
\DoxyCodeLine{8237         \textcolor{keywordflow}{return} getCurrentContext().getConfig()-\/>allowThrows();}
\DoxyCodeLine{8238     \}}
\DoxyCodeLine{8239 }
\DoxyCodeLine{8240     \textcolor{keywordtype}{void} AssertionHandler::complete() \{}
\DoxyCodeLine{8241         setCompleted();}
\DoxyCodeLine{8242         \textcolor{keywordflow}{if}( m\_reaction.shouldDebugBreak ) \{}
\DoxyCodeLine{8243 }
\DoxyCodeLine{8244             \textcolor{comment}{// If you find your debugger stopping you here then go one level up on the}}
\DoxyCodeLine{8245             \textcolor{comment}{// call-\/stack for the code that caused it (typically a failed assertion)}}
\DoxyCodeLine{8246 }
\DoxyCodeLine{8247             \textcolor{comment}{// (To go back to the test and change execution, jump over the throw, next)}}
\DoxyCodeLine{8248             CATCH\_BREAK\_INTO\_DEBUGGER();}
\DoxyCodeLine{8249         \}}
\DoxyCodeLine{8250         \textcolor{keywordflow}{if} (m\_reaction.shouldThrow) \{}
\DoxyCodeLine{8251 \textcolor{preprocessor}{\#if !defined(CATCH\_CONFIG\_DISABLE\_EXCEPTIONS)}}
\DoxyCodeLine{8252             \textcolor{keywordflow}{throw} \mbox{\hyperlink{structCatch_1_1TestFailureException}{Catch::TestFailureException}}();}
\DoxyCodeLine{8253 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{8254             CATCH\_ERROR( \textcolor{stringliteral}{"{}Test failure requires aborting test!"{}} );}
\DoxyCodeLine{8255 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{8256         \}}
\DoxyCodeLine{8257     \}}
\DoxyCodeLine{8258     \textcolor{keywordtype}{void} AssertionHandler::setCompleted() \{}
\DoxyCodeLine{8259         m\_completed = \textcolor{keyword}{true};}
\DoxyCodeLine{8260     \}}
\DoxyCodeLine{8261 }
\DoxyCodeLine{8262     \textcolor{keywordtype}{void} AssertionHandler::handleUnexpectedInflightException() \{}
\DoxyCodeLine{8263         m\_resultCapture.handleUnexpectedInflightException( m\_assertionInfo, Catch::translateActiveException(), m\_reaction );}
\DoxyCodeLine{8264     \}}
\DoxyCodeLine{8265 }
\DoxyCodeLine{8266     \textcolor{keywordtype}{void} AssertionHandler::handleExceptionThrownAsExpected() \{}
\DoxyCodeLine{8267         m\_resultCapture.handleNonExpr(m\_assertionInfo, ResultWas::Ok, m\_reaction);}
\DoxyCodeLine{8268     \}}
\DoxyCodeLine{8269     \textcolor{keywordtype}{void} AssertionHandler::handleExceptionNotThrownAsExpected() \{}
\DoxyCodeLine{8270         m\_resultCapture.handleNonExpr(m\_assertionInfo, ResultWas::Ok, m\_reaction);}
\DoxyCodeLine{8271     \}}
\DoxyCodeLine{8272 }
\DoxyCodeLine{8273     \textcolor{keywordtype}{void} AssertionHandler::handleUnexpectedExceptionNotThrown() \{}
\DoxyCodeLine{8274         m\_resultCapture.handleUnexpectedExceptionNotThrown( m\_assertionInfo, m\_reaction );}
\DoxyCodeLine{8275     \}}
\DoxyCodeLine{8276 }
\DoxyCodeLine{8277     \textcolor{keywordtype}{void} AssertionHandler::handleThrowingCallSkipped() \{}
\DoxyCodeLine{8278         m\_resultCapture.handleNonExpr(m\_assertionInfo, ResultWas::Ok, m\_reaction);}
\DoxyCodeLine{8279     \}}
\DoxyCodeLine{8280 }
\DoxyCodeLine{8281     \textcolor{comment}{// This is the overload that takes a string and infers the Equals matcher from it}}
\DoxyCodeLine{8282     \textcolor{comment}{// The more general overload, that takes any string matcher, is in catch\_capture\_matchers.cpp}}
\DoxyCodeLine{8283     \textcolor{keywordtype}{void} handleExceptionMatchExpr( AssertionHandler\& handler, std::string \textcolor{keyword}{const}\& str, StringRef \textcolor{keyword}{const}\& matcherString  ) \{}
\DoxyCodeLine{8284         handleExceptionMatchExpr( handler, Matchers::Equals( str ), matcherString );}
\DoxyCodeLine{8285     \}}
\DoxyCodeLine{8286 }
\DoxyCodeLine{8287 \} \textcolor{comment}{// namespace Catch}}
\DoxyCodeLine{8288 \textcolor{comment}{// end catch\_assertionhandler.cpp}}
\DoxyCodeLine{8289 \textcolor{comment}{// start catch\_assertionresult.cpp}}
\DoxyCodeLine{8290 }
\DoxyCodeLine{8291 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{8292     AssertionResultData::AssertionResultData(ResultWas::OfType \_resultType, LazyExpression \textcolor{keyword}{const} \& \_lazyExpression):}
\DoxyCodeLine{8293         lazyExpression(\_lazyExpression),}
\DoxyCodeLine{8294         resultType(\_resultType) \{\}}
\DoxyCodeLine{8295 }
\DoxyCodeLine{8296     std::string AssertionResultData::reconstructExpression()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{8297 }
\DoxyCodeLine{8298         \textcolor{keywordflow}{if}( reconstructedExpression.empty() ) \{}
\DoxyCodeLine{8299             \textcolor{keywordflow}{if}( lazyExpression ) \{}
\DoxyCodeLine{8300                 ReusableStringStream rss;}
\DoxyCodeLine{8301                 rss << lazyExpression;}
\DoxyCodeLine{8302                 reconstructedExpression = rss.str();}
\DoxyCodeLine{8303             \}}
\DoxyCodeLine{8304         \}}
\DoxyCodeLine{8305         \textcolor{keywordflow}{return} reconstructedExpression;}
\DoxyCodeLine{8306     \}}
\DoxyCodeLine{8307 }
\DoxyCodeLine{8308     AssertionResult::AssertionResult( AssertionInfo \textcolor{keyword}{const}\& info, AssertionResultData \textcolor{keyword}{const}\& data )}
\DoxyCodeLine{8309     :   m\_info( info ),}
\DoxyCodeLine{8310         m\_resultData( data )}
\DoxyCodeLine{8311     \{\}}
\DoxyCodeLine{8312 }
\DoxyCodeLine{8313     \textcolor{comment}{// Result was a success}}
\DoxyCodeLine{8314     \textcolor{keywordtype}{bool} AssertionResult::succeeded()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{8315         \textcolor{keywordflow}{return} Catch::isOk( m\_resultData.resultType );}
\DoxyCodeLine{8316     \}}
\DoxyCodeLine{8317 }
\DoxyCodeLine{8318     \textcolor{comment}{// Result was a success, or failure is suppressed}}
\DoxyCodeLine{8319     \textcolor{keywordtype}{bool} AssertionResult::isOk()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{8320         \textcolor{keywordflow}{return} Catch::isOk( m\_resultData.resultType ) || shouldSuppressFailure( m\_info.resultDisposition );}
\DoxyCodeLine{8321     \}}
\DoxyCodeLine{8322 }
\DoxyCodeLine{8323     ResultWas::OfType AssertionResult::getResultType()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{8324         \textcolor{keywordflow}{return} m\_resultData.resultType;}
\DoxyCodeLine{8325     \}}
\DoxyCodeLine{8326 }
\DoxyCodeLine{8327     \textcolor{keywordtype}{bool} AssertionResult::hasExpression()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{8328         \textcolor{keywordflow}{return} !m\_info.capturedExpression.empty();}
\DoxyCodeLine{8329     \}}
\DoxyCodeLine{8330 }
\DoxyCodeLine{8331     \textcolor{keywordtype}{bool} AssertionResult::hasMessage()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{8332         \textcolor{keywordflow}{return} !m\_resultData.message.empty();}
\DoxyCodeLine{8333     \}}
\DoxyCodeLine{8334 }
\DoxyCodeLine{8335     std::string AssertionResult::getExpression()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{8336         \textcolor{comment}{// Possibly overallocating by 3 characters should be basically free}}
\DoxyCodeLine{8337         std::string expr; expr.reserve(m\_info.capturedExpression.size() + 3);}
\DoxyCodeLine{8338         \textcolor{keywordflow}{if} (isFalseTest(m\_info.resultDisposition)) \{}
\DoxyCodeLine{8339             expr += "{}!("{};}
\DoxyCodeLine{8340         \}}
\DoxyCodeLine{8341         expr += m\_info.capturedExpression;}
\DoxyCodeLine{8342         \textcolor{keywordflow}{if} (isFalseTest(m\_info.resultDisposition)) \{}
\DoxyCodeLine{8343             expr += ')';}
\DoxyCodeLine{8344         \}}
\DoxyCodeLine{8345         \textcolor{keywordflow}{return} expr;}
\DoxyCodeLine{8346     \}}
\DoxyCodeLine{8347 }
\DoxyCodeLine{8348     std::string AssertionResult::getExpressionInMacro()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{8349         std::string expr;}
\DoxyCodeLine{8350         \textcolor{keywordflow}{if}( m\_info.macroName.empty() )}
\DoxyCodeLine{8351             expr = \textcolor{keyword}{static\_cast<}std::string\textcolor{keyword}{>}(m\_info.capturedExpression);}
\DoxyCodeLine{8352         \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{8353             expr.reserve( m\_info.macroName.size() + m\_info.capturedExpression.size() + 4 );}
\DoxyCodeLine{8354             expr += m\_info.macroName;}
\DoxyCodeLine{8355             expr += "{}( "{};}
\DoxyCodeLine{8356             expr += m\_info.capturedExpression;}
\DoxyCodeLine{8357             expr += "{} )"{};}
\DoxyCodeLine{8358         \}}
\DoxyCodeLine{8359         \textcolor{keywordflow}{return} expr;}
\DoxyCodeLine{8360     \}}
\DoxyCodeLine{8361 }
\DoxyCodeLine{8362     \textcolor{keywordtype}{bool} AssertionResult::hasExpandedExpression()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{8363         \textcolor{keywordflow}{return} hasExpression() \&\& getExpandedExpression() != getExpression();}
\DoxyCodeLine{8364     \}}
\DoxyCodeLine{8365 }
\DoxyCodeLine{8366     std::string AssertionResult::getExpandedExpression()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{8367         std::string expr = m\_resultData.reconstructExpression();}
\DoxyCodeLine{8368         \textcolor{keywordflow}{return} expr.empty()}
\DoxyCodeLine{8369                 ? getExpression()}
\DoxyCodeLine{8370                 : expr;}
\DoxyCodeLine{8371     \}}
\DoxyCodeLine{8372 }
\DoxyCodeLine{8373     std::string AssertionResult::getMessage()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{8374         \textcolor{keywordflow}{return} m\_resultData.message;}
\DoxyCodeLine{8375     \}}
\DoxyCodeLine{8376     SourceLineInfo AssertionResult::getSourceInfo()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{8377         \textcolor{keywordflow}{return} m\_info.lineInfo;}
\DoxyCodeLine{8378     \}}
\DoxyCodeLine{8379 }
\DoxyCodeLine{8380     StringRef AssertionResult::getTestMacroName()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{8381         \textcolor{keywordflow}{return} m\_info.macroName;}
\DoxyCodeLine{8382     \}}
\DoxyCodeLine{8383 }
\DoxyCodeLine{8384 \} \textcolor{comment}{// end namespace Catch}}
\DoxyCodeLine{8385 \textcolor{comment}{// end catch\_assertionresult.cpp}}
\DoxyCodeLine{8386 \textcolor{comment}{// start catch\_capture\_matchers.cpp}}
\DoxyCodeLine{8387 }
\DoxyCodeLine{8388 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{8389 }
\DoxyCodeLine{8390     \textcolor{keyword}{using }StringMatcher = Matchers::Impl::MatcherBase<std::string>;}
\DoxyCodeLine{8391 }
\DoxyCodeLine{8392     \textcolor{comment}{// This is the general overload that takes a any string matcher}}
\DoxyCodeLine{8393     \textcolor{comment}{// There is another overload, in catch\_assertionhandler.h/.cpp, that only takes a string and infers}}
\DoxyCodeLine{8394     \textcolor{comment}{// the Equals matcher (so the header does not mention matchers)}}
\DoxyCodeLine{8395     \textcolor{keywordtype}{void} handleExceptionMatchExpr( AssertionHandler\& handler, StringMatcher \textcolor{keyword}{const}\& matcher, StringRef \textcolor{keyword}{const}\& matcherString  ) \{}
\DoxyCodeLine{8396         std::string exceptionMessage = Catch::translateActiveException();}
\DoxyCodeLine{8397         MatchExpr<std::string, StringMatcher const\&> expr( exceptionMessage, matcher, matcherString );}
\DoxyCodeLine{8398         handler.handleExpr( expr );}
\DoxyCodeLine{8399     \}}
\DoxyCodeLine{8400 }
\DoxyCodeLine{8401 \} \textcolor{comment}{// namespace Catch}}
\DoxyCodeLine{8402 \textcolor{comment}{// end catch\_capture\_matchers.cpp}}
\DoxyCodeLine{8403 \textcolor{comment}{// start catch\_commandline.cpp}}
\DoxyCodeLine{8404 }
\DoxyCodeLine{8405 \textcolor{comment}{// start catch\_commandline.h}}
\DoxyCodeLine{8406 }
\DoxyCodeLine{8407 \textcolor{comment}{// start catch\_clara.h}}
\DoxyCodeLine{8408 }
\DoxyCodeLine{8409 \textcolor{comment}{// Use Catch's value for console width (store Clara's off to the side, if present)}}
\DoxyCodeLine{8410 \textcolor{preprocessor}{\#ifdef CLARA\_CONFIG\_CONSOLE\_WIDTH}}
\DoxyCodeLine{8411 \textcolor{preprocessor}{\#define CATCH\_TEMP\_CLARA\_CONFIG\_CONSOLE\_WIDTH CATCH\_CLARA\_TEXTFLOW\_CONFIG\_CONSOLE\_WIDTH}}
\DoxyCodeLine{8412 \textcolor{preprocessor}{\#undef CATCH\_CLARA\_TEXTFLOW\_CONFIG\_CONSOLE\_WIDTH}}
\DoxyCodeLine{8413 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{8414 \textcolor{preprocessor}{\#define CATCH\_CLARA\_TEXTFLOW\_CONFIG\_CONSOLE\_WIDTH CATCH\_CONFIG\_CONSOLE\_WIDTH-\/1}}
\DoxyCodeLine{8415 }
\DoxyCodeLine{8416 \textcolor{preprocessor}{\#ifdef \_\_clang\_\_}}
\DoxyCodeLine{8417 \textcolor{preprocessor}{\#pragma clang diagnostic push}}
\DoxyCodeLine{8418 \textcolor{preprocessor}{\#pragma clang diagnostic ignored "{}-\/Wweak-\/vtables"{}}}
\DoxyCodeLine{8419 \textcolor{preprocessor}{\#pragma clang diagnostic ignored "{}-\/Wexit-\/time-\/destructors"{}}}
\DoxyCodeLine{8420 \textcolor{preprocessor}{\#pragma clang diagnostic ignored "{}-\/Wshadow"{}}}
\DoxyCodeLine{8421 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{8422 }
\DoxyCodeLine{8423 \textcolor{comment}{// start clara.hpp}}
\DoxyCodeLine{8424 \textcolor{comment}{// Copyright 2017 Two Blue Cubes Ltd. All rights reserved.}}
\DoxyCodeLine{8425 \textcolor{comment}{//}}
\DoxyCodeLine{8426 \textcolor{comment}{// Distributed under the Boost Software License, Version 1.0. (See accompanying}}
\DoxyCodeLine{8427 \textcolor{comment}{// file LICENSE\_1\_0.txt or copy at http://www.boost.org/LICENSE\_1\_0.txt)}}
\DoxyCodeLine{8428 \textcolor{comment}{//}}
\DoxyCodeLine{8429 \textcolor{comment}{// See https://github.com/philsquared/Clara for more details}}
\DoxyCodeLine{8430 }
\DoxyCodeLine{8431 \textcolor{comment}{// Clara v1.1.5}}
\DoxyCodeLine{8432 }
\DoxyCodeLine{8433 }
\DoxyCodeLine{8434 \textcolor{preprocessor}{\#ifndef CATCH\_CLARA\_CONFIG\_CONSOLE\_WIDTH}}
\DoxyCodeLine{8435 \textcolor{preprocessor}{\#define CATCH\_CLARA\_CONFIG\_CONSOLE\_WIDTH 80}}
\DoxyCodeLine{8436 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{8437 }
\DoxyCodeLine{8438 \textcolor{preprocessor}{\#ifndef CATCH\_CLARA\_TEXTFLOW\_CONFIG\_CONSOLE\_WIDTH}}
\DoxyCodeLine{8439 \textcolor{preprocessor}{\#define CATCH\_CLARA\_TEXTFLOW\_CONFIG\_CONSOLE\_WIDTH CATCH\_CLARA\_CONFIG\_CONSOLE\_WIDTH}}
\DoxyCodeLine{8440 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{8441 }
\DoxyCodeLine{8442 \textcolor{preprocessor}{\#ifndef CLARA\_CONFIG\_OPTIONAL\_TYPE}}
\DoxyCodeLine{8443 \textcolor{preprocessor}{\#ifdef \_\_has\_include}}
\DoxyCodeLine{8444 \textcolor{preprocessor}{\#if \_\_has\_include(<optional>) \&\& \_\_cplusplus >= 201703L}}
\DoxyCodeLine{8445 \textcolor{preprocessor}{\#include <optional>}}
\DoxyCodeLine{8446 \textcolor{preprocessor}{\#define CLARA\_CONFIG\_OPTIONAL\_TYPE std::optional}}
\DoxyCodeLine{8447 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{8448 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{8449 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{8450 }
\DoxyCodeLine{8451 \textcolor{comment}{// -\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/ \#included from clara\_textflow.hpp -\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/}}
\DoxyCodeLine{8452 }
\DoxyCodeLine{8453 \textcolor{comment}{// TextFlowCpp}}
\DoxyCodeLine{8454 \textcolor{comment}{//}}
\DoxyCodeLine{8455 \textcolor{comment}{// A single-\/header library for wrapping and laying out basic text, by Phil Nash}}
\DoxyCodeLine{8456 \textcolor{comment}{//}}
\DoxyCodeLine{8457 \textcolor{comment}{// Distributed under the Boost Software License, Version 1.0. (See accompanying}}
\DoxyCodeLine{8458 \textcolor{comment}{// file LICENSE.txt or copy at http://www.boost.org/LICENSE\_1\_0.txt)}}
\DoxyCodeLine{8459 \textcolor{comment}{//}}
\DoxyCodeLine{8460 \textcolor{comment}{// This project is hosted at https://github.com/philsquared/textflowcpp}}
\DoxyCodeLine{8461 }
\DoxyCodeLine{8462 }
\DoxyCodeLine{8463 \textcolor{preprocessor}{\#include <cassert>}}
\DoxyCodeLine{8464 \textcolor{preprocessor}{\#include <ostream>}}
\DoxyCodeLine{8465 \textcolor{preprocessor}{\#include <sstream>}}
\DoxyCodeLine{8466 \textcolor{preprocessor}{\#include <vector>}}
\DoxyCodeLine{8467 }
\DoxyCodeLine{8468 \textcolor{preprocessor}{\#ifndef CATCH\_CLARA\_TEXTFLOW\_CONFIG\_CONSOLE\_WIDTH}}
\DoxyCodeLine{8469 \textcolor{preprocessor}{\#define CATCH\_CLARA\_TEXTFLOW\_CONFIG\_CONSOLE\_WIDTH 80}}
\DoxyCodeLine{8470 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{8471 }
\DoxyCodeLine{8472 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{8473 \textcolor{keyword}{namespace }clara \{}
\DoxyCodeLine{8474 \textcolor{keyword}{namespace }TextFlow \{}
\DoxyCodeLine{8475 }
\DoxyCodeLine{8476 \textcolor{keyword}{inline} \textcolor{keyword}{auto} isWhitespace(\textcolor{keywordtype}{char} c) -\/> \textcolor{keywordtype}{bool} \{}
\DoxyCodeLine{8477     \textcolor{keyword}{static} std::string chars = \textcolor{stringliteral}{"{} \(\backslash\)t\(\backslash\)n\(\backslash\)r"{}};}
\DoxyCodeLine{8478     \textcolor{keywordflow}{return} chars.find(c) != std::string::npos;}
\DoxyCodeLine{8479 \}}
\DoxyCodeLine{8480 \textcolor{keyword}{inline} \textcolor{keyword}{auto} isBreakableBefore(\textcolor{keywordtype}{char} c) -\/> \textcolor{keywordtype}{bool} \{}
\DoxyCodeLine{8481     \textcolor{keyword}{static} std::string chars = \textcolor{stringliteral}{"{}[(\{<|"{}};}
\DoxyCodeLine{8482     \textcolor{keywordflow}{return} chars.find(c) != std::string::npos;}
\DoxyCodeLine{8483 \}}
\DoxyCodeLine{8484 \textcolor{keyword}{inline} \textcolor{keyword}{auto} isBreakableAfter(\textcolor{keywordtype}{char} c) -\/> \textcolor{keywordtype}{bool} \{}
\DoxyCodeLine{8485     \textcolor{keyword}{static} std::string chars = \textcolor{stringliteral}{"{}])\}>.,:;*+-\/=\&/\(\backslash\)\(\backslash\)"{}};}
\DoxyCodeLine{8486     \textcolor{keywordflow}{return} chars.find(c) != std::string::npos;}
\DoxyCodeLine{8487 \}}
\DoxyCodeLine{8488 }
\DoxyCodeLine{8489 \textcolor{keyword}{class }Columns;}
\DoxyCodeLine{8490 }
\DoxyCodeLine{8491 \textcolor{keyword}{class }Column \{}
\DoxyCodeLine{8492     std::vector<std::string> m\_strings;}
\DoxyCodeLine{8493     \textcolor{keywordtype}{size\_t} m\_width = CATCH\_CLARA\_TEXTFLOW\_CONFIG\_CONSOLE\_WIDTH;}
\DoxyCodeLine{8494     \textcolor{keywordtype}{size\_t} m\_indent = 0;}
\DoxyCodeLine{8495     \textcolor{keywordtype}{size\_t} m\_initialIndent = std::string::npos;}
\DoxyCodeLine{8496 }
\DoxyCodeLine{8497 \textcolor{keyword}{public}:}
\DoxyCodeLine{8498     \textcolor{keyword}{class }iterator \{}
\DoxyCodeLine{8499         \textcolor{keyword}{friend} Column;}
\DoxyCodeLine{8500 }
\DoxyCodeLine{8501         Column \textcolor{keyword}{const}\& m\_column;}
\DoxyCodeLine{8502         \textcolor{keywordtype}{size\_t} m\_stringIndex = 0;}
\DoxyCodeLine{8503         \textcolor{keywordtype}{size\_t} m\_pos = 0;}
\DoxyCodeLine{8504 }
\DoxyCodeLine{8505         \textcolor{keywordtype}{size\_t} m\_len = 0;}
\DoxyCodeLine{8506         \textcolor{keywordtype}{size\_t} m\_end = 0;}
\DoxyCodeLine{8507         \textcolor{keywordtype}{bool} m\_suffix = \textcolor{keyword}{false};}
\DoxyCodeLine{8508 }
\DoxyCodeLine{8509         iterator(Column \textcolor{keyword}{const}\& column, \textcolor{keywordtype}{size\_t} stringIndex)}
\DoxyCodeLine{8510             : m\_column(column),}
\DoxyCodeLine{8511             m\_stringIndex(stringIndex) \{\}}
\DoxyCodeLine{8512 }
\DoxyCodeLine{8513         \textcolor{keyword}{auto} line() const -\/> std::\textcolor{keywordtype}{string} const\& \{ \textcolor{keywordflow}{return} m\_column.m\_strings[m\_stringIndex]; \}}
\DoxyCodeLine{8514 }
\DoxyCodeLine{8515         \textcolor{keyword}{auto} isBoundary(\textcolor{keywordtype}{size\_t} at) \textcolor{keyword}{const} -\/> \textcolor{keywordtype}{bool} \{}
\DoxyCodeLine{8516             assert(at > 0);}
\DoxyCodeLine{8517             assert(at <= line().size());}
\DoxyCodeLine{8518 }
\DoxyCodeLine{8519             \textcolor{keywordflow}{return} at == line().size() ||}
\DoxyCodeLine{8520                 (isWhitespace(line()[at]) \&\& !isWhitespace(line()[at -\/ 1])) ||}
\DoxyCodeLine{8521                 isBreakableBefore(line()[at]) ||}
\DoxyCodeLine{8522                 isBreakableAfter(line()[at -\/ 1]);}
\DoxyCodeLine{8523         \}}
\DoxyCodeLine{8524 }
\DoxyCodeLine{8525         \textcolor{keywordtype}{void} calcLength() \{}
\DoxyCodeLine{8526             assert(m\_stringIndex < m\_column.m\_strings.size());}
\DoxyCodeLine{8527 }
\DoxyCodeLine{8528             m\_suffix = \textcolor{keyword}{false};}
\DoxyCodeLine{8529             \textcolor{keyword}{auto} width = m\_column.m\_width -\/ indent();}
\DoxyCodeLine{8530             m\_end = m\_pos;}
\DoxyCodeLine{8531             \textcolor{keywordflow}{if} (line()[m\_pos] == \textcolor{charliteral}{'\(\backslash\)n'}) \{}
\DoxyCodeLine{8532                 ++m\_end;}
\DoxyCodeLine{8533             \}}
\DoxyCodeLine{8534             \textcolor{keywordflow}{while} (m\_end < line().size() \&\& line()[m\_end] != \textcolor{charliteral}{'\(\backslash\)n'})}
\DoxyCodeLine{8535                 ++m\_end;}
\DoxyCodeLine{8536 }
\DoxyCodeLine{8537             \textcolor{keywordflow}{if} (m\_end < m\_pos + width) \{}
\DoxyCodeLine{8538                 m\_len = m\_end -\/ m\_pos;}
\DoxyCodeLine{8539             \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{8540                 \textcolor{keywordtype}{size\_t} len = width;}
\DoxyCodeLine{8541                 \textcolor{keywordflow}{while} (len > 0 \&\& !isBoundary(m\_pos + len))}
\DoxyCodeLine{8542                     -\/-\/len;}
\DoxyCodeLine{8543                 \textcolor{keywordflow}{while} (len > 0 \&\& isWhitespace(line()[m\_pos + len -\/ 1]))}
\DoxyCodeLine{8544                     -\/-\/len;}
\DoxyCodeLine{8545 }
\DoxyCodeLine{8546                 \textcolor{keywordflow}{if} (len > 0) \{}
\DoxyCodeLine{8547                     m\_len = len;}
\DoxyCodeLine{8548                 \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{8549                     m\_suffix = \textcolor{keyword}{true};}
\DoxyCodeLine{8550                     m\_len = width -\/ 1;}
\DoxyCodeLine{8551                 \}}
\DoxyCodeLine{8552             \}}
\DoxyCodeLine{8553         \}}
\DoxyCodeLine{8554 }
\DoxyCodeLine{8555         \textcolor{keyword}{auto} indent() const -\/> \textcolor{keywordtype}{size\_t} \{}
\DoxyCodeLine{8556             \textcolor{keyword}{auto} initial = m\_pos == 0 \&\& m\_stringIndex == 0 ? m\_column.m\_initialIndent : std::string::npos;}
\DoxyCodeLine{8557             \textcolor{keywordflow}{return} initial == std::string::npos ? m\_column.m\_indent : initial;}
\DoxyCodeLine{8558         \}}
\DoxyCodeLine{8559 }
\DoxyCodeLine{8560         \textcolor{keyword}{auto} addIndentAndSuffix(std::string \textcolor{keyword}{const} \&plain) \textcolor{keyword}{const} -\/> std::string \{}
\DoxyCodeLine{8561             \textcolor{keywordflow}{return} std::string(indent(), \textcolor{charliteral}{' '}) + (m\_suffix ? plain + "{}-\/"{} : plain);}
\DoxyCodeLine{8562         \}}
\DoxyCodeLine{8563 }
\DoxyCodeLine{8564     \textcolor{keyword}{public}:}
\DoxyCodeLine{8565         \textcolor{keyword}{using }difference\_type = std::ptrdiff\_t;}
\DoxyCodeLine{8566         \textcolor{keyword}{using }value\_type = std::string;}
\DoxyCodeLine{8567         \textcolor{keyword}{using }pointer = value\_type * ;}
\DoxyCodeLine{8568         \textcolor{keyword}{using }reference = value\_type \& ;}
\DoxyCodeLine{8569         \textcolor{keyword}{using }iterator\_category = std::forward\_iterator\_tag;}
\DoxyCodeLine{8570 }
\DoxyCodeLine{8571         \textcolor{keyword}{explicit} iterator(Column \textcolor{keyword}{const}\& column) : m\_column(column) \{}
\DoxyCodeLine{8572             assert(m\_column.m\_width > m\_column.m\_indent);}
\DoxyCodeLine{8573             assert(m\_column.m\_initialIndent == std::string::npos || m\_column.m\_width > m\_column.m\_initialIndent);}
\DoxyCodeLine{8574             calcLength();}
\DoxyCodeLine{8575             \textcolor{keywordflow}{if} (m\_len == 0)}
\DoxyCodeLine{8576                 m\_stringIndex++; \textcolor{comment}{// Empty string}}
\DoxyCodeLine{8577         \}}
\DoxyCodeLine{8578 }
\DoxyCodeLine{8579         \textcolor{keyword}{auto} operator *() const -\/> std::\textcolor{keywordtype}{string} \{}
\DoxyCodeLine{8580             assert(m\_stringIndex < m\_column.m\_strings.size());}
\DoxyCodeLine{8581             assert(m\_pos <= m\_end);}
\DoxyCodeLine{8582             \textcolor{keywordflow}{return} addIndentAndSuffix(line().substr(m\_pos, m\_len));}
\DoxyCodeLine{8583         \}}
\DoxyCodeLine{8584 }
\DoxyCodeLine{8585         \textcolor{keyword}{auto} operator ++() -\/> iterator\& \{}
\DoxyCodeLine{8586             m\_pos += m\_len;}
\DoxyCodeLine{8587             \textcolor{keywordflow}{if} (m\_pos < line().size() \&\& line()[m\_pos] == \textcolor{charliteral}{'\(\backslash\)n'})}
\DoxyCodeLine{8588                 m\_pos += 1;}
\DoxyCodeLine{8589             \textcolor{keywordflow}{else}}
\DoxyCodeLine{8590                 \textcolor{keywordflow}{while} (m\_pos < line().size() \&\& isWhitespace(line()[m\_pos]))}
\DoxyCodeLine{8591                     ++m\_pos;}
\DoxyCodeLine{8592 }
\DoxyCodeLine{8593             \textcolor{keywordflow}{if} (m\_pos == line().size()) \{}
\DoxyCodeLine{8594                 m\_pos = 0;}
\DoxyCodeLine{8595                 ++m\_stringIndex;}
\DoxyCodeLine{8596             \}}
\DoxyCodeLine{8597             \textcolor{keywordflow}{if} (m\_stringIndex < m\_column.m\_strings.size())}
\DoxyCodeLine{8598                 calcLength();}
\DoxyCodeLine{8599             \textcolor{keywordflow}{return} *\textcolor{keyword}{this};}
\DoxyCodeLine{8600         \}}
\DoxyCodeLine{8601         \textcolor{keyword}{auto} operator ++(\textcolor{keywordtype}{int}) -\/> iterator \{}
\DoxyCodeLine{8602             iterator prev(*\textcolor{keyword}{this});}
\DoxyCodeLine{8603             operator++();}
\DoxyCodeLine{8604             \textcolor{keywordflow}{return} prev;}
\DoxyCodeLine{8605         \}}
\DoxyCodeLine{8606 }
\DoxyCodeLine{8607         \textcolor{keyword}{auto} operator ==(iterator \textcolor{keyword}{const}\& other) \textcolor{keyword}{const} -\/> \textcolor{keywordtype}{bool} \{}
\DoxyCodeLine{8608             \textcolor{keywordflow}{return}}
\DoxyCodeLine{8609                 m\_pos == other.m\_pos \&\&}
\DoxyCodeLine{8610                 m\_stringIndex == other.m\_stringIndex \&\&}
\DoxyCodeLine{8611                 \&m\_column == \&other.m\_column;}
\DoxyCodeLine{8612         \}}
\DoxyCodeLine{8613         \textcolor{keyword}{auto} operator !=(iterator \textcolor{keyword}{const}\& other) \textcolor{keyword}{const} -\/> \textcolor{keywordtype}{bool} \{}
\DoxyCodeLine{8614             \textcolor{keywordflow}{return} !operator==(other);}
\DoxyCodeLine{8615         \}}
\DoxyCodeLine{8616     \};}
\DoxyCodeLine{8617     \textcolor{keyword}{using }const\_iterator = iterator;}
\DoxyCodeLine{8618 }
\DoxyCodeLine{8619     \textcolor{keyword}{explicit} Column(std::string \textcolor{keyword}{const}\& text) \{ m\_strings.push\_back(text); \}}
\DoxyCodeLine{8620 }
\DoxyCodeLine{8621     \textcolor{keyword}{auto} width(\textcolor{keywordtype}{size\_t} newWidth) -\/> Column\& \{}
\DoxyCodeLine{8622         assert(newWidth > 0);}
\DoxyCodeLine{8623         m\_width = newWidth;}
\DoxyCodeLine{8624         \textcolor{keywordflow}{return} *\textcolor{keyword}{this};}
\DoxyCodeLine{8625     \}}
\DoxyCodeLine{8626     \textcolor{keyword}{auto} indent(\textcolor{keywordtype}{size\_t} newIndent) -\/> Column\& \{}
\DoxyCodeLine{8627         m\_indent = newIndent;}
\DoxyCodeLine{8628         \textcolor{keywordflow}{return} *\textcolor{keyword}{this};}
\DoxyCodeLine{8629     \}}
\DoxyCodeLine{8630     \textcolor{keyword}{auto} initialIndent(\textcolor{keywordtype}{size\_t} newIndent) -\/> Column\& \{}
\DoxyCodeLine{8631         m\_initialIndent = newIndent;}
\DoxyCodeLine{8632         \textcolor{keywordflow}{return} *\textcolor{keyword}{this};}
\DoxyCodeLine{8633     \}}
\DoxyCodeLine{8634 }
\DoxyCodeLine{8635     \textcolor{keyword}{auto} width() const -\/> \textcolor{keywordtype}{size\_t} \{ \textcolor{keywordflow}{return} m\_width; \}}
\DoxyCodeLine{8636     \textcolor{keyword}{auto} begin() const -\/> iterator \{ \textcolor{keywordflow}{return} iterator(*\textcolor{keyword}{this}); \}}
\DoxyCodeLine{8637     \textcolor{keyword}{auto} end() const -\/> iterator \{ \textcolor{keywordflow}{return} \{ *\textcolor{keyword}{this}, m\_strings.size() \}; \}}
\DoxyCodeLine{8638 }
\DoxyCodeLine{8639     \textcolor{keyword}{inline} \textcolor{keyword}{friend} std::ostream\& operator << (std::ostream\& os, Column \textcolor{keyword}{const}\& col) \{}
\DoxyCodeLine{8640         \textcolor{keywordtype}{bool} first = \textcolor{keyword}{true};}
\DoxyCodeLine{8641         \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} line : col) \{}
\DoxyCodeLine{8642             \textcolor{keywordflow}{if} (first)}
\DoxyCodeLine{8643                 first = \textcolor{keyword}{false};}
\DoxyCodeLine{8644             \textcolor{keywordflow}{else}}
\DoxyCodeLine{8645                 os << \textcolor{stringliteral}{"{}\(\backslash\)n"{}};}
\DoxyCodeLine{8646             os << line;}
\DoxyCodeLine{8647         \}}
\DoxyCodeLine{8648         \textcolor{keywordflow}{return} os;}
\DoxyCodeLine{8649     \}}
\DoxyCodeLine{8650 }
\DoxyCodeLine{8651     \textcolor{keyword}{auto} operator + (Column \textcolor{keyword}{const}\& other)-\/>Columns;}
\DoxyCodeLine{8652 }
\DoxyCodeLine{8653     \textcolor{keyword}{auto} toString() const -\/> std::\textcolor{keywordtype}{string} \{}
\DoxyCodeLine{8654         std::ostringstream oss;}
\DoxyCodeLine{8655         oss << *\textcolor{keyword}{this};}
\DoxyCodeLine{8656         \textcolor{keywordflow}{return} oss.str();}
\DoxyCodeLine{8657     \}}
\DoxyCodeLine{8658 \};}
\DoxyCodeLine{8659 }
\DoxyCodeLine{8660 \textcolor{keyword}{class }Spacer : \textcolor{keyword}{public} Column \{}
\DoxyCodeLine{8661 }
\DoxyCodeLine{8662 \textcolor{keyword}{public}:}
\DoxyCodeLine{8663     \textcolor{keyword}{explicit} Spacer(\textcolor{keywordtype}{size\_t} spaceWidth) : Column(\textcolor{stringliteral}{"{}"{}}) \{}
\DoxyCodeLine{8664         width(spaceWidth);}
\DoxyCodeLine{8665     \}}
\DoxyCodeLine{8666 \};}
\DoxyCodeLine{8667 }
\DoxyCodeLine{8668 \textcolor{keyword}{class }Columns \{}
\DoxyCodeLine{8669     std::vector<Column> m\_columns;}
\DoxyCodeLine{8670 }
\DoxyCodeLine{8671 \textcolor{keyword}{public}:}
\DoxyCodeLine{8672 }
\DoxyCodeLine{8673     \textcolor{keyword}{class }iterator \{}
\DoxyCodeLine{8674         \textcolor{keyword}{friend} Columns;}
\DoxyCodeLine{8675         \textcolor{keyword}{struct }EndTag \{\};}
\DoxyCodeLine{8676 }
\DoxyCodeLine{8677         std::vector<Column> \textcolor{keyword}{const}\& m\_columns;}
\DoxyCodeLine{8678         std::vector<Column::iterator> m\_iterators;}
\DoxyCodeLine{8679         \textcolor{keywordtype}{size\_t} m\_activeIterators;}
\DoxyCodeLine{8680 }
\DoxyCodeLine{8681         iterator(Columns \textcolor{keyword}{const}\& columns, EndTag)}
\DoxyCodeLine{8682             : m\_columns(columns.m\_columns),}
\DoxyCodeLine{8683             m\_activeIterators(0) \{}
\DoxyCodeLine{8684             m\_iterators.reserve(m\_columns.size());}
\DoxyCodeLine{8685 }
\DoxyCodeLine{8686             \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} \textcolor{keyword}{const}\& col : m\_columns)}
\DoxyCodeLine{8687                 m\_iterators.push\_back(col.end());}
\DoxyCodeLine{8688         \}}
\DoxyCodeLine{8689 }
\DoxyCodeLine{8690     \textcolor{keyword}{public}:}
\DoxyCodeLine{8691         \textcolor{keyword}{using }difference\_type = std::ptrdiff\_t;}
\DoxyCodeLine{8692         \textcolor{keyword}{using }value\_type = std::string;}
\DoxyCodeLine{8693         \textcolor{keyword}{using }pointer = value\_type * ;}
\DoxyCodeLine{8694         \textcolor{keyword}{using }reference = value\_type \& ;}
\DoxyCodeLine{8695         \textcolor{keyword}{using }iterator\_category = std::forward\_iterator\_tag;}
\DoxyCodeLine{8696 }
\DoxyCodeLine{8697         \textcolor{keyword}{explicit} iterator(Columns \textcolor{keyword}{const}\& columns)}
\DoxyCodeLine{8698             : m\_columns(columns.m\_columns),}
\DoxyCodeLine{8699             m\_activeIterators(m\_columns.size()) \{}
\DoxyCodeLine{8700             m\_iterators.reserve(m\_columns.size());}
\DoxyCodeLine{8701 }
\DoxyCodeLine{8702             \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} \textcolor{keyword}{const}\& col : m\_columns)}
\DoxyCodeLine{8703                 m\_iterators.push\_back(col.begin());}
\DoxyCodeLine{8704         \}}
\DoxyCodeLine{8705 }
\DoxyCodeLine{8706         \textcolor{keyword}{auto} operator ==(iterator \textcolor{keyword}{const}\& other) \textcolor{keyword}{const} -\/> \textcolor{keywordtype}{bool} \{}
\DoxyCodeLine{8707             \textcolor{keywordflow}{return} m\_iterators == other.m\_iterators;}
\DoxyCodeLine{8708         \}}
\DoxyCodeLine{8709         \textcolor{keyword}{auto} operator !=(iterator \textcolor{keyword}{const}\& other) \textcolor{keyword}{const} -\/> \textcolor{keywordtype}{bool} \{}
\DoxyCodeLine{8710             \textcolor{keywordflow}{return} m\_iterators != other.m\_iterators;}
\DoxyCodeLine{8711         \}}
\DoxyCodeLine{8712         \textcolor{keyword}{auto} operator *() const -\/> std::\textcolor{keywordtype}{string} \{}
\DoxyCodeLine{8713             std::string row, padding;}
\DoxyCodeLine{8714 }
\DoxyCodeLine{8715             \textcolor{keywordflow}{for} (\textcolor{keywordtype}{size\_t} i = 0; i < m\_columns.size(); ++i) \{}
\DoxyCodeLine{8716                 \textcolor{keyword}{auto} width = m\_columns[i].width();}
\DoxyCodeLine{8717                 \textcolor{keywordflow}{if} (m\_iterators[i] != m\_columns[i].end()) \{}
\DoxyCodeLine{8718                     std::string col = *m\_iterators[i];}
\DoxyCodeLine{8719                     row += padding + col;}
\DoxyCodeLine{8720                     \textcolor{keywordflow}{if} (col.size() < width)}
\DoxyCodeLine{8721                         padding = std::string(width -\/ col.size(), \textcolor{charliteral}{' '});}
\DoxyCodeLine{8722                     \textcolor{keywordflow}{else}}
\DoxyCodeLine{8723                         padding = \textcolor{stringliteral}{"{}"{}};}
\DoxyCodeLine{8724                 \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{8725                     padding += std::string(width, ' ');}
\DoxyCodeLine{8726                 \}}
\DoxyCodeLine{8727             \}}
\DoxyCodeLine{8728             \textcolor{keywordflow}{return} row;}
\DoxyCodeLine{8729         \}}
\DoxyCodeLine{8730         \textcolor{keyword}{auto} operator ++() -\/> iterator\& \{}
\DoxyCodeLine{8731             \textcolor{keywordflow}{for} (\textcolor{keywordtype}{size\_t} i = 0; i < m\_columns.size(); ++i) \{}
\DoxyCodeLine{8732                 \textcolor{keywordflow}{if} (m\_iterators[i] != m\_columns[i].end())}
\DoxyCodeLine{8733                     ++m\_iterators[i];}
\DoxyCodeLine{8734             \}}
\DoxyCodeLine{8735             \textcolor{keywordflow}{return} *\textcolor{keyword}{this};}
\DoxyCodeLine{8736         \}}
\DoxyCodeLine{8737         \textcolor{keyword}{auto} operator ++(\textcolor{keywordtype}{int}) -\/> iterator \{}
\DoxyCodeLine{8738             iterator prev(*\textcolor{keyword}{this});}
\DoxyCodeLine{8739             operator++();}
\DoxyCodeLine{8740             \textcolor{keywordflow}{return} prev;}
\DoxyCodeLine{8741         \}}
\DoxyCodeLine{8742     \};}
\DoxyCodeLine{8743     \textcolor{keyword}{using }const\_iterator = iterator;}
\DoxyCodeLine{8744 }
\DoxyCodeLine{8745     \textcolor{keyword}{auto} begin() const -\/> iterator \{ \textcolor{keywordflow}{return} iterator(*\textcolor{keyword}{this}); \}}
\DoxyCodeLine{8746     \textcolor{keyword}{auto} end() const -\/> iterator \{ \textcolor{keywordflow}{return} \{ *\textcolor{keyword}{this}, iterator::EndTag() \}; \}}
\DoxyCodeLine{8747 }
\DoxyCodeLine{8748     \textcolor{keyword}{auto} operator += (Column \textcolor{keyword}{const}\& col) -\/> Columns\& \{}
\DoxyCodeLine{8749         m\_columns.push\_back(col);}
\DoxyCodeLine{8750         \textcolor{keywordflow}{return} *\textcolor{keyword}{this};}
\DoxyCodeLine{8751     \}}
\DoxyCodeLine{8752     \textcolor{keyword}{auto} operator + (Column \textcolor{keyword}{const}\& col) -\/> Columns \{}
\DoxyCodeLine{8753         Columns combined = *\textcolor{keyword}{this};}
\DoxyCodeLine{8754         combined += col;}
\DoxyCodeLine{8755         \textcolor{keywordflow}{return} combined;}
\DoxyCodeLine{8756     \}}
\DoxyCodeLine{8757 }
\DoxyCodeLine{8758     \textcolor{keyword}{inline} \textcolor{keyword}{friend} std::ostream\& operator << (std::ostream\& os, Columns \textcolor{keyword}{const}\& cols) \{}
\DoxyCodeLine{8759 }
\DoxyCodeLine{8760         \textcolor{keywordtype}{bool} first = \textcolor{keyword}{true};}
\DoxyCodeLine{8761         \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} line : cols) \{}
\DoxyCodeLine{8762             \textcolor{keywordflow}{if} (first)}
\DoxyCodeLine{8763                 first = \textcolor{keyword}{false};}
\DoxyCodeLine{8764             \textcolor{keywordflow}{else}}
\DoxyCodeLine{8765                 os << \textcolor{stringliteral}{"{}\(\backslash\)n"{}};}
\DoxyCodeLine{8766             os << line;}
\DoxyCodeLine{8767         \}}
\DoxyCodeLine{8768         \textcolor{keywordflow}{return} os;}
\DoxyCodeLine{8769     \}}
\DoxyCodeLine{8770 }
\DoxyCodeLine{8771     \textcolor{keyword}{auto} toString() const -\/> std::\textcolor{keywordtype}{string} \{}
\DoxyCodeLine{8772         std::ostringstream oss;}
\DoxyCodeLine{8773         oss << *\textcolor{keyword}{this};}
\DoxyCodeLine{8774         \textcolor{keywordflow}{return} oss.str();}
\DoxyCodeLine{8775     \}}
\DoxyCodeLine{8776 \};}
\DoxyCodeLine{8777 }
\DoxyCodeLine{8778 \textcolor{keyword}{inline} \textcolor{keyword}{auto} Column::operator + (Column \textcolor{keyword}{const}\& other) -\/> Columns \{}
\DoxyCodeLine{8779     Columns cols;}
\DoxyCodeLine{8780     cols += *this;}
\DoxyCodeLine{8781     cols += other;}
\DoxyCodeLine{8782     \textcolor{keywordflow}{return} cols;}
\DoxyCodeLine{8783 \}}
\DoxyCodeLine{8784 \}}
\DoxyCodeLine{8785 }
\DoxyCodeLine{8786 \}}
\DoxyCodeLine{8787 \}}
\DoxyCodeLine{8788 }
\DoxyCodeLine{8789 \textcolor{comment}{// -\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/ end of \#include from clara\_textflow.hpp -\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/}}
\DoxyCodeLine{8790 \textcolor{comment}{// ........... back in clara.hpp}}
\DoxyCodeLine{8791 }
\DoxyCodeLine{8792 \textcolor{preprocessor}{\#include <cctype>}}
\DoxyCodeLine{8793 \textcolor{preprocessor}{\#include <string>}}
\DoxyCodeLine{8794 \textcolor{preprocessor}{\#include <memory>}}
\DoxyCodeLine{8795 \textcolor{preprocessor}{\#include <set>}}
\DoxyCodeLine{8796 \textcolor{preprocessor}{\#include <algorithm>}}
\DoxyCodeLine{8797 }
\DoxyCodeLine{8798 \textcolor{preprocessor}{\#if !defined(CATCH\_PLATFORM\_WINDOWS) \&\& ( defined(WIN32) || defined(\_\_WIN32\_\_) || defined(\_WIN32) || defined(\_MSC\_VER) )}}
\DoxyCodeLine{8799 \textcolor{preprocessor}{\#define CATCH\_PLATFORM\_WINDOWS}}
\DoxyCodeLine{8800 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{8801 }
\DoxyCodeLine{8802 \textcolor{keyword}{namespace }Catch \{ \textcolor{keyword}{namespace }clara \{}
\DoxyCodeLine{8803 \textcolor{keyword}{namespace }detail \{}
\DoxyCodeLine{8804 }
\DoxyCodeLine{8805     \textcolor{comment}{// Traits for extracting arg and return type of lambdas (for single argument lambdas)}}
\DoxyCodeLine{8806     \textcolor{keyword}{template}<\textcolor{keyword}{typename} L>}
\DoxyCodeLine{8807     \textcolor{keyword}{struct }UnaryLambdaTraits : UnaryLambdaTraits<decltype( \&L::operator() )> \{\};}
\DoxyCodeLine{8808 }
\DoxyCodeLine{8809     \textcolor{keyword}{template}<\textcolor{keyword}{typename} ClassT, \textcolor{keyword}{typename} ReturnT, \textcolor{keyword}{typename}... Args>}
\DoxyCodeLine{8810     \textcolor{keyword}{struct }UnaryLambdaTraits<ReturnT( ClassT::* )( Args... ) const> \{}
\DoxyCodeLine{8811         \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{bool} isValid = \textcolor{keyword}{false};}
\DoxyCodeLine{8812     \};}
\DoxyCodeLine{8813 }
\DoxyCodeLine{8814     \textcolor{keyword}{template}<\textcolor{keyword}{typename} ClassT, \textcolor{keyword}{typename} ReturnT, \textcolor{keyword}{typename} ArgT>}
\DoxyCodeLine{8815     \textcolor{keyword}{struct }UnaryLambdaTraits<ReturnT( ClassT::* )( ArgT ) const> \{}
\DoxyCodeLine{8816         \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{bool} isValid = \textcolor{keyword}{true};}
\DoxyCodeLine{8817         \textcolor{keyword}{using }ArgType = \textcolor{keyword}{typename} std::remove\_const<typename std::remove\_reference<ArgT>::type>::type;}
\DoxyCodeLine{8818         \textcolor{keyword}{using }ReturnType = ReturnT;}
\DoxyCodeLine{8819     \};}
\DoxyCodeLine{8820 }
\DoxyCodeLine{8821     \textcolor{keyword}{class }TokenStream;}
\DoxyCodeLine{8822 }
\DoxyCodeLine{8823     \textcolor{comment}{// Transport for raw args (copied from main args, or supplied via init list for testing)}}
\DoxyCodeLine{8824     \textcolor{keyword}{class }Args \{}
\DoxyCodeLine{8825         \textcolor{keyword}{friend} TokenStream;}
\DoxyCodeLine{8826         std::string m\_exeName;}
\DoxyCodeLine{8827         std::vector<std::string> m\_args;}
\DoxyCodeLine{8828 }
\DoxyCodeLine{8829     \textcolor{keyword}{public}:}
\DoxyCodeLine{8830         Args( \textcolor{keywordtype}{int} argc, \textcolor{keywordtype}{char} \textcolor{keyword}{const}* \textcolor{keyword}{const}* argv )}
\DoxyCodeLine{8831             : m\_exeName(argv[0]),}
\DoxyCodeLine{8832               m\_args(argv + 1, argv + argc) \{\}}
\DoxyCodeLine{8833 }
\DoxyCodeLine{8834         Args( std::initializer\_list<std::string> args )}
\DoxyCodeLine{8835         :   m\_exeName( *args.begin() ),}
\DoxyCodeLine{8836             m\_args( args.begin()+1, args.end() )}
\DoxyCodeLine{8837         \{\}}
\DoxyCodeLine{8838 }
\DoxyCodeLine{8839         \textcolor{keyword}{auto} exeName() const -\/> std::\textcolor{keywordtype}{string} \{}
\DoxyCodeLine{8840             \textcolor{keywordflow}{return} m\_exeName;}
\DoxyCodeLine{8841         \}}
\DoxyCodeLine{8842     \};}
\DoxyCodeLine{8843 }
\DoxyCodeLine{8844     \textcolor{comment}{// Wraps a token coming from a token stream. These may not directly correspond to strings as a single string}}
\DoxyCodeLine{8845     \textcolor{comment}{// may encode an option + its argument if the : or = form is used}}
\DoxyCodeLine{8846     \textcolor{keyword}{enum class} TokenType \{}
\DoxyCodeLine{8847         Option, Argument}
\DoxyCodeLine{8848     \};}
\DoxyCodeLine{8849     \textcolor{keyword}{struct }Token \{}
\DoxyCodeLine{8850         TokenType type;}
\DoxyCodeLine{8851         std::string token;}
\DoxyCodeLine{8852     \};}
\DoxyCodeLine{8853 }
\DoxyCodeLine{8854     \textcolor{keyword}{inline} \textcolor{keyword}{auto} isOptPrefix( \textcolor{keywordtype}{char} c ) -\/> \textcolor{keywordtype}{bool} \{}
\DoxyCodeLine{8855         \textcolor{keywordflow}{return} c == \textcolor{charliteral}{'-\/'}}
\DoxyCodeLine{8856 \textcolor{preprocessor}{\#ifdef CATCH\_PLATFORM\_WINDOWS}}
\DoxyCodeLine{8857             || c == \textcolor{charliteral}{'/'}}
\DoxyCodeLine{8858 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{8859         ;}
\DoxyCodeLine{8860     \}}
\DoxyCodeLine{8861 }
\DoxyCodeLine{8862     \textcolor{comment}{// Abstracts iterators into args as a stream of tokens, with option arguments uniformly handled}}
\DoxyCodeLine{8863     \textcolor{keyword}{class }TokenStream \{}
\DoxyCodeLine{8864         \textcolor{keyword}{using }Iterator = std::vector<std::string>::const\_iterator;}
\DoxyCodeLine{8865         Iterator it;}
\DoxyCodeLine{8866         Iterator itEnd;}
\DoxyCodeLine{8867         std::vector<Token> m\_tokenBuffer;}
\DoxyCodeLine{8868 }
\DoxyCodeLine{8869         \textcolor{keywordtype}{void} loadBuffer() \{}
\DoxyCodeLine{8870             m\_tokenBuffer.resize( 0 );}
\DoxyCodeLine{8871 }
\DoxyCodeLine{8872             \textcolor{comment}{// Skip any empty strings}}
\DoxyCodeLine{8873             \textcolor{keywordflow}{while}( it != itEnd \&\& it-\/>empty() )}
\DoxyCodeLine{8874                 ++it;}
\DoxyCodeLine{8875 }
\DoxyCodeLine{8876             \textcolor{keywordflow}{if}( it != itEnd ) \{}
\DoxyCodeLine{8877                 \textcolor{keyword}{auto} \textcolor{keyword}{const} \&next = *it;}
\DoxyCodeLine{8878                 \textcolor{keywordflow}{if}( isOptPrefix( next[0] ) ) \{}
\DoxyCodeLine{8879                     \textcolor{keyword}{auto} delimiterPos = next.find\_first\_of( \textcolor{stringliteral}{"{} :="{}} );}
\DoxyCodeLine{8880                     \textcolor{keywordflow}{if}( delimiterPos != std::string::npos ) \{}
\DoxyCodeLine{8881                         m\_tokenBuffer.push\_back( \{ TokenType::Option, next.substr( 0, delimiterPos ) \} );}
\DoxyCodeLine{8882                         m\_tokenBuffer.push\_back( \{ TokenType::Argument, next.substr( delimiterPos + 1 ) \} );}
\DoxyCodeLine{8883                     \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{8884                         \textcolor{keywordflow}{if}( next[1] != \textcolor{charliteral}{'-\/'} \&\& next.size() > 2 ) \{}
\DoxyCodeLine{8885                             std::string opt = \textcolor{stringliteral}{"{}-\/ "{}};}
\DoxyCodeLine{8886                             \textcolor{keywordflow}{for}( \textcolor{keywordtype}{size\_t} i = 1; i < next.size(); ++i ) \{}
\DoxyCodeLine{8887                                 opt[1] = next[i];}
\DoxyCodeLine{8888                                 m\_tokenBuffer.push\_back( \{ TokenType::Option, opt \} );}
\DoxyCodeLine{8889                             \}}
\DoxyCodeLine{8890                         \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{8891                             m\_tokenBuffer.push\_back( \{ TokenType::Option, next \} );}
\DoxyCodeLine{8892                         \}}
\DoxyCodeLine{8893                     \}}
\DoxyCodeLine{8894                 \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{8895                     m\_tokenBuffer.push\_back( \{ TokenType::Argument, next \} );}
\DoxyCodeLine{8896                 \}}
\DoxyCodeLine{8897             \}}
\DoxyCodeLine{8898         \}}
\DoxyCodeLine{8899 }
\DoxyCodeLine{8900     \textcolor{keyword}{public}:}
\DoxyCodeLine{8901         \textcolor{keyword}{explicit} TokenStream( Args \textcolor{keyword}{const} \&args ) : TokenStream( args.m\_args.begin(), args.m\_args.end() ) \{\}}
\DoxyCodeLine{8902 }
\DoxyCodeLine{8903         TokenStream( Iterator it, Iterator itEnd ) : it( it ), itEnd( itEnd ) \{}
\DoxyCodeLine{8904             loadBuffer();}
\DoxyCodeLine{8905         \}}
\DoxyCodeLine{8906 }
\DoxyCodeLine{8907         \textcolor{keyword}{explicit} \textcolor{keyword}{operator} bool()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{8908             \textcolor{keywordflow}{return} !m\_tokenBuffer.empty() || it != itEnd;}
\DoxyCodeLine{8909         \}}
\DoxyCodeLine{8910 }
\DoxyCodeLine{8911         \textcolor{keyword}{auto} count() const -\/> \textcolor{keywordtype}{size\_t} \{ \textcolor{keywordflow}{return} m\_tokenBuffer.size() + (itEnd -\/ it); \}}
\DoxyCodeLine{8912 }
\DoxyCodeLine{8913         \textcolor{keyword}{auto} operator*() const -\/> Token \{}
\DoxyCodeLine{8914             assert( !m\_tokenBuffer.empty() );}
\DoxyCodeLine{8915             \textcolor{keywordflow}{return} m\_tokenBuffer.front();}
\DoxyCodeLine{8916         \}}
\DoxyCodeLine{8917 }
\DoxyCodeLine{8918         \textcolor{keyword}{auto} operator-\/>() const -\/> Token const * \{}
\DoxyCodeLine{8919             assert( !m\_tokenBuffer.empty() );}
\DoxyCodeLine{8920             \textcolor{keywordflow}{return} \&m\_tokenBuffer.front();}
\DoxyCodeLine{8921         \}}
\DoxyCodeLine{8922 }
\DoxyCodeLine{8923         \textcolor{keyword}{auto} operator++() -\/> TokenStream \& \{}
\DoxyCodeLine{8924             \textcolor{keywordflow}{if}( m\_tokenBuffer.size() >= 2 ) \{}
\DoxyCodeLine{8925                 m\_tokenBuffer.erase( m\_tokenBuffer.begin() );}
\DoxyCodeLine{8926             \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{8927                 \textcolor{keywordflow}{if}( it != itEnd )}
\DoxyCodeLine{8928                     ++it;}
\DoxyCodeLine{8929                 loadBuffer();}
\DoxyCodeLine{8930             \}}
\DoxyCodeLine{8931             \textcolor{keywordflow}{return} *\textcolor{keyword}{this};}
\DoxyCodeLine{8932         \}}
\DoxyCodeLine{8933     \};}
\DoxyCodeLine{8934 }
\DoxyCodeLine{8935     \textcolor{keyword}{class }ResultBase \{}
\DoxyCodeLine{8936     \textcolor{keyword}{public}:}
\DoxyCodeLine{8937         \textcolor{keyword}{enum} Type \{}
\DoxyCodeLine{8938             Ok, LogicError, RuntimeError}
\DoxyCodeLine{8939         \};}
\DoxyCodeLine{8940 }
\DoxyCodeLine{8941     \textcolor{keyword}{protected}:}
\DoxyCodeLine{8942         ResultBase( Type type ) : m\_type( type ) \{\}}
\DoxyCodeLine{8943         \textcolor{keyword}{virtual} \string~ResultBase() = \textcolor{keywordflow}{default};}
\DoxyCodeLine{8944 }
\DoxyCodeLine{8945         \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} enforceOk() \textcolor{keyword}{const} = 0;}
\DoxyCodeLine{8946 }
\DoxyCodeLine{8947         Type m\_type;}
\DoxyCodeLine{8948     \};}
\DoxyCodeLine{8949 }
\DoxyCodeLine{8950     \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{8951     \textcolor{keyword}{class }ResultValueBase : \textcolor{keyword}{public} ResultBase \{}
\DoxyCodeLine{8952     \textcolor{keyword}{public}:}
\DoxyCodeLine{8953         \textcolor{keyword}{auto} value() const -\/> T const \& \{}
\DoxyCodeLine{8954             enforceOk();}
\DoxyCodeLine{8955             \textcolor{keywordflow}{return} m\_value;}
\DoxyCodeLine{8956         \}}
\DoxyCodeLine{8957 }
\DoxyCodeLine{8958     \textcolor{keyword}{protected}:}
\DoxyCodeLine{8959         ResultValueBase( Type type ) : ResultBase( type ) \{\}}
\DoxyCodeLine{8960 }
\DoxyCodeLine{8961         ResultValueBase( ResultValueBase \textcolor{keyword}{const} \&other ) : ResultBase( other ) \{}
\DoxyCodeLine{8962             \textcolor{keywordflow}{if}( m\_type == ResultBase::Ok )}
\DoxyCodeLine{8963                 \textcolor{keyword}{new}( \&m\_value ) T( other.m\_value );}
\DoxyCodeLine{8964         \}}
\DoxyCodeLine{8965 }
\DoxyCodeLine{8966         ResultValueBase( Type, T \textcolor{keyword}{const} \&value ) : ResultBase( Ok ) \{}
\DoxyCodeLine{8967             \textcolor{keyword}{new}( \&m\_value ) T( value );}
\DoxyCodeLine{8968         \}}
\DoxyCodeLine{8969 }
\DoxyCodeLine{8970         \textcolor{keyword}{auto} operator=( ResultValueBase \textcolor{keyword}{const} \&other ) -\/> ResultValueBase \& \{}
\DoxyCodeLine{8971             \textcolor{keywordflow}{if}( m\_type == ResultBase::Ok )}
\DoxyCodeLine{8972                 m\_value.\string~T();}
\DoxyCodeLine{8973             ResultBase::operator=(other);}
\DoxyCodeLine{8974             \textcolor{keywordflow}{if}( m\_type == ResultBase::Ok )}
\DoxyCodeLine{8975                 \textcolor{keyword}{new}( \&m\_value ) T( other.m\_value );}
\DoxyCodeLine{8976             \textcolor{keywordflow}{return} *\textcolor{keyword}{this};}
\DoxyCodeLine{8977         \}}
\DoxyCodeLine{8978 }
\DoxyCodeLine{8979         \string~ResultValueBase()\textcolor{keyword}{ override }\{}
\DoxyCodeLine{8980             \textcolor{keywordflow}{if}( m\_type == Ok )}
\DoxyCodeLine{8981                 m\_value.\string~T();}
\DoxyCodeLine{8982         \}}
\DoxyCodeLine{8983 }
\DoxyCodeLine{8984         \textcolor{keyword}{union }\{}
\DoxyCodeLine{8985             T m\_value;}
\DoxyCodeLine{8986         \};}
\DoxyCodeLine{8987     \};}
\DoxyCodeLine{8988 }
\DoxyCodeLine{8989     \textcolor{keyword}{template}<>}
\DoxyCodeLine{8990     \textcolor{keyword}{class }ResultValueBase<void> : \textcolor{keyword}{public} ResultBase \{}
\DoxyCodeLine{8991     \textcolor{keyword}{protected}:}
\DoxyCodeLine{8992         \textcolor{keyword}{using }ResultBase::ResultBase;}
\DoxyCodeLine{8993     \};}
\DoxyCodeLine{8994 }
\DoxyCodeLine{8995     \textcolor{keyword}{template}<\textcolor{keyword}{typename} T = \textcolor{keywordtype}{void}>}
\DoxyCodeLine{8996     \textcolor{keyword}{class }BasicResult : \textcolor{keyword}{public} ResultValueBase<T> \{}
\DoxyCodeLine{8997     \textcolor{keyword}{public}:}
\DoxyCodeLine{8998         \textcolor{keyword}{template}<\textcolor{keyword}{typename} U>}
\DoxyCodeLine{8999         \textcolor{keyword}{explicit} BasicResult( BasicResult<U> \textcolor{keyword}{const} \&other )}
\DoxyCodeLine{9000         :   ResultValueBase<T>( other.type() ),}
\DoxyCodeLine{9001             m\_errorMessage( other.errorMessage() )}
\DoxyCodeLine{9002         \{}
\DoxyCodeLine{9003             assert( type() != ResultBase::Ok );}
\DoxyCodeLine{9004         \}}
\DoxyCodeLine{9005 }
\DoxyCodeLine{9006         \textcolor{keyword}{template}<\textcolor{keyword}{typename} U>}
\DoxyCodeLine{9007         \textcolor{keyword}{static} \textcolor{keyword}{auto} ok( U \textcolor{keyword}{const} \&value ) -\/> BasicResult \{ \textcolor{keywordflow}{return} \{ ResultBase::Ok, value \}; \}}
\DoxyCodeLine{9008         \textcolor{keyword}{static} \textcolor{keyword}{auto} ok() -\/> BasicResult \{ \textcolor{keywordflow}{return} \{ ResultBase::Ok \}; \}}
\DoxyCodeLine{9009         \textcolor{keyword}{static} \textcolor{keyword}{auto} logicError( std::string \textcolor{keyword}{const} \&message ) -\/> BasicResult \{ \textcolor{keywordflow}{return} \{ ResultBase::LogicError, message \}; \}}
\DoxyCodeLine{9010         \textcolor{keyword}{static} \textcolor{keyword}{auto} runtimeError( std::string \textcolor{keyword}{const} \&message ) -\/> BasicResult \{ \textcolor{keywordflow}{return} \{ ResultBase::RuntimeError, message \}; \}}
\DoxyCodeLine{9011 }
\DoxyCodeLine{9012         \textcolor{keyword}{explicit} \textcolor{keyword}{operator} bool()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} m\_type == ResultBase::Ok; \}}
\DoxyCodeLine{9013         \textcolor{keyword}{auto} type() const -\/> ResultBase::Type \{ \textcolor{keywordflow}{return} m\_type; \}}
\DoxyCodeLine{9014         \textcolor{keyword}{auto} errorMessage() const -\/> std::\textcolor{keywordtype}{string} \{ \textcolor{keywordflow}{return} m\_errorMessage; \}}
\DoxyCodeLine{9015 }
\DoxyCodeLine{9016     \textcolor{keyword}{protected}:}
\DoxyCodeLine{9017         \textcolor{keywordtype}{void} enforceOk()\textcolor{keyword}{ const override }\{}
\DoxyCodeLine{9018 }
\DoxyCodeLine{9019             \textcolor{comment}{// Errors shouldn't reach this point, but if they do}}
\DoxyCodeLine{9020             \textcolor{comment}{// the actual error message will be in m\_errorMessage}}
\DoxyCodeLine{9021             assert( m\_type != ResultBase::LogicError );}
\DoxyCodeLine{9022             assert( m\_type != ResultBase::RuntimeError );}
\DoxyCodeLine{9023             \textcolor{keywordflow}{if}( m\_type != ResultBase::Ok )}
\DoxyCodeLine{9024                 std::abort();}
\DoxyCodeLine{9025         \}}
\DoxyCodeLine{9026 }
\DoxyCodeLine{9027         std::string m\_errorMessage; \textcolor{comment}{// Only populated if resultType is an error}}
\DoxyCodeLine{9028 }
\DoxyCodeLine{9029         BasicResult( ResultBase::Type type, std::string \textcolor{keyword}{const} \&message )}
\DoxyCodeLine{9030         :   ResultValueBase<T>(type),}
\DoxyCodeLine{9031             m\_errorMessage(message)}
\DoxyCodeLine{9032         \{}
\DoxyCodeLine{9033             assert( m\_type != ResultBase::Ok );}
\DoxyCodeLine{9034         \}}
\DoxyCodeLine{9035 }
\DoxyCodeLine{9036         \textcolor{keyword}{using }ResultValueBase<T>::ResultValueBase;}
\DoxyCodeLine{9037         \textcolor{keyword}{using }ResultBase::m\_type;}
\DoxyCodeLine{9038     \};}
\DoxyCodeLine{9039 }
\DoxyCodeLine{9040     \textcolor{keyword}{enum class} ParseResultType \{}
\DoxyCodeLine{9041         Matched, NoMatch, ShortCircuitAll, ShortCircuitSame}
\DoxyCodeLine{9042     \};}
\DoxyCodeLine{9043 }
\DoxyCodeLine{9044     \textcolor{keyword}{class }ParseState \{}
\DoxyCodeLine{9045     \textcolor{keyword}{public}:}
\DoxyCodeLine{9046 }
\DoxyCodeLine{9047         ParseState( ParseResultType type, TokenStream \textcolor{keyword}{const} \&remainingTokens )}
\DoxyCodeLine{9048         : m\_type(type),}
\DoxyCodeLine{9049           m\_remainingTokens( remainingTokens )}
\DoxyCodeLine{9050         \{\}}
\DoxyCodeLine{9051 }
\DoxyCodeLine{9052         \textcolor{keyword}{auto} type() const -\/> ParseResultType \{ \textcolor{keywordflow}{return} m\_type; \}}
\DoxyCodeLine{9053         \textcolor{keyword}{auto} remainingTokens() const -\/> TokenStream \{ \textcolor{keywordflow}{return} m\_remainingTokens; \}}
\DoxyCodeLine{9054 }
\DoxyCodeLine{9055     \textcolor{keyword}{private}:}
\DoxyCodeLine{9056         ParseResultType m\_type;}
\DoxyCodeLine{9057         TokenStream m\_remainingTokens;}
\DoxyCodeLine{9058     \};}
\DoxyCodeLine{9059 }
\DoxyCodeLine{9060     \textcolor{keyword}{using }Result = BasicResult<void>;}
\DoxyCodeLine{9061     \textcolor{keyword}{using }ParserResult = BasicResult<ParseResultType>;}
\DoxyCodeLine{9062     \textcolor{keyword}{using }InternalParseResult = BasicResult<ParseState>;}
\DoxyCodeLine{9063 }
\DoxyCodeLine{9064     \textcolor{keyword}{struct }HelpColumns \{}
\DoxyCodeLine{9065         std::string left;}
\DoxyCodeLine{9066         std::string right;}
\DoxyCodeLine{9067     \};}
\DoxyCodeLine{9068 }
\DoxyCodeLine{9069     \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{9070     \textcolor{keyword}{inline} \textcolor{keyword}{auto} convertInto( std::string \textcolor{keyword}{const} \&source, T\& target ) -\/> ParserResult \{}
\DoxyCodeLine{9071         std::stringstream ss;}
\DoxyCodeLine{9072         ss << source;}
\DoxyCodeLine{9073         ss >> target;}
\DoxyCodeLine{9074         \textcolor{keywordflow}{if}( ss.fail() )}
\DoxyCodeLine{9075             \textcolor{keywordflow}{return} ParserResult::runtimeError( \textcolor{stringliteral}{"{}Unable to convert '"{}} + source + \textcolor{stringliteral}{"{}' to destination type"{}} );}
\DoxyCodeLine{9076         \textcolor{keywordflow}{else}}
\DoxyCodeLine{9077             \textcolor{keywordflow}{return} ParserResult::ok( ParseResultType::Matched );}
\DoxyCodeLine{9078     \}}
\DoxyCodeLine{9079     \textcolor{keyword}{inline} \textcolor{keyword}{auto} convertInto( std::string \textcolor{keyword}{const} \&source, std::string\& target ) -\/> ParserResult \{}
\DoxyCodeLine{9080         target = source;}
\DoxyCodeLine{9081         \textcolor{keywordflow}{return} ParserResult::ok( ParseResultType::Matched );}
\DoxyCodeLine{9082     \}}
\DoxyCodeLine{9083     \textcolor{keyword}{inline} \textcolor{keyword}{auto} convertInto( std::string \textcolor{keyword}{const} \&source, \textcolor{keywordtype}{bool} \&target ) -\/> ParserResult \{}
\DoxyCodeLine{9084         std::string srcLC = source;}
\DoxyCodeLine{9085         std::transform( srcLC.begin(), srcLC.end(), srcLC.begin(), []( \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} c ) \{ return static\_cast<char>( std::tolower(c) ); \} );}
\DoxyCodeLine{9086         \textcolor{keywordflow}{if} (srcLC == \textcolor{stringliteral}{"{}y"{}} || srcLC == \textcolor{stringliteral}{"{}1"{}} || srcLC == \textcolor{stringliteral}{"{}true"{}} || srcLC == \textcolor{stringliteral}{"{}yes"{}} || srcLC == \textcolor{stringliteral}{"{}on"{}})}
\DoxyCodeLine{9087             target = \textcolor{keyword}{true};}
\DoxyCodeLine{9088         \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (srcLC == \textcolor{stringliteral}{"{}n"{}} || srcLC == \textcolor{stringliteral}{"{}0"{}} || srcLC == \textcolor{stringliteral}{"{}false"{}} || srcLC == \textcolor{stringliteral}{"{}no"{}} || srcLC == \textcolor{stringliteral}{"{}off"{}})}
\DoxyCodeLine{9089             target = \textcolor{keyword}{false};}
\DoxyCodeLine{9090         \textcolor{keywordflow}{else}}
\DoxyCodeLine{9091             \textcolor{keywordflow}{return} ParserResult::runtimeError( \textcolor{stringliteral}{"{}Expected a boolean value but did not recognise: '"{}} + source + \textcolor{stringliteral}{"{}'"{}} );}
\DoxyCodeLine{9092         \textcolor{keywordflow}{return} ParserResult::ok( ParseResultType::Matched );}
\DoxyCodeLine{9093     \}}
\DoxyCodeLine{9094 \textcolor{preprocessor}{\#ifdef CLARA\_CONFIG\_OPTIONAL\_TYPE}}
\DoxyCodeLine{9095     \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{9096     \textcolor{keyword}{inline} \textcolor{keyword}{auto} convertInto( std::string \textcolor{keyword}{const} \&source, CLARA\_CONFIG\_OPTIONAL\_TYPE<T>\& target ) -\/> ParserResult \{}
\DoxyCodeLine{9097         T temp;}
\DoxyCodeLine{9098         \textcolor{keyword}{auto} result = convertInto( source, temp );}
\DoxyCodeLine{9099         \textcolor{keywordflow}{if}( result )}
\DoxyCodeLine{9100             target = std::move(temp);}
\DoxyCodeLine{9101         \textcolor{keywordflow}{return} result;}
\DoxyCodeLine{9102     \}}
\DoxyCodeLine{9103 \textcolor{preprocessor}{\#endif }\textcolor{comment}{// CLARA\_CONFIG\_OPTIONAL\_TYPE}}
\DoxyCodeLine{9104 }
\DoxyCodeLine{9105     \textcolor{keyword}{struct }NonCopyable \{}
\DoxyCodeLine{9106         NonCopyable() = \textcolor{keywordflow}{default};}
\DoxyCodeLine{9107         NonCopyable( NonCopyable \textcolor{keyword}{const} \& ) = \textcolor{keyword}{delete};}
\DoxyCodeLine{9108         NonCopyable( NonCopyable \&\& ) = \textcolor{keyword}{delete};}
\DoxyCodeLine{9109         NonCopyable \&operator=( NonCopyable \textcolor{keyword}{const} \& ) = \textcolor{keyword}{delete};}
\DoxyCodeLine{9110         NonCopyable \&operator=( NonCopyable \&\& ) = \textcolor{keyword}{delete};}
\DoxyCodeLine{9111     \};}
\DoxyCodeLine{9112 }
\DoxyCodeLine{9113     \textcolor{keyword}{struct }BoundRef : NonCopyable \{}
\DoxyCodeLine{9114         \textcolor{keyword}{virtual} \string~BoundRef() = \textcolor{keywordflow}{default};}
\DoxyCodeLine{9115         \textcolor{keyword}{virtual} \textcolor{keyword}{auto} isContainer() const -\/> \textcolor{keywordtype}{bool} \{ \textcolor{keywordflow}{return} \textcolor{keyword}{false}; \}}
\DoxyCodeLine{9116         \textcolor{keyword}{virtual} \textcolor{keyword}{auto} isFlag() const -\/> \textcolor{keywordtype}{bool} \{ \textcolor{keywordflow}{return} \textcolor{keyword}{false}; \}}
\DoxyCodeLine{9117     \};}
\DoxyCodeLine{9118     \textcolor{keyword}{struct }BoundValueRefBase : BoundRef \{}
\DoxyCodeLine{9119         \textcolor{keyword}{virtual} \textcolor{keyword}{auto} setValue( std::string \textcolor{keyword}{const} \&arg ) -\/> ParserResult = 0;}
\DoxyCodeLine{9120     \};}
\DoxyCodeLine{9121     \textcolor{keyword}{struct }BoundFlagRefBase : BoundRef \{}
\DoxyCodeLine{9122         \textcolor{keyword}{virtual} \textcolor{keyword}{auto} setFlag( \textcolor{keywordtype}{bool} flag ) -\/> ParserResult = 0;}
\DoxyCodeLine{9123         \textcolor{keyword}{virtual} \textcolor{keyword}{auto} isFlag() const -\/> \textcolor{keywordtype}{bool} \{ \textcolor{keywordflow}{return} \textcolor{keyword}{true}; \}}
\DoxyCodeLine{9124     \};}
\DoxyCodeLine{9125 }
\DoxyCodeLine{9126     \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{9127     \textcolor{keyword}{struct }BoundValueRef : BoundValueRefBase \{}
\DoxyCodeLine{9128         T \&m\_ref;}
\DoxyCodeLine{9129 }
\DoxyCodeLine{9130         \textcolor{keyword}{explicit} BoundValueRef( T \&ref ) : m\_ref( ref ) \{\}}
\DoxyCodeLine{9131 }
\DoxyCodeLine{9132         \textcolor{keyword}{auto} setValue( std::string \textcolor{keyword}{const} \&arg ) -\/> ParserResult \textcolor{keyword}{override} \{}
\DoxyCodeLine{9133             \textcolor{keywordflow}{return} convertInto( arg, m\_ref );}
\DoxyCodeLine{9134         \}}
\DoxyCodeLine{9135     \};}
\DoxyCodeLine{9136 }
\DoxyCodeLine{9137     \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{9138     \textcolor{keyword}{struct }BoundValueRef<std::vector<T>> : BoundValueRefBase \{}
\DoxyCodeLine{9139         std::vector<T> \&m\_ref;}
\DoxyCodeLine{9140 }
\DoxyCodeLine{9141         \textcolor{keyword}{explicit} BoundValueRef( std::vector<T> \&ref ) : m\_ref( ref ) \{\}}
\DoxyCodeLine{9142 }
\DoxyCodeLine{9143         \textcolor{keyword}{auto} isContainer() const -\/> \textcolor{keywordtype}{bool}\textcolor{keyword}{ override }\{ \textcolor{keywordflow}{return} \textcolor{keyword}{true}; \}}
\DoxyCodeLine{9144 }
\DoxyCodeLine{9145         \textcolor{keyword}{auto} setValue( std::string \textcolor{keyword}{const} \&arg ) -\/> ParserResult \textcolor{keyword}{override} \{}
\DoxyCodeLine{9146             T temp;}
\DoxyCodeLine{9147             \textcolor{keyword}{auto} result = convertInto( arg, temp );}
\DoxyCodeLine{9148             \textcolor{keywordflow}{if}( result )}
\DoxyCodeLine{9149                 m\_ref.push\_back( temp );}
\DoxyCodeLine{9150             \textcolor{keywordflow}{return} result;}
\DoxyCodeLine{9151         \}}
\DoxyCodeLine{9152     \};}
\DoxyCodeLine{9153 }
\DoxyCodeLine{9154     \textcolor{keyword}{struct }BoundFlagRef : BoundFlagRefBase \{}
\DoxyCodeLine{9155         \textcolor{keywordtype}{bool} \&m\_ref;}
\DoxyCodeLine{9156 }
\DoxyCodeLine{9157         \textcolor{keyword}{explicit} BoundFlagRef( \textcolor{keywordtype}{bool} \&ref ) : m\_ref( ref ) \{\}}
\DoxyCodeLine{9158 }
\DoxyCodeLine{9159         \textcolor{keyword}{auto} setFlag( \textcolor{keywordtype}{bool} flag ) -\/> ParserResult \textcolor{keyword}{override} \{}
\DoxyCodeLine{9160             m\_ref = flag;}
\DoxyCodeLine{9161             \textcolor{keywordflow}{return} ParserResult::ok( ParseResultType::Matched );}
\DoxyCodeLine{9162         \}}
\DoxyCodeLine{9163     \};}
\DoxyCodeLine{9164 }
\DoxyCodeLine{9165     \textcolor{keyword}{template}<\textcolor{keyword}{typename} ReturnType>}
\DoxyCodeLine{9166     \textcolor{keyword}{struct }LambdaInvoker \{}
\DoxyCodeLine{9167         \textcolor{keyword}{static\_assert}( std::is\_same<ReturnType, ParserResult>::value, \textcolor{stringliteral}{"{}Lambda must return void or clara::ParserResult"{}} );}
\DoxyCodeLine{9168 }
\DoxyCodeLine{9169         \textcolor{keyword}{template}<\textcolor{keyword}{typename} L, \textcolor{keyword}{typename} ArgType>}
\DoxyCodeLine{9170         \textcolor{keyword}{static} \textcolor{keyword}{auto} invoke( L \textcolor{keyword}{const} \&lambda, ArgType \textcolor{keyword}{const} \&arg ) -\/> ParserResult \{}
\DoxyCodeLine{9171             \textcolor{keywordflow}{return} lambda( arg );}
\DoxyCodeLine{9172         \}}
\DoxyCodeLine{9173     \};}
\DoxyCodeLine{9174 }
\DoxyCodeLine{9175     \textcolor{keyword}{template}<>}
\DoxyCodeLine{9176     \textcolor{keyword}{struct }LambdaInvoker<void> \{}
\DoxyCodeLine{9177         \textcolor{keyword}{template}<\textcolor{keyword}{typename} L, \textcolor{keyword}{typename} ArgType>}
\DoxyCodeLine{9178         \textcolor{keyword}{static} \textcolor{keyword}{auto} invoke( L \textcolor{keyword}{const} \&lambda, ArgType \textcolor{keyword}{const} \&arg ) -\/> ParserResult \{}
\DoxyCodeLine{9179             lambda( arg );}
\DoxyCodeLine{9180             \textcolor{keywordflow}{return} ParserResult::ok( ParseResultType::Matched );}
\DoxyCodeLine{9181         \}}
\DoxyCodeLine{9182     \};}
\DoxyCodeLine{9183 }
\DoxyCodeLine{9184     \textcolor{keyword}{template}<\textcolor{keyword}{typename} ArgType, \textcolor{keyword}{typename} L>}
\DoxyCodeLine{9185     \textcolor{keyword}{inline} \textcolor{keyword}{auto} invokeLambda( L \textcolor{keyword}{const} \&lambda, std::string \textcolor{keyword}{const} \&arg ) -\/> ParserResult \{}
\DoxyCodeLine{9186         ArgType temp\{\};}
\DoxyCodeLine{9187         \textcolor{keyword}{auto} result = convertInto( arg, temp );}
\DoxyCodeLine{9188         \textcolor{keywordflow}{return} !result}
\DoxyCodeLine{9189            ? result}
\DoxyCodeLine{9190            : LambdaInvoker<typename UnaryLambdaTraits<L>::ReturnType>::invoke( lambda, temp );}
\DoxyCodeLine{9191     \}}
\DoxyCodeLine{9192 }
\DoxyCodeLine{9193     \textcolor{keyword}{template}<\textcolor{keyword}{typename} L>}
\DoxyCodeLine{9194     \textcolor{keyword}{struct }BoundLambda : BoundValueRefBase \{}
\DoxyCodeLine{9195         L m\_lambda;}
\DoxyCodeLine{9196 }
\DoxyCodeLine{9197         \textcolor{keyword}{static\_assert}( UnaryLambdaTraits<L>::isValid, \textcolor{stringliteral}{"{}Supplied lambda must take exactly one argument"{}} );}
\DoxyCodeLine{9198         \textcolor{keyword}{explicit} BoundLambda( L \textcolor{keyword}{const} \&lambda ) : m\_lambda( lambda ) \{\}}
\DoxyCodeLine{9199 }
\DoxyCodeLine{9200         \textcolor{keyword}{auto} setValue( std::string \textcolor{keyword}{const} \&arg ) -\/> ParserResult \textcolor{keyword}{override} \{}
\DoxyCodeLine{9201             \textcolor{keywordflow}{return} invokeLambda<typename UnaryLambdaTraits<L>::ArgType>( m\_lambda, arg );}
\DoxyCodeLine{9202         \}}
\DoxyCodeLine{9203     \};}
\DoxyCodeLine{9204 }
\DoxyCodeLine{9205     \textcolor{keyword}{template}<\textcolor{keyword}{typename} L>}
\DoxyCodeLine{9206     \textcolor{keyword}{struct }BoundFlagLambda : BoundFlagRefBase \{}
\DoxyCodeLine{9207         L m\_lambda;}
\DoxyCodeLine{9208 }
\DoxyCodeLine{9209         \textcolor{keyword}{static\_assert}( UnaryLambdaTraits<L>::isValid, \textcolor{stringliteral}{"{}Supplied lambda must take exactly one argument"{}} );}
\DoxyCodeLine{9210         \textcolor{keyword}{static\_assert}( std::is\_same<typename UnaryLambdaTraits<L>::ArgType, \textcolor{keywordtype}{bool}>::value, \textcolor{stringliteral}{"{}flags must be boolean"{}} );}
\DoxyCodeLine{9211 }
\DoxyCodeLine{9212         \textcolor{keyword}{explicit} BoundFlagLambda( L \textcolor{keyword}{const} \&lambda ) : m\_lambda( lambda ) \{\}}
\DoxyCodeLine{9213 }
\DoxyCodeLine{9214         \textcolor{keyword}{auto} setFlag( \textcolor{keywordtype}{bool} flag ) -\/> ParserResult \textcolor{keyword}{override} \{}
\DoxyCodeLine{9215             \textcolor{keywordflow}{return} LambdaInvoker<typename UnaryLambdaTraits<L>::ReturnType>::invoke( m\_lambda, flag );}
\DoxyCodeLine{9216         \}}
\DoxyCodeLine{9217     \};}
\DoxyCodeLine{9218 }
\DoxyCodeLine{9219     \textcolor{keyword}{enum class} Optionality \{ Optional, Required \};}
\DoxyCodeLine{9220 }
\DoxyCodeLine{9221     \textcolor{keyword}{struct }Parser;}
\DoxyCodeLine{9222 }
\DoxyCodeLine{9223     \textcolor{keyword}{class }ParserBase \{}
\DoxyCodeLine{9224     \textcolor{keyword}{public}:}
\DoxyCodeLine{9225         \textcolor{keyword}{virtual} \string~ParserBase() = \textcolor{keywordflow}{default};}
\DoxyCodeLine{9226         \textcolor{keyword}{virtual} \textcolor{keyword}{auto} validate() const -\/> Result \{ \textcolor{keywordflow}{return} Result::ok(); \}}
\DoxyCodeLine{9227         \textcolor{keyword}{virtual} \textcolor{keyword}{auto} parse( std::string \textcolor{keyword}{const}\& exeName, TokenStream \textcolor{keyword}{const} \&tokens) \textcolor{keyword}{const} -\/> InternalParseResult  = 0;}
\DoxyCodeLine{9228         \textcolor{keyword}{virtual} \textcolor{keyword}{auto} cardinality() const -\/> \textcolor{keywordtype}{size\_t} \{ \textcolor{keywordflow}{return} 1; \}}
\DoxyCodeLine{9229 }
\DoxyCodeLine{9230         \textcolor{keyword}{auto} parse( Args \textcolor{keyword}{const} \&args ) \textcolor{keyword}{const} -\/> InternalParseResult \{}
\DoxyCodeLine{9231             \textcolor{keywordflow}{return} parse( args.exeName(), TokenStream( args ) );}
\DoxyCodeLine{9232         \}}
\DoxyCodeLine{9233     \};}
\DoxyCodeLine{9234 }
\DoxyCodeLine{9235     \textcolor{keyword}{template}<\textcolor{keyword}{typename} DerivedT>}
\DoxyCodeLine{9236     \textcolor{keyword}{class }ComposableParserImpl : \textcolor{keyword}{public} ParserBase \{}
\DoxyCodeLine{9237     \textcolor{keyword}{public}:}
\DoxyCodeLine{9238         \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{9239         \textcolor{keyword}{auto} operator|( T \textcolor{keyword}{const} \&other ) \textcolor{keyword}{const} -\/> Parser;}
\DoxyCodeLine{9240 }
\DoxyCodeLine{9241         \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{9242         \textcolor{keyword}{auto} operator+( T \textcolor{keyword}{const} \&other ) \textcolor{keyword}{const} -\/> Parser;}
\DoxyCodeLine{9243     \};}
\DoxyCodeLine{9244 }
\DoxyCodeLine{9245     \textcolor{comment}{// Common code and state for Args and Opts}}
\DoxyCodeLine{9246     \textcolor{keyword}{template}<\textcolor{keyword}{typename} DerivedT>}
\DoxyCodeLine{9247     \textcolor{keyword}{class }ParserRefImpl : \textcolor{keyword}{public} ComposableParserImpl<DerivedT> \{}
\DoxyCodeLine{9248     \textcolor{keyword}{protected}:}
\DoxyCodeLine{9249         Optionality m\_optionality = Optionality::Optional;}
\DoxyCodeLine{9250         std::shared\_ptr<BoundRef> m\_ref;}
\DoxyCodeLine{9251         std::string m\_hint;}
\DoxyCodeLine{9252         std::string m\_description;}
\DoxyCodeLine{9253 }
\DoxyCodeLine{9254         \textcolor{keyword}{explicit} ParserRefImpl( std::shared\_ptr<BoundRef> \textcolor{keyword}{const} \&ref ) : m\_ref( ref ) \{\}}
\DoxyCodeLine{9255 }
\DoxyCodeLine{9256     \textcolor{keyword}{public}:}
\DoxyCodeLine{9257         \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{9258         ParserRefImpl( T \&ref, std::string \textcolor{keyword}{const} \&hint )}
\DoxyCodeLine{9259         :   m\_ref( std::make\_shared<BoundValueRef<T>>( ref ) ),}
\DoxyCodeLine{9260             m\_hint( hint )}
\DoxyCodeLine{9261         \{\}}
\DoxyCodeLine{9262 }
\DoxyCodeLine{9263         \textcolor{keyword}{template}<\textcolor{keyword}{typename} LambdaT>}
\DoxyCodeLine{9264         ParserRefImpl( LambdaT \textcolor{keyword}{const} \&ref, std::string \textcolor{keyword}{const} \&hint )}
\DoxyCodeLine{9265         :   m\_ref( std::make\_shared<BoundLambda<LambdaT>>( ref ) ),}
\DoxyCodeLine{9266             m\_hint(hint)}
\DoxyCodeLine{9267         \{\}}
\DoxyCodeLine{9268 }
\DoxyCodeLine{9269         \textcolor{keyword}{auto} operator()( std::string \textcolor{keyword}{const} \&description ) -\/> DerivedT \& \{}
\DoxyCodeLine{9270             m\_description = description;}
\DoxyCodeLine{9271             \textcolor{keywordflow}{return} \textcolor{keyword}{static\_cast<}DerivedT \&\textcolor{keyword}{>}( *this );}
\DoxyCodeLine{9272         \}}
\DoxyCodeLine{9273 }
\DoxyCodeLine{9274         \textcolor{keyword}{auto} optional() -\/> DerivedT \& \{}
\DoxyCodeLine{9275             m\_optionality = Optionality::Optional;}
\DoxyCodeLine{9276             \textcolor{keywordflow}{return} \textcolor{keyword}{static\_cast<}DerivedT \&\textcolor{keyword}{>}( *this );}
\DoxyCodeLine{9277         \};}
\DoxyCodeLine{9278 }
\DoxyCodeLine{9279         \textcolor{keyword}{auto} required() -\/> DerivedT \& \{}
\DoxyCodeLine{9280             m\_optionality = Optionality::Required;}
\DoxyCodeLine{9281             \textcolor{keywordflow}{return} \textcolor{keyword}{static\_cast<}DerivedT \&\textcolor{keyword}{>}( *this );}
\DoxyCodeLine{9282         \};}
\DoxyCodeLine{9283 }
\DoxyCodeLine{9284         \textcolor{keyword}{auto} isOptional() const -\/> \textcolor{keywordtype}{bool} \{}
\DoxyCodeLine{9285             \textcolor{keywordflow}{return} m\_optionality == Optionality::Optional;}
\DoxyCodeLine{9286         \}}
\DoxyCodeLine{9287 }
\DoxyCodeLine{9288         \textcolor{keyword}{auto} cardinality() const -\/> \textcolor{keywordtype}{size\_t}\textcolor{keyword}{ override }\{}
\DoxyCodeLine{9289             \textcolor{keywordflow}{if}( m\_ref-\/>isContainer() )}
\DoxyCodeLine{9290                 \textcolor{keywordflow}{return} 0;}
\DoxyCodeLine{9291             \textcolor{keywordflow}{else}}
\DoxyCodeLine{9292                 \textcolor{keywordflow}{return} 1;}
\DoxyCodeLine{9293         \}}
\DoxyCodeLine{9294 }
\DoxyCodeLine{9295         \textcolor{keyword}{auto} hint() const -\/> std::\textcolor{keywordtype}{string} \{ \textcolor{keywordflow}{return} m\_hint; \}}
\DoxyCodeLine{9296     \};}
\DoxyCodeLine{9297 }
\DoxyCodeLine{9298     \textcolor{keyword}{class }ExeName : \textcolor{keyword}{public} ComposableParserImpl<ExeName> \{}
\DoxyCodeLine{9299         std::shared\_ptr<std::string> m\_name;}
\DoxyCodeLine{9300         std::shared\_ptr<BoundValueRefBase> m\_ref;}
\DoxyCodeLine{9301 }
\DoxyCodeLine{9302         \textcolor{keyword}{template}<\textcolor{keyword}{typename} LambdaT>}
\DoxyCodeLine{9303         \textcolor{keyword}{static} \textcolor{keyword}{auto} makeRef(LambdaT \textcolor{keyword}{const} \&lambda) -\/> std::shared\_ptr<BoundValueRefBase> \{}
\DoxyCodeLine{9304             \textcolor{keywordflow}{return} std::make\_shared<BoundLambda<LambdaT>>( lambda) ;}
\DoxyCodeLine{9305         \}}
\DoxyCodeLine{9306 }
\DoxyCodeLine{9307     \textcolor{keyword}{public}:}
\DoxyCodeLine{9308         ExeName() : m\_name( std::make\_shared<std::string>( \textcolor{stringliteral}{"{}<executable>"{}} ) ) \{\}}
\DoxyCodeLine{9309 }
\DoxyCodeLine{9310         \textcolor{keyword}{explicit} ExeName( std::string \&ref ) : ExeName() \{}
\DoxyCodeLine{9311             m\_ref = std::make\_shared<BoundValueRef<std::string>>( ref );}
\DoxyCodeLine{9312         \}}
\DoxyCodeLine{9313 }
\DoxyCodeLine{9314         \textcolor{keyword}{template}<\textcolor{keyword}{typename} LambdaT>}
\DoxyCodeLine{9315         \textcolor{keyword}{explicit} ExeName( LambdaT \textcolor{keyword}{const}\& lambda ) : ExeName() \{}
\DoxyCodeLine{9316             m\_ref = std::make\_shared<BoundLambda<LambdaT>>( lambda );}
\DoxyCodeLine{9317         \}}
\DoxyCodeLine{9318 }
\DoxyCodeLine{9319         \textcolor{comment}{// The exe name is not parsed out of the normal tokens, but is handled specially}}
\DoxyCodeLine{9320         \textcolor{keyword}{auto} parse( std::string \textcolor{keyword}{const}\&, TokenStream \textcolor{keyword}{const} \&tokens ) \textcolor{keyword}{const} -\/> InternalParseResult \textcolor{keyword}{override} \{}
\DoxyCodeLine{9321             \textcolor{keywordflow}{return} InternalParseResult::ok( ParseState( ParseResultType::NoMatch, tokens ) );}
\DoxyCodeLine{9322         \}}
\DoxyCodeLine{9323 }
\DoxyCodeLine{9324         \textcolor{keyword}{auto} name() const -\/> std::\textcolor{keywordtype}{string} \{ \textcolor{keywordflow}{return} *m\_name; \}}
\DoxyCodeLine{9325         \textcolor{keyword}{auto} set( std::string \textcolor{keyword}{const}\& newName ) -\/> ParserResult \{}
\DoxyCodeLine{9326 }
\DoxyCodeLine{9327             \textcolor{keyword}{auto} lastSlash = newName.find\_last\_of( \textcolor{stringliteral}{"{}\(\backslash\)\(\backslash\)/"{}} );}
\DoxyCodeLine{9328             \textcolor{keyword}{auto} filename = ( lastSlash == std::string::npos )}
\DoxyCodeLine{9329                     ? newName}
\DoxyCodeLine{9330                     : newName.substr( lastSlash+1 );}
\DoxyCodeLine{9331 }
\DoxyCodeLine{9332             *m\_name = filename;}
\DoxyCodeLine{9333             \textcolor{keywordflow}{if}( m\_ref )}
\DoxyCodeLine{9334                 \textcolor{keywordflow}{return} m\_ref-\/>setValue( filename );}
\DoxyCodeLine{9335             \textcolor{keywordflow}{else}}
\DoxyCodeLine{9336                 \textcolor{keywordflow}{return} ParserResult::ok( ParseResultType::Matched );}
\DoxyCodeLine{9337         \}}
\DoxyCodeLine{9338     \};}
\DoxyCodeLine{9339 }
\DoxyCodeLine{9340     \textcolor{keyword}{class }Arg : \textcolor{keyword}{public} ParserRefImpl<Arg> \{}
\DoxyCodeLine{9341     \textcolor{keyword}{public}:}
\DoxyCodeLine{9342         \textcolor{keyword}{using }ParserRefImpl::ParserRefImpl;}
\DoxyCodeLine{9343 }
\DoxyCodeLine{9344         \textcolor{keyword}{auto} parse( std::string \textcolor{keyword}{const} \&, TokenStream \textcolor{keyword}{const} \&tokens ) \textcolor{keyword}{const} -\/> InternalParseResult \textcolor{keyword}{override} \{}
\DoxyCodeLine{9345             \textcolor{keyword}{auto} validationResult = validate();}
\DoxyCodeLine{9346             \textcolor{keywordflow}{if}( !validationResult )}
\DoxyCodeLine{9347                 \textcolor{keywordflow}{return} InternalParseResult( validationResult );}
\DoxyCodeLine{9348 }
\DoxyCodeLine{9349             \textcolor{keyword}{auto} remainingTokens = tokens;}
\DoxyCodeLine{9350             \textcolor{keyword}{auto} \textcolor{keyword}{const} \&token = *remainingTokens;}
\DoxyCodeLine{9351             \textcolor{keywordflow}{if}( token.type != TokenType::Argument )}
\DoxyCodeLine{9352                 \textcolor{keywordflow}{return} InternalParseResult::ok( ParseState( ParseResultType::NoMatch, remainingTokens ) );}
\DoxyCodeLine{9353 }
\DoxyCodeLine{9354             assert( !m\_ref-\/>isFlag() );}
\DoxyCodeLine{9355             \textcolor{keyword}{auto} valueRef = \textcolor{keyword}{static\_cast<}detail::BoundValueRefBase*\textcolor{keyword}{>}( m\_ref.get() );}
\DoxyCodeLine{9356 }
\DoxyCodeLine{9357             \textcolor{keyword}{auto} result = valueRef-\/>setValue( remainingTokens-\/>token );}
\DoxyCodeLine{9358             \textcolor{keywordflow}{if}( !result )}
\DoxyCodeLine{9359                 \textcolor{keywordflow}{return} InternalParseResult( result );}
\DoxyCodeLine{9360             \textcolor{keywordflow}{else}}
\DoxyCodeLine{9361                 \textcolor{keywordflow}{return} InternalParseResult::ok( ParseState( ParseResultType::Matched, ++remainingTokens ) );}
\DoxyCodeLine{9362         \}}
\DoxyCodeLine{9363     \};}
\DoxyCodeLine{9364 }
\DoxyCodeLine{9365     \textcolor{keyword}{inline} \textcolor{keyword}{auto} normaliseOpt( std::string \textcolor{keyword}{const} \&optName ) -\/> std::string \{}
\DoxyCodeLine{9366 \textcolor{preprocessor}{\#ifdef CATCH\_PLATFORM\_WINDOWS}}
\DoxyCodeLine{9367         \textcolor{keywordflow}{if}( optName[0] == \textcolor{charliteral}{'/'} )}
\DoxyCodeLine{9368             \textcolor{keywordflow}{return} \textcolor{stringliteral}{"{}-\/"{}} + optName.substr( 1 );}
\DoxyCodeLine{9369         \textcolor{keywordflow}{else}}
\DoxyCodeLine{9370 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{9371             \textcolor{keywordflow}{return} optName;}
\DoxyCodeLine{9372     \}}
\DoxyCodeLine{9373 }
\DoxyCodeLine{9374     \textcolor{keyword}{class }Opt : \textcolor{keyword}{public} ParserRefImpl<Opt> \{}
\DoxyCodeLine{9375     \textcolor{keyword}{protected}:}
\DoxyCodeLine{9376         std::vector<std::string> m\_optNames;}
\DoxyCodeLine{9377 }
\DoxyCodeLine{9378     \textcolor{keyword}{public}:}
\DoxyCodeLine{9379         \textcolor{keyword}{template}<\textcolor{keyword}{typename} LambdaT>}
\DoxyCodeLine{9380         \textcolor{keyword}{explicit} Opt( LambdaT \textcolor{keyword}{const} \&ref ) : ParserRefImpl( std::make\_shared<BoundFlagLambda<LambdaT>>( ref ) ) \{\}}
\DoxyCodeLine{9381 }
\DoxyCodeLine{9382         \textcolor{keyword}{explicit} Opt( \textcolor{keywordtype}{bool} \&ref ) : ParserRefImpl( std::make\_shared<BoundFlagRef>( ref ) ) \{\}}
\DoxyCodeLine{9383 }
\DoxyCodeLine{9384         \textcolor{keyword}{template}<\textcolor{keyword}{typename} LambdaT>}
\DoxyCodeLine{9385         Opt( LambdaT \textcolor{keyword}{const} \&ref, std::string \textcolor{keyword}{const} \&hint ) : ParserRefImpl( ref, hint ) \{\}}
\DoxyCodeLine{9386 }
\DoxyCodeLine{9387         \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{9388         Opt( T \&ref, std::string \textcolor{keyword}{const} \&hint ) : ParserRefImpl( ref, hint ) \{\}}
\DoxyCodeLine{9389 }
\DoxyCodeLine{9390         \textcolor{keyword}{auto} operator[]( std::string \textcolor{keyword}{const} \&optName ) -\/> Opt \& \{}
\DoxyCodeLine{9391             m\_optNames.push\_back( optName );}
\DoxyCodeLine{9392             \textcolor{keywordflow}{return} *\textcolor{keyword}{this};}
\DoxyCodeLine{9393         \}}
\DoxyCodeLine{9394 }
\DoxyCodeLine{9395         \textcolor{keyword}{auto} getHelpColumns() const -\/> std::vector<HelpColumns> \{}
\DoxyCodeLine{9396             std::ostringstream oss;}
\DoxyCodeLine{9397             \textcolor{keywordtype}{bool} first = \textcolor{keyword}{true};}
\DoxyCodeLine{9398             \textcolor{keywordflow}{for}( \textcolor{keyword}{auto} \textcolor{keyword}{const} \&opt : m\_optNames ) \{}
\DoxyCodeLine{9399                 \textcolor{keywordflow}{if} (first)}
\DoxyCodeLine{9400                     first = \textcolor{keyword}{false};}
\DoxyCodeLine{9401                 \textcolor{keywordflow}{else}}
\DoxyCodeLine{9402                     oss << \textcolor{stringliteral}{"{}, "{}};}
\DoxyCodeLine{9403                 oss << opt;}
\DoxyCodeLine{9404             \}}
\DoxyCodeLine{9405             \textcolor{keywordflow}{if}( !m\_hint.empty() )}
\DoxyCodeLine{9406                 oss << \textcolor{stringliteral}{"{} <"{}} << m\_hint << \textcolor{stringliteral}{"{}>"{}};}
\DoxyCodeLine{9407             \textcolor{keywordflow}{return} \{ \{ oss.str(), m\_description \} \};}
\DoxyCodeLine{9408         \}}
\DoxyCodeLine{9409 }
\DoxyCodeLine{9410         \textcolor{keyword}{auto} isMatch( std::string \textcolor{keyword}{const} \&optToken ) \textcolor{keyword}{const} -\/> \textcolor{keywordtype}{bool} \{}
\DoxyCodeLine{9411             \textcolor{keyword}{auto} normalisedToken = normaliseOpt( optToken );}
\DoxyCodeLine{9412             \textcolor{keywordflow}{for}( \textcolor{keyword}{auto} \textcolor{keyword}{const} \&name : m\_optNames ) \{}
\DoxyCodeLine{9413                 \textcolor{keywordflow}{if}( normaliseOpt( name ) == normalisedToken )}
\DoxyCodeLine{9414                     \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{9415             \}}
\DoxyCodeLine{9416             \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{9417         \}}
\DoxyCodeLine{9418 }
\DoxyCodeLine{9419         \textcolor{keyword}{using }ParserBase::parse;}
\DoxyCodeLine{9420 }
\DoxyCodeLine{9421         \textcolor{keyword}{auto} parse( std::string \textcolor{keyword}{const}\&, TokenStream \textcolor{keyword}{const} \&tokens ) \textcolor{keyword}{const} -\/> InternalParseResult \textcolor{keyword}{override} \{}
\DoxyCodeLine{9422             \textcolor{keyword}{auto} validationResult = validate();}
\DoxyCodeLine{9423             \textcolor{keywordflow}{if}( !validationResult )}
\DoxyCodeLine{9424                 \textcolor{keywordflow}{return} InternalParseResult( validationResult );}
\DoxyCodeLine{9425 }
\DoxyCodeLine{9426             \textcolor{keyword}{auto} remainingTokens = tokens;}
\DoxyCodeLine{9427             \textcolor{keywordflow}{if}( remainingTokens \&\& remainingTokens-\/>type == TokenType::Option ) \{}
\DoxyCodeLine{9428                 \textcolor{keyword}{auto} \textcolor{keyword}{const} \&token = *remainingTokens;}
\DoxyCodeLine{9429                 \textcolor{keywordflow}{if}( isMatch(token.token ) ) \{}
\DoxyCodeLine{9430                     \textcolor{keywordflow}{if}( m\_ref-\/>isFlag() ) \{}
\DoxyCodeLine{9431                         \textcolor{keyword}{auto} flagRef = \textcolor{keyword}{static\_cast<}detail::BoundFlagRefBase*\textcolor{keyword}{>}( m\_ref.get() );}
\DoxyCodeLine{9432                         \textcolor{keyword}{auto} result = flagRef-\/>setFlag( \textcolor{keyword}{true} );}
\DoxyCodeLine{9433                         \textcolor{keywordflow}{if}( !result )}
\DoxyCodeLine{9434                             \textcolor{keywordflow}{return} InternalParseResult( result );}
\DoxyCodeLine{9435                         \textcolor{keywordflow}{if}( result.value() == ParseResultType::ShortCircuitAll )}
\DoxyCodeLine{9436                             \textcolor{keywordflow}{return} InternalParseResult::ok( ParseState( result.value(), remainingTokens ) );}
\DoxyCodeLine{9437                     \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{9438                         \textcolor{keyword}{auto} valueRef = \textcolor{keyword}{static\_cast<}detail::BoundValueRefBase*\textcolor{keyword}{>}( m\_ref.get() );}
\DoxyCodeLine{9439                         ++remainingTokens;}
\DoxyCodeLine{9440                         \textcolor{keywordflow}{if}( !remainingTokens )}
\DoxyCodeLine{9441                             \textcolor{keywordflow}{return} InternalParseResult::runtimeError( \textcolor{stringliteral}{"{}Expected argument following "{}} + token.token );}
\DoxyCodeLine{9442                         \textcolor{keyword}{auto} \textcolor{keyword}{const} \&argToken = *remainingTokens;}
\DoxyCodeLine{9443                         \textcolor{keywordflow}{if}( argToken.type != TokenType::Argument )}
\DoxyCodeLine{9444                             \textcolor{keywordflow}{return} InternalParseResult::runtimeError( \textcolor{stringliteral}{"{}Expected argument following "{}} + token.token );}
\DoxyCodeLine{9445                         \textcolor{keyword}{auto} result = valueRef-\/>setValue( argToken.token );}
\DoxyCodeLine{9446                         \textcolor{keywordflow}{if}( !result )}
\DoxyCodeLine{9447                             \textcolor{keywordflow}{return} InternalParseResult( result );}
\DoxyCodeLine{9448                         \textcolor{keywordflow}{if}( result.value() == ParseResultType::ShortCircuitAll )}
\DoxyCodeLine{9449                             \textcolor{keywordflow}{return} InternalParseResult::ok( ParseState( result.value(), remainingTokens ) );}
\DoxyCodeLine{9450                     \}}
\DoxyCodeLine{9451                     \textcolor{keywordflow}{return} InternalParseResult::ok( ParseState( ParseResultType::Matched, ++remainingTokens ) );}
\DoxyCodeLine{9452                 \}}
\DoxyCodeLine{9453             \}}
\DoxyCodeLine{9454             \textcolor{keywordflow}{return} InternalParseResult::ok( ParseState( ParseResultType::NoMatch, remainingTokens ) );}
\DoxyCodeLine{9455         \}}
\DoxyCodeLine{9456 }
\DoxyCodeLine{9457         \textcolor{keyword}{auto} validate() const -\/> Result\textcolor{keyword}{ override }\{}
\DoxyCodeLine{9458             \textcolor{keywordflow}{if}( m\_optNames.empty() )}
\DoxyCodeLine{9459                 \textcolor{keywordflow}{return} Result::logicError( \textcolor{stringliteral}{"{}No options supplied to Opt"{}} );}
\DoxyCodeLine{9460             \textcolor{keywordflow}{for}( \textcolor{keyword}{auto} \textcolor{keyword}{const} \&name : m\_optNames ) \{}
\DoxyCodeLine{9461                 \textcolor{keywordflow}{if}( name.empty() )}
\DoxyCodeLine{9462                     \textcolor{keywordflow}{return} Result::logicError( \textcolor{stringliteral}{"{}Option name cannot be empty"{}} );}
\DoxyCodeLine{9463 \textcolor{preprocessor}{\#ifdef CATCH\_PLATFORM\_WINDOWS}}
\DoxyCodeLine{9464                 \textcolor{keywordflow}{if}( name[0] != \textcolor{charliteral}{'-\/'} \&\& name[0] != \textcolor{charliteral}{'/'} )}
\DoxyCodeLine{9465                     \textcolor{keywordflow}{return} Result::logicError( \textcolor{stringliteral}{"{}Option name must begin with '-\/' or '/'"{}} );}
\DoxyCodeLine{9466 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{9467                 \textcolor{keywordflow}{if}( name[0] != \textcolor{charliteral}{'-\/'} )}
\DoxyCodeLine{9468                     \textcolor{keywordflow}{return} Result::logicError( \textcolor{stringliteral}{"{}Option name must begin with '-\/'"{}} );}
\DoxyCodeLine{9469 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{9470             \}}
\DoxyCodeLine{9471             \textcolor{keywordflow}{return} ParserRefImpl::validate();}
\DoxyCodeLine{9472         \}}
\DoxyCodeLine{9473     \};}
\DoxyCodeLine{9474 }
\DoxyCodeLine{9475     \textcolor{keyword}{struct }Help : Opt \{}
\DoxyCodeLine{9476         Help( \textcolor{keywordtype}{bool} \&showHelpFlag )}
\DoxyCodeLine{9477         :   Opt([\&]( bool flag ) \{}
\DoxyCodeLine{9478                 showHelpFlag = flag;}
\DoxyCodeLine{9479                 \textcolor{keywordflow}{return} ParserResult::ok( ParseResultType::ShortCircuitAll );}
\DoxyCodeLine{9480             \})}
\DoxyCodeLine{9481         \{}
\DoxyCodeLine{9482             \textcolor{keyword}{static\_cast<}Opt \&\textcolor{keyword}{>}( *this )}
\DoxyCodeLine{9483                     (\textcolor{stringliteral}{"{}display usage information"{}})}
\DoxyCodeLine{9484                     [\textcolor{stringliteral}{"{}-\/?"{}}][\textcolor{stringliteral}{"{}-\/h"{}}][\textcolor{stringliteral}{"{}-\/-\/help"{}}]}
\DoxyCodeLine{9485                     .optional();}
\DoxyCodeLine{9486         \}}
\DoxyCodeLine{9487     \};}
\DoxyCodeLine{9488 }
\DoxyCodeLine{9489     \textcolor{keyword}{struct }Parser : ParserBase \{}
\DoxyCodeLine{9490 }
\DoxyCodeLine{9491         \textcolor{keyword}{mutable} ExeName m\_exeName;}
\DoxyCodeLine{9492         std::vector<Opt> m\_options;}
\DoxyCodeLine{9493         std::vector<Arg> m\_args;}
\DoxyCodeLine{9494 }
\DoxyCodeLine{9495         \textcolor{keyword}{auto} operator|=( ExeName \textcolor{keyword}{const} \&exeName ) -\/> Parser \& \{}
\DoxyCodeLine{9496             m\_exeName = exeName;}
\DoxyCodeLine{9497             \textcolor{keywordflow}{return} *\textcolor{keyword}{this};}
\DoxyCodeLine{9498         \}}
\DoxyCodeLine{9499 }
\DoxyCodeLine{9500         \textcolor{keyword}{auto} operator|=( Arg \textcolor{keyword}{const} \&arg ) -\/> Parser \& \{}
\DoxyCodeLine{9501             m\_args.push\_back(arg);}
\DoxyCodeLine{9502             \textcolor{keywordflow}{return} *\textcolor{keyword}{this};}
\DoxyCodeLine{9503         \}}
\DoxyCodeLine{9504 }
\DoxyCodeLine{9505         \textcolor{keyword}{auto} operator|=( Opt \textcolor{keyword}{const} \&opt ) -\/> Parser \& \{}
\DoxyCodeLine{9506             m\_options.push\_back(opt);}
\DoxyCodeLine{9507             \textcolor{keywordflow}{return} *\textcolor{keyword}{this};}
\DoxyCodeLine{9508         \}}
\DoxyCodeLine{9509 }
\DoxyCodeLine{9510         \textcolor{keyword}{auto} operator|=( Parser \textcolor{keyword}{const} \&other ) -\/> Parser \& \{}
\DoxyCodeLine{9511             m\_options.insert(m\_options.end(), other.m\_options.begin(), other.m\_options.end());}
\DoxyCodeLine{9512             m\_args.insert(m\_args.end(), other.m\_args.begin(), other.m\_args.end());}
\DoxyCodeLine{9513             \textcolor{keywordflow}{return} *\textcolor{keyword}{this};}
\DoxyCodeLine{9514         \}}
\DoxyCodeLine{9515 }
\DoxyCodeLine{9516         \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{9517         \textcolor{keyword}{auto} operator|( T \textcolor{keyword}{const} \&other ) \textcolor{keyword}{const} -\/> Parser \{}
\DoxyCodeLine{9518             \textcolor{keywordflow}{return} Parser( *\textcolor{keyword}{this} ) |= other;}
\DoxyCodeLine{9519         \}}
\DoxyCodeLine{9520 }
\DoxyCodeLine{9521         \textcolor{comment}{// Forward deprecated interface with '+' instead of '|'}}
\DoxyCodeLine{9522         \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{9523         \textcolor{keyword}{auto} operator+=( T \textcolor{keyword}{const} \&other ) -\/> Parser \& \{ \textcolor{keywordflow}{return} operator|=( other ); \}}
\DoxyCodeLine{9524         \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{9525         \textcolor{keyword}{auto} operator+( T \textcolor{keyword}{const} \&other ) \textcolor{keyword}{const} -\/> Parser \{ \textcolor{keywordflow}{return} operator|( other ); \}}
\DoxyCodeLine{9526 }
\DoxyCodeLine{9527         \textcolor{keyword}{auto} getHelpColumns() const -\/> std::vector<HelpColumns> \{}
\DoxyCodeLine{9528             std::vector<HelpColumns> cols;}
\DoxyCodeLine{9529             \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} \textcolor{keyword}{const} \&o : m\_options) \{}
\DoxyCodeLine{9530                 \textcolor{keyword}{auto} childCols = o.getHelpColumns();}
\DoxyCodeLine{9531                 cols.insert( cols.end(), childCols.begin(), childCols.end() );}
\DoxyCodeLine{9532             \}}
\DoxyCodeLine{9533             \textcolor{keywordflow}{return} cols;}
\DoxyCodeLine{9534         \}}
\DoxyCodeLine{9535 }
\DoxyCodeLine{9536         \textcolor{keywordtype}{void} writeToStream( std::ostream \&os )\textcolor{keyword}{ const }\{}
\DoxyCodeLine{9537             \textcolor{keywordflow}{if} (!m\_exeName.name().empty()) \{}
\DoxyCodeLine{9538                 os << \textcolor{stringliteral}{"{}usage:\(\backslash\)n"{}} << \textcolor{stringliteral}{"{}  "{}} << m\_exeName.name() << \textcolor{stringliteral}{"{} "{}};}
\DoxyCodeLine{9539                 \textcolor{keywordtype}{bool} required = \textcolor{keyword}{true}, first = \textcolor{keyword}{true};}
\DoxyCodeLine{9540                 \textcolor{keywordflow}{for}( \textcolor{keyword}{auto} \textcolor{keyword}{const} \&arg : m\_args ) \{}
\DoxyCodeLine{9541                     \textcolor{keywordflow}{if} (first)}
\DoxyCodeLine{9542                         first = \textcolor{keyword}{false};}
\DoxyCodeLine{9543                     \textcolor{keywordflow}{else}}
\DoxyCodeLine{9544                         os << \textcolor{stringliteral}{"{} "{}};}
\DoxyCodeLine{9545                     \textcolor{keywordflow}{if}( arg.isOptional() \&\& required ) \{}
\DoxyCodeLine{9546                         os << \textcolor{stringliteral}{"{}["{}};}
\DoxyCodeLine{9547                         required = \textcolor{keyword}{false};}
\DoxyCodeLine{9548                     \}}
\DoxyCodeLine{9549                     os << \textcolor{stringliteral}{"{}<"{}} << arg.hint() << \textcolor{stringliteral}{"{}>"{}};}
\DoxyCodeLine{9550                     \textcolor{keywordflow}{if}( arg.cardinality() == 0 )}
\DoxyCodeLine{9551                         os << \textcolor{stringliteral}{"{} ... "{}};}
\DoxyCodeLine{9552                 \}}
\DoxyCodeLine{9553                 \textcolor{keywordflow}{if}( !required )}
\DoxyCodeLine{9554                     os << \textcolor{stringliteral}{"{}]"{}};}
\DoxyCodeLine{9555                 \textcolor{keywordflow}{if}( !m\_options.empty() )}
\DoxyCodeLine{9556                     os << \textcolor{stringliteral}{"{} options"{}};}
\DoxyCodeLine{9557                 os << \textcolor{stringliteral}{"{}\(\backslash\)n\(\backslash\)nwhere options are:"{}} << std::endl;}
\DoxyCodeLine{9558             \}}
\DoxyCodeLine{9559 }
\DoxyCodeLine{9560             \textcolor{keyword}{auto} rows = getHelpColumns();}
\DoxyCodeLine{9561             \textcolor{keywordtype}{size\_t} consoleWidth = CATCH\_CLARA\_CONFIG\_CONSOLE\_WIDTH;}
\DoxyCodeLine{9562             \textcolor{keywordtype}{size\_t} optWidth = 0;}
\DoxyCodeLine{9563             \textcolor{keywordflow}{for}( \textcolor{keyword}{auto} \textcolor{keyword}{const} \&cols : rows )}
\DoxyCodeLine{9564                 optWidth = (std::max)(optWidth, cols.left.size() + 2);}
\DoxyCodeLine{9565 }
\DoxyCodeLine{9566             optWidth = (std::min)(optWidth, consoleWidth/2);}
\DoxyCodeLine{9567 }
\DoxyCodeLine{9568             \textcolor{keywordflow}{for}( \textcolor{keyword}{auto} \textcolor{keyword}{const} \&cols : rows ) \{}
\DoxyCodeLine{9569                 \textcolor{keyword}{auto} row =}
\DoxyCodeLine{9570                         TextFlow::Column( cols.left ).width( optWidth ).indent( 2 ) +}
\DoxyCodeLine{9571                         TextFlow::Spacer(4) +}
\DoxyCodeLine{9572                         TextFlow::Column( cols.right ).width( consoleWidth -\/ 7 -\/ optWidth );}
\DoxyCodeLine{9573                 os << row << std::endl;}
\DoxyCodeLine{9574             \}}
\DoxyCodeLine{9575         \}}
\DoxyCodeLine{9576 }
\DoxyCodeLine{9577         \textcolor{keyword}{friend} \textcolor{keyword}{auto} operator<<( std::ostream \&os, Parser \textcolor{keyword}{const} \&parser ) -\/> std::ostream\& \{}
\DoxyCodeLine{9578             parser.writeToStream( os );}
\DoxyCodeLine{9579             \textcolor{keywordflow}{return} os;}
\DoxyCodeLine{9580         \}}
\DoxyCodeLine{9581 }
\DoxyCodeLine{9582         \textcolor{keyword}{auto} validate() const -\/> Result\textcolor{keyword}{ override }\{}
\DoxyCodeLine{9583             \textcolor{keywordflow}{for}( \textcolor{keyword}{auto} \textcolor{keyword}{const} \&opt : m\_options ) \{}
\DoxyCodeLine{9584                 \textcolor{keyword}{auto} result = opt.validate();}
\DoxyCodeLine{9585                 \textcolor{keywordflow}{if}( !result )}
\DoxyCodeLine{9586                     \textcolor{keywordflow}{return} result;}
\DoxyCodeLine{9587             \}}
\DoxyCodeLine{9588             \textcolor{keywordflow}{for}( \textcolor{keyword}{auto} \textcolor{keyword}{const} \&arg : m\_args ) \{}
\DoxyCodeLine{9589                 \textcolor{keyword}{auto} result = arg.validate();}
\DoxyCodeLine{9590                 \textcolor{keywordflow}{if}( !result )}
\DoxyCodeLine{9591                     \textcolor{keywordflow}{return} result;}
\DoxyCodeLine{9592             \}}
\DoxyCodeLine{9593             \textcolor{keywordflow}{return} Result::ok();}
\DoxyCodeLine{9594         \}}
\DoxyCodeLine{9595 }
\DoxyCodeLine{9596         \textcolor{keyword}{using }ParserBase::parse;}
\DoxyCodeLine{9597 }
\DoxyCodeLine{9598         \textcolor{keyword}{auto} parse( std::string \textcolor{keyword}{const}\& exeName, TokenStream \textcolor{keyword}{const} \&tokens ) \textcolor{keyword}{const} -\/> InternalParseResult \textcolor{keyword}{override} \{}
\DoxyCodeLine{9599 }
\DoxyCodeLine{9600             \textcolor{keyword}{struct }ParserInfo \{}
\DoxyCodeLine{9601                 ParserBase \textcolor{keyword}{const}* parser = \textcolor{keyword}{nullptr};}
\DoxyCodeLine{9602                 \textcolor{keywordtype}{size\_t} count = 0;}
\DoxyCodeLine{9603             \};}
\DoxyCodeLine{9604             \textcolor{keyword}{const} \textcolor{keywordtype}{size\_t} totalParsers = m\_options.size() + m\_args.size();}
\DoxyCodeLine{9605             assert( totalParsers < 512 );}
\DoxyCodeLine{9606             \textcolor{comment}{// ParserInfo parseInfos[totalParsers]; // <-\/-\/ this is what we really want to do}}
\DoxyCodeLine{9607             ParserInfo parseInfos[512];}
\DoxyCodeLine{9608 }
\DoxyCodeLine{9609             \{}
\DoxyCodeLine{9610                 \textcolor{keywordtype}{size\_t} i = 0;}
\DoxyCodeLine{9611                 \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} \textcolor{keyword}{const} \&opt : m\_options) parseInfos[i++].parser = \&opt;}
\DoxyCodeLine{9612                 \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} \textcolor{keyword}{const} \&arg : m\_args) parseInfos[i++].parser = \&arg;}
\DoxyCodeLine{9613             \}}
\DoxyCodeLine{9614 }
\DoxyCodeLine{9615             m\_exeName.set( exeName );}
\DoxyCodeLine{9616 }
\DoxyCodeLine{9617             \textcolor{keyword}{auto} result = InternalParseResult::ok( ParseState( ParseResultType::NoMatch, tokens ) );}
\DoxyCodeLine{9618             \textcolor{keywordflow}{while}( result.value().remainingTokens() ) \{}
\DoxyCodeLine{9619                 \textcolor{keywordtype}{bool} tokenParsed = \textcolor{keyword}{false};}
\DoxyCodeLine{9620 }
\DoxyCodeLine{9621                 \textcolor{keywordflow}{for}( \textcolor{keywordtype}{size\_t} i = 0; i < totalParsers; ++i ) \{}
\DoxyCodeLine{9622                     \textcolor{keyword}{auto}\&  parseInfo = parseInfos[i];}
\DoxyCodeLine{9623                     \textcolor{keywordflow}{if}( parseInfo.parser-\/>cardinality() == 0 || parseInfo.count < parseInfo.parser-\/>cardinality() ) \{}
\DoxyCodeLine{9624                         result = parseInfo.parser-\/>parse(exeName, result.value().remainingTokens());}
\DoxyCodeLine{9625                         if (!result)}
\DoxyCodeLine{9626                             return result;}
\DoxyCodeLine{9627                         if (result.value().type() != ParseResultType::NoMatch) \{}
\DoxyCodeLine{9628                             tokenParsed = true;}
\DoxyCodeLine{9629                             ++parseInfo.count;}
\DoxyCodeLine{9630                             break;}
\DoxyCodeLine{9631                         \}}
\DoxyCodeLine{9632                     \}}
\DoxyCodeLine{9633                 \}}
\DoxyCodeLine{9634 }
\DoxyCodeLine{9635                 \textcolor{keywordflow}{if}( result.value().type() == ParseResultType::ShortCircuitAll )}
\DoxyCodeLine{9636                     \textcolor{keywordflow}{return} result;}
\DoxyCodeLine{9637                 \textcolor{keywordflow}{if}( !tokenParsed )}
\DoxyCodeLine{9638                     \textcolor{keywordflow}{return} InternalParseResult::runtimeError( \textcolor{stringliteral}{"{}Unrecognised token: "{}} + result.value().remainingTokens()-\/>token );}
\DoxyCodeLine{9639             \}}
\DoxyCodeLine{9640             \textcolor{comment}{// !TBD Check missing required options}}
\DoxyCodeLine{9641             \textcolor{keywordflow}{return} result;}
\DoxyCodeLine{9642         \}}
\DoxyCodeLine{9643     \};}
\DoxyCodeLine{9644 }
\DoxyCodeLine{9645     \textcolor{keyword}{template}<\textcolor{keyword}{typename} DerivedT>}
\DoxyCodeLine{9646     \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{9647     \textcolor{keyword}{auto} ComposableParserImpl<DerivedT>::operator|( T \textcolor{keyword}{const} \&other ) \textcolor{keyword}{const} -\/> Parser \{}
\DoxyCodeLine{9648         \textcolor{keywordflow}{return} Parser() | \textcolor{keyword}{static\_cast<}DerivedT \textcolor{keyword}{const }\&\textcolor{keyword}{>}( *this ) | other;}
\DoxyCodeLine{9649     \}}
\DoxyCodeLine{9650 \} \textcolor{comment}{// namespace detail}}
\DoxyCodeLine{9651 }
\DoxyCodeLine{9652 \textcolor{comment}{// A Combined parser}}
\DoxyCodeLine{9653 \textcolor{keyword}{using }detail::Parser;}
\DoxyCodeLine{9654 }
\DoxyCodeLine{9655 \textcolor{comment}{// A parser for options}}
\DoxyCodeLine{9656 \textcolor{keyword}{using }detail::Opt;}
\DoxyCodeLine{9657 }
\DoxyCodeLine{9658 \textcolor{comment}{// A parser for arguments}}
\DoxyCodeLine{9659 \textcolor{keyword}{using }detail::Arg;}
\DoxyCodeLine{9660 }
\DoxyCodeLine{9661 \textcolor{comment}{// Wrapper for argc, argv from main()}}
\DoxyCodeLine{9662 \textcolor{keyword}{using }detail::Args;}
\DoxyCodeLine{9663 }
\DoxyCodeLine{9664 \textcolor{comment}{// Specifies the name of the executable}}
\DoxyCodeLine{9665 \textcolor{keyword}{using }detail::ExeName;}
\DoxyCodeLine{9666 }
\DoxyCodeLine{9667 \textcolor{comment}{// Convenience wrapper for option parser that specifies the help option}}
\DoxyCodeLine{9668 \textcolor{keyword}{using }detail::Help;}
\DoxyCodeLine{9669 }
\DoxyCodeLine{9670 \textcolor{comment}{// enum of result types from a parse}}
\DoxyCodeLine{9671 \textcolor{keyword}{using }detail::ParseResultType;}
\DoxyCodeLine{9672 }
\DoxyCodeLine{9673 \textcolor{comment}{// Result type for parser operation}}
\DoxyCodeLine{9674 \textcolor{keyword}{using }detail::ParserResult;}
\DoxyCodeLine{9675 }
\DoxyCodeLine{9676 \}\} \textcolor{comment}{// namespace Catch::clara}}
\DoxyCodeLine{9677 }
\DoxyCodeLine{9678 \textcolor{comment}{// end clara.hpp}}
\DoxyCodeLine{9679 \textcolor{preprocessor}{\#ifdef \_\_clang\_\_}}
\DoxyCodeLine{9680 \textcolor{preprocessor}{\#pragma clang diagnostic pop}}
\DoxyCodeLine{9681 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{9682 }
\DoxyCodeLine{9683 \textcolor{comment}{// Restore Clara's value for console width, if present}}
\DoxyCodeLine{9684 \textcolor{preprocessor}{\#ifdef CATCH\_TEMP\_CLARA\_CONFIG\_CONSOLE\_WIDTH}}
\DoxyCodeLine{9685 \textcolor{preprocessor}{\#define CATCH\_CLARA\_TEXTFLOW\_CONFIG\_CONSOLE\_WIDTH CATCH\_TEMP\_CLARA\_CONFIG\_CONSOLE\_WIDTH}}
\DoxyCodeLine{9686 \textcolor{preprocessor}{\#undef CATCH\_TEMP\_CLARA\_CONFIG\_CONSOLE\_WIDTH}}
\DoxyCodeLine{9687 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{9688 }
\DoxyCodeLine{9689 \textcolor{comment}{// end catch\_clara.h}}
\DoxyCodeLine{9690 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{9691 }
\DoxyCodeLine{9692     clara::Parser makeCommandLineParser( ConfigData\& config );}
\DoxyCodeLine{9693 }
\DoxyCodeLine{9694 \} \textcolor{comment}{// end namespace Catch}}
\DoxyCodeLine{9695 }
\DoxyCodeLine{9696 \textcolor{comment}{// end catch\_commandline.h}}
\DoxyCodeLine{9697 \textcolor{preprocessor}{\#include <fstream>}}
\DoxyCodeLine{9698 \textcolor{preprocessor}{\#include <ctime>}}
\DoxyCodeLine{9699 }
\DoxyCodeLine{9700 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{9701 }
\DoxyCodeLine{9702     clara::Parser makeCommandLineParser( ConfigData\& config ) \{}
\DoxyCodeLine{9703 }
\DoxyCodeLine{9704         \textcolor{keyword}{using namespace }clara;}
\DoxyCodeLine{9705 }
\DoxyCodeLine{9706         \textcolor{keyword}{auto} \textcolor{keyword}{const} setWarning = [\&]( std::string \textcolor{keyword}{const}\& warning ) \{}
\DoxyCodeLine{9707                 \textcolor{keyword}{auto} warningSet = [\&]() \{}
\DoxyCodeLine{9708                     \textcolor{keywordflow}{if}( warning == \textcolor{stringliteral}{"{}NoAssertions"{}} )}
\DoxyCodeLine{9709                         \textcolor{keywordflow}{return} WarnAbout::NoAssertions;}
\DoxyCodeLine{9710 }
\DoxyCodeLine{9711                     \textcolor{keywordflow}{if} ( warning == \textcolor{stringliteral}{"{}NoTests"{}} )}
\DoxyCodeLine{9712                         \textcolor{keywordflow}{return} WarnAbout::NoTests;}
\DoxyCodeLine{9713 }
\DoxyCodeLine{9714                     \textcolor{keywordflow}{return} WarnAbout::Nothing;}
\DoxyCodeLine{9715                 \}();}
\DoxyCodeLine{9716 }
\DoxyCodeLine{9717                 \textcolor{keywordflow}{if} (warningSet == WarnAbout::Nothing)}
\DoxyCodeLine{9718                     \textcolor{keywordflow}{return} ParserResult::runtimeError( \textcolor{stringliteral}{"{}Unrecognised warning: '"{}} + warning + \textcolor{stringliteral}{"{}'"{}} );}
\DoxyCodeLine{9719                 config.warnings = \textcolor{keyword}{static\_cast<}WarnAbout::What\textcolor{keyword}{>}( config.warnings | warningSet );}
\DoxyCodeLine{9720                 \textcolor{keywordflow}{return} ParserResult::ok( ParseResultType::Matched );}
\DoxyCodeLine{9721             \};}
\DoxyCodeLine{9722         \textcolor{keyword}{auto} \textcolor{keyword}{const} loadTestNamesFromFile = [\&]( std::string \textcolor{keyword}{const}\& filename ) \{}
\DoxyCodeLine{9723                 std::ifstream f( filename.c\_str() );}
\DoxyCodeLine{9724                 \textcolor{keywordflow}{if}( !f.is\_open() )}
\DoxyCodeLine{9725                     \textcolor{keywordflow}{return} ParserResult::runtimeError( \textcolor{stringliteral}{"{}Unable to load input file: '"{}} + filename + \textcolor{stringliteral}{"{}'"{}} );}
\DoxyCodeLine{9726 }
\DoxyCodeLine{9727                 std::string line;}
\DoxyCodeLine{9728                 \textcolor{keywordflow}{while}( std::getline( f, line ) ) \{}
\DoxyCodeLine{9729                     line = trim(line);}
\DoxyCodeLine{9730                     \textcolor{keywordflow}{if}( !line.empty() \&\& !startsWith( line, \textcolor{charliteral}{'\#'} ) ) \{}
\DoxyCodeLine{9731                         \textcolor{keywordflow}{if}( !startsWith( line, \textcolor{charliteral}{'"{}'} ) )}
\DoxyCodeLine{9732                             line = \textcolor{charliteral}{'"{}'} + line + '"{}';}
\DoxyCodeLine{9733                         config.testsOrTags.push\_back( line );}
\DoxyCodeLine{9734                         config.testsOrTags.emplace\_back( \textcolor{stringliteral}{"{},"{}} );}
\DoxyCodeLine{9735                     \}}
\DoxyCodeLine{9736                 \}}
\DoxyCodeLine{9737                 \textcolor{comment}{//Remove comma in the end}}
\DoxyCodeLine{9738                 \textcolor{keywordflow}{if}(!config.testsOrTags.empty())}
\DoxyCodeLine{9739                     config.testsOrTags.erase( config.testsOrTags.end()-\/1 );}
\DoxyCodeLine{9740 }
\DoxyCodeLine{9741                 \textcolor{keywordflow}{return} ParserResult::ok( ParseResultType::Matched );}
\DoxyCodeLine{9742             \};}
\DoxyCodeLine{9743         \textcolor{keyword}{auto} \textcolor{keyword}{const} setTestOrder = [\&]( std::string \textcolor{keyword}{const}\& order ) \{}
\DoxyCodeLine{9744                 \textcolor{keywordflow}{if}( startsWith( \textcolor{stringliteral}{"{}declared"{}}, order ) )}
\DoxyCodeLine{9745                     config.runOrder = RunTests::InDeclarationOrder;}
\DoxyCodeLine{9746                 \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}( startsWith( \textcolor{stringliteral}{"{}lexical"{}}, order ) )}
\DoxyCodeLine{9747                     config.runOrder = RunTests::InLexicographicalOrder;}
\DoxyCodeLine{9748                 \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}( startsWith( \textcolor{stringliteral}{"{}random"{}}, order ) )}
\DoxyCodeLine{9749                     config.runOrder = RunTests::InRandomOrder;}
\DoxyCodeLine{9750                 \textcolor{keywordflow}{else}}
\DoxyCodeLine{9751                     \textcolor{keywordflow}{return} clara::ParserResult::runtimeError( \textcolor{stringliteral}{"{}Unrecognised ordering: '"{}} + order + \textcolor{stringliteral}{"{}'"{}} );}
\DoxyCodeLine{9752                 \textcolor{keywordflow}{return} ParserResult::ok( ParseResultType::Matched );}
\DoxyCodeLine{9753             \};}
\DoxyCodeLine{9754         \textcolor{keyword}{auto} \textcolor{keyword}{const} setRngSeed = [\&]( std::string \textcolor{keyword}{const}\& seed ) \{}
\DoxyCodeLine{9755                 \textcolor{keywordflow}{if}( seed != \textcolor{stringliteral}{"{}time"{}} )}
\DoxyCodeLine{9756                     \textcolor{keywordflow}{return} clara::detail::convertInto( seed, config.rngSeed );}
\DoxyCodeLine{9757                 config.rngSeed = \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int}\textcolor{keyword}{>}( std::time(\textcolor{keyword}{nullptr}) );}
\DoxyCodeLine{9758                 \textcolor{keywordflow}{return} ParserResult::ok( ParseResultType::Matched );}
\DoxyCodeLine{9759             \};}
\DoxyCodeLine{9760         \textcolor{keyword}{auto} \textcolor{keyword}{const} setColourUsage = [\&]( std::string \textcolor{keyword}{const}\& useColour ) \{}
\DoxyCodeLine{9761                     \textcolor{keyword}{auto} mode = toLower( useColour );}
\DoxyCodeLine{9762 }
\DoxyCodeLine{9763                     \textcolor{keywordflow}{if}( mode == \textcolor{stringliteral}{"{}yes"{}} )}
\DoxyCodeLine{9764                         config.useColour = UseColour::Yes;}
\DoxyCodeLine{9765                     \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}( mode == \textcolor{stringliteral}{"{}no"{}} )}
\DoxyCodeLine{9766                         config.useColour = UseColour::No;}
\DoxyCodeLine{9767                     \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}( mode == \textcolor{stringliteral}{"{}auto"{}} )}
\DoxyCodeLine{9768                         config.useColour = UseColour::Auto;}
\DoxyCodeLine{9769                     \textcolor{keywordflow}{else}}
\DoxyCodeLine{9770                         \textcolor{keywordflow}{return} ParserResult::runtimeError( \textcolor{stringliteral}{"{}colour mode must be one of: auto, yes or no. '"{}} + useColour + \textcolor{stringliteral}{"{}' not recognised"{}} );}
\DoxyCodeLine{9771                 \textcolor{keywordflow}{return} ParserResult::ok( ParseResultType::Matched );}
\DoxyCodeLine{9772             \};}
\DoxyCodeLine{9773         \textcolor{keyword}{auto} \textcolor{keyword}{const} setWaitForKeypress = [\&]( std::string \textcolor{keyword}{const}\& keypress ) \{}
\DoxyCodeLine{9774                 \textcolor{keyword}{auto} keypressLc = toLower( keypress );}
\DoxyCodeLine{9775                 \textcolor{keywordflow}{if} (keypressLc == \textcolor{stringliteral}{"{}never"{}})}
\DoxyCodeLine{9776                     config.waitForKeypress = WaitForKeypress::Never;}
\DoxyCodeLine{9777                 \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}( keypressLc == \textcolor{stringliteral}{"{}start"{}} )}
\DoxyCodeLine{9778                     config.waitForKeypress = WaitForKeypress::BeforeStart;}
\DoxyCodeLine{9779                 \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}( keypressLc == \textcolor{stringliteral}{"{}exit"{}} )}
\DoxyCodeLine{9780                     config.waitForKeypress = WaitForKeypress::BeforeExit;}
\DoxyCodeLine{9781                 \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}( keypressLc == \textcolor{stringliteral}{"{}both"{}} )}
\DoxyCodeLine{9782                     config.waitForKeypress = WaitForKeypress::BeforeStartAndExit;}
\DoxyCodeLine{9783                 \textcolor{keywordflow}{else}}
\DoxyCodeLine{9784                     \textcolor{keywordflow}{return} ParserResult::runtimeError( \textcolor{stringliteral}{"{}keypress argument must be one of: never, start, exit or both. '"{}} + keypress + \textcolor{stringliteral}{"{}' not recognised"{}} );}
\DoxyCodeLine{9785             \textcolor{keywordflow}{return} ParserResult::ok( ParseResultType::Matched );}
\DoxyCodeLine{9786             \};}
\DoxyCodeLine{9787         \textcolor{keyword}{auto} \textcolor{keyword}{const} setVerbosity = [\&]( std::string \textcolor{keyword}{const}\& verbosity ) \{}
\DoxyCodeLine{9788             \textcolor{keyword}{auto} lcVerbosity = toLower( verbosity );}
\DoxyCodeLine{9789             \textcolor{keywordflow}{if}( lcVerbosity == \textcolor{stringliteral}{"{}quiet"{}} )}
\DoxyCodeLine{9790                 config.verbosity = Verbosity::Quiet;}
\DoxyCodeLine{9791             \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}( lcVerbosity == \textcolor{stringliteral}{"{}normal"{}} )}
\DoxyCodeLine{9792                 config.verbosity = Verbosity::Normal;}
\DoxyCodeLine{9793             \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}( lcVerbosity == \textcolor{stringliteral}{"{}high"{}} )}
\DoxyCodeLine{9794                 config.verbosity = Verbosity::High;}
\DoxyCodeLine{9795             \textcolor{keywordflow}{else}}
\DoxyCodeLine{9796                 \textcolor{keywordflow}{return} ParserResult::runtimeError( \textcolor{stringliteral}{"{}Unrecognised verbosity, '"{}} + verbosity + \textcolor{stringliteral}{"{}'"{}} );}
\DoxyCodeLine{9797             \textcolor{keywordflow}{return} ParserResult::ok( ParseResultType::Matched );}
\DoxyCodeLine{9798         \};}
\DoxyCodeLine{9799         \textcolor{keyword}{auto} \textcolor{keyword}{const} setReporter = [\&]( std::string \textcolor{keyword}{const}\& reporter ) \{}
\DoxyCodeLine{9800             IReporterRegistry::FactoryMap \textcolor{keyword}{const}\& factories = getRegistryHub().getReporterRegistry().getFactories();}
\DoxyCodeLine{9801 }
\DoxyCodeLine{9802             \textcolor{keyword}{auto} lcReporter = toLower( reporter );}
\DoxyCodeLine{9803             \textcolor{keyword}{auto} result = factories.find( lcReporter );}
\DoxyCodeLine{9804 }
\DoxyCodeLine{9805             \textcolor{keywordflow}{if}( factories.end() != result )}
\DoxyCodeLine{9806                 config.reporterName = lcReporter;}
\DoxyCodeLine{9807             \textcolor{keywordflow}{else}}
\DoxyCodeLine{9808                 \textcolor{keywordflow}{return} ParserResult::runtimeError( \textcolor{stringliteral}{"{}Unrecognized reporter, '"{}} + reporter + \textcolor{stringliteral}{"{}'. Check available with -\/-\/list-\/reporters"{}} );}
\DoxyCodeLine{9809             \textcolor{keywordflow}{return} ParserResult::ok( ParseResultType::Matched );}
\DoxyCodeLine{9810         \};}
\DoxyCodeLine{9811 }
\DoxyCodeLine{9812         \textcolor{keyword}{auto} cli}
\DoxyCodeLine{9813             = ExeName( config.processName )}
\DoxyCodeLine{9814             | Help( config.showHelp )}
\DoxyCodeLine{9815             | Opt( config.listTests )}
\DoxyCodeLine{9816                 ["{}-\/l"{}]["{}-\/-\/list-\/tests"{}]}
\DoxyCodeLine{9817                 ( \textcolor{stringliteral}{"{}list all/matching test cases"{}} )}
\DoxyCodeLine{9818             | Opt( config.listTags )}
\DoxyCodeLine{9819                 ["{}-\/t"{}]["{}-\/-\/list-\/tags"{}]}
\DoxyCodeLine{9820                 ( \textcolor{stringliteral}{"{}list all/matching tags"{}} )}
\DoxyCodeLine{9821             | Opt( config.showSuccessfulTests )}
\DoxyCodeLine{9822                 ["{}-\/s"{}]["{}-\/-\/success"{}]}
\DoxyCodeLine{9823                 ( \textcolor{stringliteral}{"{}include successful tests in output"{}} )}
\DoxyCodeLine{9824             | Opt( config.shouldDebugBreak )}
\DoxyCodeLine{9825                 ["{}-\/b"{}]["{}-\/-\/break"{}]}
\DoxyCodeLine{9826                 ( \textcolor{stringliteral}{"{}break into debugger on failure"{}} )}
\DoxyCodeLine{9827             | Opt( config.noThrow )}
\DoxyCodeLine{9828                 ["{}-\/e"{}]["{}-\/-\/nothrow"{}]}
\DoxyCodeLine{9829                 ( \textcolor{stringliteral}{"{}skip exception tests"{}} )}
\DoxyCodeLine{9830             | Opt( config.showInvisibles )}
\DoxyCodeLine{9831                 ["{}-\/i"{}]["{}-\/-\/invisibles"{}]}
\DoxyCodeLine{9832                 ( \textcolor{stringliteral}{"{}show invisibles (tabs, newlines)"{}} )}
\DoxyCodeLine{9833             | Opt( config.outputFilename, \textcolor{stringliteral}{"{}filename"{}} )}
\DoxyCodeLine{9834                 ["{}-\/o"{}]["{}-\/-\/out"{}]}
\DoxyCodeLine{9835                 ( \textcolor{stringliteral}{"{}output filename"{}} )}
\DoxyCodeLine{9836             | Opt( setReporter, \textcolor{stringliteral}{"{}name"{}} )}
\DoxyCodeLine{9837                 ["{}-\/r"{}]["{}-\/-\/reporter"{}]}
\DoxyCodeLine{9838                 ( \textcolor{stringliteral}{"{}reporter to use (defaults to console)"{}} )}
\DoxyCodeLine{9839             | Opt( config.name, \textcolor{stringliteral}{"{}name"{}} )}
\DoxyCodeLine{9840                 ["{}-\/n"{}]["{}-\/-\/name"{}]}
\DoxyCodeLine{9841                 ( \textcolor{stringliteral}{"{}suite name"{}} )}
\DoxyCodeLine{9842             | Opt( [\&]( \textcolor{keywordtype}{bool} )\{ config.abortAfter = 1; \} )}
\DoxyCodeLine{9843                 [\textcolor{stringliteral}{"{}-\/a"{}}][\textcolor{stringliteral}{"{}-\/-\/abort"{}}]}
\DoxyCodeLine{9844                 ( \textcolor{stringliteral}{"{}abort at first failure"{}} )}
\DoxyCodeLine{9845             | Opt( [\&]( \textcolor{keywordtype}{int} x )\{ config.abortAfter = x; \}, \textcolor{stringliteral}{"{}no. failures"{}} )}
\DoxyCodeLine{9846                 [\textcolor{stringliteral}{"{}-\/x"{}}][\textcolor{stringliteral}{"{}-\/-\/abortx"{}}]}
\DoxyCodeLine{9847                 ( \textcolor{stringliteral}{"{}abort after x failures"{}} )}
\DoxyCodeLine{9848             | Opt( setWarning, \textcolor{stringliteral}{"{}warning name"{}} )}
\DoxyCodeLine{9849                 ["{}-\/w"{}]["{}-\/-\/warn"{}]}
\DoxyCodeLine{9850                 ( \textcolor{stringliteral}{"{}enable warnings"{}} )}
\DoxyCodeLine{9851             | Opt( [\&]( \textcolor{keywordtype}{bool} flag ) \{ config.showDurations = flag ? ShowDurations::Always : ShowDurations::Never; \}, \textcolor{stringliteral}{"{}yes|no"{}} )}
\DoxyCodeLine{9852                 [\textcolor{stringliteral}{"{}-\/d"{}}][\textcolor{stringliteral}{"{}-\/-\/durations"{}}]}
\DoxyCodeLine{9853                 ( \textcolor{stringliteral}{"{}show test durations"{}} )}
\DoxyCodeLine{9854             | Opt( config.minDuration, \textcolor{stringliteral}{"{}seconds"{}} )}
\DoxyCodeLine{9855                 ["{}-\/D"{}]["{}-\/-\/min-\/duration"{}]}
\DoxyCodeLine{9856                 ( \textcolor{stringliteral}{"{}show test durations for tests taking at least the given number of seconds"{}} )}
\DoxyCodeLine{9857             | Opt( loadTestNamesFromFile, \textcolor{stringliteral}{"{}filename"{}} )}
\DoxyCodeLine{9858                 ["{}-\/f"{}]["{}-\/-\/input-\/file"{}]}
\DoxyCodeLine{9859                 ( \textcolor{stringliteral}{"{}load test names to run from a file"{}} )}
\DoxyCodeLine{9860             | Opt( config.filenamesAsTags )}
\DoxyCodeLine{9861                 ["{}-\/\#"{}]["{}-\/-\/filenames-\/as-\/tags"{}]}
\DoxyCodeLine{9862                 ( \textcolor{stringliteral}{"{}adds a tag for the filename"{}} )}
\DoxyCodeLine{9863             | Opt( config.sectionsToRun, \textcolor{stringliteral}{"{}section name"{}} )}
\DoxyCodeLine{9864                 ["{}-\/c"{}]["{}-\/-\/section"{}]}
\DoxyCodeLine{9865                 ( \textcolor{stringliteral}{"{}specify section to run"{}} )}
\DoxyCodeLine{9866             | Opt( setVerbosity, \textcolor{stringliteral}{"{}quiet|normal|high"{}} )}
\DoxyCodeLine{9867                 ["{}-\/v"{}]["{}-\/-\/verbosity"{}]}
\DoxyCodeLine{9868                 ( \textcolor{stringliteral}{"{}set output verbosity"{}} )}
\DoxyCodeLine{9869             | Opt( config.listTestNamesOnly )}
\DoxyCodeLine{9870                 ["{}-\/-\/list-\/test-\/names-\/only"{}]}
\DoxyCodeLine{9871                 ( \textcolor{stringliteral}{"{}list all/matching test cases names only"{}} )}
\DoxyCodeLine{9872             | Opt( config.listReporters )}
\DoxyCodeLine{9873                 ["{}-\/-\/list-\/reporters"{}]}
\DoxyCodeLine{9874                 ( \textcolor{stringliteral}{"{}list all reporters"{}} )}
\DoxyCodeLine{9875             | Opt( setTestOrder, \textcolor{stringliteral}{"{}decl|lex|rand"{}} )}
\DoxyCodeLine{9876                 ["{}-\/-\/order"{}]}
\DoxyCodeLine{9877                 ( \textcolor{stringliteral}{"{}test case order (defaults to decl)"{}} )}
\DoxyCodeLine{9878             | Opt( setRngSeed, \textcolor{stringliteral}{"{}'time'|number"{}} )}
\DoxyCodeLine{9879                 ["{}-\/-\/rng-\/seed"{}]}
\DoxyCodeLine{9880                 ( \textcolor{stringliteral}{"{}set a specific seed for random numbers"{}} )}
\DoxyCodeLine{9881             | Opt( setColourUsage, \textcolor{stringliteral}{"{}yes|no"{}} )}
\DoxyCodeLine{9882                 ["{}-\/-\/use-\/colour"{}]}
\DoxyCodeLine{9883                 ( \textcolor{stringliteral}{"{}should output be colourised"{}} )}
\DoxyCodeLine{9884             | Opt( config.libIdentify )}
\DoxyCodeLine{9885                 ["{}-\/-\/libidentify"{}]}
\DoxyCodeLine{9886                 ( \textcolor{stringliteral}{"{}report name and version according to libidentify standard"{}} )}
\DoxyCodeLine{9887             | Opt( setWaitForKeypress, \textcolor{stringliteral}{"{}never|start|exit|both"{}} )}
\DoxyCodeLine{9888                 ["{}-\/-\/wait-\/for-\/keypress"{}]}
\DoxyCodeLine{9889                 ( \textcolor{stringliteral}{"{}waits for a keypress before exiting"{}} )}
\DoxyCodeLine{9890             | Opt( config.benchmarkSamples, \textcolor{stringliteral}{"{}samples"{}} )}
\DoxyCodeLine{9891                 ["{}-\/-\/benchmark-\/samples"{}]}
\DoxyCodeLine{9892                 ( \textcolor{stringliteral}{"{}number of samples to collect (default: 100)"{}} )}
\DoxyCodeLine{9893             | Opt( config.benchmarkResamples, \textcolor{stringliteral}{"{}resamples"{}} )}
\DoxyCodeLine{9894                 ["{}-\/-\/benchmark-\/resamples"{}]}
\DoxyCodeLine{9895                 ( \textcolor{stringliteral}{"{}number of resamples for the bootstrap (default: 100000)"{}} )}
\DoxyCodeLine{9896             | Opt( config.benchmarkConfidenceInterval, \textcolor{stringliteral}{"{}confidence interval"{}} )}
\DoxyCodeLine{9897                 ["{}-\/-\/benchmark-\/confidence-\/interval"{}]}
\DoxyCodeLine{9898                 ( \textcolor{stringliteral}{"{}confidence interval for the bootstrap (between 0 and 1, default: 0.95)"{}} )}
\DoxyCodeLine{9899             | Opt( config.benchmarkNoAnalysis )}
\DoxyCodeLine{9900                 ["{}-\/-\/benchmark-\/no-\/analysis"{}]}
\DoxyCodeLine{9901                 ( \textcolor{stringliteral}{"{}perform only measurements; do not perform any analysis"{}} )}
\DoxyCodeLine{9902             | Opt( config.benchmarkWarmupTime, \textcolor{stringliteral}{"{}benchmarkWarmupTime"{}} )}
\DoxyCodeLine{9903                 ["{}-\/-\/benchmark-\/warmup-\/time"{}]}
\DoxyCodeLine{9904                 ( \textcolor{stringliteral}{"{}amount of time in milliseconds spent on warming up each test (default: 100)"{}} )}
\DoxyCodeLine{9905             | Arg( config.testsOrTags, \textcolor{stringliteral}{"{}test name|pattern|tags"{}} )}
\DoxyCodeLine{9906                 ( \textcolor{stringliteral}{"{}which test or tests to use"{}} );}
\DoxyCodeLine{9907 }
\DoxyCodeLine{9908         \textcolor{keywordflow}{return} cli;}
\DoxyCodeLine{9909     \}}
\DoxyCodeLine{9910 }
\DoxyCodeLine{9911 \} \textcolor{comment}{// end namespace Catch}}
\DoxyCodeLine{9912 \textcolor{comment}{// end catch\_commandline.cpp}}
\DoxyCodeLine{9913 \textcolor{comment}{// start catch\_common.cpp}}
\DoxyCodeLine{9914 }
\DoxyCodeLine{9915 \textcolor{preprocessor}{\#include <cstring>}}
\DoxyCodeLine{9916 \textcolor{preprocessor}{\#include <ostream>}}
\DoxyCodeLine{9917 }
\DoxyCodeLine{9918 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{9919 }
\DoxyCodeLine{9920     \textcolor{keywordtype}{bool} SourceLineInfo::operator == ( SourceLineInfo \textcolor{keyword}{const}\& other ) \textcolor{keyword}{const} \textcolor{keyword}{noexcept} \{}
\DoxyCodeLine{9921         \textcolor{keywordflow}{return} line == other.line \&\& (file == other.file || std::strcmp(file, other.file) == 0);}
\DoxyCodeLine{9922     \}}
\DoxyCodeLine{9923     \textcolor{keywordtype}{bool} SourceLineInfo::operator < ( SourceLineInfo \textcolor{keyword}{const}\& other ) \textcolor{keyword}{const} \textcolor{keyword}{noexcept} \{}
\DoxyCodeLine{9924         \textcolor{comment}{// We can assume that the same file will usually have the same pointer.}}
\DoxyCodeLine{9925         \textcolor{comment}{// Thus, if the pointers are the same, there is no point in calling the strcmp}}
\DoxyCodeLine{9926         \textcolor{keywordflow}{return} line < other.line || ( line == other.line \&\& file != other.file \&\& (std::strcmp(file, other.file) < 0));}
\DoxyCodeLine{9927     \}}
\DoxyCodeLine{9928 }
\DoxyCodeLine{9929     std::ostream\& operator << ( std::ostream\& os, SourceLineInfo \textcolor{keyword}{const}\& info ) \{}
\DoxyCodeLine{9930 \textcolor{preprocessor}{\#ifndef \_\_GNUG\_\_}}
\DoxyCodeLine{9931         os << info.file << \textcolor{charliteral}{'('} << info.line << \textcolor{charliteral}{')'};}
\DoxyCodeLine{9932 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{9933         os << info.file << \textcolor{charliteral}{':'} << info.line;}
\DoxyCodeLine{9934 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{9935         \textcolor{keywordflow}{return} os;}
\DoxyCodeLine{9936     \}}
\DoxyCodeLine{9937 }
\DoxyCodeLine{9938     std::string StreamEndStop::operator+()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{9939         \textcolor{keywordflow}{return} std::string();}
\DoxyCodeLine{9940     \}}
\DoxyCodeLine{9941 }
\DoxyCodeLine{9942     NonCopyable::NonCopyable() = \textcolor{keywordflow}{default};}
\DoxyCodeLine{9943     NonCopyable::\string~NonCopyable() = \textcolor{keywordflow}{default};}
\DoxyCodeLine{9944 }
\DoxyCodeLine{9945 \}}
\DoxyCodeLine{9946 \textcolor{comment}{// end catch\_common.cpp}}
\DoxyCodeLine{9947 \textcolor{comment}{// start catch\_config.cpp}}
\DoxyCodeLine{9948 }
\DoxyCodeLine{9949 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{9950 }
\DoxyCodeLine{9951     Config::Config( ConfigData \textcolor{keyword}{const}\& data )}
\DoxyCodeLine{9952     :   m\_data( data ),}
\DoxyCodeLine{9953         m\_stream( openStream() )}
\DoxyCodeLine{9954     \{}
\DoxyCodeLine{9955         \textcolor{comment}{// We need to trim filter specs to avoid trouble with superfluous}}
\DoxyCodeLine{9956         \textcolor{comment}{// whitespace (esp. important for bdd macros, as those are manually}}
\DoxyCodeLine{9957         \textcolor{comment}{// aligned with whitespace).}}
\DoxyCodeLine{9958 }
\DoxyCodeLine{9959         \textcolor{keywordflow}{for} (\textcolor{keyword}{auto}\& elem : m\_data.testsOrTags) \{}
\DoxyCodeLine{9960             elem = trim(elem);}
\DoxyCodeLine{9961         \}}
\DoxyCodeLine{9962         \textcolor{keywordflow}{for} (\textcolor{keyword}{auto}\& elem : m\_data.sectionsToRun) \{}
\DoxyCodeLine{9963             elem = trim(elem);}
\DoxyCodeLine{9964         \}}
\DoxyCodeLine{9965 }
\DoxyCodeLine{9966         TestSpecParser parser(ITagAliasRegistry::get());}
\DoxyCodeLine{9967         \textcolor{keywordflow}{if} (!m\_data.testsOrTags.empty()) \{}
\DoxyCodeLine{9968             m\_hasTestFilters = \textcolor{keyword}{true};}
\DoxyCodeLine{9969             \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} \textcolor{keyword}{const}\& testOrTags : m\_data.testsOrTags) \{}
\DoxyCodeLine{9970                 parser.parse(testOrTags);}
\DoxyCodeLine{9971             \}}
\DoxyCodeLine{9972         \}}
\DoxyCodeLine{9973         m\_testSpec = parser.testSpec();}
\DoxyCodeLine{9974     \}}
\DoxyCodeLine{9975 }
\DoxyCodeLine{9976     std::string \textcolor{keyword}{const}\& Config::getFilename()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{9977         \textcolor{keywordflow}{return} m\_data.outputFilename ;}
\DoxyCodeLine{9978     \}}
\DoxyCodeLine{9979 }
\DoxyCodeLine{9980     \textcolor{keywordtype}{bool} Config::listTests()\textcolor{keyword}{ const          }\{ \textcolor{keywordflow}{return} m\_data.listTests; \}}
\DoxyCodeLine{9981     \textcolor{keywordtype}{bool} Config::listTestNamesOnly()\textcolor{keyword}{ const  }\{ \textcolor{keywordflow}{return} m\_data.listTestNamesOnly; \}}
\DoxyCodeLine{9982     \textcolor{keywordtype}{bool} Config::listTags()\textcolor{keyword}{ const           }\{ \textcolor{keywordflow}{return} m\_data.listTags; \}}
\DoxyCodeLine{9983     \textcolor{keywordtype}{bool} Config::listReporters()\textcolor{keyword}{ const      }\{ \textcolor{keywordflow}{return} m\_data.listReporters; \}}
\DoxyCodeLine{9984 }
\DoxyCodeLine{9985     std::string Config::getProcessName()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} m\_data.processName; \}}
\DoxyCodeLine{9986     std::string \textcolor{keyword}{const}\& Config::getReporterName()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} m\_data.reporterName; \}}
\DoxyCodeLine{9987 }
\DoxyCodeLine{9988     std::vector<std::string> \textcolor{keyword}{const}\& Config::getTestsOrTags()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} m\_data.testsOrTags; \}}
\DoxyCodeLine{9989     std::vector<std::string> \textcolor{keyword}{const}\& Config::getSectionsToRun()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} m\_data.sectionsToRun; \}}
\DoxyCodeLine{9990 }
\DoxyCodeLine{9991     TestSpec \textcolor{keyword}{const}\& Config::testSpec()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} m\_testSpec; \}}
\DoxyCodeLine{9992     \textcolor{keywordtype}{bool} Config::hasTestFilters()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} m\_hasTestFilters; \}}
\DoxyCodeLine{9993 }
\DoxyCodeLine{9994     \textcolor{keywordtype}{bool} Config::showHelp()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} m\_data.showHelp; \}}
\DoxyCodeLine{9995 }
\DoxyCodeLine{9996     \textcolor{comment}{// IConfig interface}}
\DoxyCodeLine{9997     \textcolor{keywordtype}{bool} Config::allowThrows()\textcolor{keyword}{ const                   }\{ \textcolor{keywordflow}{return} !m\_data.noThrow; \}}
\DoxyCodeLine{9998     std::ostream\& Config::stream()\textcolor{keyword}{ const               }\{ \textcolor{keywordflow}{return} m\_stream-\/>stream(); \}}
\DoxyCodeLine{9999     std::string Config::name()\textcolor{keyword}{ const                   }\{ \textcolor{keywordflow}{return} m\_data.name.empty() ? m\_data.processName : m\_data.name; \}}
\DoxyCodeLine{10000     \textcolor{keywordtype}{bool} Config::includeSuccessfulResults()\textcolor{keyword}{ const      }\{ \textcolor{keywordflow}{return} m\_data.showSuccessfulTests; \}}
\DoxyCodeLine{10001     \textcolor{keywordtype}{bool} Config::warnAboutMissingAssertions()\textcolor{keyword}{ const    }\{ \textcolor{keywordflow}{return} !!(m\_data.warnings \& WarnAbout::NoAssertions); \}}
\DoxyCodeLine{10002     \textcolor{keywordtype}{bool} Config::warnAboutNoTests()\textcolor{keyword}{ const              }\{ \textcolor{keywordflow}{return} !!(m\_data.warnings \& WarnAbout::NoTests); \}}
\DoxyCodeLine{10003     ShowDurations::OrNot Config::showDurations()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} m\_data.showDurations; \}}
\DoxyCodeLine{10004     \textcolor{keywordtype}{double} Config::minDuration()\textcolor{keyword}{ const                 }\{ \textcolor{keywordflow}{return} m\_data.minDuration; \}}
\DoxyCodeLine{10005     RunTests::InWhatOrder Config::runOrder()\textcolor{keyword}{ const     }\{ \textcolor{keywordflow}{return} m\_data.runOrder; \}}
\DoxyCodeLine{10006     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} Config::rngSeed()\textcolor{keyword}{ const               }\{ \textcolor{keywordflow}{return} m\_data.rngSeed; \}}
\DoxyCodeLine{10007     UseColour::YesOrNo Config::useColour()\textcolor{keyword}{ const       }\{ \textcolor{keywordflow}{return} m\_data.useColour; \}}
\DoxyCodeLine{10008     \textcolor{keywordtype}{bool} Config::shouldDebugBreak()\textcolor{keyword}{ const              }\{ \textcolor{keywordflow}{return} m\_data.shouldDebugBreak; \}}
\DoxyCodeLine{10009     \textcolor{keywordtype}{int} Config::abortAfter()\textcolor{keyword}{ const                     }\{ \textcolor{keywordflow}{return} m\_data.abortAfter; \}}
\DoxyCodeLine{10010     \textcolor{keywordtype}{bool} Config::showInvisibles()\textcolor{keyword}{ const                }\{ \textcolor{keywordflow}{return} m\_data.showInvisibles; \}}
\DoxyCodeLine{10011     Verbosity Config::verbosity()\textcolor{keyword}{ const                }\{ \textcolor{keywordflow}{return} m\_data.verbosity; \}}
\DoxyCodeLine{10012 }
\DoxyCodeLine{10013     \textcolor{keywordtype}{bool} Config::benchmarkNoAnalysis()\textcolor{keyword}{ const                      }\{ \textcolor{keywordflow}{return} m\_data.benchmarkNoAnalysis; \}}
\DoxyCodeLine{10014     \textcolor{keywordtype}{int} Config::benchmarkSamples()\textcolor{keyword}{ const                          }\{ \textcolor{keywordflow}{return} m\_data.benchmarkSamples; \}}
\DoxyCodeLine{10015     \textcolor{keywordtype}{double} Config::benchmarkConfidenceInterval()\textcolor{keyword}{ const            }\{ \textcolor{keywordflow}{return} m\_data.benchmarkConfidenceInterval; \}}
\DoxyCodeLine{10016     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} Config::benchmarkResamples()\textcolor{keyword}{ const               }\{ \textcolor{keywordflow}{return} m\_data.benchmarkResamples; \}}
\DoxyCodeLine{10017     std::chrono::milliseconds Config::benchmarkWarmupTime()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} std::chrono::milliseconds(m\_data.benchmarkWarmupTime); \}}
\DoxyCodeLine{10018 }
\DoxyCodeLine{10019     IStream \textcolor{keyword}{const}* Config::openStream() \{}
\DoxyCodeLine{10020         \textcolor{keywordflow}{return} Catch::makeStream(m\_data.outputFilename);}
\DoxyCodeLine{10021     \}}
\DoxyCodeLine{10022 }
\DoxyCodeLine{10023 \} \textcolor{comment}{// end namespace Catch}}
\DoxyCodeLine{10024 \textcolor{comment}{// end catch\_config.cpp}}
\DoxyCodeLine{10025 \textcolor{comment}{// start catch\_console\_colour.cpp}}
\DoxyCodeLine{10026 }
\DoxyCodeLine{10027 \textcolor{preprocessor}{\#if defined(\_\_clang\_\_)}}
\DoxyCodeLine{10028 \textcolor{preprocessor}{\#    pragma clang diagnostic push}}
\DoxyCodeLine{10029 \textcolor{preprocessor}{\#    pragma clang diagnostic ignored "{}-\/Wexit-\/time-\/destructors"{}}}
\DoxyCodeLine{10030 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{10031 }
\DoxyCodeLine{10032 \textcolor{comment}{// start catch\_errno\_guard.h}}
\DoxyCodeLine{10033 }
\DoxyCodeLine{10034 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{10035 }
\DoxyCodeLine{10036     \textcolor{keyword}{class }ErrnoGuard \{}
\DoxyCodeLine{10037     \textcolor{keyword}{public}:}
\DoxyCodeLine{10038         ErrnoGuard();}
\DoxyCodeLine{10039         \string~ErrnoGuard();}
\DoxyCodeLine{10040     \textcolor{keyword}{private}:}
\DoxyCodeLine{10041         \textcolor{keywordtype}{int} m\_oldErrno;}
\DoxyCodeLine{10042     \};}
\DoxyCodeLine{10043 }
\DoxyCodeLine{10044 \}}
\DoxyCodeLine{10045 }
\DoxyCodeLine{10046 \textcolor{comment}{// end catch\_errno\_guard.h}}
\DoxyCodeLine{10047 \textcolor{comment}{// start catch\_windows\_h\_proxy.h}}
\DoxyCodeLine{10048 }
\DoxyCodeLine{10049 }
\DoxyCodeLine{10050 \textcolor{preprocessor}{\#if defined(CATCH\_PLATFORM\_WINDOWS)}}
\DoxyCodeLine{10051 }
\DoxyCodeLine{10052 \textcolor{preprocessor}{\#if !defined(NOMINMAX) \&\& !defined(CATCH\_CONFIG\_NO\_NOMINMAX)}}
\DoxyCodeLine{10053 \textcolor{preprocessor}{\#  define CATCH\_DEFINED\_NOMINMAX}}
\DoxyCodeLine{10054 \textcolor{preprocessor}{\#  define NOMINMAX}}
\DoxyCodeLine{10055 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{10056 \textcolor{preprocessor}{\#if !defined(WIN32\_LEAN\_AND\_MEAN) \&\& !defined(CATCH\_CONFIG\_NO\_WIN32\_LEAN\_AND\_MEAN)}}
\DoxyCodeLine{10057 \textcolor{preprocessor}{\#  define CATCH\_DEFINED\_WIN32\_LEAN\_AND\_MEAN}}
\DoxyCodeLine{10058 \textcolor{preprocessor}{\#  define WIN32\_LEAN\_AND\_MEAN}}
\DoxyCodeLine{10059 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{10060 }
\DoxyCodeLine{10061 \textcolor{preprocessor}{\#ifdef \_\_AFXDLL}}
\DoxyCodeLine{10062 \textcolor{preprocessor}{\#include <AfxWin.h>}}
\DoxyCodeLine{10063 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{10064 \textcolor{preprocessor}{\#include <windows.h>}}
\DoxyCodeLine{10065 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{10066 }
\DoxyCodeLine{10067 \textcolor{preprocessor}{\#ifdef CATCH\_DEFINED\_NOMINMAX}}
\DoxyCodeLine{10068 \textcolor{preprocessor}{\#  undef NOMINMAX}}
\DoxyCodeLine{10069 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{10070 \textcolor{preprocessor}{\#ifdef CATCH\_DEFINED\_WIN32\_LEAN\_AND\_MEAN}}
\DoxyCodeLine{10071 \textcolor{preprocessor}{\#  undef WIN32\_LEAN\_AND\_MEAN}}
\DoxyCodeLine{10072 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{10073 }
\DoxyCodeLine{10074 \textcolor{preprocessor}{\#endif }\textcolor{comment}{// defined(CATCH\_PLATFORM\_WINDOWS)}}
\DoxyCodeLine{10075 }
\DoxyCodeLine{10076 \textcolor{comment}{// end catch\_windows\_h\_proxy.h}}
\DoxyCodeLine{10077 \textcolor{preprocessor}{\#include <sstream>}}
\DoxyCodeLine{10078 }
\DoxyCodeLine{10079 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{10080     \textcolor{keyword}{namespace }\{}
\DoxyCodeLine{10081 }
\DoxyCodeLine{10082         \textcolor{keyword}{struct }IColourImpl \{}
\DoxyCodeLine{10083             \textcolor{keyword}{virtual} \string~IColourImpl() = \textcolor{keywordflow}{default};}
\DoxyCodeLine{10084             \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} use( Colour::Code \_colourCode ) = 0;}
\DoxyCodeLine{10085         \};}
\DoxyCodeLine{10086 }
\DoxyCodeLine{10087         \textcolor{keyword}{struct }NoColourImpl : IColourImpl \{}
\DoxyCodeLine{10088             \textcolor{keywordtype}{void} use( Colour::Code )\textcolor{keyword}{ override }\{\}}
\DoxyCodeLine{10089 }
\DoxyCodeLine{10090             \textcolor{keyword}{static} IColourImpl* instance() \{}
\DoxyCodeLine{10091                 \textcolor{keyword}{static} NoColourImpl s\_instance;}
\DoxyCodeLine{10092                 \textcolor{keywordflow}{return} \&s\_instance;}
\DoxyCodeLine{10093             \}}
\DoxyCodeLine{10094         \};}
\DoxyCodeLine{10095 }
\DoxyCodeLine{10096     \} \textcolor{comment}{// anon namespace}}
\DoxyCodeLine{10097 \} \textcolor{comment}{// namespace Catch}}
\DoxyCodeLine{10098 }
\DoxyCodeLine{10099 \textcolor{preprocessor}{\#if !defined( CATCH\_CONFIG\_COLOUR\_NONE ) \&\& !defined( CATCH\_CONFIG\_COLOUR\_WINDOWS ) \&\& !defined( CATCH\_CONFIG\_COLOUR\_ANSI )}}
\DoxyCodeLine{10100 \textcolor{preprocessor}{\#   ifdef CATCH\_PLATFORM\_WINDOWS}}
\DoxyCodeLine{10101 \textcolor{preprocessor}{\#       define CATCH\_CONFIG\_COLOUR\_WINDOWS}}
\DoxyCodeLine{10102 \textcolor{preprocessor}{\#   else}}
\DoxyCodeLine{10103 \textcolor{preprocessor}{\#       define CATCH\_CONFIG\_COLOUR\_ANSI}}
\DoxyCodeLine{10104 \textcolor{preprocessor}{\#   endif}}
\DoxyCodeLine{10105 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{10106 }
\DoxyCodeLine{10107 \textcolor{preprocessor}{\#if defined ( CATCH\_CONFIG\_COLOUR\_WINDOWS ) }}
\DoxyCodeLine{10108 }
\DoxyCodeLine{10109 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{10110 \textcolor{keyword}{namespace }\{}
\DoxyCodeLine{10111 }
\DoxyCodeLine{10112     \textcolor{keyword}{class }Win32ColourImpl : \textcolor{keyword}{public} IColourImpl \{}
\DoxyCodeLine{10113     \textcolor{keyword}{public}:}
\DoxyCodeLine{10114         Win32ColourImpl() : stdoutHandle( GetStdHandle(STD\_OUTPUT\_HANDLE) )}
\DoxyCodeLine{10115         \{}
\DoxyCodeLine{10116             CONSOLE\_SCREEN\_BUFFER\_INFO csbiInfo;}
\DoxyCodeLine{10117             GetConsoleScreenBufferInfo( stdoutHandle, \&csbiInfo );}
\DoxyCodeLine{10118             originalForegroundAttributes = csbiInfo.wAttributes \& \string~( BACKGROUND\_GREEN | BACKGROUND\_RED | BACKGROUND\_BLUE | BACKGROUND\_INTENSITY );}
\DoxyCodeLine{10119             originalBackgroundAttributes = csbiInfo.wAttributes \& \string~( FOREGROUND\_GREEN | FOREGROUND\_RED | FOREGROUND\_BLUE | FOREGROUND\_INTENSITY );}
\DoxyCodeLine{10120         \}}
\DoxyCodeLine{10121 }
\DoxyCodeLine{10122         \textcolor{keywordtype}{void} use( Colour::Code \_colourCode )\textcolor{keyword}{ override }\{}
\DoxyCodeLine{10123             \textcolor{keywordflow}{switch}( \_colourCode ) \{}
\DoxyCodeLine{10124                 \textcolor{keywordflow}{case} Colour::None:      \textcolor{keywordflow}{return} setTextAttribute( originalForegroundAttributes );}
\DoxyCodeLine{10125                 \textcolor{keywordflow}{case} Colour::White:     \textcolor{keywordflow}{return} setTextAttribute( FOREGROUND\_GREEN | FOREGROUND\_RED | FOREGROUND\_BLUE );}
\DoxyCodeLine{10126                 \textcolor{keywordflow}{case} Colour::Red:       \textcolor{keywordflow}{return} setTextAttribute( FOREGROUND\_RED );}
\DoxyCodeLine{10127                 \textcolor{keywordflow}{case} Colour::Green:     \textcolor{keywordflow}{return} setTextAttribute( FOREGROUND\_GREEN );}
\DoxyCodeLine{10128                 \textcolor{keywordflow}{case} Colour::Blue:      \textcolor{keywordflow}{return} setTextAttribute( FOREGROUND\_BLUE );}
\DoxyCodeLine{10129                 \textcolor{keywordflow}{case} Colour::Cyan:      \textcolor{keywordflow}{return} setTextAttribute( FOREGROUND\_BLUE | FOREGROUND\_GREEN );}
\DoxyCodeLine{10130                 \textcolor{keywordflow}{case} Colour::Yellow:    \textcolor{keywordflow}{return} setTextAttribute( FOREGROUND\_RED | FOREGROUND\_GREEN );}
\DoxyCodeLine{10131                 \textcolor{keywordflow}{case} Colour::Grey:      \textcolor{keywordflow}{return} setTextAttribute( 0 );}
\DoxyCodeLine{10132 }
\DoxyCodeLine{10133                 \textcolor{keywordflow}{case} Colour::LightGrey:     \textcolor{keywordflow}{return} setTextAttribute( FOREGROUND\_INTENSITY );}
\DoxyCodeLine{10134                 \textcolor{keywordflow}{case} Colour::BrightRed:     \textcolor{keywordflow}{return} setTextAttribute( FOREGROUND\_INTENSITY | FOREGROUND\_RED );}
\DoxyCodeLine{10135                 \textcolor{keywordflow}{case} Colour::BrightGreen:   \textcolor{keywordflow}{return} setTextAttribute( FOREGROUND\_INTENSITY | FOREGROUND\_GREEN );}
\DoxyCodeLine{10136                 \textcolor{keywordflow}{case} Colour::BrightWhite:   \textcolor{keywordflow}{return} setTextAttribute( FOREGROUND\_INTENSITY | FOREGROUND\_GREEN | FOREGROUND\_RED | FOREGROUND\_BLUE );}
\DoxyCodeLine{10137                 \textcolor{keywordflow}{case} Colour::BrightYellow:  \textcolor{keywordflow}{return} setTextAttribute( FOREGROUND\_INTENSITY | FOREGROUND\_RED | FOREGROUND\_GREEN );}
\DoxyCodeLine{10138 }
\DoxyCodeLine{10139                 \textcolor{keywordflow}{case} Colour::Bright: CATCH\_INTERNAL\_ERROR( \textcolor{stringliteral}{"{}not a colour"{}} );}
\DoxyCodeLine{10140 }
\DoxyCodeLine{10141                 \textcolor{keywordflow}{default}:}
\DoxyCodeLine{10142                     CATCH\_ERROR( \textcolor{stringliteral}{"{}Unknown colour requested"{}} );}
\DoxyCodeLine{10143             \}}
\DoxyCodeLine{10144         \}}
\DoxyCodeLine{10145 }
\DoxyCodeLine{10146     \textcolor{keyword}{private}:}
\DoxyCodeLine{10147         \textcolor{keywordtype}{void} setTextAttribute( WORD \_textAttribute ) \{}
\DoxyCodeLine{10148             SetConsoleTextAttribute( stdoutHandle, \_textAttribute | originalBackgroundAttributes );}
\DoxyCodeLine{10149         \}}
\DoxyCodeLine{10150         HANDLE stdoutHandle;}
\DoxyCodeLine{10151         WORD originalForegroundAttributes;}
\DoxyCodeLine{10152         WORD originalBackgroundAttributes;}
\DoxyCodeLine{10153     \};}
\DoxyCodeLine{10154 }
\DoxyCodeLine{10155     IColourImpl* platformColourInstance() \{}
\DoxyCodeLine{10156         \textcolor{keyword}{static} Win32ColourImpl s\_instance;}
\DoxyCodeLine{10157 }
\DoxyCodeLine{10158         IConfigPtr config = getCurrentContext().getConfig();}
\DoxyCodeLine{10159         UseColour::YesOrNo colourMode = config}
\DoxyCodeLine{10160             ? config-\/>useColour()}
\DoxyCodeLine{10161             : UseColour::Auto;}
\DoxyCodeLine{10162         \textcolor{keywordflow}{if}( colourMode == UseColour::Auto )}
\DoxyCodeLine{10163             colourMode = UseColour::Yes;}
\DoxyCodeLine{10164         \textcolor{keywordflow}{return} colourMode == UseColour::Yes}
\DoxyCodeLine{10165             ? \&s\_instance}
\DoxyCodeLine{10166             : NoColourImpl::instance();}
\DoxyCodeLine{10167     \}}
\DoxyCodeLine{10168 }
\DoxyCodeLine{10169 \} \textcolor{comment}{// end anon namespace}}
\DoxyCodeLine{10170 \} \textcolor{comment}{// end namespace Catch}}
\DoxyCodeLine{10171 }
\DoxyCodeLine{10172 \textcolor{preprocessor}{\#elif defined( CATCH\_CONFIG\_COLOUR\_ANSI ) }}
\DoxyCodeLine{10173 }
\DoxyCodeLine{10174 \textcolor{preprocessor}{\#include <unistd.h>}}
\DoxyCodeLine{10175 }
\DoxyCodeLine{10176 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{10177 \textcolor{keyword}{namespace }\{}
\DoxyCodeLine{10178 }
\DoxyCodeLine{10179     \textcolor{comment}{// use POSIX/ ANSI console terminal codes}}
\DoxyCodeLine{10180     \textcolor{comment}{// Thanks to Adam Strzelecki for original contribution}}
\DoxyCodeLine{10181     \textcolor{comment}{// (http://github.com/nanoant)}}
\DoxyCodeLine{10182     \textcolor{comment}{// https://github.com/philsquared/Catch/pull/131}}
\DoxyCodeLine{10183     \textcolor{keyword}{class }PosixColourImpl : \textcolor{keyword}{public} IColourImpl \{}
\DoxyCodeLine{10184     \textcolor{keyword}{public}:}
\DoxyCodeLine{10185         \textcolor{keywordtype}{void} use( Colour::Code \_colourCode )\textcolor{keyword}{ override }\{}
\DoxyCodeLine{10186             \textcolor{keywordflow}{switch}( \_colourCode ) \{}
\DoxyCodeLine{10187                 \textcolor{keywordflow}{case} Colour::None:}
\DoxyCodeLine{10188                 \textcolor{keywordflow}{case} Colour::White:     \textcolor{keywordflow}{return} setColour( \textcolor{stringliteral}{"{}[0m"{}} );}
\DoxyCodeLine{10189                 \textcolor{keywordflow}{case} Colour::Red:       \textcolor{keywordflow}{return} setColour( \textcolor{stringliteral}{"{}[0;31m"{}} );}
\DoxyCodeLine{10190                 \textcolor{keywordflow}{case} Colour::Green:     \textcolor{keywordflow}{return} setColour( \textcolor{stringliteral}{"{}[0;32m"{}} );}
\DoxyCodeLine{10191                 \textcolor{keywordflow}{case} Colour::Blue:      \textcolor{keywordflow}{return} setColour( \textcolor{stringliteral}{"{}[0;34m"{}} );}
\DoxyCodeLine{10192                 \textcolor{keywordflow}{case} Colour::Cyan:      \textcolor{keywordflow}{return} setColour( \textcolor{stringliteral}{"{}[0;36m"{}} );}
\DoxyCodeLine{10193                 \textcolor{keywordflow}{case} Colour::Yellow:    \textcolor{keywordflow}{return} setColour( \textcolor{stringliteral}{"{}[0;33m"{}} );}
\DoxyCodeLine{10194                 \textcolor{keywordflow}{case} Colour::Grey:      \textcolor{keywordflow}{return} setColour( \textcolor{stringliteral}{"{}[1;30m"{}} );}
\DoxyCodeLine{10195 }
\DoxyCodeLine{10196                 \textcolor{keywordflow}{case} Colour::LightGrey:     \textcolor{keywordflow}{return} setColour( \textcolor{stringliteral}{"{}[0;37m"{}} );}
\DoxyCodeLine{10197                 \textcolor{keywordflow}{case} Colour::BrightRed:     \textcolor{keywordflow}{return} setColour( \textcolor{stringliteral}{"{}[1;31m"{}} );}
\DoxyCodeLine{10198                 \textcolor{keywordflow}{case} Colour::BrightGreen:   \textcolor{keywordflow}{return} setColour( \textcolor{stringliteral}{"{}[1;32m"{}} );}
\DoxyCodeLine{10199                 \textcolor{keywordflow}{case} Colour::BrightWhite:   \textcolor{keywordflow}{return} setColour( \textcolor{stringliteral}{"{}[1;37m"{}} );}
\DoxyCodeLine{10200                 \textcolor{keywordflow}{case} Colour::BrightYellow:  \textcolor{keywordflow}{return} setColour( \textcolor{stringliteral}{"{}[1;33m"{}} );}
\DoxyCodeLine{10201 }
\DoxyCodeLine{10202                 \textcolor{keywordflow}{case} Colour::Bright: CATCH\_INTERNAL\_ERROR( \textcolor{stringliteral}{"{}not a colour"{}} );}
\DoxyCodeLine{10203                 \textcolor{keywordflow}{default}: CATCH\_INTERNAL\_ERROR( \textcolor{stringliteral}{"{}Unknown colour requested"{}} );}
\DoxyCodeLine{10204             \}}
\DoxyCodeLine{10205         \}}
\DoxyCodeLine{10206         \textcolor{keyword}{static} IColourImpl* instance() \{}
\DoxyCodeLine{10207             \textcolor{keyword}{static} PosixColourImpl s\_instance;}
\DoxyCodeLine{10208             \textcolor{keywordflow}{return} \&s\_instance;}
\DoxyCodeLine{10209         \}}
\DoxyCodeLine{10210 }
\DoxyCodeLine{10211     \textcolor{keyword}{private}:}
\DoxyCodeLine{10212         \textcolor{keywordtype}{void} setColour( \textcolor{keyword}{const} \textcolor{keywordtype}{char}* \_escapeCode ) \{}
\DoxyCodeLine{10213             getCurrentContext().getConfig()-\/>stream()}
\DoxyCodeLine{10214                 << \textcolor{charliteral}{'\(\backslash\)033'} << \_escapeCode;}
\DoxyCodeLine{10215         \}}
\DoxyCodeLine{10216     \};}
\DoxyCodeLine{10217 }
\DoxyCodeLine{10218     \textcolor{keywordtype}{bool} useColourOnPlatform() \{}
\DoxyCodeLine{10219         \textcolor{keywordflow}{return}}
\DoxyCodeLine{10220 \textcolor{preprocessor}{\#if defined(CATCH\_PLATFORM\_MAC) || defined(CATCH\_PLATFORM\_IPHONE)}}
\DoxyCodeLine{10221             !isDebuggerActive() \&\&}
\DoxyCodeLine{10222 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{10223 \textcolor{preprocessor}{\#if !(defined(\_\_DJGPP\_\_) \&\& defined(\_\_STRICT\_ANSI\_\_))}}
\DoxyCodeLine{10224             isatty(STDOUT\_FILENO)}
\DoxyCodeLine{10225 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{10226             \textcolor{keyword}{false}}
\DoxyCodeLine{10227 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{10228             ;}
\DoxyCodeLine{10229     \}}
\DoxyCodeLine{10230     IColourImpl* platformColourInstance() \{}
\DoxyCodeLine{10231         ErrnoGuard guard;}
\DoxyCodeLine{10232         IConfigPtr config = getCurrentContext().getConfig();}
\DoxyCodeLine{10233         UseColour::YesOrNo colourMode = config}
\DoxyCodeLine{10234             ? config-\/>useColour()}
\DoxyCodeLine{10235             : UseColour::Auto;}
\DoxyCodeLine{10236         \textcolor{keywordflow}{if}( colourMode == UseColour::Auto )}
\DoxyCodeLine{10237             colourMode = useColourOnPlatform()}
\DoxyCodeLine{10238                 ? UseColour::Yes}
\DoxyCodeLine{10239                 : UseColour::No;}
\DoxyCodeLine{10240         \textcolor{keywordflow}{return} colourMode == UseColour::Yes}
\DoxyCodeLine{10241             ? PosixColourImpl::instance()}
\DoxyCodeLine{10242             : NoColourImpl::instance();}
\DoxyCodeLine{10243     \}}
\DoxyCodeLine{10244 }
\DoxyCodeLine{10245 \} \textcolor{comment}{// end anon namespace}}
\DoxyCodeLine{10246 \} \textcolor{comment}{// end namespace Catch}}
\DoxyCodeLine{10247 }
\DoxyCodeLine{10248 \textcolor{preprocessor}{\#else  }\textcolor{comment}{// not Windows or ANSI ///////////////////////////////////////////////}}
\DoxyCodeLine{10249 }
\DoxyCodeLine{10250 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{10251 }
\DoxyCodeLine{10252     \textcolor{keyword}{static} IColourImpl* platformColourInstance() \{ \textcolor{keywordflow}{return} NoColourImpl::instance(); \}}
\DoxyCodeLine{10253 }
\DoxyCodeLine{10254 \} \textcolor{comment}{// end namespace Catch}}
\DoxyCodeLine{10255 }
\DoxyCodeLine{10256 \textcolor{preprocessor}{\#endif }\textcolor{comment}{// Windows/ ANSI/ None}}
\DoxyCodeLine{10257 }
\DoxyCodeLine{10258 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{10259 }
\DoxyCodeLine{10260     Colour::Colour( Code \_colourCode ) \{ use( \_colourCode ); \}}
\DoxyCodeLine{10261     Colour::Colour( Colour\&\& other ) \textcolor{keyword}{noexcept} \{}
\DoxyCodeLine{10262         m\_moved = other.m\_moved;}
\DoxyCodeLine{10263         other.m\_moved = \textcolor{keyword}{true};}
\DoxyCodeLine{10264     \}}
\DoxyCodeLine{10265     Colour\& Colour::operator=( Colour\&\& other ) \textcolor{keyword}{noexcept} \{}
\DoxyCodeLine{10266         m\_moved = other.m\_moved;}
\DoxyCodeLine{10267         other.m\_moved  = \textcolor{keyword}{true};}
\DoxyCodeLine{10268         \textcolor{keywordflow}{return} *\textcolor{keyword}{this};}
\DoxyCodeLine{10269     \}}
\DoxyCodeLine{10270 }
\DoxyCodeLine{10271     Colour::\string~Colour()\{ \textcolor{keywordflow}{if}( !m\_moved ) use( None ); \}}
\DoxyCodeLine{10272 }
\DoxyCodeLine{10273     \textcolor{keywordtype}{void} Colour::use( Code \_colourCode ) \{}
\DoxyCodeLine{10274         \textcolor{keyword}{static} IColourImpl* impl = platformColourInstance();}
\DoxyCodeLine{10275         \textcolor{comment}{// Strictly speaking, this cannot possibly happen.}}
\DoxyCodeLine{10276         \textcolor{comment}{// However, under some conditions it does happen (see \#1626),}}
\DoxyCodeLine{10277         \textcolor{comment}{// and this change is small enough that we can let practicality}}
\DoxyCodeLine{10278         \textcolor{comment}{// triumph over purity in this case.}}
\DoxyCodeLine{10279         \textcolor{keywordflow}{if} (impl != \textcolor{keyword}{nullptr}) \{}
\DoxyCodeLine{10280             impl-\/>use( \_colourCode );}
\DoxyCodeLine{10281         \}}
\DoxyCodeLine{10282     \}}
\DoxyCodeLine{10283 }
\DoxyCodeLine{10284     std::ostream\& operator << ( std::ostream\& os, Colour \textcolor{keyword}{const}\& ) \{}
\DoxyCodeLine{10285         \textcolor{keywordflow}{return} os;}
\DoxyCodeLine{10286     \}}
\DoxyCodeLine{10287 }
\DoxyCodeLine{10288 \} \textcolor{comment}{// end namespace Catch}}
\DoxyCodeLine{10289 }
\DoxyCodeLine{10290 \textcolor{preprocessor}{\#if defined(\_\_clang\_\_)}}
\DoxyCodeLine{10291 \textcolor{preprocessor}{\#    pragma clang diagnostic pop}}
\DoxyCodeLine{10292 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{10293 }
\DoxyCodeLine{10294 \textcolor{comment}{// end catch\_console\_colour.cpp}}
\DoxyCodeLine{10295 \textcolor{comment}{// start catch\_context.cpp}}
\DoxyCodeLine{10296 }
\DoxyCodeLine{10297 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{10298 }
\DoxyCodeLine{10299     \textcolor{keyword}{class }Context : \textcolor{keyword}{public} IMutableContext, NonCopyable \{}
\DoxyCodeLine{10300 }
\DoxyCodeLine{10301     \textcolor{keyword}{public}: \textcolor{comment}{// IContext}}
\DoxyCodeLine{10302         IResultCapture* getResultCapture()\textcolor{keyword}{ override }\{}
\DoxyCodeLine{10303             \textcolor{keywordflow}{return} m\_resultCapture;}
\DoxyCodeLine{10304         \}}
\DoxyCodeLine{10305         IRunner* getRunner()\textcolor{keyword}{ override }\{}
\DoxyCodeLine{10306             \textcolor{keywordflow}{return} m\_runner;}
\DoxyCodeLine{10307         \}}
\DoxyCodeLine{10308 }
\DoxyCodeLine{10309         IConfigPtr \textcolor{keyword}{const}\& getConfig()\textcolor{keyword}{ const override }\{}
\DoxyCodeLine{10310             \textcolor{keywordflow}{return} m\_config;}
\DoxyCodeLine{10311         \}}
\DoxyCodeLine{10312 }
\DoxyCodeLine{10313         \string~Context() \textcolor{keyword}{override};}
\DoxyCodeLine{10314 }
\DoxyCodeLine{10315     \textcolor{keyword}{public}: \textcolor{comment}{// IMutableContext}}
\DoxyCodeLine{10316         \textcolor{keywordtype}{void} setResultCapture( IResultCapture* resultCapture )\textcolor{keyword}{ override }\{}
\DoxyCodeLine{10317             m\_resultCapture = resultCapture;}
\DoxyCodeLine{10318         \}}
\DoxyCodeLine{10319         \textcolor{keywordtype}{void} setRunner( IRunner* runner )\textcolor{keyword}{ override }\{}
\DoxyCodeLine{10320             m\_runner = runner;}
\DoxyCodeLine{10321         \}}
\DoxyCodeLine{10322         \textcolor{keywordtype}{void} setConfig( IConfigPtr \textcolor{keyword}{const}\& config )\textcolor{keyword}{ override }\{}
\DoxyCodeLine{10323             m\_config = config;}
\DoxyCodeLine{10324         \}}
\DoxyCodeLine{10325 }
\DoxyCodeLine{10326         \textcolor{keyword}{friend} IMutableContext\& getCurrentMutableContext();}
\DoxyCodeLine{10327 }
\DoxyCodeLine{10328     \textcolor{keyword}{private}:}
\DoxyCodeLine{10329         IConfigPtr m\_config;}
\DoxyCodeLine{10330         IRunner* m\_runner = \textcolor{keyword}{nullptr};}
\DoxyCodeLine{10331         IResultCapture* m\_resultCapture = \textcolor{keyword}{nullptr};}
\DoxyCodeLine{10332     \};}
\DoxyCodeLine{10333 }
\DoxyCodeLine{10334     IMutableContext *IMutableContext::currentContext = \textcolor{keyword}{nullptr};}
\DoxyCodeLine{10335 }
\DoxyCodeLine{10336     \textcolor{keywordtype}{void} IMutableContext::createContext()}
\DoxyCodeLine{10337     \{}
\DoxyCodeLine{10338         currentContext = \textcolor{keyword}{new} Context();}
\DoxyCodeLine{10339     \}}
\DoxyCodeLine{10340 }
\DoxyCodeLine{10341     \textcolor{keywordtype}{void} cleanUpContext() \{}
\DoxyCodeLine{10342         \textcolor{keyword}{delete} IMutableContext::currentContext;}
\DoxyCodeLine{10343         IMutableContext::currentContext = \textcolor{keyword}{nullptr};}
\DoxyCodeLine{10344     \}}
\DoxyCodeLine{10345     IContext::\string~IContext() = \textcolor{keywordflow}{default};}
\DoxyCodeLine{10346     IMutableContext::\string~IMutableContext() = \textcolor{keywordflow}{default};}
\DoxyCodeLine{10347     Context::\string~Context() = \textcolor{keywordflow}{default};}
\DoxyCodeLine{10348 }
\DoxyCodeLine{10349     SimplePcg32\& rng() \{}
\DoxyCodeLine{10350         \textcolor{keyword}{static} SimplePcg32 s\_rng;}
\DoxyCodeLine{10351         \textcolor{keywordflow}{return} s\_rng;}
\DoxyCodeLine{10352     \}}
\DoxyCodeLine{10353 }
\DoxyCodeLine{10354 \}}
\DoxyCodeLine{10355 \textcolor{comment}{// end catch\_context.cpp}}
\DoxyCodeLine{10356 \textcolor{comment}{// start catch\_debug\_console.cpp}}
\DoxyCodeLine{10357 }
\DoxyCodeLine{10358 \textcolor{comment}{// start catch\_debug\_console.h}}
\DoxyCodeLine{10359 }
\DoxyCodeLine{10360 \textcolor{preprocessor}{\#include <string>}}
\DoxyCodeLine{10361 }
\DoxyCodeLine{10362 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{10363     \textcolor{keywordtype}{void} writeToDebugConsole( std::string \textcolor{keyword}{const}\& text );}
\DoxyCodeLine{10364 \}}
\DoxyCodeLine{10365 }
\DoxyCodeLine{10366 \textcolor{comment}{// end catch\_debug\_console.h}}
\DoxyCodeLine{10367 \textcolor{preprocessor}{\#if defined(CATCH\_CONFIG\_ANDROID\_LOGWRITE)}}
\DoxyCodeLine{10368 \textcolor{preprocessor}{\#include <android/log.h>}}
\DoxyCodeLine{10369 }
\DoxyCodeLine{10370     \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{10371         \textcolor{keywordtype}{void} writeToDebugConsole( std::string \textcolor{keyword}{const}\& text ) \{}
\DoxyCodeLine{10372             \_\_android\_log\_write( ANDROID\_LOG\_DEBUG, \textcolor{stringliteral}{"{}Catch"{}}, text.c\_str() );}
\DoxyCodeLine{10373         \}}
\DoxyCodeLine{10374     \}}
\DoxyCodeLine{10375 }
\DoxyCodeLine{10376 \textcolor{preprocessor}{\#elif defined(CATCH\_PLATFORM\_WINDOWS)}}
\DoxyCodeLine{10377 }
\DoxyCodeLine{10378     \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{10379         \textcolor{keywordtype}{void} writeToDebugConsole( std::string \textcolor{keyword}{const}\& text ) \{}
\DoxyCodeLine{10380             ::OutputDebugStringA( text.c\_str() );}
\DoxyCodeLine{10381         \}}
\DoxyCodeLine{10382     \}}
\DoxyCodeLine{10383 }
\DoxyCodeLine{10384 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{10385 }
\DoxyCodeLine{10386     \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{10387         \textcolor{keywordtype}{void} writeToDebugConsole( std::string \textcolor{keyword}{const}\& text ) \{}
\DoxyCodeLine{10388             \textcolor{comment}{// !TBD: Need a version for Mac/ XCode and other IDEs}}
\DoxyCodeLine{10389             Catch::cout() << text;}
\DoxyCodeLine{10390         \}}
\DoxyCodeLine{10391     \}}
\DoxyCodeLine{10392 }
\DoxyCodeLine{10393 \textcolor{preprocessor}{\#endif }\textcolor{comment}{// Platform}}
\DoxyCodeLine{10394 \textcolor{comment}{// end catch\_debug\_console.cpp}}
\DoxyCodeLine{10395 \textcolor{comment}{// start catch\_debugger.cpp}}
\DoxyCodeLine{10396 }
\DoxyCodeLine{10397 \textcolor{preprocessor}{\#if defined(CATCH\_PLATFORM\_MAC) || defined(CATCH\_PLATFORM\_IPHONE)}}
\DoxyCodeLine{10398 }
\DoxyCodeLine{10399 \textcolor{preprocessor}{\#  include <cassert>}}
\DoxyCodeLine{10400 \textcolor{preprocessor}{\#  include <sys/types.h>}}
\DoxyCodeLine{10401 \textcolor{preprocessor}{\#  include <unistd.h>}}
\DoxyCodeLine{10402 \textcolor{preprocessor}{\#  include <cstddef>}}
\DoxyCodeLine{10403 \textcolor{preprocessor}{\#  include <ostream>}}
\DoxyCodeLine{10404 }
\DoxyCodeLine{10405 \textcolor{preprocessor}{\#ifdef \_\_apple\_build\_version\_\_}}
\DoxyCodeLine{10406     \textcolor{comment}{// These headers will only compile with AppleClang (XCode)}}
\DoxyCodeLine{10407     \textcolor{comment}{// For other compilers (Clang, GCC, ... ) we need to exclude them}}
\DoxyCodeLine{10408 \textcolor{preprocessor}{\#  include <sys/sysctl.h>}}
\DoxyCodeLine{10409 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{10410 }
\DoxyCodeLine{10411     \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{10412 \textcolor{preprocessor}{        \#ifdef \_\_apple\_build\_version\_\_}}
\DoxyCodeLine{10413         \textcolor{comment}{// The following function is taken directly from the following technical note:}}
\DoxyCodeLine{10414         \textcolor{comment}{// https://developer.apple.com/library/archive/qa/qa1361/\_index.html}}
\DoxyCodeLine{10415 }
\DoxyCodeLine{10416         \textcolor{comment}{// Returns true if the current process is being debugged (either}}
\DoxyCodeLine{10417         \textcolor{comment}{// running under the debugger or has a debugger attached post facto).}}
\DoxyCodeLine{10418         \textcolor{keywordtype}{bool} isDebuggerActive()\{}
\DoxyCodeLine{10419             \textcolor{keywordtype}{int}                 mib[4];}
\DoxyCodeLine{10420             \textcolor{keyword}{struct }kinfo\_proc   info;}
\DoxyCodeLine{10421             std::size\_t         size;}
\DoxyCodeLine{10422 }
\DoxyCodeLine{10423             \textcolor{comment}{// Initialize the flags so that, if sysctl fails for some bizarre}}
\DoxyCodeLine{10424             \textcolor{comment}{// reason, we get a predictable result.}}
\DoxyCodeLine{10425 }
\DoxyCodeLine{10426             info.kp\_proc.p\_flag = 0;}
\DoxyCodeLine{10427 }
\DoxyCodeLine{10428             \textcolor{comment}{// Initialize mib, which tells sysctl the info we want, in this case}}
\DoxyCodeLine{10429             \textcolor{comment}{// we're looking for information about a specific process ID.}}
\DoxyCodeLine{10430 }
\DoxyCodeLine{10431             mib[0] = CTL\_KERN;}
\DoxyCodeLine{10432             mib[1] = KERN\_PROC;}
\DoxyCodeLine{10433             mib[2] = KERN\_PROC\_PID;}
\DoxyCodeLine{10434             mib[3] = getpid();}
\DoxyCodeLine{10435 }
\DoxyCodeLine{10436             \textcolor{comment}{// Call sysctl.}}
\DoxyCodeLine{10437 }
\DoxyCodeLine{10438             size = \textcolor{keyword}{sizeof}(info);}
\DoxyCodeLine{10439             \textcolor{keywordflow}{if}( sysctl(mib, \textcolor{keyword}{sizeof}(mib) / \textcolor{keyword}{sizeof}(*mib), \&info, \&size, \textcolor{keyword}{nullptr}, 0) != 0 ) \{}
\DoxyCodeLine{10440                 Catch::cerr() << \textcolor{stringliteral}{"{}\(\backslash\)n** Call to sysctl failed -\/ unable to determine if debugger is active **\(\backslash\)n"{}} << std::endl;}
\DoxyCodeLine{10441                 \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{10442             \}}
\DoxyCodeLine{10443 }
\DoxyCodeLine{10444             \textcolor{comment}{// We're being debugged if the P\_TRACED flag is set.}}
\DoxyCodeLine{10445 }
\DoxyCodeLine{10446             \textcolor{keywordflow}{return} ( (info.kp\_proc.p\_flag \& P\_TRACED) != 0 );}
\DoxyCodeLine{10447         \}}
\DoxyCodeLine{10448 \textcolor{preprocessor}{        \#else}}
\DoxyCodeLine{10449         \textcolor{keywordtype}{bool} isDebuggerActive() \{}
\DoxyCodeLine{10450             \textcolor{comment}{// We need to find another way to determine this for non-\/appleclang compilers on macOS}}
\DoxyCodeLine{10451             \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{10452         \}}
\DoxyCodeLine{10453 \textcolor{preprocessor}{        \#endif}}
\DoxyCodeLine{10454     \} \textcolor{comment}{// namespace Catch}}
\DoxyCodeLine{10455 }
\DoxyCodeLine{10456 \textcolor{preprocessor}{\#elif defined(CATCH\_PLATFORM\_LINUX)}}
\DoxyCodeLine{10457 \textcolor{preprocessor}{    \#include <fstream>}}
\DoxyCodeLine{10458 \textcolor{preprocessor}{    \#include <string>}}
\DoxyCodeLine{10459 }
\DoxyCodeLine{10460     \textcolor{keyword}{namespace }Catch\{}
\DoxyCodeLine{10461         \textcolor{comment}{// The standard POSIX way of detecting a debugger is to attempt to}}
\DoxyCodeLine{10462         \textcolor{comment}{// ptrace() the process, but this needs to be done from a child and not}}
\DoxyCodeLine{10463         \textcolor{comment}{// this process itself to still allow attaching to this process later}}
\DoxyCodeLine{10464         \textcolor{comment}{// if wanted, so is rather heavy. Under Linux we have the PID of the}}
\DoxyCodeLine{10465         \textcolor{comment}{// "{}debugger"{} (which doesn't need to be gdb, of course, it could also}}
\DoxyCodeLine{10466         \textcolor{comment}{// be strace, for example) in /proc/\$PID/status, so just get it from}}
\DoxyCodeLine{10467         \textcolor{comment}{// there instead.}}
\DoxyCodeLine{10468         \textcolor{keywordtype}{bool} isDebuggerActive()\{}
\DoxyCodeLine{10469             \textcolor{comment}{// Libstdc++ has a bug, where std::ifstream sets errno to 0}}
\DoxyCodeLine{10470             \textcolor{comment}{// This way our users can properly assert over errno values}}
\DoxyCodeLine{10471             ErrnoGuard guard;}
\DoxyCodeLine{10472             std::ifstream in(\textcolor{stringliteral}{"{}/proc/self/status"{}});}
\DoxyCodeLine{10473             \textcolor{keywordflow}{for}( std::string line; std::getline(in, line); ) \{}
\DoxyCodeLine{10474                 \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{int} PREFIX\_LEN = 11;}
\DoxyCodeLine{10475                 \textcolor{keywordflow}{if}( line.compare(0, PREFIX\_LEN, \textcolor{stringliteral}{"{}TracerPid:\(\backslash\)t"{}}) == 0 ) \{}
\DoxyCodeLine{10476                     \textcolor{comment}{// We're traced if the PID is not 0 and no other PID starts}}
\DoxyCodeLine{10477                     \textcolor{comment}{// with 0 digit, so it's enough to check for just a single}}
\DoxyCodeLine{10478                     \textcolor{comment}{// character.}}
\DoxyCodeLine{10479                     \textcolor{keywordflow}{return} line.length() > PREFIX\_LEN \&\& line[PREFIX\_LEN] != \textcolor{charliteral}{'0'};}
\DoxyCodeLine{10480                 \}}
\DoxyCodeLine{10481             \}}
\DoxyCodeLine{10482 }
\DoxyCodeLine{10483             \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{10484         \}}
\DoxyCodeLine{10485     \} \textcolor{comment}{// namespace Catch}}
\DoxyCodeLine{10486 \textcolor{preprocessor}{\#elif defined(\_MSC\_VER)}}
\DoxyCodeLine{10487     \textcolor{keyword}{extern} \textcolor{stringliteral}{"{}C"{}} \_\_declspec(dllimport) \textcolor{keywordtype}{int} \_\_stdcall IsDebuggerPresent();}
\DoxyCodeLine{10488     \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{10489         \textcolor{keywordtype}{bool} isDebuggerActive() \{}
\DoxyCodeLine{10490             \textcolor{keywordflow}{return} IsDebuggerPresent() != 0;}
\DoxyCodeLine{10491         \}}
\DoxyCodeLine{10492     \}}
\DoxyCodeLine{10493 \textcolor{preprocessor}{\#elif defined(\_\_MINGW32\_\_)}}
\DoxyCodeLine{10494     \textcolor{keyword}{extern} \textcolor{stringliteral}{"{}C"{}} \_\_declspec(dllimport) \textcolor{keywordtype}{int} \_\_stdcall IsDebuggerPresent();}
\DoxyCodeLine{10495     \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{10496         \textcolor{keywordtype}{bool} isDebuggerActive() \{}
\DoxyCodeLine{10497             \textcolor{keywordflow}{return} IsDebuggerPresent() != 0;}
\DoxyCodeLine{10498         \}}
\DoxyCodeLine{10499     \}}
\DoxyCodeLine{10500 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{10501     \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{10502        \textcolor{keywordtype}{bool} isDebuggerActive() \{ \textcolor{keywordflow}{return} \textcolor{keyword}{false}; \}}
\DoxyCodeLine{10503     \}}
\DoxyCodeLine{10504 \textcolor{preprocessor}{\#endif }\textcolor{comment}{// Platform}}
\DoxyCodeLine{10505 \textcolor{comment}{// end catch\_debugger.cpp}}
\DoxyCodeLine{10506 \textcolor{comment}{// start catch\_decomposer.cpp}}
\DoxyCodeLine{10507 }
\DoxyCodeLine{10508 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{10509 }
\DoxyCodeLine{10510     ITransientExpression::\string~ITransientExpression() = \textcolor{keywordflow}{default};}
\DoxyCodeLine{10511 }
\DoxyCodeLine{10512     \textcolor{keywordtype}{void} formatReconstructedExpression( std::ostream \&os, std::string \textcolor{keyword}{const}\& lhs, StringRef op, std::string \textcolor{keyword}{const}\& rhs ) \{}
\DoxyCodeLine{10513         \textcolor{keywordflow}{if}( lhs.size() + rhs.size() < 40 \&\&}
\DoxyCodeLine{10514                 lhs.find(\textcolor{charliteral}{'\(\backslash\)n'}) == std::string::npos \&\&}
\DoxyCodeLine{10515                 rhs.find(\textcolor{charliteral}{'\(\backslash\)n'}) == std::string::npos )}
\DoxyCodeLine{10516             os << lhs << \textcolor{stringliteral}{"{} "{}} << op << \textcolor{stringliteral}{"{} "{}} << rhs;}
\DoxyCodeLine{10517         \textcolor{keywordflow}{else}}
\DoxyCodeLine{10518             os << lhs << \textcolor{stringliteral}{"{}\(\backslash\)n"{}} << op << \textcolor{stringliteral}{"{}\(\backslash\)n"{}} << rhs;}
\DoxyCodeLine{10519     \}}
\DoxyCodeLine{10520 \}}
\DoxyCodeLine{10521 \textcolor{comment}{// end catch\_decomposer.cpp}}
\DoxyCodeLine{10522 \textcolor{comment}{// start catch\_enforce.cpp}}
\DoxyCodeLine{10523 }
\DoxyCodeLine{10524 \textcolor{preprocessor}{\#include <stdexcept>}}
\DoxyCodeLine{10525 }
\DoxyCodeLine{10526 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{10527 \textcolor{preprocessor}{\#if defined(CATCH\_CONFIG\_DISABLE\_EXCEPTIONS) \&\& !defined(CATCH\_CONFIG\_DISABLE\_EXCEPTIONS\_CUSTOM\_HANDLER)}}
\DoxyCodeLine{10528     [[noreturn]]}
\DoxyCodeLine{10529     \textcolor{keywordtype}{void} throw\_exception(std::exception \textcolor{keyword}{const}\& e) \{}
\DoxyCodeLine{10530         Catch::cerr() << \textcolor{stringliteral}{"{}Catch will terminate because it needed to throw an exception.\(\backslash\)n"{}}}
\DoxyCodeLine{10531                       << \textcolor{stringliteral}{"{}The message was: "{}} << e.what() << \textcolor{charliteral}{'\(\backslash\)n'};}
\DoxyCodeLine{10532         std::terminate();}
\DoxyCodeLine{10533     \}}
\DoxyCodeLine{10534 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{10535 }
\DoxyCodeLine{10536     [[noreturn]]}
\DoxyCodeLine{10537     \textcolor{keywordtype}{void} throw\_logic\_error(std::string \textcolor{keyword}{const}\& msg) \{}
\DoxyCodeLine{10538         throw\_exception(std::logic\_error(msg));}
\DoxyCodeLine{10539     \}}
\DoxyCodeLine{10540 }
\DoxyCodeLine{10541     [[noreturn]]}
\DoxyCodeLine{10542     \textcolor{keywordtype}{void} throw\_domain\_error(std::string \textcolor{keyword}{const}\& msg) \{}
\DoxyCodeLine{10543         throw\_exception(std::domain\_error(msg));}
\DoxyCodeLine{10544     \}}
\DoxyCodeLine{10545 }
\DoxyCodeLine{10546     [[noreturn]]}
\DoxyCodeLine{10547     \textcolor{keywordtype}{void} throw\_runtime\_error(std::string \textcolor{keyword}{const}\& msg) \{}
\DoxyCodeLine{10548         throw\_exception(std::runtime\_error(msg));}
\DoxyCodeLine{10549     \}}
\DoxyCodeLine{10550 }
\DoxyCodeLine{10551 \} \textcolor{comment}{// namespace Catch;}}
\DoxyCodeLine{10552 \textcolor{comment}{// end catch\_enforce.cpp}}
\DoxyCodeLine{10553 \textcolor{comment}{// start catch\_enum\_values\_registry.cpp}}
\DoxyCodeLine{10554 \textcolor{comment}{// start catch\_enum\_values\_registry.h}}
\DoxyCodeLine{10555 }
\DoxyCodeLine{10556 \textcolor{preprocessor}{\#include <vector>}}
\DoxyCodeLine{10557 \textcolor{preprocessor}{\#include <memory>}}
\DoxyCodeLine{10558 }
\DoxyCodeLine{10559 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{10560 }
\DoxyCodeLine{10561     \textcolor{keyword}{namespace }Detail \{}
\DoxyCodeLine{10562 }
\DoxyCodeLine{10563         std::unique\_ptr<EnumInfo> makeEnumInfo( StringRef enumName, StringRef allValueNames, std::vector<int> \textcolor{keyword}{const}\& values );}
\DoxyCodeLine{10564 }
\DoxyCodeLine{10565         \textcolor{keyword}{class }EnumValuesRegistry : \textcolor{keyword}{public} IMutableEnumValuesRegistry \{}
\DoxyCodeLine{10566 }
\DoxyCodeLine{10567             std::vector<std::unique\_ptr<EnumInfo>> m\_enumInfos;}
\DoxyCodeLine{10568 }
\DoxyCodeLine{10569             EnumInfo \textcolor{keyword}{const}\& registerEnum( StringRef enumName, StringRef allEnums, std::vector<int> \textcolor{keyword}{const}\& values) \textcolor{keyword}{override};}
\DoxyCodeLine{10570         \};}
\DoxyCodeLine{10571 }
\DoxyCodeLine{10572         std::vector<StringRef> parseEnums( StringRef enums );}
\DoxyCodeLine{10573 }
\DoxyCodeLine{10574     \} \textcolor{comment}{// Detail}}
\DoxyCodeLine{10575 }
\DoxyCodeLine{10576 \} \textcolor{comment}{// Catch}}
\DoxyCodeLine{10577 }
\DoxyCodeLine{10578 \textcolor{comment}{// end catch\_enum\_values\_registry.h}}
\DoxyCodeLine{10579 }
\DoxyCodeLine{10580 \textcolor{preprocessor}{\#include <map>}}
\DoxyCodeLine{10581 \textcolor{preprocessor}{\#include <cassert>}}
\DoxyCodeLine{10582 }
\DoxyCodeLine{10583 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{10584 }
\DoxyCodeLine{10585     IMutableEnumValuesRegistry::\string~IMutableEnumValuesRegistry() \{\}}
\DoxyCodeLine{10586 }
\DoxyCodeLine{10587     \textcolor{keyword}{namespace }Detail \{}
\DoxyCodeLine{10588 }
\DoxyCodeLine{10589         \textcolor{keyword}{namespace }\{}
\DoxyCodeLine{10590             \textcolor{comment}{// Extracts the actual name part of an enum instance}}
\DoxyCodeLine{10591             \textcolor{comment}{// In other words, it returns the Blue part of Bikeshed::Colour::Blue}}
\DoxyCodeLine{10592             StringRef extractInstanceName(StringRef enumInstance) \{}
\DoxyCodeLine{10593                 \textcolor{comment}{// Find last occurrence of "{}:"{}}}
\DoxyCodeLine{10594                 \textcolor{keywordtype}{size\_t} name\_start = enumInstance.size();}
\DoxyCodeLine{10595                 \textcolor{keywordflow}{while} (name\_start > 0 \&\& enumInstance[name\_start -\/ 1] != \textcolor{charliteral}{':'}) \{}
\DoxyCodeLine{10596                     -\/-\/name\_start;}
\DoxyCodeLine{10597                 \}}
\DoxyCodeLine{10598                 \textcolor{keywordflow}{return} enumInstance.substr(name\_start, enumInstance.size() -\/ name\_start);}
\DoxyCodeLine{10599             \}}
\DoxyCodeLine{10600         \}}
\DoxyCodeLine{10601 }
\DoxyCodeLine{10602         std::vector<StringRef> parseEnums( StringRef enums ) \{}
\DoxyCodeLine{10603             \textcolor{keyword}{auto} enumValues = splitStringRef( enums, \textcolor{charliteral}{','} );}
\DoxyCodeLine{10604             std::vector<StringRef> parsed;}
\DoxyCodeLine{10605             parsed.reserve( enumValues.size() );}
\DoxyCodeLine{10606             \textcolor{keywordflow}{for}( \textcolor{keyword}{auto} \textcolor{keyword}{const}\& enumValue : enumValues ) \{}
\DoxyCodeLine{10607                 parsed.push\_back(trim(extractInstanceName(enumValue)));}
\DoxyCodeLine{10608             \}}
\DoxyCodeLine{10609             \textcolor{keywordflow}{return} parsed;}
\DoxyCodeLine{10610         \}}
\DoxyCodeLine{10611 }
\DoxyCodeLine{10612         EnumInfo::\string~EnumInfo() \{\}}
\DoxyCodeLine{10613 }
\DoxyCodeLine{10614         StringRef EnumInfo::lookup( \textcolor{keywordtype}{int} value )\textcolor{keyword}{ const }\{}
\DoxyCodeLine{10615             \textcolor{keywordflow}{for}( \textcolor{keyword}{auto} \textcolor{keyword}{const}\& valueToName : m\_values ) \{}
\DoxyCodeLine{10616                 \textcolor{keywordflow}{if}( valueToName.first == value )}
\DoxyCodeLine{10617                     \textcolor{keywordflow}{return} valueToName.second;}
\DoxyCodeLine{10618             \}}
\DoxyCodeLine{10619             \textcolor{keywordflow}{return} \textcolor{stringliteral}{"{}\{** unexpected enum value **\}"{}}\_sr;}
\DoxyCodeLine{10620         \}}
\DoxyCodeLine{10621 }
\DoxyCodeLine{10622         std::unique\_ptr<EnumInfo> makeEnumInfo( StringRef enumName, StringRef allValueNames, std::vector<int> \textcolor{keyword}{const}\& values ) \{}
\DoxyCodeLine{10623             std::unique\_ptr<EnumInfo> enumInfo( \textcolor{keyword}{new} EnumInfo );}
\DoxyCodeLine{10624             enumInfo-\/>m\_name = enumName;}
\DoxyCodeLine{10625             enumInfo-\/>m\_values.reserve( values.size() );}
\DoxyCodeLine{10626 }
\DoxyCodeLine{10627             \textcolor{keyword}{const} \textcolor{keyword}{auto} valueNames = Catch::Detail::parseEnums( allValueNames );}
\DoxyCodeLine{10628             assert( valueNames.size() == values.size() );}
\DoxyCodeLine{10629             std::size\_t i = 0;}
\DoxyCodeLine{10630             \textcolor{keywordflow}{for}( \textcolor{keyword}{auto} value : values )}
\DoxyCodeLine{10631                 enumInfo-\/>m\_values.emplace\_back(value, valueNames[i++]);}
\DoxyCodeLine{10632 }
\DoxyCodeLine{10633             \textcolor{keywordflow}{return} enumInfo;}
\DoxyCodeLine{10634         \}}
\DoxyCodeLine{10635 }
\DoxyCodeLine{10636         EnumInfo \textcolor{keyword}{const}\& EnumValuesRegistry::registerEnum( StringRef enumName, StringRef allValueNames, std::vector<int> \textcolor{keyword}{const}\& values ) \{}
\DoxyCodeLine{10637             m\_enumInfos.push\_back(makeEnumInfo(enumName, allValueNames, values));}
\DoxyCodeLine{10638             \textcolor{keywordflow}{return} *m\_enumInfos.back();}
\DoxyCodeLine{10639         \}}
\DoxyCodeLine{10640 }
\DoxyCodeLine{10641     \} \textcolor{comment}{// Detail}}
\DoxyCodeLine{10642 \} \textcolor{comment}{// Catch}}
\DoxyCodeLine{10643 }
\DoxyCodeLine{10644 \textcolor{comment}{// end catch\_enum\_values\_registry.cpp}}
\DoxyCodeLine{10645 \textcolor{comment}{// start catch\_errno\_guard.cpp}}
\DoxyCodeLine{10646 }
\DoxyCodeLine{10647 \textcolor{preprocessor}{\#include <cerrno>}}
\DoxyCodeLine{10648 }
\DoxyCodeLine{10649 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{10650         ErrnoGuard::ErrnoGuard():m\_oldErrno(errno)\{\}}
\DoxyCodeLine{10651         ErrnoGuard::\string~ErrnoGuard() \{ errno = m\_oldErrno; \}}
\DoxyCodeLine{10652 \}}
\DoxyCodeLine{10653 \textcolor{comment}{// end catch\_errno\_guard.cpp}}
\DoxyCodeLine{10654 \textcolor{comment}{// start catch\_exception\_translator\_registry.cpp}}
\DoxyCodeLine{10655 }
\DoxyCodeLine{10656 \textcolor{comment}{// start catch\_exception\_translator\_registry.h}}
\DoxyCodeLine{10657 }
\DoxyCodeLine{10658 \textcolor{preprocessor}{\#include <vector>}}
\DoxyCodeLine{10659 \textcolor{preprocessor}{\#include <string>}}
\DoxyCodeLine{10660 \textcolor{preprocessor}{\#include <memory>}}
\DoxyCodeLine{10661 }
\DoxyCodeLine{10662 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{10663 }
\DoxyCodeLine{10664     \textcolor{keyword}{class }ExceptionTranslatorRegistry : \textcolor{keyword}{public} IExceptionTranslatorRegistry \{}
\DoxyCodeLine{10665     \textcolor{keyword}{public}:}
\DoxyCodeLine{10666         \string~ExceptionTranslatorRegistry();}
\DoxyCodeLine{10667         \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} registerTranslator( \textcolor{keyword}{const} IExceptionTranslator* translator );}
\DoxyCodeLine{10668         std::string translateActiveException() \textcolor{keyword}{const override};}
\DoxyCodeLine{10669         std::string tryTranslators() \textcolor{keyword}{const};}
\DoxyCodeLine{10670 }
\DoxyCodeLine{10671     \textcolor{keyword}{private}:}
\DoxyCodeLine{10672         std::vector<std::unique\_ptr<IExceptionTranslator const>> m\_translators;}
\DoxyCodeLine{10673     \};}
\DoxyCodeLine{10674 \}}
\DoxyCodeLine{10675 }
\DoxyCodeLine{10676 \textcolor{comment}{// end catch\_exception\_translator\_registry.h}}
\DoxyCodeLine{10677 \textcolor{preprocessor}{\#ifdef \_\_OBJC\_\_}}
\DoxyCodeLine{10678 \textcolor{preprocessor}{\#import "{}Foundation/Foundation.h"{}}}
\DoxyCodeLine{10679 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{10680 }
\DoxyCodeLine{10681 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{10682 }
\DoxyCodeLine{10683     ExceptionTranslatorRegistry::\string~ExceptionTranslatorRegistry() \{}
\DoxyCodeLine{10684     \}}
\DoxyCodeLine{10685 }
\DoxyCodeLine{10686     \textcolor{keywordtype}{void} ExceptionTranslatorRegistry::registerTranslator( \textcolor{keyword}{const} IExceptionTranslator* translator ) \{}
\DoxyCodeLine{10687         m\_translators.push\_back( std::unique\_ptr<const IExceptionTranslator>( translator ) );}
\DoxyCodeLine{10688     \}}
\DoxyCodeLine{10689 }
\DoxyCodeLine{10690 \textcolor{preprocessor}{\#if !defined(CATCH\_CONFIG\_DISABLE\_EXCEPTIONS)}}
\DoxyCodeLine{10691     std::string ExceptionTranslatorRegistry::translateActiveException()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{10692         \textcolor{keywordflow}{try} \{}
\DoxyCodeLine{10693 \textcolor{preprocessor}{\#ifdef \_\_OBJC\_\_}}
\DoxyCodeLine{10694             \textcolor{comment}{// In Objective-\/C try objective-\/c exceptions first}}
\DoxyCodeLine{10695             \textcolor{keywordflow}{@try} \{}
\DoxyCodeLine{10696                 \textcolor{keywordflow}{return} tryTranslators();}
\DoxyCodeLine{10697             \}}
\DoxyCodeLine{10698             \textcolor{keywordflow}{@catch} (NSException *exception) \{}
\DoxyCodeLine{10699                 \textcolor{keywordflow}{return} Catch::Detail::stringify( [exception description] );}
\DoxyCodeLine{10700             \}}
\DoxyCodeLine{10701 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{10702             \textcolor{comment}{// Compiling a mixed mode project with MSVC means that CLR}}
\DoxyCodeLine{10703             \textcolor{comment}{// exceptions will be caught in (...) as well. However, these}}
\DoxyCodeLine{10704             \textcolor{comment}{// do not fill-\/in std::current\_exception and thus lead to crash}}
\DoxyCodeLine{10705             \textcolor{comment}{// when attempting rethrow.}}
\DoxyCodeLine{10706             \textcolor{comment}{// /EHa switch also causes structured exceptions to be caught}}
\DoxyCodeLine{10707             \textcolor{comment}{// here, but they fill-\/in current\_exception properly, so}}
\DoxyCodeLine{10708             \textcolor{comment}{// at worst the output should be a little weird, instead of}}
\DoxyCodeLine{10709             \textcolor{comment}{// causing a crash.}}
\DoxyCodeLine{10710             \textcolor{keywordflow}{if} (std::current\_exception() == \textcolor{keyword}{nullptr}) \{}
\DoxyCodeLine{10711                 \textcolor{keywordflow}{return} \textcolor{stringliteral}{"{}Non C++ exception. Possibly a CLR exception."{}};}
\DoxyCodeLine{10712             \}}
\DoxyCodeLine{10713             \textcolor{keywordflow}{return} tryTranslators();}
\DoxyCodeLine{10714 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{10715         \}}
\DoxyCodeLine{10716         \textcolor{keywordflow}{catch}( TestFailureException\& ) \{}
\DoxyCodeLine{10717             std::rethrow\_exception(std::current\_exception());}
\DoxyCodeLine{10718         \}}
\DoxyCodeLine{10719         \textcolor{keywordflow}{catch}( std::exception\& ex ) \{}
\DoxyCodeLine{10720             \textcolor{keywordflow}{return} ex.what();}
\DoxyCodeLine{10721         \}}
\DoxyCodeLine{10722         \textcolor{keywordflow}{catch}( std::string\& msg ) \{}
\DoxyCodeLine{10723             \textcolor{keywordflow}{return} msg;}
\DoxyCodeLine{10724         \}}
\DoxyCodeLine{10725         \textcolor{keywordflow}{catch}( \textcolor{keyword}{const} \textcolor{keywordtype}{char}* msg ) \{}
\DoxyCodeLine{10726             \textcolor{keywordflow}{return} msg;}
\DoxyCodeLine{10727         \}}
\DoxyCodeLine{10728         \textcolor{keywordflow}{catch}(...) \{}
\DoxyCodeLine{10729             \textcolor{keywordflow}{return} \textcolor{stringliteral}{"{}Unknown exception"{}};}
\DoxyCodeLine{10730         \}}
\DoxyCodeLine{10731     \}}
\DoxyCodeLine{10732 }
\DoxyCodeLine{10733     std::string ExceptionTranslatorRegistry::tryTranslators()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{10734         \textcolor{keywordflow}{if} (m\_translators.empty()) \{}
\DoxyCodeLine{10735             std::rethrow\_exception(std::current\_exception());}
\DoxyCodeLine{10736         \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{10737             \textcolor{keywordflow}{return} m\_translators[0]-\/>translate(m\_translators.begin() + 1, m\_translators.end());}
\DoxyCodeLine{10738         \}}
\DoxyCodeLine{10739     \}}
\DoxyCodeLine{10740 }
\DoxyCodeLine{10741 \textcolor{preprocessor}{\#else }\textcolor{comment}{// \string^\string^ Exceptions are enabled // Exceptions are disabled vv}}
\DoxyCodeLine{10742     std::string ExceptionTranslatorRegistry::translateActiveException()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{10743         CATCH\_INTERNAL\_ERROR(\textcolor{stringliteral}{"{}Attempted to translate active exception under CATCH\_CONFIG\_DISABLE\_EXCEPTIONS!"{}});}
\DoxyCodeLine{10744     \}}
\DoxyCodeLine{10745 }
\DoxyCodeLine{10746     std::string ExceptionTranslatorRegistry::tryTranslators()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{10747         CATCH\_INTERNAL\_ERROR(\textcolor{stringliteral}{"{}Attempted to use exception translators under CATCH\_CONFIG\_DISABLE\_EXCEPTIONS!"{}});}
\DoxyCodeLine{10748     \}}
\DoxyCodeLine{10749 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{10750 }
\DoxyCodeLine{10751 \}}
\DoxyCodeLine{10752 \textcolor{comment}{// end catch\_exception\_translator\_registry.cpp}}
\DoxyCodeLine{10753 \textcolor{comment}{// start catch\_fatal\_condition.cpp}}
\DoxyCodeLine{10754 }
\DoxyCodeLine{10755 \textcolor{preprocessor}{\#include <algorithm>}}
\DoxyCodeLine{10756 }
\DoxyCodeLine{10757 \textcolor{preprocessor}{\#if !defined( CATCH\_CONFIG\_WINDOWS\_SEH ) \&\& !defined( CATCH\_CONFIG\_POSIX\_SIGNALS )}}
\DoxyCodeLine{10758 }
\DoxyCodeLine{10759 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{10760 }
\DoxyCodeLine{10761     \textcolor{comment}{// If neither SEH nor signal handling is required, the handler impls}}
\DoxyCodeLine{10762     \textcolor{comment}{// do not have to do anything, and can be empty.}}
\DoxyCodeLine{10763     \textcolor{keywordtype}{void} FatalConditionHandler::engage\_platform() \{\}}
\DoxyCodeLine{10764     \textcolor{keywordtype}{void} FatalConditionHandler::disengage\_platform() \{\}}
\DoxyCodeLine{10765     FatalConditionHandler::FatalConditionHandler() = \textcolor{keywordflow}{default};}
\DoxyCodeLine{10766     FatalConditionHandler::\string~FatalConditionHandler() = \textcolor{keywordflow}{default};}
\DoxyCodeLine{10767 }
\DoxyCodeLine{10768 \} \textcolor{comment}{// end namespace Catch}}
\DoxyCodeLine{10769 }
\DoxyCodeLine{10770 \textcolor{preprocessor}{\#endif }\textcolor{comment}{// !CATCH\_CONFIG\_WINDOWS\_SEH \&\& !CATCH\_CONFIG\_POSIX\_SIGNALS}}
\DoxyCodeLine{10771 }
\DoxyCodeLine{10772 \textcolor{preprocessor}{\#if defined( CATCH\_CONFIG\_WINDOWS\_SEH ) \&\& defined( CATCH\_CONFIG\_POSIX\_SIGNALS )}}
\DoxyCodeLine{10773 \textcolor{preprocessor}{\#error "{}Inconsistent configuration: Windows' SEH handling and POSIX signals cannot be enabled at the same time"{}}}
\DoxyCodeLine{10774 \textcolor{preprocessor}{\#endif }\textcolor{comment}{// CATCH\_CONFIG\_WINDOWS\_SEH \&\& CATCH\_CONFIG\_POSIX\_SIGNALS}}
\DoxyCodeLine{10775 }
\DoxyCodeLine{10776 \textcolor{preprocessor}{\#if defined( CATCH\_CONFIG\_WINDOWS\_SEH ) || defined( CATCH\_CONFIG\_POSIX\_SIGNALS )}}
\DoxyCodeLine{10777 }
\DoxyCodeLine{10778 \textcolor{keyword}{namespace }\{}
\DoxyCodeLine{10780     \textcolor{keywordtype}{void} reportFatal( \textcolor{keywordtype}{char} \textcolor{keyword}{const} * \textcolor{keyword}{const} message ) \{}
\DoxyCodeLine{10781         Catch::getCurrentContext().getResultCapture()-\/>handleFatalErrorCondition( message );}
\DoxyCodeLine{10782     \}}
\DoxyCodeLine{10783 }
\DoxyCodeLine{10787     \textcolor{keyword}{constexpr} std::size\_t minStackSizeForErrors = 32 * 1024;}
\DoxyCodeLine{10788 \} \textcolor{comment}{// end unnamed namespace}}
\DoxyCodeLine{10789 }
\DoxyCodeLine{10790 \textcolor{preprocessor}{\#endif }\textcolor{comment}{// CATCH\_CONFIG\_WINDOWS\_SEH || CATCH\_CONFIG\_POSIX\_SIGNALS}}
\DoxyCodeLine{10791 }
\DoxyCodeLine{10792 \textcolor{preprocessor}{\#if defined( CATCH\_CONFIG\_WINDOWS\_SEH )}}
\DoxyCodeLine{10793 }
\DoxyCodeLine{10794 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{10795 }
\DoxyCodeLine{10796     \textcolor{keyword}{struct }SignalDefs \{ DWORD id; \textcolor{keyword}{const} \textcolor{keywordtype}{char}* name; \};}
\DoxyCodeLine{10797 }
\DoxyCodeLine{10798     \textcolor{comment}{// There is no 1-\/1 mapping between signals and windows exceptions.}}
\DoxyCodeLine{10799     \textcolor{comment}{// Windows can easily distinguish between SO and SigSegV,}}
\DoxyCodeLine{10800     \textcolor{comment}{// but SigInt, SigTerm, etc are handled differently.}}
\DoxyCodeLine{10801     \textcolor{keyword}{static} SignalDefs signalDefs[] = \{}
\DoxyCodeLine{10802         \{ \textcolor{keyword}{static\_cast<}DWORD\textcolor{keyword}{>}(EXCEPTION\_ILLEGAL\_INSTRUCTION),  \textcolor{stringliteral}{"{}SIGILL -\/ Illegal instruction signal"{}} \},}
\DoxyCodeLine{10803         \{ \textcolor{keyword}{static\_cast<}DWORD\textcolor{keyword}{>}(EXCEPTION\_STACK\_OVERFLOW), \textcolor{stringliteral}{"{}SIGSEGV -\/ Stack overflow"{}} \},}
\DoxyCodeLine{10804         \{ \textcolor{keyword}{static\_cast<}DWORD\textcolor{keyword}{>}(EXCEPTION\_ACCESS\_VIOLATION), \textcolor{stringliteral}{"{}SIGSEGV -\/ Segmentation violation signal"{}} \},}
\DoxyCodeLine{10805         \{ \textcolor{keyword}{static\_cast<}DWORD\textcolor{keyword}{>}(EXCEPTION\_INT\_DIVIDE\_BY\_ZERO), \textcolor{stringliteral}{"{}Divide by zero error"{}} \},}
\DoxyCodeLine{10806     \};}
\DoxyCodeLine{10807 }
\DoxyCodeLine{10808     \textcolor{keyword}{static} LONG CALLBACK handleVectoredException(PEXCEPTION\_POINTERS ExceptionInfo) \{}
\DoxyCodeLine{10809         \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} \textcolor{keyword}{const}\& def : signalDefs) \{}
\DoxyCodeLine{10810             \textcolor{keywordflow}{if} (ExceptionInfo-\/>ExceptionRecord-\/>ExceptionCode == def.id) \{}
\DoxyCodeLine{10811                 reportFatal(def.name);}
\DoxyCodeLine{10812             \}}
\DoxyCodeLine{10813         \}}
\DoxyCodeLine{10814         \textcolor{comment}{// If its not an exception we care about, pass it along.}}
\DoxyCodeLine{10815         \textcolor{comment}{// This stops us from eating debugger breaks etc.}}
\DoxyCodeLine{10816         \textcolor{keywordflow}{return} EXCEPTION\_CONTINUE\_SEARCH;}
\DoxyCodeLine{10817     \}}
\DoxyCodeLine{10818 }
\DoxyCodeLine{10819     \textcolor{comment}{// Since we do not support multiple instantiations, we put these}}
\DoxyCodeLine{10820     \textcolor{comment}{// into global variables and rely on cleaning them up in outlined}}
\DoxyCodeLine{10821     \textcolor{comment}{// constructors/destructors}}
\DoxyCodeLine{10822     \textcolor{keyword}{static} PVOID exceptionHandlerHandle = \textcolor{keyword}{nullptr};}
\DoxyCodeLine{10823 }
\DoxyCodeLine{10824     \textcolor{comment}{// For MSVC, we reserve part of the stack memory for handling}}
\DoxyCodeLine{10825     \textcolor{comment}{// memory overflow structured exception.}}
\DoxyCodeLine{10826     FatalConditionHandler::FatalConditionHandler() \{}
\DoxyCodeLine{10827         ULONG guaranteeSize = \textcolor{keyword}{static\_cast<}ULONG\textcolor{keyword}{>}(minStackSizeForErrors);}
\DoxyCodeLine{10828         \textcolor{keywordflow}{if} (!SetThreadStackGuarantee(\&guaranteeSize)) \{}
\DoxyCodeLine{10829             \textcolor{comment}{// We do not want to fully error out, because needing}}
\DoxyCodeLine{10830             \textcolor{comment}{// the stack reserve should be rare enough anyway.}}
\DoxyCodeLine{10831             Catch::cerr()}
\DoxyCodeLine{10832                 << \textcolor{stringliteral}{"{}Failed to reserve piece of stack."{}}}
\DoxyCodeLine{10833                 << \textcolor{stringliteral}{"{} Stack overflows will not be reported successfully."{}};}
\DoxyCodeLine{10834         \}}
\DoxyCodeLine{10835     \}}
\DoxyCodeLine{10836 }
\DoxyCodeLine{10837     \textcolor{comment}{// We do not attempt to unset the stack guarantee, because}}
\DoxyCodeLine{10838     \textcolor{comment}{// Windows does not support lowering the stack size guarantee.}}
\DoxyCodeLine{10839     FatalConditionHandler::\string~FatalConditionHandler() = \textcolor{keywordflow}{default};}
\DoxyCodeLine{10840 }
\DoxyCodeLine{10841     \textcolor{keywordtype}{void} FatalConditionHandler::engage\_platform() \{}
\DoxyCodeLine{10842         \textcolor{comment}{// Register as first handler in current chain}}
\DoxyCodeLine{10843         exceptionHandlerHandle = AddVectoredExceptionHandler(1, handleVectoredException);}
\DoxyCodeLine{10844         \textcolor{keywordflow}{if} (!exceptionHandlerHandle) \{}
\DoxyCodeLine{10845             CATCH\_RUNTIME\_ERROR(\textcolor{stringliteral}{"{}Could not register vectored exception handler"{}});}
\DoxyCodeLine{10846         \}}
\DoxyCodeLine{10847     \}}
\DoxyCodeLine{10848 }
\DoxyCodeLine{10849     \textcolor{keywordtype}{void} FatalConditionHandler::disengage\_platform() \{}
\DoxyCodeLine{10850         \textcolor{keywordflow}{if} (!RemoveVectoredExceptionHandler(exceptionHandlerHandle)) \{}
\DoxyCodeLine{10851             CATCH\_RUNTIME\_ERROR(\textcolor{stringliteral}{"{}Could not unregister vectored exception handler"{}});}
\DoxyCodeLine{10852         \}}
\DoxyCodeLine{10853         exceptionHandlerHandle = \textcolor{keyword}{nullptr};}
\DoxyCodeLine{10854     \}}
\DoxyCodeLine{10855 }
\DoxyCodeLine{10856 \} \textcolor{comment}{// end namespace Catch}}
\DoxyCodeLine{10857 }
\DoxyCodeLine{10858 \textcolor{preprocessor}{\#endif }\textcolor{comment}{// CATCH\_CONFIG\_WINDOWS\_SEH}}
\DoxyCodeLine{10859 }
\DoxyCodeLine{10860 \textcolor{preprocessor}{\#if defined( CATCH\_CONFIG\_POSIX\_SIGNALS )}}
\DoxyCodeLine{10861 }
\DoxyCodeLine{10862 \textcolor{preprocessor}{\#include <signal.h>}}
\DoxyCodeLine{10863 }
\DoxyCodeLine{10864 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{10865 }
\DoxyCodeLine{10866     \textcolor{keyword}{struct }SignalDefs \{}
\DoxyCodeLine{10867         \textcolor{keywordtype}{int} id;}
\DoxyCodeLine{10868         \textcolor{keyword}{const} \textcolor{keywordtype}{char}* name;}
\DoxyCodeLine{10869     \};}
\DoxyCodeLine{10870 }
\DoxyCodeLine{10871     \textcolor{keyword}{static} SignalDefs signalDefs[] = \{}
\DoxyCodeLine{10872         \{ SIGINT,  \textcolor{stringliteral}{"{}SIGINT -\/ Terminal interrupt signal"{}} \},}
\DoxyCodeLine{10873         \{ SIGILL,  \textcolor{stringliteral}{"{}SIGILL -\/ Illegal instruction signal"{}} \},}
\DoxyCodeLine{10874         \{ SIGFPE,  \textcolor{stringliteral}{"{}SIGFPE -\/ Floating point error signal"{}} \},}
\DoxyCodeLine{10875         \{ SIGSEGV, \textcolor{stringliteral}{"{}SIGSEGV -\/ Segmentation violation signal"{}} \},}
\DoxyCodeLine{10876         \{ SIGTERM, \textcolor{stringliteral}{"{}SIGTERM -\/ Termination request signal"{}} \},}
\DoxyCodeLine{10877         \{ SIGABRT, \textcolor{stringliteral}{"{}SIGABRT -\/ Abort (abnormal termination) signal"{}} \}}
\DoxyCodeLine{10878     \};}
\DoxyCodeLine{10879 }
\DoxyCodeLine{10880 \textcolor{comment}{// Older GCCs trigger -\/Wmissing-\/field-\/initializers for T foo = \{\}}}
\DoxyCodeLine{10881 \textcolor{comment}{// which is zero initialization, but not explicit. We want to avoid}}
\DoxyCodeLine{10882 \textcolor{comment}{// that.}}
\DoxyCodeLine{10883 \textcolor{preprocessor}{\#if defined(\_\_GNUC\_\_)}}
\DoxyCodeLine{10884 \textcolor{preprocessor}{\#    pragma GCC diagnostic push}}
\DoxyCodeLine{10885 \textcolor{preprocessor}{\#    pragma GCC diagnostic ignored "{}-\/Wmissing-\/field-\/initializers"{}}}
\DoxyCodeLine{10886 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{10887 }
\DoxyCodeLine{10888     \textcolor{keyword}{static} \textcolor{keywordtype}{char}* altStackMem = \textcolor{keyword}{nullptr};}
\DoxyCodeLine{10889     \textcolor{keyword}{static} std::size\_t altStackSize = 0;}
\DoxyCodeLine{10890     \textcolor{keyword}{static} stack\_t oldSigStack\{\};}
\DoxyCodeLine{10891     \textcolor{keyword}{static} \textcolor{keyword}{struct }sigaction oldSigActions[sizeof(signalDefs) / sizeof(SignalDefs)]\{\};}
\DoxyCodeLine{10892 }
\DoxyCodeLine{10893     \textcolor{keyword}{static} \textcolor{keywordtype}{void} restorePreviousSignalHandlers() \{}
\DoxyCodeLine{10894         \textcolor{comment}{// We set signal handlers back to the previous ones. Hopefully}}
\DoxyCodeLine{10895         \textcolor{comment}{// nobody overwrote them in the meantime, and doesn't expect}}
\DoxyCodeLine{10896         \textcolor{comment}{// their signal handlers to live past ours given that they}}
\DoxyCodeLine{10897         \textcolor{comment}{// installed them after ours..}}
\DoxyCodeLine{10898         \textcolor{keywordflow}{for} (std::size\_t i = 0; i < \textcolor{keyword}{sizeof}(signalDefs) / \textcolor{keyword}{sizeof}(SignalDefs); ++i) \{}
\DoxyCodeLine{10899             sigaction(signalDefs[i].\textcolor{keywordtype}{id}, \&oldSigActions[i], \textcolor{keyword}{nullptr});}
\DoxyCodeLine{10900         \}}
\DoxyCodeLine{10901         \textcolor{comment}{// Return the old stack}}
\DoxyCodeLine{10902         sigaltstack(\&oldSigStack, \textcolor{keyword}{nullptr});}
\DoxyCodeLine{10903     \}}
\DoxyCodeLine{10904 }
\DoxyCodeLine{10905     \textcolor{keyword}{static} \textcolor{keywordtype}{void} handleSignal( \textcolor{keywordtype}{int} sig ) \{}
\DoxyCodeLine{10906         \textcolor{keywordtype}{char} \textcolor{keyword}{const} * name = \textcolor{stringliteral}{"{}<unknown signal>"{}};}
\DoxyCodeLine{10907         \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} \textcolor{keyword}{const}\& def : signalDefs) \{}
\DoxyCodeLine{10908             \textcolor{keywordflow}{if} (sig == def.id) \{}
\DoxyCodeLine{10909                 name = def.name;}
\DoxyCodeLine{10910                 \textcolor{keywordflow}{break};}
\DoxyCodeLine{10911             \}}
\DoxyCodeLine{10912         \}}
\DoxyCodeLine{10913         \textcolor{comment}{// We need to restore previous signal handlers and let them do}}
\DoxyCodeLine{10914         \textcolor{comment}{// their thing, so that the users can have the debugger break}}
\DoxyCodeLine{10915         \textcolor{comment}{// when a signal is raised, and so on.}}
\DoxyCodeLine{10916         restorePreviousSignalHandlers();}
\DoxyCodeLine{10917         reportFatal( name );}
\DoxyCodeLine{10918         raise( sig );}
\DoxyCodeLine{10919     \}}
\DoxyCodeLine{10920 }
\DoxyCodeLine{10921     FatalConditionHandler::FatalConditionHandler() \{}
\DoxyCodeLine{10922         assert(!altStackMem \&\& \textcolor{stringliteral}{"{}Cannot initialize POSIX signal handler when one already exists"{}});}
\DoxyCodeLine{10923         \textcolor{keywordflow}{if} (altStackSize == 0) \{}
\DoxyCodeLine{10924             altStackSize = std::max(\textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{size\_t}\textcolor{keyword}{>}(SIGSTKSZ), minStackSizeForErrors);}
\DoxyCodeLine{10925         \}}
\DoxyCodeLine{10926         altStackMem = \textcolor{keyword}{new} \textcolor{keywordtype}{char}[altStackSize]();}
\DoxyCodeLine{10927     \}}
\DoxyCodeLine{10928 }
\DoxyCodeLine{10929     FatalConditionHandler::\string~FatalConditionHandler() \{}
\DoxyCodeLine{10930         \textcolor{keyword}{delete}[] altStackMem;}
\DoxyCodeLine{10931         \textcolor{comment}{// We signal that another instance can be constructed by zeroing}}
\DoxyCodeLine{10932         \textcolor{comment}{// out the pointer.}}
\DoxyCodeLine{10933         altStackMem = \textcolor{keyword}{nullptr};}
\DoxyCodeLine{10934     \}}
\DoxyCodeLine{10935 }
\DoxyCodeLine{10936     \textcolor{keywordtype}{void} FatalConditionHandler::engage\_platform() \{}
\DoxyCodeLine{10937         stack\_t sigStack;}
\DoxyCodeLine{10938         sigStack.ss\_sp = altStackMem;}
\DoxyCodeLine{10939         sigStack.ss\_size = altStackSize;}
\DoxyCodeLine{10940         sigStack.ss\_flags = 0;}
\DoxyCodeLine{10941         sigaltstack(\&sigStack, \&oldSigStack);}
\DoxyCodeLine{10942         \textcolor{keyword}{struct }sigaction sa = \{ \};}
\DoxyCodeLine{10943 }
\DoxyCodeLine{10944         sa.sa\_handler = handleSignal;}
\DoxyCodeLine{10945         sa.sa\_flags = SA\_ONSTACK;}
\DoxyCodeLine{10946         \textcolor{keywordflow}{for} (std::size\_t i = 0; i < \textcolor{keyword}{sizeof}(signalDefs)/\textcolor{keyword}{sizeof}(SignalDefs); ++i) \{}
\DoxyCodeLine{10947             sigaction(signalDefs[i].\textcolor{keywordtype}{id}, \&sa, \&oldSigActions[i]);}
\DoxyCodeLine{10948         \}}
\DoxyCodeLine{10949     \}}
\DoxyCodeLine{10950 }
\DoxyCodeLine{10951 \textcolor{preprocessor}{\#if defined(\_\_GNUC\_\_)}}
\DoxyCodeLine{10952 \textcolor{preprocessor}{\#    pragma GCC diagnostic pop}}
\DoxyCodeLine{10953 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{10954 }
\DoxyCodeLine{10955     \textcolor{keywordtype}{void} FatalConditionHandler::disengage\_platform() \{}
\DoxyCodeLine{10956         restorePreviousSignalHandlers();}
\DoxyCodeLine{10957     \}}
\DoxyCodeLine{10958 }
\DoxyCodeLine{10959 \} \textcolor{comment}{// end namespace Catch}}
\DoxyCodeLine{10960 }
\DoxyCodeLine{10961 \textcolor{preprocessor}{\#endif }\textcolor{comment}{// CATCH\_CONFIG\_POSIX\_SIGNALS}}
\DoxyCodeLine{10962 \textcolor{comment}{// end catch\_fatal\_condition.cpp}}
\DoxyCodeLine{10963 \textcolor{comment}{// start catch\_generators.cpp}}
\DoxyCodeLine{10964 }
\DoxyCodeLine{10965 \textcolor{preprocessor}{\#include <limits>}}
\DoxyCodeLine{10966 \textcolor{preprocessor}{\#include <set>}}
\DoxyCodeLine{10967 }
\DoxyCodeLine{10968 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{10969 }
\DoxyCodeLine{10970 IGeneratorTracker::\string~IGeneratorTracker() \{\}}
\DoxyCodeLine{10971 }
\DoxyCodeLine{10972 \textcolor{keyword}{const} \textcolor{keywordtype}{char}* GeneratorException::what() const noexcept \{}
\DoxyCodeLine{10973     \textcolor{keywordflow}{return} m\_msg;}
\DoxyCodeLine{10974 \}}
\DoxyCodeLine{10975 }
\DoxyCodeLine{10976 \textcolor{keyword}{namespace }Generators \{}
\DoxyCodeLine{10977 }
\DoxyCodeLine{10978     GeneratorUntypedBase::\string~GeneratorUntypedBase() \{\}}
\DoxyCodeLine{10979 }
\DoxyCodeLine{10980     \textcolor{keyword}{auto} acquireGeneratorTracker( StringRef generatorName, SourceLineInfo \textcolor{keyword}{const}\& lineInfo ) -\/> IGeneratorTracker\& \{}
\DoxyCodeLine{10981         \textcolor{keywordflow}{return} getResultCapture().acquireGeneratorTracker( generatorName, lineInfo );}
\DoxyCodeLine{10982     \}}
\DoxyCodeLine{10983 }
\DoxyCodeLine{10984 \} \textcolor{comment}{// namespace Generators}}
\DoxyCodeLine{10985 \} \textcolor{comment}{// namespace Catch}}
\DoxyCodeLine{10986 \textcolor{comment}{// end catch\_generators.cpp}}
\DoxyCodeLine{10987 \textcolor{comment}{// start catch\_interfaces\_capture.cpp}}
\DoxyCodeLine{10988 }
\DoxyCodeLine{10989 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{10990     IResultCapture::\string~IResultCapture() = \textcolor{keywordflow}{default};}
\DoxyCodeLine{10991 \}}
\DoxyCodeLine{10992 \textcolor{comment}{// end catch\_interfaces\_capture.cpp}}
\DoxyCodeLine{10993 \textcolor{comment}{// start catch\_interfaces\_config.cpp}}
\DoxyCodeLine{10994 }
\DoxyCodeLine{10995 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{10996     IConfig::\string~IConfig() = \textcolor{keywordflow}{default};}
\DoxyCodeLine{10997 \}}
\DoxyCodeLine{10998 \textcolor{comment}{// end catch\_interfaces\_config.cpp}}
\DoxyCodeLine{10999 \textcolor{comment}{// start catch\_interfaces\_exception.cpp}}
\DoxyCodeLine{11000 }
\DoxyCodeLine{11001 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{11002     IExceptionTranslator::\string~IExceptionTranslator() = \textcolor{keywordflow}{default};}
\DoxyCodeLine{11003     IExceptionTranslatorRegistry::\string~IExceptionTranslatorRegistry() = \textcolor{keywordflow}{default};}
\DoxyCodeLine{11004 \}}
\DoxyCodeLine{11005 \textcolor{comment}{// end catch\_interfaces\_exception.cpp}}
\DoxyCodeLine{11006 \textcolor{comment}{// start catch\_interfaces\_registry\_hub.cpp}}
\DoxyCodeLine{11007 }
\DoxyCodeLine{11008 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{11009     IRegistryHub::\string~IRegistryHub() = \textcolor{keywordflow}{default};}
\DoxyCodeLine{11010     IMutableRegistryHub::\string~IMutableRegistryHub() = \textcolor{keywordflow}{default};}
\DoxyCodeLine{11011 \}}
\DoxyCodeLine{11012 \textcolor{comment}{// end catch\_interfaces\_registry\_hub.cpp}}
\DoxyCodeLine{11013 \textcolor{comment}{// start catch\_interfaces\_reporter.cpp}}
\DoxyCodeLine{11014 }
\DoxyCodeLine{11015 \textcolor{comment}{// start catch\_reporter\_listening.h}}
\DoxyCodeLine{11016 }
\DoxyCodeLine{11017 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{11018 }
\DoxyCodeLine{11019     \textcolor{keyword}{class }ListeningReporter : \textcolor{keyword}{public} IStreamingReporter \{}
\DoxyCodeLine{11020         \textcolor{keyword}{using }Reporters = std::vector<IStreamingReporterPtr>;}
\DoxyCodeLine{11021         Reporters m\_listeners;}
\DoxyCodeLine{11022         IStreamingReporterPtr m\_reporter = \textcolor{keyword}{nullptr};}
\DoxyCodeLine{11023         ReporterPreferences m\_preferences;}
\DoxyCodeLine{11024 }
\DoxyCodeLine{11025     \textcolor{keyword}{public}:}
\DoxyCodeLine{11026         ListeningReporter();}
\DoxyCodeLine{11027 }
\DoxyCodeLine{11028         \textcolor{keywordtype}{void} addListener( IStreamingReporterPtr\&\& listener );}
\DoxyCodeLine{11029         \textcolor{keywordtype}{void} addReporter( IStreamingReporterPtr\&\& reporter );}
\DoxyCodeLine{11030 }
\DoxyCodeLine{11031     \textcolor{keyword}{public}: \textcolor{comment}{// IStreamingReporter}}
\DoxyCodeLine{11032 }
\DoxyCodeLine{11033         ReporterPreferences getPreferences() \textcolor{keyword}{const override};}
\DoxyCodeLine{11034 }
\DoxyCodeLine{11035         \textcolor{keywordtype}{void} noMatchingTestCases( std::string \textcolor{keyword}{const}\& spec ) \textcolor{keyword}{override};}
\DoxyCodeLine{11036 }
\DoxyCodeLine{11037         \textcolor{keywordtype}{void} reportInvalidArguments(std::string \textcolor{keyword}{const}\&arg) \textcolor{keyword}{override};}
\DoxyCodeLine{11038 }
\DoxyCodeLine{11039         \textcolor{keyword}{static} std::set<Verbosity> getSupportedVerbosities();}
\DoxyCodeLine{11040 }
\DoxyCodeLine{11041 \textcolor{preprocessor}{\#if defined(CATCH\_CONFIG\_ENABLE\_BENCHMARKING)}}
\DoxyCodeLine{11042         \textcolor{keywordtype}{void} benchmarkPreparing(std::string \textcolor{keyword}{const}\& name) \textcolor{keyword}{override};}
\DoxyCodeLine{11043         \textcolor{keywordtype}{void} benchmarkStarting( BenchmarkInfo \textcolor{keyword}{const}\& benchmarkInfo ) \textcolor{keyword}{override};}
\DoxyCodeLine{11044         \textcolor{keywordtype}{void} benchmarkEnded( BenchmarkStats<> \textcolor{keyword}{const}\& benchmarkStats ) \textcolor{keyword}{override};}
\DoxyCodeLine{11045         \textcolor{keywordtype}{void} benchmarkFailed(std::string \textcolor{keyword}{const}\&) \textcolor{keyword}{override};}
\DoxyCodeLine{11046 \textcolor{preprocessor}{\#endif }\textcolor{comment}{// CATCH\_CONFIG\_ENABLE\_BENCHMARKING}}
\DoxyCodeLine{11047 }
\DoxyCodeLine{11048         \textcolor{keywordtype}{void} testRunStarting( TestRunInfo \textcolor{keyword}{const}\& testRunInfo ) \textcolor{keyword}{override};}
\DoxyCodeLine{11049         \textcolor{keywordtype}{void} testGroupStarting( GroupInfo \textcolor{keyword}{const}\& groupInfo ) \textcolor{keyword}{override};}
\DoxyCodeLine{11050         \textcolor{keywordtype}{void} testCaseStarting( TestCaseInfo \textcolor{keyword}{const}\& testInfo ) \textcolor{keyword}{override};}
\DoxyCodeLine{11051         \textcolor{keywordtype}{void} sectionStarting( SectionInfo \textcolor{keyword}{const}\& sectionInfo ) \textcolor{keyword}{override};}
\DoxyCodeLine{11052         \textcolor{keywordtype}{void} assertionStarting( AssertionInfo \textcolor{keyword}{const}\& assertionInfo ) \textcolor{keyword}{override};}
\DoxyCodeLine{11053 }
\DoxyCodeLine{11054         \textcolor{comment}{// The return value indicates if the messages buffer should be cleared:}}
\DoxyCodeLine{11055         \textcolor{keywordtype}{bool} assertionEnded( AssertionStats \textcolor{keyword}{const}\& assertionStats ) \textcolor{keyword}{override};}
\DoxyCodeLine{11056         \textcolor{keywordtype}{void} sectionEnded( SectionStats \textcolor{keyword}{const}\& sectionStats ) \textcolor{keyword}{override};}
\DoxyCodeLine{11057         \textcolor{keywordtype}{void} testCaseEnded( TestCaseStats \textcolor{keyword}{const}\& testCaseStats ) \textcolor{keyword}{override};}
\DoxyCodeLine{11058         \textcolor{keywordtype}{void} testGroupEnded( TestGroupStats \textcolor{keyword}{const}\& testGroupStats ) \textcolor{keyword}{override};}
\DoxyCodeLine{11059         \textcolor{keywordtype}{void} testRunEnded( TestRunStats \textcolor{keyword}{const}\& testRunStats ) \textcolor{keyword}{override};}
\DoxyCodeLine{11060 }
\DoxyCodeLine{11061         \textcolor{keywordtype}{void} skipTest( TestCaseInfo \textcolor{keyword}{const}\& testInfo ) \textcolor{keyword}{override};}
\DoxyCodeLine{11062         \textcolor{keywordtype}{bool} isMulti() \textcolor{keyword}{const override};}
\DoxyCodeLine{11063 }
\DoxyCodeLine{11064     \};}
\DoxyCodeLine{11065 }
\DoxyCodeLine{11066 \} \textcolor{comment}{// end namespace Catch}}
\DoxyCodeLine{11067 }
\DoxyCodeLine{11068 \textcolor{comment}{// end catch\_reporter\_listening.h}}
\DoxyCodeLine{11069 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{11070 }
\DoxyCodeLine{11071     ReporterConfig::ReporterConfig( IConfigPtr \textcolor{keyword}{const}\& \_fullConfig )}
\DoxyCodeLine{11072     :   m\_stream( \&\_fullConfig-\/>stream() ), m\_fullConfig( \_fullConfig ) \{\}}
\DoxyCodeLine{11073 }
\DoxyCodeLine{11074     ReporterConfig::ReporterConfig( IConfigPtr \textcolor{keyword}{const}\& \_fullConfig, std::ostream\& \_stream )}
\DoxyCodeLine{11075     :   m\_stream( \&\_stream ), m\_fullConfig( \_fullConfig ) \{\}}
\DoxyCodeLine{11076 }
\DoxyCodeLine{11077     std::ostream\& ReporterConfig::stream()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} *m\_stream; \}}
\DoxyCodeLine{11078     IConfigPtr ReporterConfig::fullConfig()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} m\_fullConfig; \}}
\DoxyCodeLine{11079 }
\DoxyCodeLine{11080     TestRunInfo::TestRunInfo( std::string \textcolor{keyword}{const}\& \_name ) : name( \_name ) \{\}}
\DoxyCodeLine{11081 }
\DoxyCodeLine{11082     GroupInfo::GroupInfo(  std::string \textcolor{keyword}{const}\& \_name,}
\DoxyCodeLine{11083                            std::size\_t \_groupIndex,}
\DoxyCodeLine{11084                            std::size\_t \_groupsCount )}
\DoxyCodeLine{11085     :   name( \_name ),}
\DoxyCodeLine{11086         groupIndex( \_groupIndex ),}
\DoxyCodeLine{11087         groupsCounts( \_groupsCount )}
\DoxyCodeLine{11088     \{\}}
\DoxyCodeLine{11089 }
\DoxyCodeLine{11090      AssertionStats::AssertionStats( AssertionResult \textcolor{keyword}{const}\& \_assertionResult,}
\DoxyCodeLine{11091                                      std::vector<MessageInfo> \textcolor{keyword}{const}\& \_infoMessages,}
\DoxyCodeLine{11092                                      Totals \textcolor{keyword}{const}\& \_totals )}
\DoxyCodeLine{11093     :   assertionResult( \_assertionResult ),}
\DoxyCodeLine{11094         infoMessages( \_infoMessages ),}
\DoxyCodeLine{11095         totals( \_totals )}
\DoxyCodeLine{11096     \{}
\DoxyCodeLine{11097         assertionResult.m\_resultData.lazyExpression.m\_transientExpression = \_assertionResult.m\_resultData.lazyExpression.m\_transientExpression;}
\DoxyCodeLine{11098 }
\DoxyCodeLine{11099         \textcolor{keywordflow}{if}( assertionResult.hasMessage() ) \{}
\DoxyCodeLine{11100             \textcolor{comment}{// Copy message into messages list.}}
\DoxyCodeLine{11101             \textcolor{comment}{// !TBD This should have been done earlier, somewhere}}
\DoxyCodeLine{11102             MessageBuilder builder( assertionResult.getTestMacroName(), assertionResult.getSourceInfo(), assertionResult.getResultType() );}
\DoxyCodeLine{11103             builder << assertionResult.getMessage();}
\DoxyCodeLine{11104             builder.m\_info.message = builder.m\_stream.str();}
\DoxyCodeLine{11105 }
\DoxyCodeLine{11106             infoMessages.push\_back( builder.m\_info );}
\DoxyCodeLine{11107         \}}
\DoxyCodeLine{11108     \}}
\DoxyCodeLine{11109 }
\DoxyCodeLine{11110      AssertionStats::\string~AssertionStats() = \textcolor{keywordflow}{default};}
\DoxyCodeLine{11111 }
\DoxyCodeLine{11112     SectionStats::SectionStats(  SectionInfo \textcolor{keyword}{const}\& \_sectionInfo,}
\DoxyCodeLine{11113                                  Counts \textcolor{keyword}{const}\& \_assertions,}
\DoxyCodeLine{11114                                  \textcolor{keywordtype}{double} \_durationInSeconds,}
\DoxyCodeLine{11115                                  \textcolor{keywordtype}{bool} \_missingAssertions )}
\DoxyCodeLine{11116     :   sectionInfo( \_sectionInfo ),}
\DoxyCodeLine{11117         assertions( \_assertions ),}
\DoxyCodeLine{11118         durationInSeconds( \_durationInSeconds ),}
\DoxyCodeLine{11119         missingAssertions( \_missingAssertions )}
\DoxyCodeLine{11120     \{\}}
\DoxyCodeLine{11121 }
\DoxyCodeLine{11122     SectionStats::\string~SectionStats() = \textcolor{keywordflow}{default};}
\DoxyCodeLine{11123 }
\DoxyCodeLine{11124     TestCaseStats::TestCaseStats(  TestCaseInfo \textcolor{keyword}{const}\& \_testInfo,}
\DoxyCodeLine{11125                                    Totals \textcolor{keyword}{const}\& \_totals,}
\DoxyCodeLine{11126                                    std::string \textcolor{keyword}{const}\& \_stdOut,}
\DoxyCodeLine{11127                                    std::string \textcolor{keyword}{const}\& \_stdErr,}
\DoxyCodeLine{11128                                    \textcolor{keywordtype}{bool} \_aborting )}
\DoxyCodeLine{11129     : testInfo( \_testInfo ),}
\DoxyCodeLine{11130         totals( \_totals ),}
\DoxyCodeLine{11131         stdOut( \_stdOut ),}
\DoxyCodeLine{11132         stdErr( \_stdErr ),}
\DoxyCodeLine{11133         aborting( \_aborting )}
\DoxyCodeLine{11134     \{\}}
\DoxyCodeLine{11135 }
\DoxyCodeLine{11136     TestCaseStats::\string~TestCaseStats() = \textcolor{keywordflow}{default};}
\DoxyCodeLine{11137 }
\DoxyCodeLine{11138     TestGroupStats::TestGroupStats( GroupInfo \textcolor{keyword}{const}\& \_groupInfo,}
\DoxyCodeLine{11139                                     Totals \textcolor{keyword}{const}\& \_totals,}
\DoxyCodeLine{11140                                     \textcolor{keywordtype}{bool} \_aborting )}
\DoxyCodeLine{11141     :   groupInfo( \_groupInfo ),}
\DoxyCodeLine{11142         totals( \_totals ),}
\DoxyCodeLine{11143         aborting( \_aborting )}
\DoxyCodeLine{11144     \{\}}
\DoxyCodeLine{11145 }
\DoxyCodeLine{11146     TestGroupStats::TestGroupStats( GroupInfo \textcolor{keyword}{const}\& \_groupInfo )}
\DoxyCodeLine{11147     :   groupInfo( \_groupInfo ),}
\DoxyCodeLine{11148         aborting( false )}
\DoxyCodeLine{11149     \{\}}
\DoxyCodeLine{11150 }
\DoxyCodeLine{11151     TestGroupStats::\string~TestGroupStats() = \textcolor{keywordflow}{default};}
\DoxyCodeLine{11152 }
\DoxyCodeLine{11153     TestRunStats::TestRunStats(   TestRunInfo \textcolor{keyword}{const}\& \_runInfo,}
\DoxyCodeLine{11154                     Totals \textcolor{keyword}{const}\& \_totals,}
\DoxyCodeLine{11155                     \textcolor{keywordtype}{bool} \_aborting )}
\DoxyCodeLine{11156     :   runInfo( \_runInfo ),}
\DoxyCodeLine{11157         totals( \_totals ),}
\DoxyCodeLine{11158         aborting( \_aborting )}
\DoxyCodeLine{11159     \{\}}
\DoxyCodeLine{11160 }
\DoxyCodeLine{11161     TestRunStats::\string~TestRunStats() = \textcolor{keywordflow}{default};}
\DoxyCodeLine{11162 }
\DoxyCodeLine{11163     \textcolor{keywordtype}{void} IStreamingReporter::fatalErrorEncountered( StringRef ) \{\}}
\DoxyCodeLine{11164     \textcolor{keywordtype}{bool} IStreamingReporter::isMulti()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} \textcolor{keyword}{false}; \}}
\DoxyCodeLine{11165 }
\DoxyCodeLine{11166     IReporterFactory::\string~IReporterFactory() = \textcolor{keywordflow}{default};}
\DoxyCodeLine{11167     IReporterRegistry::\string~IReporterRegistry() = \textcolor{keywordflow}{default};}
\DoxyCodeLine{11168 }
\DoxyCodeLine{11169 \} \textcolor{comment}{// end namespace Catch}}
\DoxyCodeLine{11170 \textcolor{comment}{// end catch\_interfaces\_reporter.cpp}}
\DoxyCodeLine{11171 \textcolor{comment}{// start catch\_interfaces\_runner.cpp}}
\DoxyCodeLine{11172 }
\DoxyCodeLine{11173 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{11174     IRunner::\string~IRunner() = \textcolor{keywordflow}{default};}
\DoxyCodeLine{11175 \}}
\DoxyCodeLine{11176 \textcolor{comment}{// end catch\_interfaces\_runner.cpp}}
\DoxyCodeLine{11177 \textcolor{comment}{// start catch\_interfaces\_testcase.cpp}}
\DoxyCodeLine{11178 }
\DoxyCodeLine{11179 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{11180     ITestInvoker::\string~ITestInvoker() = \textcolor{keywordflow}{default};}
\DoxyCodeLine{11181     ITestCaseRegistry::\string~ITestCaseRegistry() = \textcolor{keywordflow}{default};}
\DoxyCodeLine{11182 \}}
\DoxyCodeLine{11183 \textcolor{comment}{// end catch\_interfaces\_testcase.cpp}}
\DoxyCodeLine{11184 \textcolor{comment}{// start catch\_leak\_detector.cpp}}
\DoxyCodeLine{11185 }
\DoxyCodeLine{11186 \textcolor{preprocessor}{\#ifdef CATCH\_CONFIG\_WINDOWS\_CRTDBG}}
\DoxyCodeLine{11187 \textcolor{preprocessor}{\#include <crtdbg.h>}}
\DoxyCodeLine{11188 }
\DoxyCodeLine{11189 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{11190 }
\DoxyCodeLine{11191     LeakDetector::LeakDetector() \{}
\DoxyCodeLine{11192         \textcolor{keywordtype}{int} flag = \_CrtSetDbgFlag(\_CRTDBG\_REPORT\_FLAG);}
\DoxyCodeLine{11193         flag |= \_CRTDBG\_LEAK\_CHECK\_DF;}
\DoxyCodeLine{11194         flag |= \_CRTDBG\_ALLOC\_MEM\_DF;}
\DoxyCodeLine{11195         \_CrtSetDbgFlag(flag);}
\DoxyCodeLine{11196         \_CrtSetReportMode(\_CRT\_WARN, \_CRTDBG\_MODE\_FILE | \_CRTDBG\_MODE\_DEBUG);}
\DoxyCodeLine{11197         \_CrtSetReportFile(\_CRT\_WARN, \_CRTDBG\_FILE\_STDERR);}
\DoxyCodeLine{11198         \textcolor{comment}{// Change this to leaking allocation's number to break there}}
\DoxyCodeLine{11199         \_CrtSetBreakAlloc(-\/1);}
\DoxyCodeLine{11200     \}}
\DoxyCodeLine{11201 \}}
\DoxyCodeLine{11202 }
\DoxyCodeLine{11203 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{11204 }
\DoxyCodeLine{11205     Catch::LeakDetector::LeakDetector() \{\}}
\DoxyCodeLine{11206 }
\DoxyCodeLine{11207 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{11208 }
\DoxyCodeLine{11209 Catch::LeakDetector::\string~LeakDetector() \{}
\DoxyCodeLine{11210     Catch::cleanUp();}
\DoxyCodeLine{11211 \}}
\DoxyCodeLine{11212 \textcolor{comment}{// end catch\_leak\_detector.cpp}}
\DoxyCodeLine{11213 \textcolor{comment}{// start catch\_list.cpp}}
\DoxyCodeLine{11214 }
\DoxyCodeLine{11215 \textcolor{comment}{// start catch\_list.h}}
\DoxyCodeLine{11216 }
\DoxyCodeLine{11217 \textcolor{preprocessor}{\#include <set>}}
\DoxyCodeLine{11218 }
\DoxyCodeLine{11219 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{11220 }
\DoxyCodeLine{11221     std::size\_t listTests( Config \textcolor{keyword}{const}\& config );}
\DoxyCodeLine{11222 }
\DoxyCodeLine{11223     std::size\_t listTestsNamesOnly( Config \textcolor{keyword}{const}\& config );}
\DoxyCodeLine{11224 }
\DoxyCodeLine{11225     \textcolor{keyword}{struct }TagInfo \{}
\DoxyCodeLine{11226         \textcolor{keywordtype}{void} add( std::string \textcolor{keyword}{const}\& spelling );}
\DoxyCodeLine{11227         std::string all() \textcolor{keyword}{const};}
\DoxyCodeLine{11228 }
\DoxyCodeLine{11229         std::set<std::string> spellings;}
\DoxyCodeLine{11230         std::size\_t count = 0;}
\DoxyCodeLine{11231     \};}
\DoxyCodeLine{11232 }
\DoxyCodeLine{11233     std::size\_t listTags( Config \textcolor{keyword}{const}\& config );}
\DoxyCodeLine{11234 }
\DoxyCodeLine{11235     std::size\_t listReporters();}
\DoxyCodeLine{11236 }
\DoxyCodeLine{11237     Option<std::size\_t> list( std::shared\_ptr<Config> \textcolor{keyword}{const}\& config );}
\DoxyCodeLine{11238 }
\DoxyCodeLine{11239 \} \textcolor{comment}{// end namespace Catch}}
\DoxyCodeLine{11240 }
\DoxyCodeLine{11241 \textcolor{comment}{// end catch\_list.h}}
\DoxyCodeLine{11242 \textcolor{comment}{// start catch\_text.h}}
\DoxyCodeLine{11243 }
\DoxyCodeLine{11244 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{11245     \textcolor{keyword}{using namespace }clara::TextFlow;}
\DoxyCodeLine{11246 \}}
\DoxyCodeLine{11247 }
\DoxyCodeLine{11248 \textcolor{comment}{// end catch\_text.h}}
\DoxyCodeLine{11249 \textcolor{preprocessor}{\#include <limits>}}
\DoxyCodeLine{11250 \textcolor{preprocessor}{\#include <algorithm>}}
\DoxyCodeLine{11251 \textcolor{preprocessor}{\#include <iomanip>}}
\DoxyCodeLine{11252 }
\DoxyCodeLine{11253 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{11254 }
\DoxyCodeLine{11255     std::size\_t listTests( Config \textcolor{keyword}{const}\& config ) \{}
\DoxyCodeLine{11256         TestSpec \textcolor{keyword}{const}\& testSpec = config.testSpec();}
\DoxyCodeLine{11257         \textcolor{keywordflow}{if}( config.hasTestFilters() )}
\DoxyCodeLine{11258             Catch::cout() << \textcolor{stringliteral}{"{}Matching test cases:\(\backslash\)n"{}};}
\DoxyCodeLine{11259         \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{11260             Catch::cout() << \textcolor{stringliteral}{"{}All available test cases:\(\backslash\)n"{}};}
\DoxyCodeLine{11261         \}}
\DoxyCodeLine{11262 }
\DoxyCodeLine{11263         \textcolor{keyword}{auto} matchedTestCases = filterTests( getAllTestCasesSorted( config ), testSpec, config );}
\DoxyCodeLine{11264         \textcolor{keywordflow}{for}( \textcolor{keyword}{auto} \textcolor{keyword}{const}\& testCaseInfo : matchedTestCases ) \{}
\DoxyCodeLine{11265             Colour::Code colour = testCaseInfo.isHidden()}
\DoxyCodeLine{11266                 ? Colour::SecondaryText}
\DoxyCodeLine{11267                 : Colour::None;}
\DoxyCodeLine{11268             Colour colourGuard( colour );}
\DoxyCodeLine{11269 }
\DoxyCodeLine{11270             Catch::cout() << Column( testCaseInfo.name ).initialIndent( 2 ).indent( 4 ) << \textcolor{stringliteral}{"{}\(\backslash\)n"{}};}
\DoxyCodeLine{11271             \textcolor{keywordflow}{if}( config.verbosity() >= Verbosity::High ) \{}
\DoxyCodeLine{11272                 Catch::cout() << Column( Catch::Detail::stringify( testCaseInfo.lineInfo ) ).indent(4) << std::endl;}
\DoxyCodeLine{11273                 std::string description = testCaseInfo.description;}
\DoxyCodeLine{11274                 \textcolor{keywordflow}{if}( description.empty() )}
\DoxyCodeLine{11275                     description = \textcolor{stringliteral}{"{}(NO DESCRIPTION)"{}};}
\DoxyCodeLine{11276                 Catch::cout() << Column( description ).indent(4) << std::endl;}
\DoxyCodeLine{11277             \}}
\DoxyCodeLine{11278             \textcolor{keywordflow}{if}( !testCaseInfo.tags.empty() )}
\DoxyCodeLine{11279                 Catch::cout() << Column( testCaseInfo.tagsAsString() ).indent( 6 ) << \textcolor{stringliteral}{"{}\(\backslash\)n"{}};}
\DoxyCodeLine{11280         \}}
\DoxyCodeLine{11281 }
\DoxyCodeLine{11282         \textcolor{keywordflow}{if}( !config.hasTestFilters() )}
\DoxyCodeLine{11283             Catch::cout() << pluralise( matchedTestCases.size(), \textcolor{stringliteral}{"{}test case"{}} ) << \textcolor{charliteral}{'\(\backslash\)n'} << std::endl;}
\DoxyCodeLine{11284         \textcolor{keywordflow}{else}}
\DoxyCodeLine{11285             Catch::cout() << pluralise( matchedTestCases.size(), \textcolor{stringliteral}{"{}matching test case"{}} ) << \textcolor{charliteral}{'\(\backslash\)n'} << std::endl;}
\DoxyCodeLine{11286         \textcolor{keywordflow}{return} matchedTestCases.size();}
\DoxyCodeLine{11287     \}}
\DoxyCodeLine{11288 }
\DoxyCodeLine{11289     std::size\_t listTestsNamesOnly( Config \textcolor{keyword}{const}\& config ) \{}
\DoxyCodeLine{11290         TestSpec \textcolor{keyword}{const}\& testSpec = config.testSpec();}
\DoxyCodeLine{11291         std::size\_t matchedTests = 0;}
\DoxyCodeLine{11292         std::vector<TestCase> matchedTestCases = filterTests( getAllTestCasesSorted( config ), testSpec, config );}
\DoxyCodeLine{11293         \textcolor{keywordflow}{for}( \textcolor{keyword}{auto} \textcolor{keyword}{const}\& testCaseInfo : matchedTestCases ) \{}
\DoxyCodeLine{11294             matchedTests++;}
\DoxyCodeLine{11295             \textcolor{keywordflow}{if}( startsWith( testCaseInfo.name, \textcolor{charliteral}{'\#'} ) )}
\DoxyCodeLine{11296                Catch::cout() << \textcolor{charliteral}{'"{}'} << testCaseInfo.name << \textcolor{charliteral}{'"{}'};}
\DoxyCodeLine{11297             \textcolor{keywordflow}{else}}
\DoxyCodeLine{11298                Catch::cout() << testCaseInfo.name;}
\DoxyCodeLine{11299             \textcolor{keywordflow}{if} ( config.verbosity() >= Verbosity::High )}
\DoxyCodeLine{11300                 Catch::cout() << \textcolor{stringliteral}{"{}\(\backslash\)t@"{}} << testCaseInfo.lineInfo;}
\DoxyCodeLine{11301             Catch::cout() << std::endl;}
\DoxyCodeLine{11302         \}}
\DoxyCodeLine{11303         \textcolor{keywordflow}{return} matchedTests;}
\DoxyCodeLine{11304     \}}
\DoxyCodeLine{11305 }
\DoxyCodeLine{11306     \textcolor{keywordtype}{void} TagInfo::add( std::string \textcolor{keyword}{const}\& spelling ) \{}
\DoxyCodeLine{11307         ++count;}
\DoxyCodeLine{11308         spellings.insert( spelling );}
\DoxyCodeLine{11309     \}}
\DoxyCodeLine{11310 }
\DoxyCodeLine{11311     std::string TagInfo::all()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{11312         \textcolor{keywordtype}{size\_t} size = 0;}
\DoxyCodeLine{11313         \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} \textcolor{keyword}{const}\& spelling : spellings) \{}
\DoxyCodeLine{11314             \textcolor{comment}{// Add 2 for the brackes}}
\DoxyCodeLine{11315             size += spelling.size() + 2;}
\DoxyCodeLine{11316         \}}
\DoxyCodeLine{11317 }
\DoxyCodeLine{11318         std::string out; out.reserve(size);}
\DoxyCodeLine{11319         \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} \textcolor{keyword}{const}\& spelling : spellings) \{}
\DoxyCodeLine{11320             out += '[';}
\DoxyCodeLine{11321             out += spelling;}
\DoxyCodeLine{11322             out += ']';}
\DoxyCodeLine{11323         \}}
\DoxyCodeLine{11324         \textcolor{keywordflow}{return} out;}
\DoxyCodeLine{11325     \}}
\DoxyCodeLine{11326 }
\DoxyCodeLine{11327     std::size\_t listTags( Config \textcolor{keyword}{const}\& config ) \{}
\DoxyCodeLine{11328         TestSpec \textcolor{keyword}{const}\& testSpec = config.testSpec();}
\DoxyCodeLine{11329         \textcolor{keywordflow}{if}( config.hasTestFilters() )}
\DoxyCodeLine{11330             Catch::cout() << \textcolor{stringliteral}{"{}Tags for matching test cases:\(\backslash\)n"{}};}
\DoxyCodeLine{11331         \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{11332             Catch::cout() << \textcolor{stringliteral}{"{}All available tags:\(\backslash\)n"{}};}
\DoxyCodeLine{11333         \}}
\DoxyCodeLine{11334 }
\DoxyCodeLine{11335         std::map<std::string, TagInfo> tagCounts;}
\DoxyCodeLine{11336 }
\DoxyCodeLine{11337         std::vector<TestCase> matchedTestCases = filterTests( getAllTestCasesSorted( config ), testSpec, config );}
\DoxyCodeLine{11338         \textcolor{keywordflow}{for}( \textcolor{keyword}{auto} \textcolor{keyword}{const}\& testCase : matchedTestCases ) \{}
\DoxyCodeLine{11339             \textcolor{keywordflow}{for}( \textcolor{keyword}{auto} \textcolor{keyword}{const}\& tagName : testCase.getTestCaseInfo().tags ) \{}
\DoxyCodeLine{11340                 std::string lcaseTagName = toLower( tagName );}
\DoxyCodeLine{11341                 \textcolor{keyword}{auto} countIt = tagCounts.find( lcaseTagName );}
\DoxyCodeLine{11342                 \textcolor{keywordflow}{if}( countIt == tagCounts.end() )}
\DoxyCodeLine{11343                     countIt = tagCounts.insert( std::make\_pair( lcaseTagName, TagInfo() ) ).first;}
\DoxyCodeLine{11344                 countIt-\/>second.add( tagName );}
\DoxyCodeLine{11345             \}}
\DoxyCodeLine{11346         \}}
\DoxyCodeLine{11347 }
\DoxyCodeLine{11348         \textcolor{keywordflow}{for}( \textcolor{keyword}{auto} \textcolor{keyword}{const}\& tagCount : tagCounts ) \{}
\DoxyCodeLine{11349             ReusableStringStream rss;}
\DoxyCodeLine{11350             rss << \textcolor{stringliteral}{"{}  "{}} << std::setw(2) << tagCount.second.count << \textcolor{stringliteral}{"{}  "{}};}
\DoxyCodeLine{11351             \textcolor{keyword}{auto} str = rss.str();}
\DoxyCodeLine{11352             \textcolor{keyword}{auto} wrapper = Column( tagCount.second.all() )}
\DoxyCodeLine{11353                                                     .initialIndent( 0 )}
\DoxyCodeLine{11354                                                     .indent( str.size() )}
\DoxyCodeLine{11355                                                     .width( CATCH\_CONFIG\_CONSOLE\_WIDTH-\/10 );}
\DoxyCodeLine{11356             Catch::cout() << str << wrapper << \textcolor{charliteral}{'\(\backslash\)n'};}
\DoxyCodeLine{11357         \}}
\DoxyCodeLine{11358         Catch::cout() << pluralise( tagCounts.size(), \textcolor{stringliteral}{"{}tag"{}} ) << \textcolor{charliteral}{'\(\backslash\)n'} << std::endl;}
\DoxyCodeLine{11359         \textcolor{keywordflow}{return} tagCounts.size();}
\DoxyCodeLine{11360     \}}
\DoxyCodeLine{11361 }
\DoxyCodeLine{11362     std::size\_t listReporters() \{}
\DoxyCodeLine{11363         Catch::cout() << \textcolor{stringliteral}{"{}Available reporters:\(\backslash\)n"{}};}
\DoxyCodeLine{11364         IReporterRegistry::FactoryMap \textcolor{keyword}{const}\& factories = getRegistryHub().getReporterRegistry().getFactories();}
\DoxyCodeLine{11365         std::size\_t maxNameLen = 0;}
\DoxyCodeLine{11366         \textcolor{keywordflow}{for}( \textcolor{keyword}{auto} \textcolor{keyword}{const}\& factoryKvp : factories )}
\DoxyCodeLine{11367             maxNameLen = (std::max)( maxNameLen, factoryKvp.first.size() );}
\DoxyCodeLine{11368 }
\DoxyCodeLine{11369         \textcolor{keywordflow}{for}( \textcolor{keyword}{auto} \textcolor{keyword}{const}\& factoryKvp : factories ) \{}
\DoxyCodeLine{11370             Catch::cout()}
\DoxyCodeLine{11371                     << Column( factoryKvp.first + \textcolor{stringliteral}{"{}:"{}} )}
\DoxyCodeLine{11372                             .indent(2)}
\DoxyCodeLine{11373                             .width( 5+maxNameLen )}
\DoxyCodeLine{11374                     +  Column( factoryKvp.second-\/>getDescription() )}
\DoxyCodeLine{11375                             .initialIndent(0)}
\DoxyCodeLine{11376                             .indent(2)}
\DoxyCodeLine{11377                             .width( CATCH\_CONFIG\_CONSOLE\_WIDTH -\/ maxNameLen-\/8 )}
\DoxyCodeLine{11378                     << "{}\(\backslash\)n"{};}
\DoxyCodeLine{11379         \}}
\DoxyCodeLine{11380         Catch::cout() << std::endl;}
\DoxyCodeLine{11381         \textcolor{keywordflow}{return} factories.size();}
\DoxyCodeLine{11382     \}}
\DoxyCodeLine{11383 }
\DoxyCodeLine{11384     Option<std::size\_t> list( std::shared\_ptr<Config> \textcolor{keyword}{const}\& config ) \{}
\DoxyCodeLine{11385         Option<std::size\_t> listedCount;}
\DoxyCodeLine{11386         getCurrentMutableContext().setConfig( config );}
\DoxyCodeLine{11387         \textcolor{keywordflow}{if}( config-\/>listTests() )}
\DoxyCodeLine{11388             listedCount = listedCount.valueOr(0) + listTests( *config );}
\DoxyCodeLine{11389         \textcolor{keywordflow}{if}( config-\/>listTestNamesOnly() )}
\DoxyCodeLine{11390             listedCount = listedCount.valueOr(0) + listTestsNamesOnly( *config );}
\DoxyCodeLine{11391         \textcolor{keywordflow}{if}( config-\/>listTags() )}
\DoxyCodeLine{11392             listedCount = listedCount.valueOr(0) + listTags( *config );}
\DoxyCodeLine{11393         \textcolor{keywordflow}{if}( config-\/>listReporters() )}
\DoxyCodeLine{11394             listedCount = listedCount.valueOr(0) + listReporters();}
\DoxyCodeLine{11395         \textcolor{keywordflow}{return} listedCount;}
\DoxyCodeLine{11396     \}}
\DoxyCodeLine{11397 }
\DoxyCodeLine{11398 \} \textcolor{comment}{// end namespace Catch}}
\DoxyCodeLine{11399 \textcolor{comment}{// end catch\_list.cpp}}
\DoxyCodeLine{11400 \textcolor{comment}{// start catch\_matchers.cpp}}
\DoxyCodeLine{11401 }
\DoxyCodeLine{11402 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{11403 \textcolor{keyword}{namespace }Matchers \{}
\DoxyCodeLine{11404     \textcolor{keyword}{namespace }Impl \{}
\DoxyCodeLine{11405 }
\DoxyCodeLine{11406         std::string MatcherUntypedBase::toString()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{11407             \textcolor{keywordflow}{if}( m\_cachedToString.empty() )}
\DoxyCodeLine{11408                 m\_cachedToString = describe();}
\DoxyCodeLine{11409             \textcolor{keywordflow}{return} m\_cachedToString;}
\DoxyCodeLine{11410         \}}
\DoxyCodeLine{11411 }
\DoxyCodeLine{11412         MatcherUntypedBase::\string~MatcherUntypedBase() = \textcolor{keywordflow}{default};}
\DoxyCodeLine{11413 }
\DoxyCodeLine{11414     \} \textcolor{comment}{// namespace Impl}}
\DoxyCodeLine{11415 \} \textcolor{comment}{// namespace Matchers}}
\DoxyCodeLine{11416 }
\DoxyCodeLine{11417 \textcolor{keyword}{using namespace }Matchers;}
\DoxyCodeLine{11418 \textcolor{keyword}{using }Matchers::Impl::MatcherBase;}
\DoxyCodeLine{11419 }
\DoxyCodeLine{11420 \} \textcolor{comment}{// namespace Catch}}
\DoxyCodeLine{11421 \textcolor{comment}{// end catch\_matchers.cpp}}
\DoxyCodeLine{11422 \textcolor{comment}{// start catch\_matchers\_exception.cpp}}
\DoxyCodeLine{11423 }
\DoxyCodeLine{11424 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{11425 \textcolor{keyword}{namespace }Matchers \{}
\DoxyCodeLine{11426 \textcolor{keyword}{namespace }Exception \{}
\DoxyCodeLine{11427 }
\DoxyCodeLine{11428 \textcolor{keywordtype}{bool} ExceptionMessageMatcher::match(std::exception \textcolor{keyword}{const}\& ex)\textcolor{keyword}{ const }\{}
\DoxyCodeLine{11429     \textcolor{keywordflow}{return} ex.what() == m\_message;}
\DoxyCodeLine{11430 \}}
\DoxyCodeLine{11431 }
\DoxyCodeLine{11432 std::string ExceptionMessageMatcher::describe()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{11433     \textcolor{keywordflow}{return} \textcolor{stringliteral}{"{}exception message matches \(\backslash\)"{}"{}} + m\_message + "{}\(\backslash\)"{}"{};}
\DoxyCodeLine{11434 \}}
\DoxyCodeLine{11435 }
\DoxyCodeLine{11436 \}}
\DoxyCodeLine{11437 Exception::ExceptionMessageMatcher Message(std::string \textcolor{keyword}{const}\& message) \{}
\DoxyCodeLine{11438     \textcolor{keywordflow}{return} Exception::ExceptionMessageMatcher(message);}
\DoxyCodeLine{11439 \}}
\DoxyCodeLine{11440 }
\DoxyCodeLine{11441 \textcolor{comment}{// namespace Exception}}
\DoxyCodeLine{11442 \} \textcolor{comment}{// namespace Matchers}}
\DoxyCodeLine{11443 \} \textcolor{comment}{// namespace Catch}}
\DoxyCodeLine{11444 \textcolor{comment}{// end catch\_matchers\_exception.cpp}}
\DoxyCodeLine{11445 \textcolor{comment}{// start catch\_matchers\_floating.cpp}}
\DoxyCodeLine{11446 }
\DoxyCodeLine{11447 \textcolor{comment}{// start catch\_polyfills.hpp}}
\DoxyCodeLine{11448 }
\DoxyCodeLine{11449 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{11450     \textcolor{keywordtype}{bool} isnan(\textcolor{keywordtype}{float} f);}
\DoxyCodeLine{11451     \textcolor{keywordtype}{bool} isnan(\textcolor{keywordtype}{double} d);}
\DoxyCodeLine{11452 \}}
\DoxyCodeLine{11453 }
\DoxyCodeLine{11454 \textcolor{comment}{// end catch\_polyfills.hpp}}
\DoxyCodeLine{11455 \textcolor{comment}{// start catch\_to\_string.hpp}}
\DoxyCodeLine{11456 }
\DoxyCodeLine{11457 \textcolor{preprocessor}{\#include <string>}}
\DoxyCodeLine{11458 }
\DoxyCodeLine{11459 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{11460     \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{11461     std::string to\_string(T \textcolor{keyword}{const}\& t) \{}
\DoxyCodeLine{11462 \textcolor{preprocessor}{\#if defined(CATCH\_CONFIG\_CPP11\_TO\_STRING)}}
\DoxyCodeLine{11463         \textcolor{keywordflow}{return} std::to\_string(t);}
\DoxyCodeLine{11464 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{11465         ReusableStringStream rss;}
\DoxyCodeLine{11466         rss << t;}
\DoxyCodeLine{11467         \textcolor{keywordflow}{return} rss.str();}
\DoxyCodeLine{11468 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{11469     \}}
\DoxyCodeLine{11470 \} \textcolor{comment}{// end namespace Catch}}
\DoxyCodeLine{11471 }
\DoxyCodeLine{11472 \textcolor{comment}{// end catch\_to\_string.hpp}}
\DoxyCodeLine{11473 \textcolor{preprocessor}{\#include <algorithm>}}
\DoxyCodeLine{11474 \textcolor{preprocessor}{\#include <cmath>}}
\DoxyCodeLine{11475 \textcolor{preprocessor}{\#include <cstdlib>}}
\DoxyCodeLine{11476 \textcolor{preprocessor}{\#include <cstdint>}}
\DoxyCodeLine{11477 \textcolor{preprocessor}{\#include <cstring>}}
\DoxyCodeLine{11478 \textcolor{preprocessor}{\#include <sstream>}}
\DoxyCodeLine{11479 \textcolor{preprocessor}{\#include <type\_traits>}}
\DoxyCodeLine{11480 \textcolor{preprocessor}{\#include <iomanip>}}
\DoxyCodeLine{11481 \textcolor{preprocessor}{\#include <limits>}}
\DoxyCodeLine{11482 }
\DoxyCodeLine{11483 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{11484 \textcolor{keyword}{namespace }\{}
\DoxyCodeLine{11485 }
\DoxyCodeLine{11486     int32\_t convert(\textcolor{keywordtype}{float} f) \{}
\DoxyCodeLine{11487         \textcolor{keyword}{static\_assert}(\textcolor{keyword}{sizeof}(float) == \textcolor{keyword}{sizeof}(int32\_t), \textcolor{stringliteral}{"{}Important ULP matcher assumption violated"{}});}
\DoxyCodeLine{11488         int32\_t i;}
\DoxyCodeLine{11489         std::memcpy(\&i, \&f, \textcolor{keyword}{sizeof}(f));}
\DoxyCodeLine{11490         \textcolor{keywordflow}{return} i;}
\DoxyCodeLine{11491     \}}
\DoxyCodeLine{11492 }
\DoxyCodeLine{11493     int64\_t convert(\textcolor{keywordtype}{double} d) \{}
\DoxyCodeLine{11494         \textcolor{keyword}{static\_assert}(\textcolor{keyword}{sizeof}(double) == \textcolor{keyword}{sizeof}(int64\_t), \textcolor{stringliteral}{"{}Important ULP matcher assumption violated"{}});}
\DoxyCodeLine{11495         int64\_t i;}
\DoxyCodeLine{11496         std::memcpy(\&i, \&d, \textcolor{keyword}{sizeof}(d));}
\DoxyCodeLine{11497         \textcolor{keywordflow}{return} i;}
\DoxyCodeLine{11498     \}}
\DoxyCodeLine{11499 }
\DoxyCodeLine{11500     \textcolor{keyword}{template} <\textcolor{keyword}{typename} FP>}
\DoxyCodeLine{11501     \textcolor{keywordtype}{bool} almostEqualUlps(FP lhs, FP rhs, uint64\_t maxUlpDiff) \{}
\DoxyCodeLine{11502         \textcolor{comment}{// Comparison with NaN should always be false.}}
\DoxyCodeLine{11503         \textcolor{comment}{// This way we can rule it out before getting into the ugly details}}
\DoxyCodeLine{11504         \textcolor{keywordflow}{if} (Catch::isnan(lhs) || Catch::isnan(rhs)) \{}
\DoxyCodeLine{11505             \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{11506         \}}
\DoxyCodeLine{11507 }
\DoxyCodeLine{11508         \textcolor{keyword}{auto} lc = convert(lhs);}
\DoxyCodeLine{11509         \textcolor{keyword}{auto} rc = convert(rhs);}
\DoxyCodeLine{11510 }
\DoxyCodeLine{11511         \textcolor{keywordflow}{if} ((lc < 0) != (rc < 0)) \{}
\DoxyCodeLine{11512             \textcolor{comment}{// Potentially we can have +0 and -\/0}}
\DoxyCodeLine{11513             \textcolor{keywordflow}{return} lhs == rhs;}
\DoxyCodeLine{11514         \}}
\DoxyCodeLine{11515 }
\DoxyCodeLine{11516         \textcolor{comment}{// static cast as a workaround for IBM XLC}}
\DoxyCodeLine{11517         \textcolor{keyword}{auto} ulpDiff = std::abs(\textcolor{keyword}{static\_cast<}FP\textcolor{keyword}{>}(lc -\/ rc));}
\DoxyCodeLine{11518         \textcolor{keywordflow}{return} \textcolor{keyword}{static\_cast<}uint64\_t\textcolor{keyword}{>}(ulpDiff) <= maxUlpDiff;}
\DoxyCodeLine{11519     \}}
\DoxyCodeLine{11520 }
\DoxyCodeLine{11521 \textcolor{preprocessor}{\#if defined(CATCH\_CONFIG\_GLOBAL\_NEXTAFTER)}}
\DoxyCodeLine{11522 }
\DoxyCodeLine{11523     \textcolor{keywordtype}{float} nextafter(\textcolor{keywordtype}{float} x, \textcolor{keywordtype}{float} y) \{}
\DoxyCodeLine{11524         return ::nextafterf(x, y);}
\DoxyCodeLine{11525     \}}
\DoxyCodeLine{11526 }
\DoxyCodeLine{11527     \textcolor{keywordtype}{double} nextafter(\textcolor{keywordtype}{double} x, \textcolor{keywordtype}{double} y) \{}
\DoxyCodeLine{11528         return ::nextafter(x, y);}
\DoxyCodeLine{11529     \}}
\DoxyCodeLine{11530 }
\DoxyCodeLine{11531 \textcolor{preprocessor}{\#endif }\textcolor{comment}{// \string^\string^\string^ CATCH\_CONFIG\_GLOBAL\_NEXTAFTER \string^\string^\string^}}
\DoxyCodeLine{11532 }
\DoxyCodeLine{11533 \textcolor{keyword}{template} <\textcolor{keyword}{typename} FP>}
\DoxyCodeLine{11534 FP step(FP start, FP direction, uint64\_t steps) \{}
\DoxyCodeLine{11535     \textcolor{keywordflow}{for} (uint64\_t i = 0; i < steps; ++i) \{}
\DoxyCodeLine{11536 \textcolor{preprocessor}{\#if defined(CATCH\_CONFIG\_GLOBAL\_NEXTAFTER)}}
\DoxyCodeLine{11537         start = Catch::nextafter(start, direction);}
\DoxyCodeLine{11538 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{11539         start = std::nextafter(start, direction);}
\DoxyCodeLine{11540 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{11541     \}}
\DoxyCodeLine{11542     \textcolor{keywordflow}{return} start;}
\DoxyCodeLine{11543 \}}
\DoxyCodeLine{11544 }
\DoxyCodeLine{11545 \textcolor{comment}{// Performs equivalent check of std::fabs(lhs -\/ rhs) <= margin}}
\DoxyCodeLine{11546 \textcolor{comment}{// But without the subtraction to allow for INFINITY in comparison}}
\DoxyCodeLine{11547 \textcolor{keywordtype}{bool} marginComparison(\textcolor{keywordtype}{double} lhs, \textcolor{keywordtype}{double} rhs, \textcolor{keywordtype}{double} margin) \{}
\DoxyCodeLine{11548     \textcolor{keywordflow}{return} (lhs + margin >= rhs) \&\& (rhs + margin >= lhs);}
\DoxyCodeLine{11549 \}}
\DoxyCodeLine{11550 }
\DoxyCodeLine{11551 \textcolor{keyword}{template} <\textcolor{keyword}{typename} FloatingPo\textcolor{keywordtype}{int}>}
\DoxyCodeLine{11552 \textcolor{keywordtype}{void} write(std::ostream\& out, FloatingPoint num) \{}
\DoxyCodeLine{11553     out << std::scientific}
\DoxyCodeLine{11554         << std::setprecision(std::numeric\_limits<FloatingPoint>::max\_digits10 -\/ 1)}
\DoxyCodeLine{11555         << num;}
\DoxyCodeLine{11556 \}}
\DoxyCodeLine{11557 }
\DoxyCodeLine{11558 \} \textcolor{comment}{// end anonymous namespace}}
\DoxyCodeLine{11559 }
\DoxyCodeLine{11560 \textcolor{keyword}{namespace }Matchers \{}
\DoxyCodeLine{11561 \textcolor{keyword}{namespace }Floating \{}
\DoxyCodeLine{11562 }
\DoxyCodeLine{11563     \textcolor{keyword}{enum class} FloatingPointKind : uint8\_t \{}
\DoxyCodeLine{11564         Float,}
\DoxyCodeLine{11565         Double}
\DoxyCodeLine{11566     \};}
\DoxyCodeLine{11567 }
\DoxyCodeLine{11568     WithinAbsMatcher::WithinAbsMatcher(\textcolor{keywordtype}{double} target, \textcolor{keywordtype}{double} margin)}
\DoxyCodeLine{11569         :m\_target\{ target \}, m\_margin\{ margin \} \{}
\DoxyCodeLine{11570         CATCH\_ENFORCE(margin >= 0, \textcolor{stringliteral}{"{}Invalid margin: "{}} << margin << \textcolor{charliteral}{'.'}}
\DoxyCodeLine{11571             << \textcolor{stringliteral}{"{} Margin has to be non-\/negative."{}});}
\DoxyCodeLine{11572     \}}
\DoxyCodeLine{11573 }
\DoxyCodeLine{11574     \textcolor{comment}{// Performs equivalent check of std::fabs(lhs -\/ rhs) <= margin}}
\DoxyCodeLine{11575     \textcolor{comment}{// But without the subtraction to allow for INFINITY in comparison}}
\DoxyCodeLine{11576     \textcolor{keywordtype}{bool} WithinAbsMatcher::match(\textcolor{keywordtype}{double} \textcolor{keyword}{const}\& matchee)\textcolor{keyword}{ const }\{}
\DoxyCodeLine{11577         \textcolor{keywordflow}{return} (matchee + m\_margin >= m\_target) \&\& (m\_target + m\_margin >= matchee);}
\DoxyCodeLine{11578     \}}
\DoxyCodeLine{11579 }
\DoxyCodeLine{11580     std::string WithinAbsMatcher::describe()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{11581         \textcolor{keywordflow}{return} \textcolor{stringliteral}{"{}is within "{}} + ::Catch::Detail::stringify(m\_margin) + "{} of "{} + ::Catch::Detail::stringify(m\_target);}
\DoxyCodeLine{11582     \}}
\DoxyCodeLine{11583 }
\DoxyCodeLine{11584     WithinUlpsMatcher::WithinUlpsMatcher(\textcolor{keywordtype}{double} target, uint64\_t ulps, FloatingPointKind baseType)}
\DoxyCodeLine{11585         :m\_target\{ target \}, m\_ulps\{ ulps \}, m\_type\{ baseType \} \{}
\DoxyCodeLine{11586         CATCH\_ENFORCE(m\_type == FloatingPointKind::Double}
\DoxyCodeLine{11587                    || m\_ulps < (std::numeric\_limits<uint32\_t>::max)(),}
\DoxyCodeLine{11588             \textcolor{stringliteral}{"{}Provided ULP is impossibly large for a float comparison."{}});}
\DoxyCodeLine{11589     \}}
\DoxyCodeLine{11590 }
\DoxyCodeLine{11591 \textcolor{preprocessor}{\#if defined(\_\_clang\_\_)}}
\DoxyCodeLine{11592 \textcolor{preprocessor}{\#pragma clang diagnostic push}}
\DoxyCodeLine{11593 \textcolor{comment}{// Clang <3.5 reports on the default branch in the switch below}}
\DoxyCodeLine{11594 \textcolor{preprocessor}{\#pragma clang diagnostic ignored "{}-\/Wunreachable-\/code"{}}}
\DoxyCodeLine{11595 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{11596 }
\DoxyCodeLine{11597     \textcolor{keywordtype}{bool} WithinUlpsMatcher::match(\textcolor{keywordtype}{double} \textcolor{keyword}{const}\& matchee)\textcolor{keyword}{ const }\{}
\DoxyCodeLine{11598         \textcolor{keywordflow}{switch} (m\_type) \{}
\DoxyCodeLine{11599         \textcolor{keywordflow}{case} FloatingPointKind::Float:}
\DoxyCodeLine{11600             \textcolor{keywordflow}{return} almostEqualUlps<float>(\textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{float}\textcolor{keyword}{>}(matchee), \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{float}\textcolor{keyword}{>}(m\_target), m\_ulps);}
\DoxyCodeLine{11601         \textcolor{keywordflow}{case} FloatingPointKind::Double:}
\DoxyCodeLine{11602             \textcolor{keywordflow}{return} almostEqualUlps<double>(matchee, m\_target, m\_ulps);}
\DoxyCodeLine{11603         \textcolor{keywordflow}{default}:}
\DoxyCodeLine{11604             CATCH\_INTERNAL\_ERROR( \textcolor{stringliteral}{"{}Unknown FloatingPointKind value"{}} );}
\DoxyCodeLine{11605         \}}
\DoxyCodeLine{11606     \}}
\DoxyCodeLine{11607 }
\DoxyCodeLine{11608 \textcolor{preprocessor}{\#if defined(\_\_clang\_\_)}}
\DoxyCodeLine{11609 \textcolor{preprocessor}{\#pragma clang diagnostic pop}}
\DoxyCodeLine{11610 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{11611 }
\DoxyCodeLine{11612     std::string WithinUlpsMatcher::describe()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{11613         std::stringstream ret;}
\DoxyCodeLine{11614 }
\DoxyCodeLine{11615         ret << \textcolor{stringliteral}{"{}is within "{}} << m\_ulps << \textcolor{stringliteral}{"{} ULPs of "{}};}
\DoxyCodeLine{11616 }
\DoxyCodeLine{11617         \textcolor{keywordflow}{if} (m\_type == FloatingPointKind::Float) \{}
\DoxyCodeLine{11618             write(ret, \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{float}\textcolor{keyword}{>}(m\_target));}
\DoxyCodeLine{11619             ret << \textcolor{charliteral}{'f'};}
\DoxyCodeLine{11620         \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{11621             write(ret, m\_target);}
\DoxyCodeLine{11622         \}}
\DoxyCodeLine{11623 }
\DoxyCodeLine{11624         ret << \textcolor{stringliteral}{"{} (["{}};}
\DoxyCodeLine{11625         \textcolor{keywordflow}{if} (m\_type == FloatingPointKind::Double) \{}
\DoxyCodeLine{11626             write(ret, step(m\_target, \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{double}\textcolor{keyword}{>}(-\/INFINITY), m\_ulps));}
\DoxyCodeLine{11627             ret << \textcolor{stringliteral}{"{}, "{}};}
\DoxyCodeLine{11628             write(ret, step(m\_target, \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{double}\textcolor{keyword}{>}( INFINITY), m\_ulps));}
\DoxyCodeLine{11629         \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{11630             \textcolor{comment}{// We have to cast INFINITY to float because of MinGW, see \#1782}}
\DoxyCodeLine{11631             write(ret, step(\textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{float}\textcolor{keyword}{>}(m\_target), \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{float}\textcolor{keyword}{>}(-\/INFINITY), m\_ulps));}
\DoxyCodeLine{11632             ret << \textcolor{stringliteral}{"{}, "{}};}
\DoxyCodeLine{11633             write(ret, step(\textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{float}\textcolor{keyword}{>}(m\_target), \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{float}\textcolor{keyword}{>}( INFINITY), m\_ulps));}
\DoxyCodeLine{11634         \}}
\DoxyCodeLine{11635         ret << \textcolor{stringliteral}{"{}])"{}};}
\DoxyCodeLine{11636 }
\DoxyCodeLine{11637         \textcolor{keywordflow}{return} ret.str();}
\DoxyCodeLine{11638     \}}
\DoxyCodeLine{11639 }
\DoxyCodeLine{11640     WithinRelMatcher::WithinRelMatcher(\textcolor{keywordtype}{double} target, \textcolor{keywordtype}{double} epsilon):}
\DoxyCodeLine{11641         m\_target(target),}
\DoxyCodeLine{11642         m\_epsilon(epsilon)\{}
\DoxyCodeLine{11643         CATCH\_ENFORCE(m\_epsilon >= 0., \textcolor{stringliteral}{"{}Relative comparison with epsilon <  0 does not make sense."{}});}
\DoxyCodeLine{11644         CATCH\_ENFORCE(m\_epsilon  < 1., "{}Relative comparison with epsilon >= 1 does not make sense.\textcolor{stringliteral}{"{});}}
\DoxyCodeLine{11645 \textcolor{stringliteral}{    \}}}
\DoxyCodeLine{11646 \textcolor{stringliteral}{}}
\DoxyCodeLine{11647 \textcolor{stringliteral}{    bool WithinRelMatcher::match(double const\& matchee) const \{}}
\DoxyCodeLine{11648 \textcolor{stringliteral}{        const auto relMargin = m\_epsilon * (std::max)(std::fabs(matchee), std::fabs(m\_target));}}
\DoxyCodeLine{11649 \textcolor{stringliteral}{        return marginComparison(matchee, m\_target,}}
\DoxyCodeLine{11650 \textcolor{stringliteral}{                                std::isinf(relMargin)? 0 : relMargin);}}
\DoxyCodeLine{11651 \textcolor{stringliteral}{    \}}}
\DoxyCodeLine{11652 \textcolor{stringliteral}{}}
\DoxyCodeLine{11653 \textcolor{stringliteral}{    std::string WithinRelMatcher::describe() const \{}}
\DoxyCodeLine{11654 \textcolor{stringliteral}{        Catch::ReusableStringStream sstr;}}
\DoxyCodeLine{11655 \textcolor{stringliteral}{        sstr << "{}}and \textcolor{stringliteral}{"{} << m\_target << "{}} are within \textcolor{stringliteral}{"{} << m\_epsilon * 100. << "{}}\% of each other\textcolor{stringliteral}{"{};}}
\DoxyCodeLine{11656 \textcolor{stringliteral}{        return sstr.str();}}
\DoxyCodeLine{11657 \textcolor{stringliteral}{    \}}}
\DoxyCodeLine{11658 \textcolor{stringliteral}{}}
\DoxyCodeLine{11659 \textcolor{stringliteral}{\}// namespace Floating}}
\DoxyCodeLine{11660 \textcolor{stringliteral}{}}
\DoxyCodeLine{11661 \textcolor{stringliteral}{Floating::WithinUlpsMatcher WithinULP(double target, uint64\_t maxUlpDiff) \{}}
\DoxyCodeLine{11662 \textcolor{stringliteral}{    return Floating::WithinUlpsMatcher(target, maxUlpDiff, Floating::FloatingPointKind::Double);}}
\DoxyCodeLine{11663 \textcolor{stringliteral}{\}}}
\DoxyCodeLine{11664 \textcolor{stringliteral}{}}
\DoxyCodeLine{11665 \textcolor{stringliteral}{Floating::WithinUlpsMatcher WithinULP(float target, uint64\_t maxUlpDiff) \{}}
\DoxyCodeLine{11666 \textcolor{stringliteral}{    return Floating::WithinUlpsMatcher(target, maxUlpDiff, Floating::FloatingPointKind::Float);}}
\DoxyCodeLine{11667 \textcolor{stringliteral}{\}}}
\DoxyCodeLine{11668 \textcolor{stringliteral}{}}
\DoxyCodeLine{11669 \textcolor{stringliteral}{Floating::WithinAbsMatcher WithinAbs(double target, double margin) \{}}
\DoxyCodeLine{11670 \textcolor{stringliteral}{    return Floating::WithinAbsMatcher(target, margin);}}
\DoxyCodeLine{11671 \textcolor{stringliteral}{\}}}
\DoxyCodeLine{11672 \textcolor{stringliteral}{}}
\DoxyCodeLine{11673 \textcolor{stringliteral}{Floating::WithinRelMatcher WithinRel(double target, double eps) \{}}
\DoxyCodeLine{11674 \textcolor{stringliteral}{    return Floating::WithinRelMatcher(target, eps);}}
\DoxyCodeLine{11675 \textcolor{stringliteral}{\}}}
\DoxyCodeLine{11676 \textcolor{stringliteral}{}}
\DoxyCodeLine{11677 \textcolor{stringliteral}{Floating::WithinRelMatcher WithinRel(double target) \{}}
\DoxyCodeLine{11678 \textcolor{stringliteral}{    return Floating::WithinRelMatcher(target, std::numeric\_limits<double>::epsilon() * 100);}}
\DoxyCodeLine{11679 \textcolor{stringliteral}{\}}}
\DoxyCodeLine{11680 \textcolor{stringliteral}{}}
\DoxyCodeLine{11681 \textcolor{stringliteral}{Floating::WithinRelMatcher WithinRel(float target, float eps) \{}}
\DoxyCodeLine{11682 \textcolor{stringliteral}{    return Floating::WithinRelMatcher(target, eps);}}
\DoxyCodeLine{11683 \textcolor{stringliteral}{\}}}
\DoxyCodeLine{11684 \textcolor{stringliteral}{}}
\DoxyCodeLine{11685 \textcolor{stringliteral}{Floating::WithinRelMatcher WithinRel(float target) \{}}
\DoxyCodeLine{11686 \textcolor{stringliteral}{    return Floating::WithinRelMatcher(target, std::numeric\_limits<float>::epsilon() * 100);}}
\DoxyCodeLine{11687 \textcolor{stringliteral}{\}}}
\DoxyCodeLine{11688 \textcolor{stringliteral}{}}
\DoxyCodeLine{11689 \textcolor{stringliteral}{\} // namespace Matchers}}
\DoxyCodeLine{11690 \textcolor{stringliteral}{\} // namespace Catch}}
\DoxyCodeLine{11691 \textcolor{stringliteral}{// end catch\_matchers\_floating.cpp}}
\DoxyCodeLine{11692 \textcolor{stringliteral}{// start catch\_matchers\_generic.cpp}}
\DoxyCodeLine{11693 \textcolor{stringliteral}{}}
\DoxyCodeLine{11694 \textcolor{stringliteral}{std::string Catch::Matchers::Generic::Detail::finalizeDescription(const std::string\& desc) \{}}
\DoxyCodeLine{11695 \textcolor{stringliteral}{    if (desc.empty()) \{}}
\DoxyCodeLine{11696 \textcolor{stringliteral}{        return "{}}matches undescribed predicate\textcolor{stringliteral}{"{};}}
\DoxyCodeLine{11697 \textcolor{stringliteral}{    \} else \{}}
\DoxyCodeLine{11698 \textcolor{stringliteral}{        return "{}}matches predicate: \(\backslash\)\textcolor{stringliteral}{"{}"{}} + desc + \textcolor{charliteral}{'"{}'};}
\DoxyCodeLine{11699     \}}
\DoxyCodeLine{11700 \}}
\DoxyCodeLine{11701 \textcolor{comment}{// end catch\_matchers\_generic.cpp}}
\DoxyCodeLine{11702 \textcolor{comment}{// start catch\_matchers\_string.cpp}}
\DoxyCodeLine{11703 }
\DoxyCodeLine{11704 \textcolor{preprocessor}{\#include <regex>}}
\DoxyCodeLine{11705 }
\DoxyCodeLine{11706 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{11707 \textcolor{keyword}{namespace }Matchers \{}
\DoxyCodeLine{11708 }
\DoxyCodeLine{11709     \textcolor{keyword}{namespace }StdString \{}
\DoxyCodeLine{11710 }
\DoxyCodeLine{11711         CasedString::CasedString( std::string \textcolor{keyword}{const}\& str, CaseSensitive::Choice caseSensitivity )}
\DoxyCodeLine{11712         :   m\_caseSensitivity( caseSensitivity ),}
\DoxyCodeLine{11713             m\_str( adjustString( str ) )}
\DoxyCodeLine{11714         \{\}}
\DoxyCodeLine{11715         std::string CasedString::adjustString( std::string \textcolor{keyword}{const}\& str )\textcolor{keyword}{ const }\{}
\DoxyCodeLine{11716             \textcolor{keywordflow}{return} m\_caseSensitivity == CaseSensitive::No}
\DoxyCodeLine{11717                    ? toLower( str )}
\DoxyCodeLine{11718                    : str;}
\DoxyCodeLine{11719         \}}
\DoxyCodeLine{11720         std::string CasedString::caseSensitivitySuffix()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{11721             \textcolor{keywordflow}{return} m\_caseSensitivity == CaseSensitive::No}
\DoxyCodeLine{11722                    ? \textcolor{stringliteral}{"{} (case insensitive)"{}}}
\DoxyCodeLine{11723                    : std::string();}
\DoxyCodeLine{11724         \}}
\DoxyCodeLine{11725 }
\DoxyCodeLine{11726         StringMatcherBase::StringMatcherBase( std::string \textcolor{keyword}{const}\& operation, CasedString \textcolor{keyword}{const}\& comparator )}
\DoxyCodeLine{11727         : m\_comparator( comparator ),}
\DoxyCodeLine{11728           m\_operation( operation ) \{}
\DoxyCodeLine{11729         \}}
\DoxyCodeLine{11730 }
\DoxyCodeLine{11731         std::string StringMatcherBase::describe()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{11732             std::string description;}
\DoxyCodeLine{11733             description.reserve(5 + m\_operation.size() + m\_comparator.m\_str.size() +}
\DoxyCodeLine{11734                                         m\_comparator.caseSensitivitySuffix().size());}
\DoxyCodeLine{11735             description += m\_operation;}
\DoxyCodeLine{11736             description += "{}: \(\backslash\)"{}"{};}
\DoxyCodeLine{11737             description += m\_comparator.m\_str;}
\DoxyCodeLine{11738             description += "{}\(\backslash\)"{}"{};}
\DoxyCodeLine{11739             description += m\_comparator.caseSensitivitySuffix();}
\DoxyCodeLine{11740             \textcolor{keywordflow}{return} description;}
\DoxyCodeLine{11741         \}}
\DoxyCodeLine{11742 }
\DoxyCodeLine{11743         EqualsMatcher::EqualsMatcher( CasedString \textcolor{keyword}{const}\& comparator ) : StringMatcherBase( \textcolor{stringliteral}{"{}equals"{}}, comparator ) \{\}}
\DoxyCodeLine{11744 }
\DoxyCodeLine{11745         \textcolor{keywordtype}{bool} EqualsMatcher::match( std::string \textcolor{keyword}{const}\& source )\textcolor{keyword}{ const }\{}
\DoxyCodeLine{11746             \textcolor{keywordflow}{return} m\_comparator.adjustString( source ) == m\_comparator.m\_str;}
\DoxyCodeLine{11747         \}}
\DoxyCodeLine{11748 }
\DoxyCodeLine{11749         ContainsMatcher::ContainsMatcher( CasedString \textcolor{keyword}{const}\& comparator ) : StringMatcherBase( \textcolor{stringliteral}{"{}contains"{}}, comparator ) \{\}}
\DoxyCodeLine{11750 }
\DoxyCodeLine{11751         \textcolor{keywordtype}{bool} ContainsMatcher::match( std::string \textcolor{keyword}{const}\& source )\textcolor{keyword}{ const }\{}
\DoxyCodeLine{11752             \textcolor{keywordflow}{return} contains( m\_comparator.adjustString( source ), m\_comparator.m\_str );}
\DoxyCodeLine{11753         \}}
\DoxyCodeLine{11754 }
\DoxyCodeLine{11755         StartsWithMatcher::StartsWithMatcher( CasedString \textcolor{keyword}{const}\& comparator ) : StringMatcherBase( \textcolor{stringliteral}{"{}starts with"{}}, comparator ) \{\}}
\DoxyCodeLine{11756 }
\DoxyCodeLine{11757         \textcolor{keywordtype}{bool} StartsWithMatcher::match( std::string \textcolor{keyword}{const}\& source )\textcolor{keyword}{ const }\{}
\DoxyCodeLine{11758             \textcolor{keywordflow}{return} startsWith( m\_comparator.adjustString( source ), m\_comparator.m\_str );}
\DoxyCodeLine{11759         \}}
\DoxyCodeLine{11760 }
\DoxyCodeLine{11761         EndsWithMatcher::EndsWithMatcher( CasedString \textcolor{keyword}{const}\& comparator ) : StringMatcherBase( \textcolor{stringliteral}{"{}ends with"{}}, comparator ) \{\}}
\DoxyCodeLine{11762 }
\DoxyCodeLine{11763         \textcolor{keywordtype}{bool} EndsWithMatcher::match( std::string \textcolor{keyword}{const}\& source )\textcolor{keyword}{ const }\{}
\DoxyCodeLine{11764             \textcolor{keywordflow}{return} endsWith( m\_comparator.adjustString( source ), m\_comparator.m\_str );}
\DoxyCodeLine{11765         \}}
\DoxyCodeLine{11766 }
\DoxyCodeLine{11767         RegexMatcher::RegexMatcher(std::string regex, CaseSensitive::Choice caseSensitivity): m\_regex(std::move(regex)), m\_caseSensitivity(caseSensitivity) \{\}}
\DoxyCodeLine{11768 }
\DoxyCodeLine{11769         \textcolor{keywordtype}{bool} RegexMatcher::match(std::string \textcolor{keyword}{const}\& matchee)\textcolor{keyword}{ const }\{}
\DoxyCodeLine{11770             \textcolor{keyword}{auto} flags = std::regex::ECMAScript; \textcolor{comment}{// ECMAScript is the default syntax option anyway}}
\DoxyCodeLine{11771             \textcolor{keywordflow}{if} (m\_caseSensitivity == CaseSensitive::Choice::No) \{}
\DoxyCodeLine{11772                 flags |= std::regex::icase;}
\DoxyCodeLine{11773             \}}
\DoxyCodeLine{11774             \textcolor{keyword}{auto} reg = std::regex(m\_regex, flags);}
\DoxyCodeLine{11775             \textcolor{keywordflow}{return} std::regex\_match(matchee, reg);}
\DoxyCodeLine{11776         \}}
\DoxyCodeLine{11777 }
\DoxyCodeLine{11778         std::string RegexMatcher::describe()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{11779             \textcolor{keywordflow}{return} \textcolor{stringliteral}{"{}matches "{}} + ::Catch::Detail::stringify(m\_regex) + ((m\_caseSensitivity == CaseSensitive::Choice::Yes)? "{} case sensitively"{} : "{} case insensitively"{});}
\DoxyCodeLine{11780         \}}
\DoxyCodeLine{11781 }
\DoxyCodeLine{11782     \} \textcolor{comment}{// namespace StdString}}
\DoxyCodeLine{11783 }
\DoxyCodeLine{11784     StdString::EqualsMatcher Equals( std::string \textcolor{keyword}{const}\& str, CaseSensitive::Choice caseSensitivity ) \{}
\DoxyCodeLine{11785         \textcolor{keywordflow}{return} StdString::EqualsMatcher( StdString::CasedString( str, caseSensitivity) );}
\DoxyCodeLine{11786     \}}
\DoxyCodeLine{11787     StdString::ContainsMatcher Contains( std::string \textcolor{keyword}{const}\& str, CaseSensitive::Choice caseSensitivity ) \{}
\DoxyCodeLine{11788         \textcolor{keywordflow}{return} StdString::ContainsMatcher( StdString::CasedString( str, caseSensitivity) );}
\DoxyCodeLine{11789     \}}
\DoxyCodeLine{11790     StdString::EndsWithMatcher EndsWith( std::string \textcolor{keyword}{const}\& str, CaseSensitive::Choice caseSensitivity ) \{}
\DoxyCodeLine{11791         \textcolor{keywordflow}{return} StdString::EndsWithMatcher( StdString::CasedString( str, caseSensitivity) );}
\DoxyCodeLine{11792     \}}
\DoxyCodeLine{11793     StdString::StartsWithMatcher StartsWith( std::string \textcolor{keyword}{const}\& str, CaseSensitive::Choice caseSensitivity ) \{}
\DoxyCodeLine{11794         \textcolor{keywordflow}{return} StdString::StartsWithMatcher( StdString::CasedString( str, caseSensitivity) );}
\DoxyCodeLine{11795     \}}
\DoxyCodeLine{11796 }
\DoxyCodeLine{11797     StdString::RegexMatcher Matches(std::string \textcolor{keyword}{const}\& regex, CaseSensitive::Choice caseSensitivity) \{}
\DoxyCodeLine{11798         \textcolor{keywordflow}{return} StdString::RegexMatcher(regex, caseSensitivity);}
\DoxyCodeLine{11799     \}}
\DoxyCodeLine{11800 }
\DoxyCodeLine{11801 \} \textcolor{comment}{// namespace Matchers}}
\DoxyCodeLine{11802 \} \textcolor{comment}{// namespace Catch}}
\DoxyCodeLine{11803 \textcolor{comment}{// end catch\_matchers\_string.cpp}}
\DoxyCodeLine{11804 \textcolor{comment}{// start catch\_message.cpp}}
\DoxyCodeLine{11805 }
\DoxyCodeLine{11806 \textcolor{comment}{// start catch\_uncaught\_exceptions.h}}
\DoxyCodeLine{11807 }
\DoxyCodeLine{11808 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{11809     \textcolor{keywordtype}{bool} uncaught\_exceptions();}
\DoxyCodeLine{11810 \} \textcolor{comment}{// end namespace Catch}}
\DoxyCodeLine{11811 }
\DoxyCodeLine{11812 \textcolor{comment}{// end catch\_uncaught\_exceptions.h}}
\DoxyCodeLine{11813 \textcolor{preprocessor}{\#include <cassert>}}
\DoxyCodeLine{11814 \textcolor{preprocessor}{\#include <stack>}}
\DoxyCodeLine{11815 }
\DoxyCodeLine{11816 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{11817 }
\DoxyCodeLine{11818     MessageInfo::MessageInfo(   StringRef \textcolor{keyword}{const}\& \_macroName,}
\DoxyCodeLine{11819                                 SourceLineInfo \textcolor{keyword}{const}\& \_lineInfo,}
\DoxyCodeLine{11820                                 ResultWas::OfType \_type )}
\DoxyCodeLine{11821     :   macroName( \_macroName ),}
\DoxyCodeLine{11822         lineInfo( \_lineInfo ),}
\DoxyCodeLine{11823         type( \_type ),}
\DoxyCodeLine{11824         sequence( ++globalCount )}
\DoxyCodeLine{11825     \{\}}
\DoxyCodeLine{11826 }
\DoxyCodeLine{11827     \textcolor{keywordtype}{bool} MessageInfo::operator==( MessageInfo \textcolor{keyword}{const}\& other )\textcolor{keyword}{ const }\{}
\DoxyCodeLine{11828         \textcolor{keywordflow}{return} sequence == other.sequence;}
\DoxyCodeLine{11829     \}}
\DoxyCodeLine{11830 }
\DoxyCodeLine{11831     \textcolor{keywordtype}{bool} MessageInfo::operator<( MessageInfo \textcolor{keyword}{const}\& other )\textcolor{keyword}{ const }\{}
\DoxyCodeLine{11832         \textcolor{keywordflow}{return} sequence < other.sequence;}
\DoxyCodeLine{11833     \}}
\DoxyCodeLine{11834 }
\DoxyCodeLine{11835     \textcolor{comment}{// This may need protecting if threading support is added}}
\DoxyCodeLine{11836     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} MessageInfo::globalCount = 0;}
\DoxyCodeLine{11837 }
\DoxyCodeLine{11839 }
\DoxyCodeLine{11840     Catch::MessageBuilder::MessageBuilder( StringRef \textcolor{keyword}{const}\& macroName,}
\DoxyCodeLine{11841                                            SourceLineInfo \textcolor{keyword}{const}\& lineInfo,}
\DoxyCodeLine{11842                                            ResultWas::OfType type )}
\DoxyCodeLine{11843         :m\_info(macroName, lineInfo, type) \{\}}
\DoxyCodeLine{11844 }
\DoxyCodeLine{11846 }
\DoxyCodeLine{11847     ScopedMessage::ScopedMessage( MessageBuilder \textcolor{keyword}{const}\& builder )}
\DoxyCodeLine{11848     : m\_info( builder.m\_info ), m\_moved()}
\DoxyCodeLine{11849     \{}
\DoxyCodeLine{11850         m\_info.message = builder.m\_stream.str();}
\DoxyCodeLine{11851         getResultCapture().pushScopedMessage( m\_info );}
\DoxyCodeLine{11852     \}}
\DoxyCodeLine{11853 }
\DoxyCodeLine{11854     ScopedMessage::ScopedMessage( ScopedMessage\&\& old )}
\DoxyCodeLine{11855     : m\_info( old.m\_info ), m\_moved()}
\DoxyCodeLine{11856     \{}
\DoxyCodeLine{11857         old.m\_moved = \textcolor{keyword}{true};}
\DoxyCodeLine{11858     \}}
\DoxyCodeLine{11859 }
\DoxyCodeLine{11860     ScopedMessage::\string~ScopedMessage() \{}
\DoxyCodeLine{11861         \textcolor{keywordflow}{if} ( !uncaught\_exceptions() \&\& !m\_moved )\{}
\DoxyCodeLine{11862             getResultCapture().popScopedMessage(m\_info);}
\DoxyCodeLine{11863         \}}
\DoxyCodeLine{11864     \}}
\DoxyCodeLine{11865 }
\DoxyCodeLine{11866     Capturer::Capturer( StringRef macroName, SourceLineInfo \textcolor{keyword}{const}\& lineInfo, ResultWas::OfType resultType, StringRef names ) \{}
\DoxyCodeLine{11867         \textcolor{keyword}{auto} trimmed = [\&] (\textcolor{keywordtype}{size\_t} start, \textcolor{keywordtype}{size\_t} end) \{}
\DoxyCodeLine{11868             \textcolor{keywordflow}{while} (names[start] == \textcolor{charliteral}{','} || isspace(\textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char}\textcolor{keyword}{>}(names[start]))) \{}
\DoxyCodeLine{11869                 ++start;}
\DoxyCodeLine{11870             \}}
\DoxyCodeLine{11871             \textcolor{keywordflow}{while} (names[end] == \textcolor{charliteral}{','} || isspace(\textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char}\textcolor{keyword}{>}(names[end]))) \{}
\DoxyCodeLine{11872                 -\/-\/end;}
\DoxyCodeLine{11873             \}}
\DoxyCodeLine{11874             \textcolor{keywordflow}{return} names.substr(start, end -\/ start + 1);}
\DoxyCodeLine{11875         \};}
\DoxyCodeLine{11876         \textcolor{keyword}{auto} skipq = [\&] (\textcolor{keywordtype}{size\_t} start, \textcolor{keywordtype}{char} quote) \{}
\DoxyCodeLine{11877             \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} i = start + 1; i < names.size() ; ++i) \{}
\DoxyCodeLine{11878                 \textcolor{keywordflow}{if} (names[i] == quote)}
\DoxyCodeLine{11879                     \textcolor{keywordflow}{return} i;}
\DoxyCodeLine{11880                 \textcolor{keywordflow}{if} (names[i] == \textcolor{charliteral}{'\(\backslash\)\(\backslash\)'})}
\DoxyCodeLine{11881                     ++i;}
\DoxyCodeLine{11882             \}}
\DoxyCodeLine{11883             CATCH\_INTERNAL\_ERROR(\textcolor{stringliteral}{"{}CAPTURE parsing encountered unmatched quote"{}});}
\DoxyCodeLine{11884         \};}
\DoxyCodeLine{11885 }
\DoxyCodeLine{11886         \textcolor{keywordtype}{size\_t} start = 0;}
\DoxyCodeLine{11887         std::stack<char> openings;}
\DoxyCodeLine{11888         \textcolor{keywordflow}{for} (\textcolor{keywordtype}{size\_t} pos = 0; pos < names.size(); ++pos) \{}
\DoxyCodeLine{11889             \textcolor{keywordtype}{char} c = names[pos];}
\DoxyCodeLine{11890             \textcolor{keywordflow}{switch} (c) \{}
\DoxyCodeLine{11891             \textcolor{keywordflow}{case} \textcolor{charliteral}{'['}:}
\DoxyCodeLine{11892             \textcolor{keywordflow}{case} \textcolor{charliteral}{'\{'}:}
\DoxyCodeLine{11893             \textcolor{keywordflow}{case} \textcolor{charliteral}{'('}:}
\DoxyCodeLine{11894             \textcolor{comment}{// It is basically impossible to disambiguate between}}
\DoxyCodeLine{11895             \textcolor{comment}{// comparison and start of template args in this context}}
\DoxyCodeLine{11896 \textcolor{comment}{//            case '<':}}
\DoxyCodeLine{11897                 openings.push(c);}
\DoxyCodeLine{11898                 \textcolor{keywordflow}{break};}
\DoxyCodeLine{11899             \textcolor{keywordflow}{case} \textcolor{charliteral}{']'}:}
\DoxyCodeLine{11900             \textcolor{keywordflow}{case} \textcolor{charliteral}{'\}'}:}
\DoxyCodeLine{11901             \textcolor{keywordflow}{case} \textcolor{charliteral}{')'}:}
\DoxyCodeLine{11902 \textcolor{comment}{//           case '>':}}
\DoxyCodeLine{11903                 openings.pop();}
\DoxyCodeLine{11904                 \textcolor{keywordflow}{break};}
\DoxyCodeLine{11905             \textcolor{keywordflow}{case} \textcolor{charliteral}{'"{}'}:}
\DoxyCodeLine{11906             \textcolor{keywordflow}{case} \textcolor{charliteral}{'\(\backslash\)''}:}
\DoxyCodeLine{11907                 pos = skipq(pos, c);}
\DoxyCodeLine{11908                 \textcolor{keywordflow}{break};}
\DoxyCodeLine{11909             \textcolor{keywordflow}{case} \textcolor{charliteral}{','}:}
\DoxyCodeLine{11910                 \textcolor{keywordflow}{if} (start != pos \&\& openings.empty()) \{}
\DoxyCodeLine{11911                     m\_messages.emplace\_back(macroName, lineInfo, resultType);}
\DoxyCodeLine{11912                     m\_messages.back().message = \textcolor{keyword}{static\_cast<}std::string\textcolor{keyword}{>}(trimmed(start, pos));}
\DoxyCodeLine{11913                     m\_messages.back().message += "{} := "{};}
\DoxyCodeLine{11914                     start = pos;}
\DoxyCodeLine{11915                 \}}
\DoxyCodeLine{11916             \}}
\DoxyCodeLine{11917         \}}
\DoxyCodeLine{11918         assert(openings.empty() \&\& \textcolor{stringliteral}{"{}Mismatched openings"{}});}
\DoxyCodeLine{11919         m\_messages.emplace\_back(macroName, lineInfo, resultType);}
\DoxyCodeLine{11920         m\_messages.back().message = \textcolor{keyword}{static\_cast<}std::string\textcolor{keyword}{>}(trimmed(start, names.size() -\/ 1));}
\DoxyCodeLine{11921         m\_messages.back().message += "{} := "{};}
\DoxyCodeLine{11922     \}}
\DoxyCodeLine{11923     Capturer::\string~Capturer() \{}
\DoxyCodeLine{11924         \textcolor{keywordflow}{if} ( !uncaught\_exceptions() )\{}
\DoxyCodeLine{11925             assert( m\_captured == m\_messages.size() );}
\DoxyCodeLine{11926             \textcolor{keywordflow}{for}( \textcolor{keywordtype}{size\_t} i = 0; i < m\_captured; ++i  )}
\DoxyCodeLine{11927                 m\_resultCapture.popScopedMessage( m\_messages[i] );}
\DoxyCodeLine{11928         \}}
\DoxyCodeLine{11929     \}}
\DoxyCodeLine{11930 }
\DoxyCodeLine{11931     \textcolor{keywordtype}{void} Capturer::captureValue( \textcolor{keywordtype}{size\_t} index, std::string \textcolor{keyword}{const}\& value ) \{}
\DoxyCodeLine{11932         assert( index < m\_messages.size() );}
\DoxyCodeLine{11933         m\_messages[index].message += value;}
\DoxyCodeLine{11934         m\_resultCapture.pushScopedMessage( m\_messages[index] );}
\DoxyCodeLine{11935         m\_captured++;}
\DoxyCodeLine{11936     \}}
\DoxyCodeLine{11937 }
\DoxyCodeLine{11938 \} \textcolor{comment}{// end namespace Catch}}
\DoxyCodeLine{11939 \textcolor{comment}{// end catch\_message.cpp}}
\DoxyCodeLine{11940 \textcolor{comment}{// start catch\_output\_redirect.cpp}}
\DoxyCodeLine{11941 }
\DoxyCodeLine{11942 \textcolor{comment}{// start catch\_output\_redirect.h}}
\DoxyCodeLine{11943 \textcolor{preprocessor}{\#ifndef TWOBLUECUBES\_CATCH\_OUTPUT\_REDIRECT\_H}}
\DoxyCodeLine{11944 \textcolor{preprocessor}{\#define TWOBLUECUBES\_CATCH\_OUTPUT\_REDIRECT\_H}}
\DoxyCodeLine{11945 }
\DoxyCodeLine{11946 \textcolor{preprocessor}{\#include <cstdio>}}
\DoxyCodeLine{11947 \textcolor{preprocessor}{\#include <iosfwd>}}
\DoxyCodeLine{11948 \textcolor{preprocessor}{\#include <string>}}
\DoxyCodeLine{11949 }
\DoxyCodeLine{11950 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{11951 }
\DoxyCodeLine{11952     \textcolor{keyword}{class }RedirectedStream \{}
\DoxyCodeLine{11953         std::ostream\& m\_originalStream;}
\DoxyCodeLine{11954         std::ostream\& m\_redirectionStream;}
\DoxyCodeLine{11955         std::streambuf* m\_prevBuf;}
\DoxyCodeLine{11956 }
\DoxyCodeLine{11957     \textcolor{keyword}{public}:}
\DoxyCodeLine{11958         RedirectedStream( std::ostream\& originalStream, std::ostream\& redirectionStream );}
\DoxyCodeLine{11959         \string~RedirectedStream();}
\DoxyCodeLine{11960     \};}
\DoxyCodeLine{11961 }
\DoxyCodeLine{11962     \textcolor{keyword}{class }RedirectedStdOut \{}
\DoxyCodeLine{11963         ReusableStringStream m\_rss;}
\DoxyCodeLine{11964         RedirectedStream m\_cout;}
\DoxyCodeLine{11965     \textcolor{keyword}{public}:}
\DoxyCodeLine{11966         RedirectedStdOut();}
\DoxyCodeLine{11967         \textcolor{keyword}{auto} str() const -\/> std::\textcolor{keywordtype}{string};}
\DoxyCodeLine{11968     \};}
\DoxyCodeLine{11969 }
\DoxyCodeLine{11970     \textcolor{comment}{// StdErr has two constituent streams in C++, std::cerr and std::clog}}
\DoxyCodeLine{11971     \textcolor{comment}{// This means that we need to redirect 2 streams into 1 to keep proper}}
\DoxyCodeLine{11972     \textcolor{comment}{// order of writes}}
\DoxyCodeLine{11973     class RedirectedStdErr \{}
\DoxyCodeLine{11974         ReusableStringStream m\_rss;}
\DoxyCodeLine{11975         RedirectedStream m\_cerr;}
\DoxyCodeLine{11976         RedirectedStream m\_clog;}
\DoxyCodeLine{11977     \textcolor{keyword}{public}:}
\DoxyCodeLine{11978         RedirectedStdErr();}
\DoxyCodeLine{11979         \textcolor{keyword}{auto} str() const -\/> std::\textcolor{keywordtype}{string};}
\DoxyCodeLine{11980     \};}
\DoxyCodeLine{11981 }
\DoxyCodeLine{11982     class RedirectedStreams \{}
\DoxyCodeLine{11983     \textcolor{keyword}{public}:}
\DoxyCodeLine{11984         RedirectedStreams(RedirectedStreams \textcolor{keyword}{const}\&) = \textcolor{keyword}{delete};}
\DoxyCodeLine{11985         RedirectedStreams\& operator=(RedirectedStreams \textcolor{keyword}{const}\&) = \textcolor{keyword}{delete};}
\DoxyCodeLine{11986         RedirectedStreams(RedirectedStreams\&\&) = \textcolor{keyword}{delete};}
\DoxyCodeLine{11987         RedirectedStreams\& operator=(RedirectedStreams\&\&) = \textcolor{keyword}{delete};}
\DoxyCodeLine{11988 }
\DoxyCodeLine{11989         RedirectedStreams(std::string\& redirectedCout, std::string\& redirectedCerr);}
\DoxyCodeLine{11990         \string~RedirectedStreams();}
\DoxyCodeLine{11991     \textcolor{keyword}{private}:}
\DoxyCodeLine{11992         std::string\& m\_redirectedCout;}
\DoxyCodeLine{11993         std::string\& m\_redirectedCerr;}
\DoxyCodeLine{11994         RedirectedStdOut m\_redirectedStdOut;}
\DoxyCodeLine{11995         RedirectedStdErr m\_redirectedStdErr;}
\DoxyCodeLine{11996     \};}
\DoxyCodeLine{11997 }
\DoxyCodeLine{11998 \textcolor{preprocessor}{\#if defined(CATCH\_CONFIG\_NEW\_CAPTURE)}}
\DoxyCodeLine{11999 }
\DoxyCodeLine{12000     \textcolor{comment}{// Windows's implementation of std::tmpfile is terrible (it tries}}
\DoxyCodeLine{12001     \textcolor{comment}{// to create a file inside system folder, thus requiring elevated}}
\DoxyCodeLine{12002     \textcolor{comment}{// privileges for the binary), so we have to use tmpnam(\_s) and}}
\DoxyCodeLine{12003     \textcolor{comment}{// create the file ourselves there.}}
\DoxyCodeLine{12004     \textcolor{keyword}{class }TempFile \{}
\DoxyCodeLine{12005     \textcolor{keyword}{public}:}
\DoxyCodeLine{12006         TempFile(TempFile \textcolor{keyword}{const}\&) = \textcolor{keyword}{delete};}
\DoxyCodeLine{12007         TempFile\& operator=(TempFile \textcolor{keyword}{const}\&) = \textcolor{keyword}{delete};}
\DoxyCodeLine{12008         TempFile(TempFile\&\&) = \textcolor{keyword}{delete};}
\DoxyCodeLine{12009         TempFile\& operator=(TempFile\&\&) = \textcolor{keyword}{delete};}
\DoxyCodeLine{12010 }
\DoxyCodeLine{12011         TempFile();}
\DoxyCodeLine{12012         \string~TempFile();}
\DoxyCodeLine{12013 }
\DoxyCodeLine{12014         std::FILE* getFile();}
\DoxyCodeLine{12015         std::string getContents();}
\DoxyCodeLine{12016 }
\DoxyCodeLine{12017     \textcolor{keyword}{private}:}
\DoxyCodeLine{12018         std::FILE* m\_file = \textcolor{keyword}{nullptr};}
\DoxyCodeLine{12019 \textcolor{preprocessor}{    \#if defined(\_MSC\_VER)}}
\DoxyCodeLine{12020         \textcolor{keywordtype}{char} m\_buffer[L\_tmpnam] = \{ 0 \};}
\DoxyCodeLine{12021 \textcolor{preprocessor}{    \#endif}}
\DoxyCodeLine{12022     \};}
\DoxyCodeLine{12023 }
\DoxyCodeLine{12024     \textcolor{keyword}{class }OutputRedirect \{}
\DoxyCodeLine{12025     \textcolor{keyword}{public}:}
\DoxyCodeLine{12026         OutputRedirect(OutputRedirect \textcolor{keyword}{const}\&) = \textcolor{keyword}{delete};}
\DoxyCodeLine{12027         OutputRedirect\& operator=(OutputRedirect \textcolor{keyword}{const}\&) = \textcolor{keyword}{delete};}
\DoxyCodeLine{12028         OutputRedirect(OutputRedirect\&\&) = \textcolor{keyword}{delete};}
\DoxyCodeLine{12029         OutputRedirect\& operator=(OutputRedirect\&\&) = \textcolor{keyword}{delete};}
\DoxyCodeLine{12030 }
\DoxyCodeLine{12031         OutputRedirect(std::string\& stdout\_dest, std::string\& stderr\_dest);}
\DoxyCodeLine{12032         \string~OutputRedirect();}
\DoxyCodeLine{12033 }
\DoxyCodeLine{12034     \textcolor{keyword}{private}:}
\DoxyCodeLine{12035         \textcolor{keywordtype}{int} m\_originalStdout = -\/1;}
\DoxyCodeLine{12036         \textcolor{keywordtype}{int} m\_originalStderr = -\/1;}
\DoxyCodeLine{12037         TempFile m\_stdoutFile;}
\DoxyCodeLine{12038         TempFile m\_stderrFile;}
\DoxyCodeLine{12039         std::string\& m\_stdoutDest;}
\DoxyCodeLine{12040         std::string\& m\_stderrDest;}
\DoxyCodeLine{12041     \};}
\DoxyCodeLine{12042 }
\DoxyCodeLine{12043 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{12044 }
\DoxyCodeLine{12045 \} \textcolor{comment}{// end namespace Catch}}
\DoxyCodeLine{12046 }
\DoxyCodeLine{12047 \textcolor{preprocessor}{\#endif }\textcolor{comment}{// TWOBLUECUBES\_CATCH\_OUTPUT\_REDIRECT\_H}}
\DoxyCodeLine{12048 \textcolor{comment}{// end catch\_output\_redirect.h}}
\DoxyCodeLine{12049 \textcolor{preprocessor}{\#include <cstdio>}}
\DoxyCodeLine{12050 \textcolor{preprocessor}{\#include <cstring>}}
\DoxyCodeLine{12051 \textcolor{preprocessor}{\#include <fstream>}}
\DoxyCodeLine{12052 \textcolor{preprocessor}{\#include <sstream>}}
\DoxyCodeLine{12053 \textcolor{preprocessor}{\#include <stdexcept>}}
\DoxyCodeLine{12054 }
\DoxyCodeLine{12055 \textcolor{preprocessor}{\#if defined(CATCH\_CONFIG\_NEW\_CAPTURE)}}
\DoxyCodeLine{12056 \textcolor{preprocessor}{    \#if defined(\_MSC\_VER)}}
\DoxyCodeLine{12057 \textcolor{preprocessor}{    \#include <io.h>}      \textcolor{comment}{//\_dup and \_dup2}}
\DoxyCodeLine{12058 \textcolor{preprocessor}{    \#define dup \_dup}}
\DoxyCodeLine{12059 \textcolor{preprocessor}{    \#define dup2 \_dup2}}
\DoxyCodeLine{12060 \textcolor{preprocessor}{    \#define fileno \_fileno}}
\DoxyCodeLine{12061 \textcolor{preprocessor}{    \#else}}
\DoxyCodeLine{12062 \textcolor{preprocessor}{    \#include <unistd.h>}  \textcolor{comment}{// dup and dup2}}
\DoxyCodeLine{12063 \textcolor{preprocessor}{    \#endif}}
\DoxyCodeLine{12064 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{12065 }
\DoxyCodeLine{12066 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{12067 }
\DoxyCodeLine{12068     RedirectedStream::RedirectedStream( std::ostream\& originalStream, std::ostream\& redirectionStream )}
\DoxyCodeLine{12069     :   m\_originalStream( originalStream ),}
\DoxyCodeLine{12070         m\_redirectionStream( redirectionStream ),}
\DoxyCodeLine{12071         m\_prevBuf( m\_originalStream.rdbuf() )}
\DoxyCodeLine{12072     \{}
\DoxyCodeLine{12073         m\_originalStream.rdbuf( m\_redirectionStream.rdbuf() );}
\DoxyCodeLine{12074     \}}
\DoxyCodeLine{12075 }
\DoxyCodeLine{12076     RedirectedStream::\string~RedirectedStream() \{}
\DoxyCodeLine{12077         m\_originalStream.rdbuf( m\_prevBuf );}
\DoxyCodeLine{12078     \}}
\DoxyCodeLine{12079 }
\DoxyCodeLine{12080     RedirectedStdOut::RedirectedStdOut() : m\_cout( Catch::cout(), m\_rss.get() ) \{\}}
\DoxyCodeLine{12081     \textcolor{keyword}{auto} RedirectedStdOut::str() const -\/> std::\textcolor{keywordtype}{string} \{ \textcolor{keywordflow}{return} m\_rss.str(); \}}
\DoxyCodeLine{12082 }
\DoxyCodeLine{12083     RedirectedStdErr::RedirectedStdErr()}
\DoxyCodeLine{12084     :   m\_cerr( Catch::cerr(), m\_rss.get() ),}
\DoxyCodeLine{12085         m\_clog( Catch::clog(), m\_rss.get() )}
\DoxyCodeLine{12086     \{\}}
\DoxyCodeLine{12087     \textcolor{keyword}{auto} RedirectedStdErr::str() const -\/> std::\textcolor{keywordtype}{string} \{ \textcolor{keywordflow}{return} m\_rss.str(); \}}
\DoxyCodeLine{12088 }
\DoxyCodeLine{12089     RedirectedStreams::RedirectedStreams(std::string\& redirectedCout, std::string\& redirectedCerr)}
\DoxyCodeLine{12090     :   m\_redirectedCout(redirectedCout),}
\DoxyCodeLine{12091         m\_redirectedCerr(redirectedCerr)}
\DoxyCodeLine{12092     \{\}}
\DoxyCodeLine{12093 }
\DoxyCodeLine{12094     RedirectedStreams::\string~RedirectedStreams() \{}
\DoxyCodeLine{12095         m\_redirectedCout += m\_redirectedStdOut.str();}
\DoxyCodeLine{12096         m\_redirectedCerr += m\_redirectedStdErr.str();}
\DoxyCodeLine{12097     \}}
\DoxyCodeLine{12098 }
\DoxyCodeLine{12099 \textcolor{preprocessor}{\#if defined(CATCH\_CONFIG\_NEW\_CAPTURE)}}
\DoxyCodeLine{12100 }
\DoxyCodeLine{12101 \textcolor{preprocessor}{\#if defined(\_MSC\_VER)}}
\DoxyCodeLine{12102     TempFile::TempFile() \{}
\DoxyCodeLine{12103         \textcolor{keywordflow}{if} (tmpnam\_s(m\_buffer)) \{}
\DoxyCodeLine{12104             CATCH\_RUNTIME\_ERROR(\textcolor{stringliteral}{"{}Could not get a temp filename"{}});}
\DoxyCodeLine{12105         \}}
\DoxyCodeLine{12106         \textcolor{keywordflow}{if} (fopen\_s(\&m\_file, m\_buffer, \textcolor{stringliteral}{"{}w+"{}})) \{}
\DoxyCodeLine{12107             \textcolor{keywordtype}{char} buffer[100];}
\DoxyCodeLine{12108             \textcolor{keywordflow}{if} (strerror\_s(buffer, errno)) \{}
\DoxyCodeLine{12109                 CATCH\_RUNTIME\_ERROR(\textcolor{stringliteral}{"{}Could not translate errno to a string"{}});}
\DoxyCodeLine{12110             \}}
\DoxyCodeLine{12111             CATCH\_RUNTIME\_ERROR(\textcolor{stringliteral}{"{}Could not open the temp file: '"{}} << m\_buffer << \textcolor{stringliteral}{"{}' because: "{}} << buffer);}
\DoxyCodeLine{12112         \}}
\DoxyCodeLine{12113     \}}
\DoxyCodeLine{12114 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{12115     TempFile::TempFile() \{}
\DoxyCodeLine{12116         m\_file = std::tmpfile();}
\DoxyCodeLine{12117         \textcolor{keywordflow}{if} (!m\_file) \{}
\DoxyCodeLine{12118             CATCH\_RUNTIME\_ERROR(\textcolor{stringliteral}{"{}Could not create a temp file."{}});}
\DoxyCodeLine{12119         \}}
\DoxyCodeLine{12120     \}}
\DoxyCodeLine{12121 }
\DoxyCodeLine{12122 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{12123 }
\DoxyCodeLine{12124     TempFile::\string~TempFile() \{}
\DoxyCodeLine{12125          \textcolor{comment}{// TBD: What to do about errors here?}}
\DoxyCodeLine{12126          std::fclose(m\_file);}
\DoxyCodeLine{12127          \textcolor{comment}{// We manually create the file on Windows only, on Linux}}
\DoxyCodeLine{12128          \textcolor{comment}{// it will be autodeleted}}
\DoxyCodeLine{12129 \textcolor{preprocessor}{\#if defined(\_MSC\_VER)}}
\DoxyCodeLine{12130          std::remove(m\_buffer);}
\DoxyCodeLine{12131 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{12132     \}}
\DoxyCodeLine{12133 }
\DoxyCodeLine{12134     FILE* TempFile::getFile() \{}
\DoxyCodeLine{12135         \textcolor{keywordflow}{return} m\_file;}
\DoxyCodeLine{12136     \}}
\DoxyCodeLine{12137 }
\DoxyCodeLine{12138     std::string TempFile::getContents() \{}
\DoxyCodeLine{12139         std::stringstream sstr;}
\DoxyCodeLine{12140         \textcolor{keywordtype}{char} buffer[100] = \{\};}
\DoxyCodeLine{12141         std::rewind(m\_file);}
\DoxyCodeLine{12142         \textcolor{keywordflow}{while} (std::fgets(buffer, \textcolor{keyword}{sizeof}(buffer), m\_file)) \{}
\DoxyCodeLine{12143             sstr << buffer;}
\DoxyCodeLine{12144         \}}
\DoxyCodeLine{12145         \textcolor{keywordflow}{return} sstr.str();}
\DoxyCodeLine{12146     \}}
\DoxyCodeLine{12147 }
\DoxyCodeLine{12148     OutputRedirect::OutputRedirect(std::string\& stdout\_dest, std::string\& stderr\_dest) :}
\DoxyCodeLine{12149         m\_originalStdout(dup(1)),}
\DoxyCodeLine{12150         m\_originalStderr(dup(2)),}
\DoxyCodeLine{12151         m\_stdoutDest(stdout\_dest),}
\DoxyCodeLine{12152         m\_stderrDest(stderr\_dest) \{}
\DoxyCodeLine{12153         dup2(fileno(m\_stdoutFile.getFile()), 1);}
\DoxyCodeLine{12154         dup2(fileno(m\_stderrFile.getFile()), 2);}
\DoxyCodeLine{12155     \}}
\DoxyCodeLine{12156 }
\DoxyCodeLine{12157     OutputRedirect::\string~OutputRedirect() \{}
\DoxyCodeLine{12158         Catch::cout() << std::flush;}
\DoxyCodeLine{12159         fflush(stdout);}
\DoxyCodeLine{12160         \textcolor{comment}{// Since we support overriding these streams, we flush cerr}}
\DoxyCodeLine{12161         \textcolor{comment}{// even though std::cerr is unbuffered}}
\DoxyCodeLine{12162         Catch::cerr() << std::flush;}
\DoxyCodeLine{12163         Catch::clog() << std::flush;}
\DoxyCodeLine{12164         fflush(stderr);}
\DoxyCodeLine{12165 }
\DoxyCodeLine{12166         dup2(m\_originalStdout, 1);}
\DoxyCodeLine{12167         dup2(m\_originalStderr, 2);}
\DoxyCodeLine{12168 }
\DoxyCodeLine{12169         m\_stdoutDest += m\_stdoutFile.getContents();}
\DoxyCodeLine{12170         m\_stderrDest += m\_stderrFile.getContents();}
\DoxyCodeLine{12171     \}}
\DoxyCodeLine{12172 }
\DoxyCodeLine{12173 \textcolor{preprocessor}{\#endif }\textcolor{comment}{// CATCH\_CONFIG\_NEW\_CAPTURE}}
\DoxyCodeLine{12174 }
\DoxyCodeLine{12175 \} \textcolor{comment}{// namespace Catch}}
\DoxyCodeLine{12176 }
\DoxyCodeLine{12177 \textcolor{preprocessor}{\#if defined(CATCH\_CONFIG\_NEW\_CAPTURE)}}
\DoxyCodeLine{12178 \textcolor{preprocessor}{    \#if defined(\_MSC\_VER)}}
\DoxyCodeLine{12179 \textcolor{preprocessor}{    \#undef dup}}
\DoxyCodeLine{12180 \textcolor{preprocessor}{    \#undef dup2}}
\DoxyCodeLine{12181 \textcolor{preprocessor}{    \#undef fileno}}
\DoxyCodeLine{12182 \textcolor{preprocessor}{    \#endif}}
\DoxyCodeLine{12183 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{12184 \textcolor{comment}{// end catch\_output\_redirect.cpp}}
\DoxyCodeLine{12185 \textcolor{comment}{// start catch\_polyfills.cpp}}
\DoxyCodeLine{12186 }
\DoxyCodeLine{12187 \textcolor{preprocessor}{\#include <cmath>}}
\DoxyCodeLine{12188 }
\DoxyCodeLine{12189 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{12190 }
\DoxyCodeLine{12191 \textcolor{preprocessor}{\#if !defined(CATCH\_CONFIG\_POLYFILL\_ISNAN)}}
\DoxyCodeLine{12192     \textcolor{keywordtype}{bool} isnan(\textcolor{keywordtype}{float} f) \{}
\DoxyCodeLine{12193         \textcolor{keywordflow}{return} std::isnan(f);}
\DoxyCodeLine{12194     \}}
\DoxyCodeLine{12195     \textcolor{keywordtype}{bool} isnan(\textcolor{keywordtype}{double} d) \{}
\DoxyCodeLine{12196         \textcolor{keywordflow}{return} std::isnan(d);}
\DoxyCodeLine{12197     \}}
\DoxyCodeLine{12198 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{12199     \textcolor{comment}{// For now we only use this for embarcadero}}
\DoxyCodeLine{12200     \textcolor{keywordtype}{bool} isnan(\textcolor{keywordtype}{float} f) \{}
\DoxyCodeLine{12201         \textcolor{keywordflow}{return} std::\_isnan(f);}
\DoxyCodeLine{12202     \}}
\DoxyCodeLine{12203     \textcolor{keywordtype}{bool} isnan(\textcolor{keywordtype}{double} d) \{}
\DoxyCodeLine{12204         \textcolor{keywordflow}{return} std::\_isnan(d);}
\DoxyCodeLine{12205     \}}
\DoxyCodeLine{12206 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{12207 }
\DoxyCodeLine{12208 \} \textcolor{comment}{// end namespace Catch}}
\DoxyCodeLine{12209 \textcolor{comment}{// end catch\_polyfills.cpp}}
\DoxyCodeLine{12210 \textcolor{comment}{// start catch\_random\_number\_generator.cpp}}
\DoxyCodeLine{12211 }
\DoxyCodeLine{12212 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{12213 }
\DoxyCodeLine{12214 \textcolor{keyword}{namespace }\{}
\DoxyCodeLine{12215 }
\DoxyCodeLine{12216 \textcolor{preprocessor}{\#if defined(\_MSC\_VER)}}
\DoxyCodeLine{12217 \textcolor{preprocessor}{\#pragma warning(push)}}
\DoxyCodeLine{12218 \textcolor{preprocessor}{\#pragma warning(disable:4146) }\textcolor{comment}{// we negate uint32 during the rotate}}
\DoxyCodeLine{12219 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{12220         \textcolor{comment}{// Safe rotr implementation thanks to John Regehr}}
\DoxyCodeLine{12221         uint32\_t rotate\_right(uint32\_t val, uint32\_t count) \{}
\DoxyCodeLine{12222             \textcolor{keyword}{const} uint32\_t mask = 31;}
\DoxyCodeLine{12223             count \&= mask;}
\DoxyCodeLine{12224             \textcolor{keywordflow}{return} (val >> count) | (val << (-\/count \& mask));}
\DoxyCodeLine{12225         \}}
\DoxyCodeLine{12226 }
\DoxyCodeLine{12227 \textcolor{preprocessor}{\#if defined(\_MSC\_VER)}}
\DoxyCodeLine{12228 \textcolor{preprocessor}{\#pragma warning(pop)}}
\DoxyCodeLine{12229 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{12230 }
\DoxyCodeLine{12231 \}}
\DoxyCodeLine{12232 }
\DoxyCodeLine{12233     SimplePcg32::SimplePcg32(result\_type seed\_) \{}
\DoxyCodeLine{12234         seed(seed\_);}
\DoxyCodeLine{12235     \}}
\DoxyCodeLine{12236 }
\DoxyCodeLine{12237     \textcolor{keywordtype}{void} SimplePcg32::seed(result\_type seed\_) \{}
\DoxyCodeLine{12238         m\_state = 0;}
\DoxyCodeLine{12239         (*this)();}
\DoxyCodeLine{12240         m\_state += seed\_;}
\DoxyCodeLine{12241         (*this)();}
\DoxyCodeLine{12242     \}}
\DoxyCodeLine{12243 }
\DoxyCodeLine{12244     \textcolor{keywordtype}{void} SimplePcg32::discard(uint64\_t skip) \{}
\DoxyCodeLine{12245         \textcolor{comment}{// We could implement this to run in O(log n) steps, but this}}
\DoxyCodeLine{12246         \textcolor{comment}{// should suffice for our use case.}}
\DoxyCodeLine{12247         \textcolor{keywordflow}{for} (uint64\_t s = 0; s < skip; ++s) \{}
\DoxyCodeLine{12248             \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{void}\textcolor{keyword}{>}((*this)());}
\DoxyCodeLine{12249         \}}
\DoxyCodeLine{12250     \}}
\DoxyCodeLine{12251 }
\DoxyCodeLine{12252     SimplePcg32::result\_type SimplePcg32::operator()() \{}
\DoxyCodeLine{12253         \textcolor{comment}{// prepare the output value}}
\DoxyCodeLine{12254         \textcolor{keyword}{const} uint32\_t xorshifted = \textcolor{keyword}{static\_cast<}uint32\_t\textcolor{keyword}{>}(((m\_state >> 18u) \string^ m\_state) >> 27u);}
\DoxyCodeLine{12255         \textcolor{keyword}{const} \textcolor{keyword}{auto} output = rotate\_right(xorshifted, m\_state >> 59u);}
\DoxyCodeLine{12256 }
\DoxyCodeLine{12257         \textcolor{comment}{// advance state}}
\DoxyCodeLine{12258         m\_state = m\_state * 6364136223846793005ULL + s\_inc;}
\DoxyCodeLine{12259 }
\DoxyCodeLine{12260         \textcolor{keywordflow}{return} output;}
\DoxyCodeLine{12261     \}}
\DoxyCodeLine{12262 }
\DoxyCodeLine{12263     \textcolor{keywordtype}{bool} operator==(SimplePcg32 \textcolor{keyword}{const}\& lhs, SimplePcg32 \textcolor{keyword}{const}\& rhs) \{}
\DoxyCodeLine{12264         \textcolor{keywordflow}{return} lhs.m\_state == rhs.m\_state;}
\DoxyCodeLine{12265     \}}
\DoxyCodeLine{12266 }
\DoxyCodeLine{12267     \textcolor{keywordtype}{bool} operator!=(SimplePcg32 \textcolor{keyword}{const}\& lhs, SimplePcg32 \textcolor{keyword}{const}\& rhs) \{}
\DoxyCodeLine{12268         \textcolor{keywordflow}{return} lhs.m\_state != rhs.m\_state;}
\DoxyCodeLine{12269     \}}
\DoxyCodeLine{12270 \}}
\DoxyCodeLine{12271 \textcolor{comment}{// end catch\_random\_number\_generator.cpp}}
\DoxyCodeLine{12272 \textcolor{comment}{// start catch\_registry\_hub.cpp}}
\DoxyCodeLine{12273 }
\DoxyCodeLine{12274 \textcolor{comment}{// start catch\_test\_case\_registry\_impl.h}}
\DoxyCodeLine{12275 }
\DoxyCodeLine{12276 \textcolor{preprocessor}{\#include <vector>}}
\DoxyCodeLine{12277 \textcolor{preprocessor}{\#include <set>}}
\DoxyCodeLine{12278 \textcolor{preprocessor}{\#include <algorithm>}}
\DoxyCodeLine{12279 \textcolor{preprocessor}{\#include <ios>}}
\DoxyCodeLine{12280 }
\DoxyCodeLine{12281 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{12282 }
\DoxyCodeLine{12283     \textcolor{keyword}{class }TestCase;}
\DoxyCodeLine{12284     \textcolor{keyword}{struct }IConfig;}
\DoxyCodeLine{12285 }
\DoxyCodeLine{12286     std::vector<TestCase> sortTests( IConfig \textcolor{keyword}{const}\& config, std::vector<TestCase> \textcolor{keyword}{const}\& unsortedTestCases );}
\DoxyCodeLine{12287 }
\DoxyCodeLine{12288     \textcolor{keywordtype}{bool} isThrowSafe( TestCase \textcolor{keyword}{const}\& testCase, IConfig \textcolor{keyword}{const}\& config );}
\DoxyCodeLine{12289     \textcolor{keywordtype}{bool} matchTest( TestCase \textcolor{keyword}{const}\& testCase, TestSpec \textcolor{keyword}{const}\& testSpec, IConfig \textcolor{keyword}{const}\& config );}
\DoxyCodeLine{12290 }
\DoxyCodeLine{12291     \textcolor{keywordtype}{void} enforceNoDuplicateTestCases( std::vector<TestCase> \textcolor{keyword}{const}\& functions );}
\DoxyCodeLine{12292 }
\DoxyCodeLine{12293     std::vector<TestCase> filterTests( std::vector<TestCase> \textcolor{keyword}{const}\& testCases, TestSpec \textcolor{keyword}{const}\& testSpec, IConfig \textcolor{keyword}{const}\& config );}
\DoxyCodeLine{12294     std::vector<TestCase> \textcolor{keyword}{const}\& getAllTestCasesSorted( IConfig \textcolor{keyword}{const}\& config );}
\DoxyCodeLine{12295 }
\DoxyCodeLine{12296     \textcolor{keyword}{class }TestRegistry : \textcolor{keyword}{public} ITestCaseRegistry \{}
\DoxyCodeLine{12297     \textcolor{keyword}{public}:}
\DoxyCodeLine{12298         \textcolor{keyword}{virtual} \string~TestRegistry() = \textcolor{keywordflow}{default};}
\DoxyCodeLine{12299 }
\DoxyCodeLine{12300         \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} registerTest( TestCase \textcolor{keyword}{const}\& testCase );}
\DoxyCodeLine{12301 }
\DoxyCodeLine{12302         std::vector<TestCase> \textcolor{keyword}{const}\& getAllTests() \textcolor{keyword}{const override};}
\DoxyCodeLine{12303         std::vector<TestCase> \textcolor{keyword}{const}\& getAllTestsSorted( IConfig \textcolor{keyword}{const}\& config ) \textcolor{keyword}{const override};}
\DoxyCodeLine{12304 }
\DoxyCodeLine{12305     \textcolor{keyword}{private}:}
\DoxyCodeLine{12306         std::vector<TestCase> m\_functions;}
\DoxyCodeLine{12307         \textcolor{keyword}{mutable} RunTests::InWhatOrder m\_currentSortOrder = RunTests::InDeclarationOrder;}
\DoxyCodeLine{12308         \textcolor{keyword}{mutable} std::vector<TestCase> m\_sortedFunctions;}
\DoxyCodeLine{12309         std::size\_t m\_unnamedCount = 0;}
\DoxyCodeLine{12310         std::ios\_base::Init m\_ostreamInit; \textcolor{comment}{// Forces cout/ cerr to be initialised}}
\DoxyCodeLine{12311     \};}
\DoxyCodeLine{12312 }
\DoxyCodeLine{12314 }
\DoxyCodeLine{12315     \textcolor{keyword}{class }TestInvokerAsFunction : \textcolor{keyword}{public} ITestInvoker \{}
\DoxyCodeLine{12316         void(*m\_testAsFunction)();}
\DoxyCodeLine{12317     \textcolor{keyword}{public}:}
\DoxyCodeLine{12318         TestInvokerAsFunction( \textcolor{keywordtype}{void}(*testAsFunction)() ) noexcept;}
\DoxyCodeLine{12319 }
\DoxyCodeLine{12320         \textcolor{keywordtype}{void} invoke() const override;}
\DoxyCodeLine{12321     \};}
\DoxyCodeLine{12322 }
\DoxyCodeLine{12323     std::\textcolor{keywordtype}{string} extractClassName( StringRef const\& classOrQualifiedMethodName );}
\DoxyCodeLine{12324 }
\DoxyCodeLine{12326 }
\DoxyCodeLine{12327 \} \textcolor{comment}{// end namespace Catch}}
\DoxyCodeLine{12328 }
\DoxyCodeLine{12329 \textcolor{comment}{// end catch\_test\_case\_registry\_impl.h}}
\DoxyCodeLine{12330 \textcolor{comment}{// start catch\_reporter\_registry.h}}
\DoxyCodeLine{12331 }
\DoxyCodeLine{12332 \textcolor{preprocessor}{\#include <map>}}
\DoxyCodeLine{12333 }
\DoxyCodeLine{12334 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{12335 }
\DoxyCodeLine{12336     \textcolor{keyword}{class }ReporterRegistry : \textcolor{keyword}{public} IReporterRegistry \{}
\DoxyCodeLine{12337 }
\DoxyCodeLine{12338     \textcolor{keyword}{public}:}
\DoxyCodeLine{12339 }
\DoxyCodeLine{12340         \string~ReporterRegistry() \textcolor{keyword}{override};}
\DoxyCodeLine{12341 }
\DoxyCodeLine{12342         IStreamingReporterPtr create( std::string \textcolor{keyword}{const}\& name, IConfigPtr \textcolor{keyword}{const}\& config ) \textcolor{keyword}{const override};}
\DoxyCodeLine{12343 }
\DoxyCodeLine{12344         \textcolor{keywordtype}{void} registerReporter( std::string \textcolor{keyword}{const}\& name, IReporterFactoryPtr \textcolor{keyword}{const}\& factory );}
\DoxyCodeLine{12345         \textcolor{keywordtype}{void} registerListener( IReporterFactoryPtr \textcolor{keyword}{const}\& factory );}
\DoxyCodeLine{12346 }
\DoxyCodeLine{12347         FactoryMap \textcolor{keyword}{const}\& getFactories() \textcolor{keyword}{const override};}
\DoxyCodeLine{12348         Listeners \textcolor{keyword}{const}\& getListeners() \textcolor{keyword}{const override};}
\DoxyCodeLine{12349 }
\DoxyCodeLine{12350     \textcolor{keyword}{private}:}
\DoxyCodeLine{12351         FactoryMap m\_factories;}
\DoxyCodeLine{12352         Listeners m\_listeners;}
\DoxyCodeLine{12353     \};}
\DoxyCodeLine{12354 \}}
\DoxyCodeLine{12355 }
\DoxyCodeLine{12356 \textcolor{comment}{// end catch\_reporter\_registry.h}}
\DoxyCodeLine{12357 \textcolor{comment}{// start catch\_tag\_alias\_registry.h}}
\DoxyCodeLine{12358 }
\DoxyCodeLine{12359 \textcolor{comment}{// start catch\_tag\_alias.h}}
\DoxyCodeLine{12360 }
\DoxyCodeLine{12361 \textcolor{preprocessor}{\#include <string>}}
\DoxyCodeLine{12362 }
\DoxyCodeLine{12363 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{12364 }
\DoxyCodeLine{12365     \textcolor{keyword}{struct }TagAlias \{}
\DoxyCodeLine{12366         TagAlias(std::string \textcolor{keyword}{const}\& \_tag, SourceLineInfo \_lineInfo);}
\DoxyCodeLine{12367 }
\DoxyCodeLine{12368         std::string tag;}
\DoxyCodeLine{12369         SourceLineInfo lineInfo;}
\DoxyCodeLine{12370     \};}
\DoxyCodeLine{12371 }
\DoxyCodeLine{12372 \} \textcolor{comment}{// end namespace Catch}}
\DoxyCodeLine{12373 }
\DoxyCodeLine{12374 \textcolor{comment}{// end catch\_tag\_alias.h}}
\DoxyCodeLine{12375 \textcolor{preprocessor}{\#include <map>}}
\DoxyCodeLine{12376 }
\DoxyCodeLine{12377 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{12378 }
\DoxyCodeLine{12379     \textcolor{keyword}{class }TagAliasRegistry : \textcolor{keyword}{public} ITagAliasRegistry \{}
\DoxyCodeLine{12380     \textcolor{keyword}{public}:}
\DoxyCodeLine{12381         \string~TagAliasRegistry() \textcolor{keyword}{override};}
\DoxyCodeLine{12382         TagAlias \textcolor{keyword}{const}* find( std::string \textcolor{keyword}{const}\& alias ) \textcolor{keyword}{const override};}
\DoxyCodeLine{12383         std::string expandAliases( std::string \textcolor{keyword}{const}\& unexpandedTestSpec ) \textcolor{keyword}{const override};}
\DoxyCodeLine{12384         \textcolor{keywordtype}{void} add( std::string \textcolor{keyword}{const}\& alias, std::string \textcolor{keyword}{const}\& tag, SourceLineInfo \textcolor{keyword}{const}\& lineInfo );}
\DoxyCodeLine{12385 }
\DoxyCodeLine{12386     \textcolor{keyword}{private}:}
\DoxyCodeLine{12387         std::map<std::string, TagAlias> m\_registry;}
\DoxyCodeLine{12388     \};}
\DoxyCodeLine{12389 }
\DoxyCodeLine{12390 \} \textcolor{comment}{// end namespace Catch}}
\DoxyCodeLine{12391 }
\DoxyCodeLine{12392 \textcolor{comment}{// end catch\_tag\_alias\_registry.h}}
\DoxyCodeLine{12393 \textcolor{comment}{// start catch\_startup\_exception\_registry.h}}
\DoxyCodeLine{12394 }
\DoxyCodeLine{12395 \textcolor{preprocessor}{\#include <vector>}}
\DoxyCodeLine{12396 \textcolor{preprocessor}{\#include <exception>}}
\DoxyCodeLine{12397 }
\DoxyCodeLine{12398 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{12399 }
\DoxyCodeLine{12400     \textcolor{keyword}{class }StartupExceptionRegistry \{}
\DoxyCodeLine{12401 \textcolor{preprocessor}{\#if !defined(CATCH\_CONFIG\_DISABLE\_EXCEPTIONS)}}
\DoxyCodeLine{12402     \textcolor{keyword}{public}:}
\DoxyCodeLine{12403         \textcolor{keywordtype}{void} add(std::exception\_ptr \textcolor{keyword}{const}\& exception) \textcolor{keyword}{noexcept};}
\DoxyCodeLine{12404         std::vector<std::exception\_ptr> \textcolor{keyword}{const}\& getExceptions() const noexcept;}
\DoxyCodeLine{12405     private:}
\DoxyCodeLine{12406         std::vector<std::exception\_ptr> m\_exceptions;}
\DoxyCodeLine{12407 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{12408     \};}
\DoxyCodeLine{12409 }
\DoxyCodeLine{12410 \} \textcolor{comment}{// end namespace Catch}}
\DoxyCodeLine{12411 }
\DoxyCodeLine{12412 \textcolor{comment}{// end catch\_startup\_exception\_registry.h}}
\DoxyCodeLine{12413 \textcolor{comment}{// start catch\_singletons.hpp}}
\DoxyCodeLine{12414 }
\DoxyCodeLine{12415 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{12416 }
\DoxyCodeLine{12417     \textcolor{keyword}{struct }ISingleton \{}
\DoxyCodeLine{12418         \textcolor{keyword}{virtual} \string~ISingleton();}
\DoxyCodeLine{12419     \};}
\DoxyCodeLine{12420 }
\DoxyCodeLine{12421     \textcolor{keywordtype}{void} addSingleton( ISingleton* singleton );}
\DoxyCodeLine{12422     \textcolor{keywordtype}{void} cleanupSingletons();}
\DoxyCodeLine{12423 }
\DoxyCodeLine{12424     \textcolor{keyword}{template}<\textcolor{keyword}{typename} SingletonImplT, \textcolor{keyword}{typename} InterfaceT = SingletonImplT, \textcolor{keyword}{typename} MutableInterfaceT = InterfaceT>}
\DoxyCodeLine{12425     \textcolor{keyword}{class }Singleton : SingletonImplT, \textcolor{keyword}{public} ISingleton \{}
\DoxyCodeLine{12426 }
\DoxyCodeLine{12427         \textcolor{keyword}{static} \textcolor{keyword}{auto} getInternal() -\/> Singleton* \{}
\DoxyCodeLine{12428             \textcolor{keyword}{static} Singleton* s\_instance = \textcolor{keyword}{nullptr};}
\DoxyCodeLine{12429             \textcolor{keywordflow}{if}( !s\_instance ) \{}
\DoxyCodeLine{12430                 s\_instance = \textcolor{keyword}{new} Singleton;}
\DoxyCodeLine{12431                 addSingleton( s\_instance );}
\DoxyCodeLine{12432             \}}
\DoxyCodeLine{12433             \textcolor{keywordflow}{return} s\_instance;}
\DoxyCodeLine{12434         \}}
\DoxyCodeLine{12435 }
\DoxyCodeLine{12436     \textcolor{keyword}{public}:}
\DoxyCodeLine{12437         \textcolor{keyword}{static} \textcolor{keyword}{auto} get() -\/> InterfaceT \textcolor{keyword}{const}\& \{}
\DoxyCodeLine{12438             \textcolor{keywordflow}{return} *getInternal();}
\DoxyCodeLine{12439         \}}
\DoxyCodeLine{12440         \textcolor{keyword}{static} \textcolor{keyword}{auto} getMutable() -\/> MutableInterfaceT\& \{}
\DoxyCodeLine{12441             \textcolor{keywordflow}{return} *getInternal();}
\DoxyCodeLine{12442         \}}
\DoxyCodeLine{12443     \};}
\DoxyCodeLine{12444 }
\DoxyCodeLine{12445 \} \textcolor{comment}{// namespace Catch}}
\DoxyCodeLine{12446 }
\DoxyCodeLine{12447 \textcolor{comment}{// end catch\_singletons.hpp}}
\DoxyCodeLine{12448 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{12449 }
\DoxyCodeLine{12450     \textcolor{keyword}{namespace }\{}
\DoxyCodeLine{12451 }
\DoxyCodeLine{12452         \textcolor{keyword}{class }RegistryHub : \textcolor{keyword}{public} IRegistryHub, \textcolor{keyword}{public} IMutableRegistryHub,}
\DoxyCodeLine{12453                             \textcolor{keyword}{private} NonCopyable \{}
\DoxyCodeLine{12454 }
\DoxyCodeLine{12455         \textcolor{keyword}{public}: \textcolor{comment}{// IRegistryHub}}
\DoxyCodeLine{12456             RegistryHub() = \textcolor{keywordflow}{default};}
\DoxyCodeLine{12457             IReporterRegistry \textcolor{keyword}{const}\& getReporterRegistry()\textcolor{keyword}{ const override }\{}
\DoxyCodeLine{12458                 \textcolor{keywordflow}{return} m\_reporterRegistry;}
\DoxyCodeLine{12459             \}}
\DoxyCodeLine{12460             ITestCaseRegistry \textcolor{keyword}{const}\& getTestCaseRegistry()\textcolor{keyword}{ const override }\{}
\DoxyCodeLine{12461                 \textcolor{keywordflow}{return} m\_testCaseRegistry;}
\DoxyCodeLine{12462             \}}
\DoxyCodeLine{12463             IExceptionTranslatorRegistry \textcolor{keyword}{const}\& getExceptionTranslatorRegistry()\textcolor{keyword}{ const override }\{}
\DoxyCodeLine{12464                 \textcolor{keywordflow}{return} m\_exceptionTranslatorRegistry;}
\DoxyCodeLine{12465             \}}
\DoxyCodeLine{12466             ITagAliasRegistry \textcolor{keyword}{const}\& getTagAliasRegistry()\textcolor{keyword}{ const override }\{}
\DoxyCodeLine{12467                 \textcolor{keywordflow}{return} m\_tagAliasRegistry;}
\DoxyCodeLine{12468             \}}
\DoxyCodeLine{12469             StartupExceptionRegistry \textcolor{keyword}{const}\& getStartupExceptionRegistry()\textcolor{keyword}{ const override }\{}
\DoxyCodeLine{12470                 \textcolor{keywordflow}{return} m\_exceptionRegistry;}
\DoxyCodeLine{12471             \}}
\DoxyCodeLine{12472 }
\DoxyCodeLine{12473         \textcolor{keyword}{public}: \textcolor{comment}{// IMutableRegistryHub}}
\DoxyCodeLine{12474             \textcolor{keywordtype}{void} registerReporter( std::string \textcolor{keyword}{const}\& name, IReporterFactoryPtr \textcolor{keyword}{const}\& factory )\textcolor{keyword}{ override }\{}
\DoxyCodeLine{12475                 m\_reporterRegistry.registerReporter( name, factory );}
\DoxyCodeLine{12476             \}}
\DoxyCodeLine{12477             \textcolor{keywordtype}{void} registerListener( IReporterFactoryPtr \textcolor{keyword}{const}\& factory )\textcolor{keyword}{ override }\{}
\DoxyCodeLine{12478                 m\_reporterRegistry.registerListener( factory );}
\DoxyCodeLine{12479             \}}
\DoxyCodeLine{12480             \textcolor{keywordtype}{void} registerTest( TestCase \textcolor{keyword}{const}\& testInfo )\textcolor{keyword}{ override }\{}
\DoxyCodeLine{12481                 m\_testCaseRegistry.registerTest( testInfo );}
\DoxyCodeLine{12482             \}}
\DoxyCodeLine{12483             \textcolor{keywordtype}{void} registerTranslator( \textcolor{keyword}{const} IExceptionTranslator* translator )\textcolor{keyword}{ override }\{}
\DoxyCodeLine{12484                 m\_exceptionTranslatorRegistry.registerTranslator( translator );}
\DoxyCodeLine{12485             \}}
\DoxyCodeLine{12486             \textcolor{keywordtype}{void} registerTagAlias( std::string \textcolor{keyword}{const}\& alias, std::string \textcolor{keyword}{const}\& tag, SourceLineInfo \textcolor{keyword}{const}\& lineInfo )\textcolor{keyword}{ override }\{}
\DoxyCodeLine{12487                 m\_tagAliasRegistry.add( alias, tag, lineInfo );}
\DoxyCodeLine{12488             \}}
\DoxyCodeLine{12489             \textcolor{keywordtype}{void} registerStartupException() noexcept\textcolor{keyword}{ override }\{}
\DoxyCodeLine{12490 \textcolor{preprocessor}{\#if !defined(CATCH\_CONFIG\_DISABLE\_EXCEPTIONS)}}
\DoxyCodeLine{12491                 m\_exceptionRegistry.add(std::current\_exception());}
\DoxyCodeLine{12492 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{12493                 CATCH\_INTERNAL\_ERROR(\textcolor{stringliteral}{"{}Attempted to register active exception under CATCH\_CONFIG\_DISABLE\_EXCEPTIONS!"{}});}
\DoxyCodeLine{12494 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{12495             \}}
\DoxyCodeLine{12496             IMutableEnumValuesRegistry\& getMutableEnumValuesRegistry()\textcolor{keyword}{ override }\{}
\DoxyCodeLine{12497                 \textcolor{keywordflow}{return} m\_enumValuesRegistry;}
\DoxyCodeLine{12498             \}}
\DoxyCodeLine{12499 }
\DoxyCodeLine{12500         \textcolor{keyword}{private}:}
\DoxyCodeLine{12501             TestRegistry m\_testCaseRegistry;}
\DoxyCodeLine{12502             ReporterRegistry m\_reporterRegistry;}
\DoxyCodeLine{12503             ExceptionTranslatorRegistry m\_exceptionTranslatorRegistry;}
\DoxyCodeLine{12504             TagAliasRegistry m\_tagAliasRegistry;}
\DoxyCodeLine{12505             StartupExceptionRegistry m\_exceptionRegistry;}
\DoxyCodeLine{12506             Detail::EnumValuesRegistry m\_enumValuesRegistry;}
\DoxyCodeLine{12507         \};}
\DoxyCodeLine{12508     \}}
\DoxyCodeLine{12509 }
\DoxyCodeLine{12510     \textcolor{keyword}{using }RegistryHubSingleton = Singleton<RegistryHub, IRegistryHub, IMutableRegistryHub>;}
\DoxyCodeLine{12511 }
\DoxyCodeLine{12512     IRegistryHub \textcolor{keyword}{const}\& getRegistryHub() \{}
\DoxyCodeLine{12513         \textcolor{keywordflow}{return} RegistryHubSingleton::get();}
\DoxyCodeLine{12514     \}}
\DoxyCodeLine{12515     IMutableRegistryHub\& getMutableRegistryHub() \{}
\DoxyCodeLine{12516         \textcolor{keywordflow}{return} RegistryHubSingleton::getMutable();}
\DoxyCodeLine{12517     \}}
\DoxyCodeLine{12518     \textcolor{keywordtype}{void} cleanUp() \{}
\DoxyCodeLine{12519         cleanupSingletons();}
\DoxyCodeLine{12520         cleanUpContext();}
\DoxyCodeLine{12521     \}}
\DoxyCodeLine{12522     std::string translateActiveException() \{}
\DoxyCodeLine{12523         \textcolor{keywordflow}{return} getRegistryHub().getExceptionTranslatorRegistry().translateActiveException();}
\DoxyCodeLine{12524     \}}
\DoxyCodeLine{12525 }
\DoxyCodeLine{12526 \} \textcolor{comment}{// end namespace Catch}}
\DoxyCodeLine{12527 \textcolor{comment}{// end catch\_registry\_hub.cpp}}
\DoxyCodeLine{12528 \textcolor{comment}{// start catch\_reporter\_registry.cpp}}
\DoxyCodeLine{12529 }
\DoxyCodeLine{12530 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{12531 }
\DoxyCodeLine{12532     ReporterRegistry::\string~ReporterRegistry() = \textcolor{keywordflow}{default};}
\DoxyCodeLine{12533 }
\DoxyCodeLine{12534     IStreamingReporterPtr ReporterRegistry::create( std::string \textcolor{keyword}{const}\& name, IConfigPtr \textcolor{keyword}{const}\& config )\textcolor{keyword}{ const }\{}
\DoxyCodeLine{12535         \textcolor{keyword}{auto} it =  m\_factories.find( name );}
\DoxyCodeLine{12536         \textcolor{keywordflow}{if}( it == m\_factories.end() )}
\DoxyCodeLine{12537             \textcolor{keywordflow}{return} \textcolor{keyword}{nullptr};}
\DoxyCodeLine{12538         \textcolor{keywordflow}{return} it-\/>second-\/>create( ReporterConfig( config ) );}
\DoxyCodeLine{12539     \}}
\DoxyCodeLine{12540 }
\DoxyCodeLine{12541     \textcolor{keywordtype}{void} ReporterRegistry::registerReporter( std::string \textcolor{keyword}{const}\& name, IReporterFactoryPtr \textcolor{keyword}{const}\& factory ) \{}
\DoxyCodeLine{12542         m\_factories.emplace(name, factory);}
\DoxyCodeLine{12543     \}}
\DoxyCodeLine{12544     \textcolor{keywordtype}{void} ReporterRegistry::registerListener( IReporterFactoryPtr \textcolor{keyword}{const}\& factory ) \{}
\DoxyCodeLine{12545         m\_listeners.push\_back( factory );}
\DoxyCodeLine{12546     \}}
\DoxyCodeLine{12547 }
\DoxyCodeLine{12548     IReporterRegistry::FactoryMap \textcolor{keyword}{const}\& ReporterRegistry::getFactories()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{12549         \textcolor{keywordflow}{return} m\_factories;}
\DoxyCodeLine{12550     \}}
\DoxyCodeLine{12551     IReporterRegistry::Listeners \textcolor{keyword}{const}\& ReporterRegistry::getListeners()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{12552         \textcolor{keywordflow}{return} m\_listeners;}
\DoxyCodeLine{12553     \}}
\DoxyCodeLine{12554 }
\DoxyCodeLine{12555 \}}
\DoxyCodeLine{12556 \textcolor{comment}{// end catch\_reporter\_registry.cpp}}
\DoxyCodeLine{12557 \textcolor{comment}{// start catch\_result\_type.cpp}}
\DoxyCodeLine{12558 }
\DoxyCodeLine{12559 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{12560 }
\DoxyCodeLine{12561     \textcolor{keywordtype}{bool} isOk( ResultWas::OfType resultType ) \{}
\DoxyCodeLine{12562         \textcolor{keywordflow}{return} ( resultType \& ResultWas::FailureBit ) == 0;}
\DoxyCodeLine{12563     \}}
\DoxyCodeLine{12564     \textcolor{keywordtype}{bool} isJustInfo( \textcolor{keywordtype}{int} flags ) \{}
\DoxyCodeLine{12565         \textcolor{keywordflow}{return} flags == ResultWas::Info;}
\DoxyCodeLine{12566     \}}
\DoxyCodeLine{12567 }
\DoxyCodeLine{12568     ResultDisposition::Flags operator | ( ResultDisposition::Flags lhs, ResultDisposition::Flags rhs ) \{}
\DoxyCodeLine{12569         \textcolor{keywordflow}{return} \textcolor{keyword}{static\_cast<}ResultDisposition::Flags\textcolor{keyword}{>}( \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{int}\textcolor{keyword}{>}( lhs ) | \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{int}\textcolor{keyword}{>}( rhs ) );}
\DoxyCodeLine{12570     \}}
\DoxyCodeLine{12571 }
\DoxyCodeLine{12572     \textcolor{keywordtype}{bool} shouldContinueOnFailure( \textcolor{keywordtype}{int} flags )    \{ \textcolor{keywordflow}{return} ( flags \& ResultDisposition::ContinueOnFailure ) != 0; \}}
\DoxyCodeLine{12573     \textcolor{keywordtype}{bool} shouldSuppressFailure( \textcolor{keywordtype}{int} flags )      \{ \textcolor{keywordflow}{return} ( flags \& ResultDisposition::SuppressFail ) != 0; \}}
\DoxyCodeLine{12574 }
\DoxyCodeLine{12575 \} \textcolor{comment}{// end namespace Catch}}
\DoxyCodeLine{12576 \textcolor{comment}{// end catch\_result\_type.cpp}}
\DoxyCodeLine{12577 \textcolor{comment}{// start catch\_run\_context.cpp}}
\DoxyCodeLine{12578 }
\DoxyCodeLine{12579 \textcolor{preprocessor}{\#include <cassert>}}
\DoxyCodeLine{12580 \textcolor{preprocessor}{\#include <algorithm>}}
\DoxyCodeLine{12581 \textcolor{preprocessor}{\#include <sstream>}}
\DoxyCodeLine{12582 }
\DoxyCodeLine{12583 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{12584 }
\DoxyCodeLine{12585     \textcolor{keyword}{namespace }Generators \{}
\DoxyCodeLine{12586         \textcolor{keyword}{struct }GeneratorTracker : TestCaseTracking::TrackerBase, IGeneratorTracker \{}
\DoxyCodeLine{12587             GeneratorBasePtr m\_generator;}
\DoxyCodeLine{12588 }
\DoxyCodeLine{12589             GeneratorTracker( TestCaseTracking::NameAndLocation \textcolor{keyword}{const}\& nameAndLocation, TrackerContext\& ctx, ITracker* parent )}
\DoxyCodeLine{12590             :   TrackerBase( nameAndLocation, ctx, parent )}
\DoxyCodeLine{12591             \{\}}
\DoxyCodeLine{12592             \string~GeneratorTracker();}
\DoxyCodeLine{12593 }
\DoxyCodeLine{12594             \textcolor{keyword}{static} GeneratorTracker\& acquire( TrackerContext\& ctx, TestCaseTracking::NameAndLocation \textcolor{keyword}{const}\& nameAndLocation ) \{}
\DoxyCodeLine{12595                 std::shared\_ptr<GeneratorTracker> tracker;}
\DoxyCodeLine{12596 }
\DoxyCodeLine{12597                 ITracker\& currentTracker = ctx.currentTracker();}
\DoxyCodeLine{12598                 \textcolor{comment}{// Under specific circumstances, the generator we want}}
\DoxyCodeLine{12599                 \textcolor{comment}{// to acquire is also the current tracker. If this is}}
\DoxyCodeLine{12600                 \textcolor{comment}{// the case, we have to avoid looking through current}}
\DoxyCodeLine{12601                 \textcolor{comment}{// tracker's children, and instead return the current}}
\DoxyCodeLine{12602                 \textcolor{comment}{// tracker.}}
\DoxyCodeLine{12603                 \textcolor{comment}{// A case where this check is important is e.g.}}
\DoxyCodeLine{12604                 \textcolor{comment}{//     for (int i = 0; i < 5; ++i) \{}}
\DoxyCodeLine{12605                 \textcolor{comment}{//         int n = GENERATE(1, 2);}}
\DoxyCodeLine{12606                 \textcolor{comment}{//     \}}}
\DoxyCodeLine{12607                 \textcolor{comment}{//}}
\DoxyCodeLine{12608                 \textcolor{comment}{// without it, the code above creates 5 nested generators.}}
\DoxyCodeLine{12609                 \textcolor{keywordflow}{if} (currentTracker.nameAndLocation() == nameAndLocation) \{}
\DoxyCodeLine{12610                     \textcolor{keyword}{auto} thisTracker = currentTracker.parent().findChild(nameAndLocation);}
\DoxyCodeLine{12611                     assert(thisTracker);}
\DoxyCodeLine{12612                     assert(thisTracker-\/>isGeneratorTracker());}
\DoxyCodeLine{12613                     tracker = std::static\_pointer\_cast<GeneratorTracker>(thisTracker);}
\DoxyCodeLine{12614                 \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} ( TestCaseTracking::ITrackerPtr childTracker = currentTracker.findChild( nameAndLocation ) ) \{}
\DoxyCodeLine{12615                     assert( childTracker );}
\DoxyCodeLine{12616                     assert( childTracker-\/>isGeneratorTracker() );}
\DoxyCodeLine{12617                     tracker = std::static\_pointer\_cast<GeneratorTracker>( childTracker );}
\DoxyCodeLine{12618                 \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{12619                     tracker = std::make\_shared<GeneratorTracker>( nameAndLocation, ctx, \&currentTracker );}
\DoxyCodeLine{12620                     currentTracker.addChild( tracker );}
\DoxyCodeLine{12621                 \}}
\DoxyCodeLine{12622 }
\DoxyCodeLine{12623                 \textcolor{keywordflow}{if}( !tracker-\/>isComplete() ) \{}
\DoxyCodeLine{12624                     tracker-\/>open();}
\DoxyCodeLine{12625                 \}}
\DoxyCodeLine{12626 }
\DoxyCodeLine{12627                 \textcolor{keywordflow}{return} *tracker;}
\DoxyCodeLine{12628             \}}
\DoxyCodeLine{12629 }
\DoxyCodeLine{12630             \textcolor{comment}{// TrackerBase interface}}
\DoxyCodeLine{12631             \textcolor{keywordtype}{bool} isGeneratorTracker()\textcolor{keyword}{ const override }\{ \textcolor{keywordflow}{return} \textcolor{keyword}{true}; \}}
\DoxyCodeLine{12632             \textcolor{keyword}{auto} hasGenerator() const -\/> \textcolor{keywordtype}{bool}\textcolor{keyword}{ override }\{}
\DoxyCodeLine{12633                 \textcolor{keywordflow}{return} !!m\_generator;}
\DoxyCodeLine{12634             \}}
\DoxyCodeLine{12635             \textcolor{keywordtype}{void} close()\textcolor{keyword}{ override }\{}
\DoxyCodeLine{12636                 TrackerBase::close();}
\DoxyCodeLine{12637                 \textcolor{comment}{// If a generator has a child (it is followed by a section)}}
\DoxyCodeLine{12638                 \textcolor{comment}{// and none of its children have started, then we must wait}}
\DoxyCodeLine{12639                 \textcolor{comment}{// until later to start consuming its values.}}
\DoxyCodeLine{12640                 \textcolor{comment}{// This catches cases where `GENERATE` is placed between two}}
\DoxyCodeLine{12641                 \textcolor{comment}{// `SECTION`s.}}
\DoxyCodeLine{12642                 \textcolor{comment}{// **The check for m\_children.empty cannot be removed**.}}
\DoxyCodeLine{12643                 \textcolor{comment}{// doing so would break `GENERATE` \_not\_ followed by `SECTION`s.}}
\DoxyCodeLine{12644                 \textcolor{keyword}{const} \textcolor{keywordtype}{bool} should\_wait\_for\_child = [\&]() \{}
\DoxyCodeLine{12645                     \textcolor{comment}{// No children -\/> nobody to wait for}}
\DoxyCodeLine{12646                     \textcolor{keywordflow}{if} ( m\_children.empty() ) \{}
\DoxyCodeLine{12647                         \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{12648                     \}}
\DoxyCodeLine{12649                     \textcolor{comment}{// If at least one child started executing, don't wait}}
\DoxyCodeLine{12650                     \textcolor{keywordflow}{if} ( std::find\_if(}
\DoxyCodeLine{12651                              m\_children.begin(),}
\DoxyCodeLine{12652                              m\_children.end(),}
\DoxyCodeLine{12653                              []( TestCaseTracking::ITrackerPtr tracker ) \{}
\DoxyCodeLine{12654                                  return tracker-\/>hasStarted();}
\DoxyCodeLine{12655                              \} ) != m\_children.end() ) \{}
\DoxyCodeLine{12656                         \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{12657                     \}}
\DoxyCodeLine{12658 }
\DoxyCodeLine{12659                     \textcolor{comment}{// No children have started. We need to check if they \_can\_}}
\DoxyCodeLine{12660                     \textcolor{comment}{// start, and thus we should wait for them, or they cannot}}
\DoxyCodeLine{12661                     \textcolor{comment}{// start (due to filters), and we shouldn't wait for them}}
\DoxyCodeLine{12662                     \textcolor{keyword}{auto}* parent = m\_parent;}
\DoxyCodeLine{12663                     \textcolor{comment}{// This is safe: there is always at least one section}}
\DoxyCodeLine{12664                     \textcolor{comment}{// tracker in a test case tracking tree}}
\DoxyCodeLine{12665                     \textcolor{keywordflow}{while} ( !parent-\/>isSectionTracker() ) \{}
\DoxyCodeLine{12666                         parent = \&( parent-\/>parent() );}
\DoxyCodeLine{12667                     \}}
\DoxyCodeLine{12668                     assert( parent \&\&}
\DoxyCodeLine{12669                             \textcolor{stringliteral}{"{}Missing root (test case) level section"{}} );}
\DoxyCodeLine{12670 }
\DoxyCodeLine{12671                     \textcolor{keyword}{auto} \textcolor{keyword}{const}\& parentSection =}
\DoxyCodeLine{12672                         \textcolor{keyword}{static\_cast<}SectionTracker\&\textcolor{keyword}{>}( *parent );}
\DoxyCodeLine{12673                     \textcolor{keyword}{auto} \textcolor{keyword}{const}\& filters = parentSection.getFilters();}
\DoxyCodeLine{12674                     \textcolor{comment}{// No filters -\/> no restrictions on running sections}}
\DoxyCodeLine{12675                     \textcolor{keywordflow}{if} ( filters.empty() ) \{}
\DoxyCodeLine{12676                         \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{12677                     \}}
\DoxyCodeLine{12678 }
\DoxyCodeLine{12679                     \textcolor{keywordflow}{for} ( \textcolor{keyword}{auto} \textcolor{keyword}{const}\& child : m\_children ) \{}
\DoxyCodeLine{12680                         \textcolor{keywordflow}{if} ( child-\/>isSectionTracker() \&\&}
\DoxyCodeLine{12681                              std::find( filters.begin(),}
\DoxyCodeLine{12682                                         filters.end(),}
\DoxyCodeLine{12683                                         \textcolor{keyword}{static\_cast<}SectionTracker\&\textcolor{keyword}{>}( *child )}
\DoxyCodeLine{12684                                             .trimmedName() ) !=}
\DoxyCodeLine{12685                                  filters.end() ) \{}
\DoxyCodeLine{12686                             \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{12687                         \}}
\DoxyCodeLine{12688                     \}}
\DoxyCodeLine{12689                     \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{12690                 \}();}
\DoxyCodeLine{12691 }
\DoxyCodeLine{12692                 \textcolor{comment}{// This check is a bit tricky, because m\_generator-\/>next()}}
\DoxyCodeLine{12693                 \textcolor{comment}{// has a side-\/effect, where it consumes generator's current}}
\DoxyCodeLine{12694                 \textcolor{comment}{// value, but we do not want to invoke the side-\/effect if}}
\DoxyCodeLine{12695                 \textcolor{comment}{// this generator is still waiting for any child to start.}}
\DoxyCodeLine{12696                 \textcolor{keywordflow}{if} ( should\_wait\_for\_child ||}
\DoxyCodeLine{12697                      ( m\_runState == CompletedSuccessfully \&\&}
\DoxyCodeLine{12698                        m\_generator-\/>next() ) ) \{}
\DoxyCodeLine{12699                     m\_children.clear();}
\DoxyCodeLine{12700                     m\_runState = Executing;}
\DoxyCodeLine{12701                 \}}
\DoxyCodeLine{12702             \}}
\DoxyCodeLine{12703 }
\DoxyCodeLine{12704             \textcolor{comment}{// IGeneratorTracker interface}}
\DoxyCodeLine{12705             \textcolor{keyword}{auto} getGenerator() const -\/> GeneratorBasePtr const\&\textcolor{keyword}{ override }\{}
\DoxyCodeLine{12706                 \textcolor{keywordflow}{return} m\_generator;}
\DoxyCodeLine{12707             \}}
\DoxyCodeLine{12708             \textcolor{keywordtype}{void} setGenerator( GeneratorBasePtr\&\& generator )\textcolor{keyword}{ override }\{}
\DoxyCodeLine{12709                 m\_generator = std::move( generator );}
\DoxyCodeLine{12710             \}}
\DoxyCodeLine{12711         \};}
\DoxyCodeLine{12712         GeneratorTracker::\string~GeneratorTracker() \{\}}
\DoxyCodeLine{12713     \}}
\DoxyCodeLine{12714 }
\DoxyCodeLine{12715     RunContext::RunContext(IConfigPtr \textcolor{keyword}{const}\& \_config, IStreamingReporterPtr\&\& reporter)}
\DoxyCodeLine{12716     :   m\_runInfo(\_config-\/>name()),}
\DoxyCodeLine{12717         m\_context(getCurrentMutableContext()),}
\DoxyCodeLine{12718         m\_config(\_config),}
\DoxyCodeLine{12719         m\_reporter(std::move(reporter)),}
\DoxyCodeLine{12720         m\_lastAssertionInfo\{ StringRef(), SourceLineInfo(\textcolor{stringliteral}{"{}"{}},0), StringRef(), ResultDisposition::Normal \},}
\DoxyCodeLine{12721         m\_includeSuccessfulResults( m\_config-\/>includeSuccessfulResults() || m\_reporter-\/>getPreferences().shouldReportAllAssertions )}
\DoxyCodeLine{12722     \{}
\DoxyCodeLine{12723         m\_context.setRunner(\textcolor{keyword}{this});}
\DoxyCodeLine{12724         m\_context.setConfig(m\_config);}
\DoxyCodeLine{12725         m\_context.setResultCapture(\textcolor{keyword}{this});}
\DoxyCodeLine{12726         m\_reporter-\/>testRunStarting(m\_runInfo);}
\DoxyCodeLine{12727     \}}
\DoxyCodeLine{12728 }
\DoxyCodeLine{12729     RunContext::\string~RunContext() \{}
\DoxyCodeLine{12730         m\_reporter-\/>testRunEnded(TestRunStats(m\_runInfo, m\_totals, aborting()));}
\DoxyCodeLine{12731     \}}
\DoxyCodeLine{12732 }
\DoxyCodeLine{12733     \textcolor{keywordtype}{void} RunContext::testGroupStarting(std::string \textcolor{keyword}{const}\& testSpec, std::size\_t groupIndex, std::size\_t groupsCount) \{}
\DoxyCodeLine{12734         m\_reporter-\/>testGroupStarting(GroupInfo(testSpec, groupIndex, groupsCount));}
\DoxyCodeLine{12735     \}}
\DoxyCodeLine{12736 }
\DoxyCodeLine{12737     \textcolor{keywordtype}{void} RunContext::testGroupEnded(std::string \textcolor{keyword}{const}\& testSpec, Totals \textcolor{keyword}{const}\& totals, std::size\_t groupIndex, std::size\_t groupsCount) \{}
\DoxyCodeLine{12738         m\_reporter-\/>testGroupEnded(TestGroupStats(GroupInfo(testSpec, groupIndex, groupsCount), totals, aborting()));}
\DoxyCodeLine{12739     \}}
\DoxyCodeLine{12740 }
\DoxyCodeLine{12741     Totals RunContext::runTest(TestCase \textcolor{keyword}{const}\& testCase) \{}
\DoxyCodeLine{12742         Totals prevTotals = m\_totals;}
\DoxyCodeLine{12743 }
\DoxyCodeLine{12744         std::string redirectedCout;}
\DoxyCodeLine{12745         std::string redirectedCerr;}
\DoxyCodeLine{12746 }
\DoxyCodeLine{12747         \textcolor{keyword}{auto} \textcolor{keyword}{const}\& testInfo = testCase.getTestCaseInfo();}
\DoxyCodeLine{12748 }
\DoxyCodeLine{12749         m\_reporter-\/>testCaseStarting(testInfo);}
\DoxyCodeLine{12750 }
\DoxyCodeLine{12751         m\_activeTestCase = \&testCase;}
\DoxyCodeLine{12752 }
\DoxyCodeLine{12753         ITracker\& rootTracker = m\_trackerContext.startRun();}
\DoxyCodeLine{12754         assert(rootTracker.isSectionTracker());}
\DoxyCodeLine{12755         \textcolor{keyword}{static\_cast<}SectionTracker\&\textcolor{keyword}{>}(rootTracker).addInitialFilters(m\_config-\/>getSectionsToRun());}
\DoxyCodeLine{12756         \textcolor{keywordflow}{do} \{}
\DoxyCodeLine{12757             m\_trackerContext.startCycle();}
\DoxyCodeLine{12758             m\_testCaseTracker = \&SectionTracker::acquire(m\_trackerContext, TestCaseTracking::NameAndLocation(testInfo.name, testInfo.lineInfo));}
\DoxyCodeLine{12759             runCurrentTest(redirectedCout, redirectedCerr);}
\DoxyCodeLine{12760         \} \textcolor{keywordflow}{while} (!m\_testCaseTracker-\/>isSuccessfullyCompleted() \&\& !aborting());}
\DoxyCodeLine{12761 }
\DoxyCodeLine{12762         Totals deltaTotals = m\_totals.delta(prevTotals);}
\DoxyCodeLine{12763         \textcolor{keywordflow}{if} (testInfo.expectedToFail() \&\& deltaTotals.testCases.passed > 0) \{}
\DoxyCodeLine{12764             deltaTotals.assertions.failed++;}
\DoxyCodeLine{12765             deltaTotals.testCases.passed-\/-\/;}
\DoxyCodeLine{12766             deltaTotals.testCases.failed++;}
\DoxyCodeLine{12767         \}}
\DoxyCodeLine{12768         m\_totals.testCases += deltaTotals.testCases;}
\DoxyCodeLine{12769         m\_reporter-\/>testCaseEnded(TestCaseStats(testInfo,}
\DoxyCodeLine{12770                                   deltaTotals,}
\DoxyCodeLine{12771                                   redirectedCout,}
\DoxyCodeLine{12772                                   redirectedCerr,}
\DoxyCodeLine{12773                                   aborting()));}
\DoxyCodeLine{12774 }
\DoxyCodeLine{12775         m\_activeTestCase = \textcolor{keyword}{nullptr};}
\DoxyCodeLine{12776         m\_testCaseTracker = \textcolor{keyword}{nullptr};}
\DoxyCodeLine{12777 }
\DoxyCodeLine{12778         \textcolor{keywordflow}{return} deltaTotals;}
\DoxyCodeLine{12779     \}}
\DoxyCodeLine{12780 }
\DoxyCodeLine{12781     IConfigPtr RunContext::config()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{12782         \textcolor{keywordflow}{return} m\_config;}
\DoxyCodeLine{12783     \}}
\DoxyCodeLine{12784 }
\DoxyCodeLine{12785     IStreamingReporter\& RunContext::reporter()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{12786         \textcolor{keywordflow}{return} *m\_reporter;}
\DoxyCodeLine{12787     \}}
\DoxyCodeLine{12788 }
\DoxyCodeLine{12789     \textcolor{keywordtype}{void} RunContext::assertionEnded(AssertionResult \textcolor{keyword}{const} \& result) \{}
\DoxyCodeLine{12790         \textcolor{keywordflow}{if} (result.getResultType() == ResultWas::Ok) \{}
\DoxyCodeLine{12791             m\_totals.assertions.passed++;}
\DoxyCodeLine{12792             m\_lastAssertionPassed = \textcolor{keyword}{true};}
\DoxyCodeLine{12793         \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (!result.isOk()) \{}
\DoxyCodeLine{12794             m\_lastAssertionPassed = \textcolor{keyword}{false};}
\DoxyCodeLine{12795             \textcolor{keywordflow}{if}( m\_activeTestCase-\/>getTestCaseInfo().okToFail() )}
\DoxyCodeLine{12796                 m\_totals.assertions.failedButOk++;}
\DoxyCodeLine{12797             \textcolor{keywordflow}{else}}
\DoxyCodeLine{12798                 m\_totals.assertions.failed++;}
\DoxyCodeLine{12799         \}}
\DoxyCodeLine{12800         \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{12801             m\_lastAssertionPassed = \textcolor{keyword}{true};}
\DoxyCodeLine{12802         \}}
\DoxyCodeLine{12803 }
\DoxyCodeLine{12804         \textcolor{comment}{// We have no use for the return value (whether messages should be cleared), because messages were made scoped}}
\DoxyCodeLine{12805         \textcolor{comment}{// and should be let to clear themselves out.}}
\DoxyCodeLine{12806         \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{void}\textcolor{keyword}{>}(m\_reporter-\/>assertionEnded(AssertionStats(result, m\_messages, m\_totals)));}
\DoxyCodeLine{12807 }
\DoxyCodeLine{12808         \textcolor{keywordflow}{if} (result.getResultType() != ResultWas::Warning)}
\DoxyCodeLine{12809             m\_messageScopes.clear();}
\DoxyCodeLine{12810 }
\DoxyCodeLine{12811         \textcolor{comment}{// Reset working state}}
\DoxyCodeLine{12812         resetAssertionInfo();}
\DoxyCodeLine{12813         m\_lastResult = result;}
\DoxyCodeLine{12814     \}}
\DoxyCodeLine{12815     \textcolor{keywordtype}{void} RunContext::resetAssertionInfo() \{}
\DoxyCodeLine{12816         m\_lastAssertionInfo.macroName = StringRef();}
\DoxyCodeLine{12817         m\_lastAssertionInfo.capturedExpression = \textcolor{stringliteral}{"{}\{Unknown expression after the reported line\}"{}}\_sr;}
\DoxyCodeLine{12818     \}}
\DoxyCodeLine{12819 }
\DoxyCodeLine{12820     \textcolor{keywordtype}{bool} RunContext::sectionStarted(SectionInfo \textcolor{keyword}{const} \& sectionInfo, Counts \& assertions) \{}
\DoxyCodeLine{12821         ITracker\& sectionTracker = SectionTracker::acquire(m\_trackerContext, TestCaseTracking::NameAndLocation(sectionInfo.name, sectionInfo.lineInfo));}
\DoxyCodeLine{12822         \textcolor{keywordflow}{if} (!sectionTracker.isOpen())}
\DoxyCodeLine{12823             \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{12824         m\_activeSections.push\_back(\&sectionTracker);}
\DoxyCodeLine{12825 }
\DoxyCodeLine{12826         m\_lastAssertionInfo.lineInfo = sectionInfo.lineInfo;}
\DoxyCodeLine{12827 }
\DoxyCodeLine{12828         m\_reporter-\/>sectionStarting(sectionInfo);}
\DoxyCodeLine{12829 }
\DoxyCodeLine{12830         assertions = m\_totals.assertions;}
\DoxyCodeLine{12831 }
\DoxyCodeLine{12832         \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{12833     \}}
\DoxyCodeLine{12834     \textcolor{keyword}{auto} RunContext::acquireGeneratorTracker( StringRef generatorName, SourceLineInfo \textcolor{keyword}{const}\& lineInfo ) -\/> IGeneratorTracker\& \{}
\DoxyCodeLine{12835         \textcolor{keyword}{using namespace }Generators;}
\DoxyCodeLine{12836         GeneratorTracker\& tracker = GeneratorTracker::acquire(m\_trackerContext,}
\DoxyCodeLine{12837                                                               TestCaseTracking::NameAndLocation( \textcolor{keyword}{static\_cast<}std::string\textcolor{keyword}{>}(generatorName), lineInfo ) );}
\DoxyCodeLine{12838         m\_lastAssertionInfo.lineInfo = lineInfo;}
\DoxyCodeLine{12839         \textcolor{keywordflow}{return} tracker;}
\DoxyCodeLine{12840     \}}
\DoxyCodeLine{12841 }
\DoxyCodeLine{12842     \textcolor{keywordtype}{bool} RunContext::testForMissingAssertions(Counts\& assertions) \{}
\DoxyCodeLine{12843         \textcolor{keywordflow}{if} (assertions.total() != 0)}
\DoxyCodeLine{12844             \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{12845         \textcolor{keywordflow}{if} (!m\_config-\/>warnAboutMissingAssertions())}
\DoxyCodeLine{12846             \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{12847         \textcolor{keywordflow}{if} (m\_trackerContext.currentTracker().hasChildren())}
\DoxyCodeLine{12848             \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{12849         m\_totals.assertions.failed++;}
\DoxyCodeLine{12850         assertions.failed++;}
\DoxyCodeLine{12851         \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{12852     \}}
\DoxyCodeLine{12853 }
\DoxyCodeLine{12854     \textcolor{keywordtype}{void} RunContext::sectionEnded(SectionEndInfo \textcolor{keyword}{const} \& endInfo) \{}
\DoxyCodeLine{12855         Counts assertions = m\_totals.assertions -\/ endInfo.prevAssertions;}
\DoxyCodeLine{12856         \textcolor{keywordtype}{bool} missingAssertions = testForMissingAssertions(assertions);}
\DoxyCodeLine{12857 }
\DoxyCodeLine{12858         \textcolor{keywordflow}{if} (!m\_activeSections.empty()) \{}
\DoxyCodeLine{12859             m\_activeSections.back()-\/>close();}
\DoxyCodeLine{12860             m\_activeSections.pop\_back();}
\DoxyCodeLine{12861         \}}
\DoxyCodeLine{12862 }
\DoxyCodeLine{12863         m\_reporter-\/>sectionEnded(SectionStats(endInfo.sectionInfo, assertions, endInfo.durationInSeconds, missingAssertions));}
\DoxyCodeLine{12864         m\_messages.clear();}
\DoxyCodeLine{12865         m\_messageScopes.clear();}
\DoxyCodeLine{12866     \}}
\DoxyCodeLine{12867 }
\DoxyCodeLine{12868     \textcolor{keywordtype}{void} RunContext::sectionEndedEarly(SectionEndInfo \textcolor{keyword}{const} \& endInfo) \{}
\DoxyCodeLine{12869         \textcolor{keywordflow}{if} (m\_unfinishedSections.empty())}
\DoxyCodeLine{12870             m\_activeSections.back()-\/>fail();}
\DoxyCodeLine{12871         \textcolor{keywordflow}{else}}
\DoxyCodeLine{12872             m\_activeSections.back()-\/>close();}
\DoxyCodeLine{12873         m\_activeSections.pop\_back();}
\DoxyCodeLine{12874 }
\DoxyCodeLine{12875         m\_unfinishedSections.push\_back(endInfo);}
\DoxyCodeLine{12876     \}}
\DoxyCodeLine{12877 }
\DoxyCodeLine{12878 \textcolor{preprocessor}{\#if defined(CATCH\_CONFIG\_ENABLE\_BENCHMARKING)}}
\DoxyCodeLine{12879     \textcolor{keywordtype}{void} RunContext::benchmarkPreparing(std::string \textcolor{keyword}{const}\& name) \{}
\DoxyCodeLine{12880         m\_reporter-\/>benchmarkPreparing(name);}
\DoxyCodeLine{12881     \}}
\DoxyCodeLine{12882     \textcolor{keywordtype}{void} RunContext::benchmarkStarting( BenchmarkInfo \textcolor{keyword}{const}\& info ) \{}
\DoxyCodeLine{12883         m\_reporter-\/>benchmarkStarting( info );}
\DoxyCodeLine{12884     \}}
\DoxyCodeLine{12885     \textcolor{keywordtype}{void} RunContext::benchmarkEnded( BenchmarkStats<> \textcolor{keyword}{const}\& stats ) \{}
\DoxyCodeLine{12886         m\_reporter-\/>benchmarkEnded( stats );}
\DoxyCodeLine{12887     \}}
\DoxyCodeLine{12888     \textcolor{keywordtype}{void} RunContext::benchmarkFailed(std::string \textcolor{keyword}{const} \& error) \{}
\DoxyCodeLine{12889         m\_reporter-\/>benchmarkFailed(error);}
\DoxyCodeLine{12890     \}}
\DoxyCodeLine{12891 \textcolor{preprocessor}{\#endif }\textcolor{comment}{// CATCH\_CONFIG\_ENABLE\_BENCHMARKING}}
\DoxyCodeLine{12892 }
\DoxyCodeLine{12893     \textcolor{keywordtype}{void} RunContext::pushScopedMessage(MessageInfo \textcolor{keyword}{const} \& message) \{}
\DoxyCodeLine{12894         m\_messages.push\_back(message);}
\DoxyCodeLine{12895     \}}
\DoxyCodeLine{12896 }
\DoxyCodeLine{12897     \textcolor{keywordtype}{void} RunContext::popScopedMessage(MessageInfo \textcolor{keyword}{const} \& message) \{}
\DoxyCodeLine{12898         m\_messages.erase(std::remove(m\_messages.begin(), m\_messages.end(), message), m\_messages.end());}
\DoxyCodeLine{12899     \}}
\DoxyCodeLine{12900 }
\DoxyCodeLine{12901     \textcolor{keywordtype}{void} RunContext::emplaceUnscopedMessage( MessageBuilder \textcolor{keyword}{const}\& builder ) \{}
\DoxyCodeLine{12902         m\_messageScopes.emplace\_back( builder );}
\DoxyCodeLine{12903     \}}
\DoxyCodeLine{12904 }
\DoxyCodeLine{12905     std::string RunContext::getCurrentTestName()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{12906         \textcolor{keywordflow}{return} m\_activeTestCase}
\DoxyCodeLine{12907             ? m\_activeTestCase-\/>getTestCaseInfo().name}
\DoxyCodeLine{12908             : std::string();}
\DoxyCodeLine{12909     \}}
\DoxyCodeLine{12910 }
\DoxyCodeLine{12911     \textcolor{keyword}{const} AssertionResult * RunContext::getLastResult()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{12912         \textcolor{keywordflow}{return} \&(*m\_lastResult);}
\DoxyCodeLine{12913     \}}
\DoxyCodeLine{12914 }
\DoxyCodeLine{12915     \textcolor{keywordtype}{void} RunContext::exceptionEarlyReported() \{}
\DoxyCodeLine{12916         m\_shouldReportUnexpected = \textcolor{keyword}{false};}
\DoxyCodeLine{12917     \}}
\DoxyCodeLine{12918 }
\DoxyCodeLine{12919     \textcolor{keywordtype}{void} RunContext::handleFatalErrorCondition( StringRef message ) \{}
\DoxyCodeLine{12920         \textcolor{comment}{// First notify reporter that bad things happened}}
\DoxyCodeLine{12921         m\_reporter-\/>fatalErrorEncountered(message);}
\DoxyCodeLine{12922 }
\DoxyCodeLine{12923         \textcolor{comment}{// Don't rebuild the result -\/-\/ the stringification itself can cause more fatal errors}}
\DoxyCodeLine{12924         \textcolor{comment}{// Instead, fake a result data.}}
\DoxyCodeLine{12925         AssertionResultData tempResult( ResultWas::FatalErrorCondition, \{ \textcolor{keyword}{false} \} );}
\DoxyCodeLine{12926         tempResult.message = \textcolor{keyword}{static\_cast<}std::string\textcolor{keyword}{>}(message);}
\DoxyCodeLine{12927         AssertionResult result(m\_lastAssertionInfo, tempResult);}
\DoxyCodeLine{12928 }
\DoxyCodeLine{12929         assertionEnded(result);}
\DoxyCodeLine{12930 }
\DoxyCodeLine{12931         handleUnfinishedSections();}
\DoxyCodeLine{12932 }
\DoxyCodeLine{12933         \textcolor{comment}{// Recreate section for test case (as we will lose the one that was in scope)}}
\DoxyCodeLine{12934         \textcolor{keyword}{auto} \textcolor{keyword}{const}\& testCaseInfo = m\_activeTestCase-\/>getTestCaseInfo();}
\DoxyCodeLine{12935         SectionInfo testCaseSection(testCaseInfo.lineInfo, testCaseInfo.name);}
\DoxyCodeLine{12936 }
\DoxyCodeLine{12937         Counts assertions;}
\DoxyCodeLine{12938         assertions.failed = 1;}
\DoxyCodeLine{12939         SectionStats testCaseSectionStats(testCaseSection, assertions, 0, \textcolor{keyword}{false});}
\DoxyCodeLine{12940         m\_reporter-\/>sectionEnded(testCaseSectionStats);}
\DoxyCodeLine{12941 }
\DoxyCodeLine{12942         \textcolor{keyword}{auto} \textcolor{keyword}{const}\& testInfo = m\_activeTestCase-\/>getTestCaseInfo();}
\DoxyCodeLine{12943 }
\DoxyCodeLine{12944         Totals deltaTotals;}
\DoxyCodeLine{12945         deltaTotals.testCases.failed = 1;}
\DoxyCodeLine{12946         deltaTotals.assertions.failed = 1;}
\DoxyCodeLine{12947         m\_reporter-\/>testCaseEnded(TestCaseStats(testInfo,}
\DoxyCodeLine{12948                                   deltaTotals,}
\DoxyCodeLine{12949                                   std::string(),}
\DoxyCodeLine{12950                                   std::string(),}
\DoxyCodeLine{12951                                   \textcolor{keyword}{false}));}
\DoxyCodeLine{12952         m\_totals.testCases.failed++;}
\DoxyCodeLine{12953         testGroupEnded(std::string(), m\_totals, 1, 1);}
\DoxyCodeLine{12954         m\_reporter-\/>testRunEnded(TestRunStats(m\_runInfo, m\_totals, \textcolor{keyword}{false}));}
\DoxyCodeLine{12955     \}}
\DoxyCodeLine{12956 }
\DoxyCodeLine{12957     \textcolor{keywordtype}{bool} RunContext::lastAssertionPassed() \{}
\DoxyCodeLine{12958          \textcolor{keywordflow}{return} m\_lastAssertionPassed;}
\DoxyCodeLine{12959     \}}
\DoxyCodeLine{12960 }
\DoxyCodeLine{12961     \textcolor{keywordtype}{void} RunContext::assertionPassed() \{}
\DoxyCodeLine{12962         m\_lastAssertionPassed = \textcolor{keyword}{true};}
\DoxyCodeLine{12963         ++m\_totals.assertions.passed;}
\DoxyCodeLine{12964         resetAssertionInfo();}
\DoxyCodeLine{12965         m\_messageScopes.clear();}
\DoxyCodeLine{12966     \}}
\DoxyCodeLine{12967 }
\DoxyCodeLine{12968     \textcolor{keywordtype}{bool} RunContext::aborting()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{12969         \textcolor{keywordflow}{return} m\_totals.assertions.failed >= \textcolor{keyword}{static\_cast<}std::size\_t\textcolor{keyword}{>}(m\_config-\/>abortAfter());}
\DoxyCodeLine{12970     \}}
\DoxyCodeLine{12971 }
\DoxyCodeLine{12972     \textcolor{keywordtype}{void} RunContext::runCurrentTest(std::string \& redirectedCout, std::string \& redirectedCerr) \{}
\DoxyCodeLine{12973         \textcolor{keyword}{auto} \textcolor{keyword}{const}\& testCaseInfo = m\_activeTestCase-\/>getTestCaseInfo();}
\DoxyCodeLine{12974         SectionInfo testCaseSection(testCaseInfo.lineInfo, testCaseInfo.name);}
\DoxyCodeLine{12975         m\_reporter-\/>sectionStarting(testCaseSection);}
\DoxyCodeLine{12976         Counts prevAssertions = m\_totals.assertions;}
\DoxyCodeLine{12977         \textcolor{keywordtype}{double} duration = 0;}
\DoxyCodeLine{12978         m\_shouldReportUnexpected = \textcolor{keyword}{true};}
\DoxyCodeLine{12979         m\_lastAssertionInfo = \{ \textcolor{stringliteral}{"{}TEST\_CASE"{}}\_sr, testCaseInfo.lineInfo, StringRef(), ResultDisposition::Normal \};}
\DoxyCodeLine{12980 }
\DoxyCodeLine{12981         seedRng(*m\_config);}
\DoxyCodeLine{12982 }
\DoxyCodeLine{12983         Timer timer;}
\DoxyCodeLine{12984         CATCH\_TRY \{}
\DoxyCodeLine{12985             \textcolor{keywordflow}{if} (m\_reporter-\/>getPreferences().shouldRedirectStdOut) \{}
\DoxyCodeLine{12986 \textcolor{preprocessor}{\#if !defined(CATCH\_CONFIG\_EXPERIMENTAL\_REDIRECT)}}
\DoxyCodeLine{12987                 RedirectedStreams redirectedStreams(redirectedCout, redirectedCerr);}
\DoxyCodeLine{12988 }
\DoxyCodeLine{12989                 timer.start();}
\DoxyCodeLine{12990                 invokeActiveTestCase();}
\DoxyCodeLine{12991 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{12992                 OutputRedirect r(redirectedCout, redirectedCerr);}
\DoxyCodeLine{12993                 timer.start();}
\DoxyCodeLine{12994                 invokeActiveTestCase();}
\DoxyCodeLine{12995 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{12996             \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{12997                 timer.start();}
\DoxyCodeLine{12998                 invokeActiveTestCase();}
\DoxyCodeLine{12999             \}}
\DoxyCodeLine{13000             duration = timer.getElapsedSeconds();}
\DoxyCodeLine{13001         \} CATCH\_CATCH\_ANON (TestFailureException\&) \{}
\DoxyCodeLine{13002             \textcolor{comment}{// This just means the test was aborted due to failure}}
\DoxyCodeLine{13003         \} CATCH\_CATCH\_ALL \{}
\DoxyCodeLine{13004             \textcolor{comment}{// Under CATCH\_CONFIG\_FAST\_COMPILE, unexpected exceptions under REQUIRE assertions}}
\DoxyCodeLine{13005             \textcolor{comment}{// are reported without translation at the point of origin.}}
\DoxyCodeLine{13006             \textcolor{keywordflow}{if}( m\_shouldReportUnexpected ) \{}
\DoxyCodeLine{13007                 AssertionReaction dummyReaction;}
\DoxyCodeLine{13008                 handleUnexpectedInflightException( m\_lastAssertionInfo, translateActiveException(), dummyReaction );}
\DoxyCodeLine{13009             \}}
\DoxyCodeLine{13010         \}}
\DoxyCodeLine{13011         Counts assertions = m\_totals.assertions -\/ prevAssertions;}
\DoxyCodeLine{13012         \textcolor{keywordtype}{bool} missingAssertions = testForMissingAssertions(assertions);}
\DoxyCodeLine{13013 }
\DoxyCodeLine{13014         m\_testCaseTracker-\/>close();}
\DoxyCodeLine{13015         handleUnfinishedSections();}
\DoxyCodeLine{13016         m\_messages.clear();}
\DoxyCodeLine{13017         m\_messageScopes.clear();}
\DoxyCodeLine{13018 }
\DoxyCodeLine{13019         SectionStats testCaseSectionStats(testCaseSection, assertions, duration, missingAssertions);}
\DoxyCodeLine{13020         m\_reporter-\/>sectionEnded(testCaseSectionStats);}
\DoxyCodeLine{13021     \}}
\DoxyCodeLine{13022 }
\DoxyCodeLine{13023     \textcolor{keywordtype}{void} RunContext::invokeActiveTestCase() \{}
\DoxyCodeLine{13024         FatalConditionHandlerGuard \_(\&m\_fatalConditionhandler);}
\DoxyCodeLine{13025         m\_activeTestCase-\/>invoke();}
\DoxyCodeLine{13026     \}}
\DoxyCodeLine{13027 }
\DoxyCodeLine{13028     \textcolor{keywordtype}{void} RunContext::handleUnfinishedSections() \{}
\DoxyCodeLine{13029         \textcolor{comment}{// If sections ended prematurely due to an exception we stored their}}
\DoxyCodeLine{13030         \textcolor{comment}{// infos here so we can tear them down outside the unwind process.}}
\DoxyCodeLine{13031         \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} it = m\_unfinishedSections.rbegin(),}
\DoxyCodeLine{13032              itEnd = m\_unfinishedSections.rend();}
\DoxyCodeLine{13033              it != itEnd;}
\DoxyCodeLine{13034              ++it)}
\DoxyCodeLine{13035             sectionEnded(*it);}
\DoxyCodeLine{13036         m\_unfinishedSections.clear();}
\DoxyCodeLine{13037     \}}
\DoxyCodeLine{13038 }
\DoxyCodeLine{13039     \textcolor{keywordtype}{void} RunContext::handleExpr(}
\DoxyCodeLine{13040         AssertionInfo \textcolor{keyword}{const}\& info,}
\DoxyCodeLine{13041         ITransientExpression \textcolor{keyword}{const}\& expr,}
\DoxyCodeLine{13042         AssertionReaction\& reaction}
\DoxyCodeLine{13043     ) \{}
\DoxyCodeLine{13044         m\_reporter-\/>assertionStarting( info );}
\DoxyCodeLine{13045 }
\DoxyCodeLine{13046         \textcolor{keywordtype}{bool} negated = isFalseTest( info.resultDisposition );}
\DoxyCodeLine{13047         \textcolor{keywordtype}{bool} result = expr.getResult() != negated;}
\DoxyCodeLine{13048 }
\DoxyCodeLine{13049         \textcolor{keywordflow}{if}( result ) \{}
\DoxyCodeLine{13050             \textcolor{keywordflow}{if} (!m\_includeSuccessfulResults) \{}
\DoxyCodeLine{13051                 assertionPassed();}
\DoxyCodeLine{13052             \}}
\DoxyCodeLine{13053             \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{13054                 reportExpr(info, ResultWas::Ok, \&expr, negated);}
\DoxyCodeLine{13055             \}}
\DoxyCodeLine{13056         \}}
\DoxyCodeLine{13057         \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{13058             reportExpr(info, ResultWas::ExpressionFailed, \&expr, negated );}
\DoxyCodeLine{13059             populateReaction( reaction );}
\DoxyCodeLine{13060         \}}
\DoxyCodeLine{13061     \}}
\DoxyCodeLine{13062     \textcolor{keywordtype}{void} RunContext::reportExpr(}
\DoxyCodeLine{13063             AssertionInfo \textcolor{keyword}{const} \&info,}
\DoxyCodeLine{13064             ResultWas::OfType resultType,}
\DoxyCodeLine{13065             ITransientExpression \textcolor{keyword}{const} *expr,}
\DoxyCodeLine{13066             \textcolor{keywordtype}{bool} negated ) \{}
\DoxyCodeLine{13067 }
\DoxyCodeLine{13068         m\_lastAssertionInfo = info;}
\DoxyCodeLine{13069         AssertionResultData data( resultType, LazyExpression( negated ) );}
\DoxyCodeLine{13070 }
\DoxyCodeLine{13071         AssertionResult assertionResult\{ info, data \};}
\DoxyCodeLine{13072         assertionResult.m\_resultData.lazyExpression.m\_transientExpression = expr;}
\DoxyCodeLine{13073 }
\DoxyCodeLine{13074         assertionEnded( assertionResult );}
\DoxyCodeLine{13075     \}}
\DoxyCodeLine{13076 }
\DoxyCodeLine{13077     \textcolor{keywordtype}{void} RunContext::handleMessage(}
\DoxyCodeLine{13078             AssertionInfo \textcolor{keyword}{const}\& info,}
\DoxyCodeLine{13079             ResultWas::OfType resultType,}
\DoxyCodeLine{13080             StringRef \textcolor{keyword}{const}\& message,}
\DoxyCodeLine{13081             AssertionReaction\& reaction}
\DoxyCodeLine{13082     ) \{}
\DoxyCodeLine{13083         m\_reporter-\/>assertionStarting( info );}
\DoxyCodeLine{13084 }
\DoxyCodeLine{13085         m\_lastAssertionInfo = info;}
\DoxyCodeLine{13086 }
\DoxyCodeLine{13087         AssertionResultData data( resultType, LazyExpression( \textcolor{keyword}{false} ) );}
\DoxyCodeLine{13088         data.message = \textcolor{keyword}{static\_cast<}std::string\textcolor{keyword}{>}(message);}
\DoxyCodeLine{13089         AssertionResult assertionResult\{ m\_lastAssertionInfo, data \};}
\DoxyCodeLine{13090         assertionEnded( assertionResult );}
\DoxyCodeLine{13091         \textcolor{keywordflow}{if}( !assertionResult.isOk() )}
\DoxyCodeLine{13092             populateReaction( reaction );}
\DoxyCodeLine{13093     \}}
\DoxyCodeLine{13094     \textcolor{keywordtype}{void} RunContext::handleUnexpectedExceptionNotThrown(}
\DoxyCodeLine{13095             AssertionInfo \textcolor{keyword}{const}\& info,}
\DoxyCodeLine{13096             AssertionReaction\& reaction}
\DoxyCodeLine{13097     ) \{}
\DoxyCodeLine{13098         handleNonExpr(info, Catch::ResultWas::DidntThrowException, reaction);}
\DoxyCodeLine{13099     \}}
\DoxyCodeLine{13100 }
\DoxyCodeLine{13101     \textcolor{keywordtype}{void} RunContext::handleUnexpectedInflightException(}
\DoxyCodeLine{13102             AssertionInfo \textcolor{keyword}{const}\& info,}
\DoxyCodeLine{13103             std::string \textcolor{keyword}{const}\& message,}
\DoxyCodeLine{13104             AssertionReaction\& reaction}
\DoxyCodeLine{13105     ) \{}
\DoxyCodeLine{13106         m\_lastAssertionInfo = info;}
\DoxyCodeLine{13107 }
\DoxyCodeLine{13108         AssertionResultData data( ResultWas::ThrewException, LazyExpression( \textcolor{keyword}{false} ) );}
\DoxyCodeLine{13109         data.message = message;}
\DoxyCodeLine{13110         AssertionResult assertionResult\{ info, data \};}
\DoxyCodeLine{13111         assertionEnded( assertionResult );}
\DoxyCodeLine{13112         populateReaction( reaction );}
\DoxyCodeLine{13113     \}}
\DoxyCodeLine{13114 }
\DoxyCodeLine{13115     \textcolor{keywordtype}{void} RunContext::populateReaction( AssertionReaction\& reaction ) \{}
\DoxyCodeLine{13116         reaction.shouldDebugBreak = m\_config-\/>shouldDebugBreak();}
\DoxyCodeLine{13117         reaction.shouldThrow = aborting() || (m\_lastAssertionInfo.resultDisposition \& ResultDisposition::Normal);}
\DoxyCodeLine{13118     \}}
\DoxyCodeLine{13119 }
\DoxyCodeLine{13120     \textcolor{keywordtype}{void} RunContext::handleIncomplete(}
\DoxyCodeLine{13121             AssertionInfo \textcolor{keyword}{const}\& info}
\DoxyCodeLine{13122     ) \{}
\DoxyCodeLine{13123         m\_lastAssertionInfo = info;}
\DoxyCodeLine{13124 }
\DoxyCodeLine{13125         AssertionResultData data( ResultWas::ThrewException, LazyExpression( \textcolor{keyword}{false} ) );}
\DoxyCodeLine{13126         data.message = \textcolor{stringliteral}{"{}Exception translation was disabled by CATCH\_CONFIG\_FAST\_COMPILE"{}};}
\DoxyCodeLine{13127         AssertionResult assertionResult\{ info, data \};}
\DoxyCodeLine{13128         assertionEnded( assertionResult );}
\DoxyCodeLine{13129     \}}
\DoxyCodeLine{13130     \textcolor{keywordtype}{void} RunContext::handleNonExpr(}
\DoxyCodeLine{13131             AssertionInfo \textcolor{keyword}{const} \&info,}
\DoxyCodeLine{13132             ResultWas::OfType resultType,}
\DoxyCodeLine{13133             AssertionReaction \&reaction}
\DoxyCodeLine{13134     ) \{}
\DoxyCodeLine{13135         m\_lastAssertionInfo = info;}
\DoxyCodeLine{13136 }
\DoxyCodeLine{13137         AssertionResultData data( resultType, LazyExpression( \textcolor{keyword}{false} ) );}
\DoxyCodeLine{13138         AssertionResult assertionResult\{ info, data \};}
\DoxyCodeLine{13139         assertionEnded( assertionResult );}
\DoxyCodeLine{13140 }
\DoxyCodeLine{13141         \textcolor{keywordflow}{if}( !assertionResult.isOk() )}
\DoxyCodeLine{13142             populateReaction( reaction );}
\DoxyCodeLine{13143     \}}
\DoxyCodeLine{13144 }
\DoxyCodeLine{13145     IResultCapture\& getResultCapture() \{}
\DoxyCodeLine{13146         \textcolor{keywordflow}{if} (\textcolor{keyword}{auto}* capture = getCurrentContext().getResultCapture())}
\DoxyCodeLine{13147             \textcolor{keywordflow}{return} *capture;}
\DoxyCodeLine{13148         \textcolor{keywordflow}{else}}
\DoxyCodeLine{13149             CATCH\_INTERNAL\_ERROR(\textcolor{stringliteral}{"{}No result capture instance"{}});}
\DoxyCodeLine{13150     \}}
\DoxyCodeLine{13151 }
\DoxyCodeLine{13152     \textcolor{keywordtype}{void} seedRng(IConfig \textcolor{keyword}{const}\& config) \{}
\DoxyCodeLine{13153         \textcolor{keywordflow}{if} (config.rngSeed() != 0) \{}
\DoxyCodeLine{13154             std::srand(config.rngSeed());}
\DoxyCodeLine{13155             rng().seed(config.rngSeed());}
\DoxyCodeLine{13156         \}}
\DoxyCodeLine{13157     \}}
\DoxyCodeLine{13158 }
\DoxyCodeLine{13159     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} rngSeed() \{}
\DoxyCodeLine{13160         \textcolor{keywordflow}{return} getCurrentContext().getConfig()-\/>rngSeed();}
\DoxyCodeLine{13161     \}}
\DoxyCodeLine{13162 }
\DoxyCodeLine{13163 \}}
\DoxyCodeLine{13164 \textcolor{comment}{// end catch\_run\_context.cpp}}
\DoxyCodeLine{13165 \textcolor{comment}{// start catch\_section.cpp}}
\DoxyCodeLine{13166 }
\DoxyCodeLine{13167 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{13168 }
\DoxyCodeLine{13169     Section::Section( SectionInfo \textcolor{keyword}{const}\& info )}
\DoxyCodeLine{13170     :   m\_info( info ),}
\DoxyCodeLine{13171         m\_sectionIncluded( getResultCapture().sectionStarted( m\_info, m\_assertions ) )}
\DoxyCodeLine{13172     \{}
\DoxyCodeLine{13173         m\_timer.start();}
\DoxyCodeLine{13174     \}}
\DoxyCodeLine{13175 }
\DoxyCodeLine{13176     Section::\string~Section() \{}
\DoxyCodeLine{13177         \textcolor{keywordflow}{if}( m\_sectionIncluded ) \{}
\DoxyCodeLine{13178             SectionEndInfo endInfo\{ m\_info, m\_assertions, m\_timer.getElapsedSeconds() \};}
\DoxyCodeLine{13179             \textcolor{keywordflow}{if}( uncaught\_exceptions() )}
\DoxyCodeLine{13180                 getResultCapture().sectionEndedEarly( endInfo );}
\DoxyCodeLine{13181             \textcolor{keywordflow}{else}}
\DoxyCodeLine{13182                 getResultCapture().sectionEnded( endInfo );}
\DoxyCodeLine{13183         \}}
\DoxyCodeLine{13184     \}}
\DoxyCodeLine{13185 }
\DoxyCodeLine{13186     \textcolor{comment}{// This indicates whether the section should be executed or not}}
\DoxyCodeLine{13187     Section::operator bool()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{13188         \textcolor{keywordflow}{return} m\_sectionIncluded;}
\DoxyCodeLine{13189     \}}
\DoxyCodeLine{13190 }
\DoxyCodeLine{13191 \} \textcolor{comment}{// end namespace Catch}}
\DoxyCodeLine{13192 \textcolor{comment}{// end catch\_section.cpp}}
\DoxyCodeLine{13193 \textcolor{comment}{// start catch\_section\_info.cpp}}
\DoxyCodeLine{13194 }
\DoxyCodeLine{13195 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{13196 }
\DoxyCodeLine{13197     SectionInfo::SectionInfo}
\DoxyCodeLine{13198         (   SourceLineInfo \textcolor{keyword}{const}\& \_lineInfo,}
\DoxyCodeLine{13199             std::string \textcolor{keyword}{const}\& \_name )}
\DoxyCodeLine{13200     :   name( \_name ),}
\DoxyCodeLine{13201         lineInfo( \_lineInfo )}
\DoxyCodeLine{13202     \{\}}
\DoxyCodeLine{13203 }
\DoxyCodeLine{13204 \} \textcolor{comment}{// end namespace Catch}}
\DoxyCodeLine{13205 \textcolor{comment}{// end catch\_section\_info.cpp}}
\DoxyCodeLine{13206 \textcolor{comment}{// start catch\_session.cpp}}
\DoxyCodeLine{13207 }
\DoxyCodeLine{13208 \textcolor{comment}{// start catch\_session.h}}
\DoxyCodeLine{13209 }
\DoxyCodeLine{13210 \textcolor{preprocessor}{\#include <memory>}}
\DoxyCodeLine{13211 }
\DoxyCodeLine{13212 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{13213 }
\DoxyCodeLine{13214     \textcolor{keyword}{class }Session : NonCopyable \{}
\DoxyCodeLine{13215     \textcolor{keyword}{public}:}
\DoxyCodeLine{13216 }
\DoxyCodeLine{13217         Session();}
\DoxyCodeLine{13218         \string~Session() \textcolor{keyword}{override};}
\DoxyCodeLine{13219 }
\DoxyCodeLine{13220         \textcolor{keywordtype}{void} showHelp() \textcolor{keyword}{const};}
\DoxyCodeLine{13221         \textcolor{keywordtype}{void} libIdentify();}
\DoxyCodeLine{13222 }
\DoxyCodeLine{13223         \textcolor{keywordtype}{int} applyCommandLine( \textcolor{keywordtype}{int} argc, \textcolor{keywordtype}{char} \textcolor{keyword}{const} * \textcolor{keyword}{const} * argv );}
\DoxyCodeLine{13224 \textcolor{preprocessor}{    \#if defined(CATCH\_CONFIG\_WCHAR) \&\& defined(\_WIN32) \&\& defined(UNICODE)}}
\DoxyCodeLine{13225         \textcolor{keywordtype}{int} applyCommandLine( \textcolor{keywordtype}{int} argc, \textcolor{keywordtype}{wchar\_t} \textcolor{keyword}{const} * \textcolor{keyword}{const} * argv );}
\DoxyCodeLine{13226 \textcolor{preprocessor}{    \#endif}}
\DoxyCodeLine{13227 }
\DoxyCodeLine{13228         \textcolor{keywordtype}{void} useConfigData( ConfigData \textcolor{keyword}{const}\& configData );}
\DoxyCodeLine{13229 }
\DoxyCodeLine{13230         \textcolor{keyword}{template}<\textcolor{keyword}{typename} CharT>}
\DoxyCodeLine{13231         \textcolor{keywordtype}{int} run(\textcolor{keywordtype}{int} argc, CharT \textcolor{keyword}{const} * \textcolor{keyword}{const} argv[]) \{}
\DoxyCodeLine{13232             \textcolor{keywordflow}{if} (m\_startupExceptions)}
\DoxyCodeLine{13233                 \textcolor{keywordflow}{return} 1;}
\DoxyCodeLine{13234             \textcolor{keywordtype}{int} returnCode = applyCommandLine(argc, argv);}
\DoxyCodeLine{13235             \textcolor{keywordflow}{if} (returnCode == 0)}
\DoxyCodeLine{13236                 returnCode = run();}
\DoxyCodeLine{13237             \textcolor{keywordflow}{return} returnCode;}
\DoxyCodeLine{13238         \}}
\DoxyCodeLine{13239 }
\DoxyCodeLine{13240         \textcolor{keywordtype}{int} run();}
\DoxyCodeLine{13241 }
\DoxyCodeLine{13242         clara::Parser \textcolor{keyword}{const}\& cli() \textcolor{keyword}{const};}
\DoxyCodeLine{13243         \textcolor{keywordtype}{void} cli( clara::Parser \textcolor{keyword}{const}\& newParser );}
\DoxyCodeLine{13244         ConfigData\& configData();}
\DoxyCodeLine{13245         Config\& config();}
\DoxyCodeLine{13246     \textcolor{keyword}{private}:}
\DoxyCodeLine{13247         \textcolor{keywordtype}{int} runInternal();}
\DoxyCodeLine{13248 }
\DoxyCodeLine{13249         clara::Parser m\_cli;}
\DoxyCodeLine{13250         ConfigData m\_configData;}
\DoxyCodeLine{13251         std::shared\_ptr<Config> m\_config;}
\DoxyCodeLine{13252         \textcolor{keywordtype}{bool} m\_startupExceptions = \textcolor{keyword}{false};}
\DoxyCodeLine{13253     \};}
\DoxyCodeLine{13254 }
\DoxyCodeLine{13255 \} \textcolor{comment}{// end namespace Catch}}
\DoxyCodeLine{13256 }
\DoxyCodeLine{13257 \textcolor{comment}{// end catch\_session.h}}
\DoxyCodeLine{13258 \textcolor{comment}{// start catch\_version.h}}
\DoxyCodeLine{13259 }
\DoxyCodeLine{13260 \textcolor{preprocessor}{\#include <iosfwd>}}
\DoxyCodeLine{13261 }
\DoxyCodeLine{13262 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{13263 }
\DoxyCodeLine{13264     \textcolor{comment}{// Versioning information}}
\DoxyCodeLine{13265     \textcolor{keyword}{struct }Version \{}
\DoxyCodeLine{13266         Version( Version \textcolor{keyword}{const}\& ) = \textcolor{keyword}{delete};}
\DoxyCodeLine{13267         Version\& operator=( Version \textcolor{keyword}{const}\& ) = \textcolor{keyword}{delete};}
\DoxyCodeLine{13268         Version(    \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} \_majorVersion,}
\DoxyCodeLine{13269                     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} \_minorVersion,}
\DoxyCodeLine{13270                     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} \_patchNumber,}
\DoxyCodeLine{13271                     \textcolor{keywordtype}{char} \textcolor{keyword}{const} * \textcolor{keyword}{const} \_branchName,}
\DoxyCodeLine{13272                     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} \_buildNumber );}
\DoxyCodeLine{13273 }
\DoxyCodeLine{13274         \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} \textcolor{keyword}{const} majorVersion;}
\DoxyCodeLine{13275         \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} \textcolor{keyword}{const} minorVersion;}
\DoxyCodeLine{13276         \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} \textcolor{keyword}{const} patchNumber;}
\DoxyCodeLine{13277 }
\DoxyCodeLine{13278         \textcolor{comment}{// buildNumber is only used if branchName is not null}}
\DoxyCodeLine{13279         \textcolor{keywordtype}{char} \textcolor{keyword}{const} * \textcolor{keyword}{const} branchName;}
\DoxyCodeLine{13280         \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} \textcolor{keyword}{const} buildNumber;}
\DoxyCodeLine{13281 }
\DoxyCodeLine{13282         \textcolor{keyword}{friend} std::ostream\& operator << ( std::ostream\& os, Version \textcolor{keyword}{const}\& version );}
\DoxyCodeLine{13283     \};}
\DoxyCodeLine{13284 }
\DoxyCodeLine{13285     Version \textcolor{keyword}{const}\& libraryVersion();}
\DoxyCodeLine{13286 \}}
\DoxyCodeLine{13287 }
\DoxyCodeLine{13288 \textcolor{comment}{// end catch\_version.h}}
\DoxyCodeLine{13289 \textcolor{preprocessor}{\#include <cstdlib>}}
\DoxyCodeLine{13290 \textcolor{preprocessor}{\#include <iomanip>}}
\DoxyCodeLine{13291 \textcolor{preprocessor}{\#include <set>}}
\DoxyCodeLine{13292 \textcolor{preprocessor}{\#include <iterator>}}
\DoxyCodeLine{13293 }
\DoxyCodeLine{13294 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{13295 }
\DoxyCodeLine{13296     \textcolor{keyword}{namespace }\{}
\DoxyCodeLine{13297         \textcolor{keyword}{const} \textcolor{keywordtype}{int} MaxExitCode = 255;}
\DoxyCodeLine{13298 }
\DoxyCodeLine{13299         IStreamingReporterPtr createReporter(std::string \textcolor{keyword}{const}\& reporterName, IConfigPtr \textcolor{keyword}{const}\& config) \{}
\DoxyCodeLine{13300             \textcolor{keyword}{auto} reporter = Catch::getRegistryHub().getReporterRegistry().create(reporterName, config);}
\DoxyCodeLine{13301             CATCH\_ENFORCE(reporter, \textcolor{stringliteral}{"{}No reporter registered with name: '"{}} << reporterName << \textcolor{stringliteral}{"{}'"{}});}
\DoxyCodeLine{13302 }
\DoxyCodeLine{13303             \textcolor{keywordflow}{return} reporter;}
\DoxyCodeLine{13304         \}}
\DoxyCodeLine{13305 }
\DoxyCodeLine{13306         IStreamingReporterPtr makeReporter(std::shared\_ptr<Config> \textcolor{keyword}{const}\& config) \{}
\DoxyCodeLine{13307             \textcolor{keywordflow}{if} (Catch::getRegistryHub().getReporterRegistry().getListeners().empty()) \{}
\DoxyCodeLine{13308                 \textcolor{keywordflow}{return} createReporter(config-\/>getReporterName(), config);}
\DoxyCodeLine{13309             \}}
\DoxyCodeLine{13310 }
\DoxyCodeLine{13311             \textcolor{comment}{// On older platforms, returning std::unique\_ptr<ListeningReporter>}}
\DoxyCodeLine{13312             \textcolor{comment}{// when the return type is std::unique\_ptr<IStreamingReporter>}}
\DoxyCodeLine{13313             \textcolor{comment}{// doesn't compile without a std::move call. However, this causes}}
\DoxyCodeLine{13314             \textcolor{comment}{// a warning on newer platforms. Thus, we have to work around}}
\DoxyCodeLine{13315             \textcolor{comment}{// it a bit and downcast the pointer manually.}}
\DoxyCodeLine{13316             \textcolor{keyword}{auto} ret = std::unique\_ptr<IStreamingReporter>(\textcolor{keyword}{new} ListeningReporter);}
\DoxyCodeLine{13317             \textcolor{keyword}{auto}\& multi = \textcolor{keyword}{static\_cast<}ListeningReporter\&\textcolor{keyword}{>}(*ret);}
\DoxyCodeLine{13318             \textcolor{keyword}{auto} \textcolor{keyword}{const}\& listeners = Catch::getRegistryHub().getReporterRegistry().getListeners();}
\DoxyCodeLine{13319             \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} \textcolor{keyword}{const}\& listener : listeners) \{}
\DoxyCodeLine{13320                 multi.addListener(listener-\/>create(Catch::ReporterConfig(config)));}
\DoxyCodeLine{13321             \}}
\DoxyCodeLine{13322             multi.addReporter(createReporter(config-\/>getReporterName(), config));}
\DoxyCodeLine{13323             \textcolor{keywordflow}{return} ret;}
\DoxyCodeLine{13324         \}}
\DoxyCodeLine{13325 }
\DoxyCodeLine{13326         \textcolor{keyword}{class }TestGroup \{}
\DoxyCodeLine{13327         \textcolor{keyword}{public}:}
\DoxyCodeLine{13328             \textcolor{keyword}{explicit} TestGroup(std::shared\_ptr<Config> \textcolor{keyword}{const}\& config)}
\DoxyCodeLine{13329             : m\_config\{config\}}
\DoxyCodeLine{13330             , m\_context\{config, makeReporter(config)\}}
\DoxyCodeLine{13331             \{}
\DoxyCodeLine{13332                 \textcolor{keyword}{auto} \textcolor{keyword}{const}\& allTestCases = getAllTestCasesSorted(*m\_config);}
\DoxyCodeLine{13333                 m\_matches = m\_config-\/>testSpec().matchesByFilter(allTestCases, *m\_config);}
\DoxyCodeLine{13334                 \textcolor{keyword}{auto} \textcolor{keyword}{const}\& invalidArgs = m\_config-\/>testSpec().getInvalidArgs();}
\DoxyCodeLine{13335 }
\DoxyCodeLine{13336                 \textcolor{keywordflow}{if} (m\_matches.empty() \&\& invalidArgs.empty()) \{}
\DoxyCodeLine{13337                     \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} \textcolor{keyword}{const}\& test : allTestCases)}
\DoxyCodeLine{13338                         \textcolor{keywordflow}{if} (!test.isHidden())}
\DoxyCodeLine{13339                             m\_tests.emplace(\&test);}
\DoxyCodeLine{13340                 \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{13341                     \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} \textcolor{keyword}{const}\& match : m\_matches)}
\DoxyCodeLine{13342                         m\_tests.insert(match.tests.begin(), match.tests.end());}
\DoxyCodeLine{13343                 \}}
\DoxyCodeLine{13344             \}}
\DoxyCodeLine{13345 }
\DoxyCodeLine{13346             Totals execute() \{}
\DoxyCodeLine{13347                 \textcolor{keyword}{auto} \textcolor{keyword}{const}\& invalidArgs = m\_config-\/>testSpec().getInvalidArgs();}
\DoxyCodeLine{13348                 Totals totals;}
\DoxyCodeLine{13349                 m\_context.testGroupStarting(m\_config-\/>name(), 1, 1);}
\DoxyCodeLine{13350                 \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} \textcolor{keyword}{const}\& testCase : m\_tests) \{}
\DoxyCodeLine{13351                     \textcolor{keywordflow}{if} (!m\_context.aborting())}
\DoxyCodeLine{13352                         totals += m\_context.runTest(*testCase);}
\DoxyCodeLine{13353                     \textcolor{keywordflow}{else}}
\DoxyCodeLine{13354                         m\_context.reporter().skipTest(*testCase);}
\DoxyCodeLine{13355                 \}}
\DoxyCodeLine{13356 }
\DoxyCodeLine{13357                 \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} \textcolor{keyword}{const}\& match : m\_matches) \{}
\DoxyCodeLine{13358                     \textcolor{keywordflow}{if} (match.tests.empty()) \{}
\DoxyCodeLine{13359                         m\_context.reporter().noMatchingTestCases(match.name);}
\DoxyCodeLine{13360                         totals.error = -\/1;}
\DoxyCodeLine{13361                     \}}
\DoxyCodeLine{13362                 \}}
\DoxyCodeLine{13363 }
\DoxyCodeLine{13364                 \textcolor{keywordflow}{if} (!invalidArgs.empty()) \{}
\DoxyCodeLine{13365                     \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} \textcolor{keyword}{const}\& invalidArg: invalidArgs)}
\DoxyCodeLine{13366                          m\_context.reporter().reportInvalidArguments(invalidArg);}
\DoxyCodeLine{13367                 \}}
\DoxyCodeLine{13368 }
\DoxyCodeLine{13369                 m\_context.testGroupEnded(m\_config-\/>name(), totals, 1, 1);}
\DoxyCodeLine{13370                 \textcolor{keywordflow}{return} totals;}
\DoxyCodeLine{13371             \}}
\DoxyCodeLine{13372 }
\DoxyCodeLine{13373         \textcolor{keyword}{private}:}
\DoxyCodeLine{13374             \textcolor{keyword}{using }Tests = std::set<TestCase const*>;}
\DoxyCodeLine{13375 }
\DoxyCodeLine{13376             std::shared\_ptr<Config> m\_config;}
\DoxyCodeLine{13377             RunContext m\_context;}
\DoxyCodeLine{13378             Tests m\_tests;}
\DoxyCodeLine{13379             TestSpec::Matches m\_matches;}
\DoxyCodeLine{13380         \};}
\DoxyCodeLine{13381 }
\DoxyCodeLine{13382         \textcolor{keywordtype}{void} applyFilenamesAsTags(\mbox{\hyperlink{structCatch_1_1IConfig}{Catch::IConfig}} \textcolor{keyword}{const}\& config) \{}
\DoxyCodeLine{13383             \textcolor{keyword}{auto}\& tests = \textcolor{keyword}{const\_cast<}std::vector<TestCase>\&\textcolor{keyword}{>}(getAllTestCasesSorted(config));}
\DoxyCodeLine{13384             \textcolor{keywordflow}{for} (\textcolor{keyword}{auto}\& testCase : tests) \{}
\DoxyCodeLine{13385                 \textcolor{keyword}{auto} tags = testCase.tags;}
\DoxyCodeLine{13386 }
\DoxyCodeLine{13387                 std::string filename = testCase.lineInfo.file;}
\DoxyCodeLine{13388                 \textcolor{keyword}{auto} lastSlash = filename.find\_last\_of(\textcolor{stringliteral}{"{}\(\backslash\)\(\backslash\)/"{}});}
\DoxyCodeLine{13389                 \textcolor{keywordflow}{if} (lastSlash != std::string::npos) \{}
\DoxyCodeLine{13390                     filename.erase(0, lastSlash);}
\DoxyCodeLine{13391                     filename[0] = \textcolor{charliteral}{'\#'};}
\DoxyCodeLine{13392                 \}}
\DoxyCodeLine{13393                 \textcolor{keywordflow}{else}}
\DoxyCodeLine{13394                 \{}
\DoxyCodeLine{13395                     filename.insert(0, \textcolor{stringliteral}{"{}\#"{}});}
\DoxyCodeLine{13396                 \}}
\DoxyCodeLine{13397 }
\DoxyCodeLine{13398                 \textcolor{keyword}{auto} lastDot = filename.find\_last\_of(\textcolor{charliteral}{'.'});}
\DoxyCodeLine{13399                 \textcolor{keywordflow}{if} (lastDot != std::string::npos) \{}
\DoxyCodeLine{13400                     filename.erase(lastDot);}
\DoxyCodeLine{13401                 \}}
\DoxyCodeLine{13402 }
\DoxyCodeLine{13403                 tags.push\_back(std::move(filename));}
\DoxyCodeLine{13404                 setTags(testCase, tags);}
\DoxyCodeLine{13405             \}}
\DoxyCodeLine{13406         \}}
\DoxyCodeLine{13407 }
\DoxyCodeLine{13408     \} \textcolor{comment}{// anon namespace}}
\DoxyCodeLine{13409 }
\DoxyCodeLine{13410     Session::Session() \{}
\DoxyCodeLine{13411         \textcolor{keyword}{static} \textcolor{keywordtype}{bool} alreadyInstantiated = \textcolor{keyword}{false};}
\DoxyCodeLine{13412         \textcolor{keywordflow}{if}( alreadyInstantiated ) \{}
\DoxyCodeLine{13413             CATCH\_TRY \{ CATCH\_INTERNAL\_ERROR( \textcolor{stringliteral}{"{}Only one instance of Catch::Session can ever be used"{}} ); \}}
\DoxyCodeLine{13414             CATCH\_CATCH\_ALL \{ getMutableRegistryHub().registerStartupException(); \}}
\DoxyCodeLine{13415         \}}
\DoxyCodeLine{13416 }
\DoxyCodeLine{13417         \textcolor{comment}{// There cannot be exceptions at startup in no-\/exception mode.}}
\DoxyCodeLine{13418 \textcolor{preprocessor}{\#if !defined(CATCH\_CONFIG\_DISABLE\_EXCEPTIONS)}}
\DoxyCodeLine{13419         \textcolor{keyword}{const} \textcolor{keyword}{auto}\& exceptions = getRegistryHub().getStartupExceptionRegistry().getExceptions();}
\DoxyCodeLine{13420         \textcolor{keywordflow}{if} ( !exceptions.empty() ) \{}
\DoxyCodeLine{13421             config();}
\DoxyCodeLine{13422             getCurrentMutableContext().setConfig(m\_config);}
\DoxyCodeLine{13423 }
\DoxyCodeLine{13424             m\_startupExceptions = \textcolor{keyword}{true};}
\DoxyCodeLine{13425             Colour colourGuard( Colour::Red );}
\DoxyCodeLine{13426             Catch::cerr() << \textcolor{stringliteral}{"{}Errors occurred during startup!"{}} << \textcolor{charliteral}{'\(\backslash\)n'};}
\DoxyCodeLine{13427             \textcolor{comment}{// iterate over all exceptions and notify user}}
\DoxyCodeLine{13428             \textcolor{keywordflow}{for} ( \textcolor{keyword}{const} \textcolor{keyword}{auto}\& ex\_ptr : exceptions ) \{}
\DoxyCodeLine{13429                 \textcolor{keywordflow}{try} \{}
\DoxyCodeLine{13430                     std::rethrow\_exception(ex\_ptr);}
\DoxyCodeLine{13431                 \} \textcolor{keywordflow}{catch} ( std::exception \textcolor{keyword}{const}\& ex ) \{}
\DoxyCodeLine{13432                     Catch::cerr() << Column( ex.what() ).indent(2) << \textcolor{charliteral}{'\(\backslash\)n'};}
\DoxyCodeLine{13433                 \}}
\DoxyCodeLine{13434             \}}
\DoxyCodeLine{13435         \}}
\DoxyCodeLine{13436 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{13437 }
\DoxyCodeLine{13438         alreadyInstantiated = \textcolor{keyword}{true};}
\DoxyCodeLine{13439         m\_cli = makeCommandLineParser( m\_configData );}
\DoxyCodeLine{13440     \}}
\DoxyCodeLine{13441     Session::\string~Session() \{}
\DoxyCodeLine{13442         Catch::cleanUp();}
\DoxyCodeLine{13443     \}}
\DoxyCodeLine{13444 }
\DoxyCodeLine{13445     \textcolor{keywordtype}{void} Session::showHelp()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{13446         Catch::cout()}
\DoxyCodeLine{13447                 << \textcolor{stringliteral}{"{}\(\backslash\)nCatch v"{}} << libraryVersion() << \textcolor{stringliteral}{"{}\(\backslash\)n"{}}}
\DoxyCodeLine{13448                 << m\_cli << std::endl}
\DoxyCodeLine{13449                 << \textcolor{stringliteral}{"{}For more detailed usage please see the project docs\(\backslash\)n"{}} << std::endl;}
\DoxyCodeLine{13450     \}}
\DoxyCodeLine{13451     \textcolor{keywordtype}{void} Session::libIdentify() \{}
\DoxyCodeLine{13452         Catch::cout()}
\DoxyCodeLine{13453                 << std::left << std::setw(16) << \textcolor{stringliteral}{"{}description: "{}} << \textcolor{stringliteral}{"{}A Catch2 test executable\(\backslash\)n"{}}}
\DoxyCodeLine{13454                 << std::left << std::setw(16) << \textcolor{stringliteral}{"{}category: "{}} << \textcolor{stringliteral}{"{}testframework\(\backslash\)n"{}}}
\DoxyCodeLine{13455                 << std::left << std::setw(16) << \textcolor{stringliteral}{"{}framework: "{}} << \textcolor{stringliteral}{"{}Catch Test\(\backslash\)n"{}}}
\DoxyCodeLine{13456                 << std::left << std::setw(16) << \textcolor{stringliteral}{"{}version: "{}} << libraryVersion() << std::endl;}
\DoxyCodeLine{13457     \}}
\DoxyCodeLine{13458 }
\DoxyCodeLine{13459     \textcolor{keywordtype}{int} Session::applyCommandLine( \textcolor{keywordtype}{int} argc, \textcolor{keywordtype}{char} \textcolor{keyword}{const} * \textcolor{keyword}{const} * argv ) \{}
\DoxyCodeLine{13460         \textcolor{keywordflow}{if}( m\_startupExceptions )}
\DoxyCodeLine{13461             \textcolor{keywordflow}{return} 1;}
\DoxyCodeLine{13462 }
\DoxyCodeLine{13463         \textcolor{keyword}{auto} result = m\_cli.parse( clara::Args( argc, argv ) );}
\DoxyCodeLine{13464         \textcolor{keywordflow}{if}( !result ) \{}
\DoxyCodeLine{13465             config();}
\DoxyCodeLine{13466             getCurrentMutableContext().setConfig(m\_config);}
\DoxyCodeLine{13467             Catch::cerr()}
\DoxyCodeLine{13468                 << Colour( Colour::Red )}
\DoxyCodeLine{13469                 << \textcolor{stringliteral}{"{}\(\backslash\)nError(s) in input:\(\backslash\)n"{}}}
\DoxyCodeLine{13470                 << Column( result.errorMessage() ).indent( 2 )}
\DoxyCodeLine{13471                 << \textcolor{stringliteral}{"{}\(\backslash\)n\(\backslash\)n"{}};}
\DoxyCodeLine{13472             Catch::cerr() << \textcolor{stringliteral}{"{}Run with -\/? for usage\(\backslash\)n"{}} << std::endl;}
\DoxyCodeLine{13473             \textcolor{keywordflow}{return} MaxExitCode;}
\DoxyCodeLine{13474         \}}
\DoxyCodeLine{13475 }
\DoxyCodeLine{13476         \textcolor{keywordflow}{if}( m\_configData.showHelp )}
\DoxyCodeLine{13477             showHelp();}
\DoxyCodeLine{13478         \textcolor{keywordflow}{if}( m\_configData.libIdentify )}
\DoxyCodeLine{13479             libIdentify();}
\DoxyCodeLine{13480         m\_config.reset();}
\DoxyCodeLine{13481         \textcolor{keywordflow}{return} 0;}
\DoxyCodeLine{13482     \}}
\DoxyCodeLine{13483 }
\DoxyCodeLine{13484 \textcolor{preprocessor}{\#if defined(CATCH\_CONFIG\_WCHAR) \&\& defined(\_WIN32) \&\& defined(UNICODE)}}
\DoxyCodeLine{13485     \textcolor{keywordtype}{int} Session::applyCommandLine( \textcolor{keywordtype}{int} argc, \textcolor{keywordtype}{wchar\_t} \textcolor{keyword}{const} * \textcolor{keyword}{const} * argv ) \{}
\DoxyCodeLine{13486 }
\DoxyCodeLine{13487         \textcolor{keywordtype}{char} **utf8Argv = \textcolor{keyword}{new} \textcolor{keywordtype}{char} *[ argc ];}
\DoxyCodeLine{13488 }
\DoxyCodeLine{13489         \textcolor{keywordflow}{for} ( \textcolor{keywordtype}{int} i = 0; i < argc; ++i ) \{}
\DoxyCodeLine{13490             \textcolor{keywordtype}{int} bufSize = WideCharToMultiByte( CP\_UTF8, 0, argv[i], -\/1, \textcolor{keyword}{nullptr}, 0, \textcolor{keyword}{nullptr}, \textcolor{keyword}{nullptr} );}
\DoxyCodeLine{13491 }
\DoxyCodeLine{13492             utf8Argv[ i ] = \textcolor{keyword}{new} \textcolor{keywordtype}{char}[ bufSize ];}
\DoxyCodeLine{13493 }
\DoxyCodeLine{13494             WideCharToMultiByte( CP\_UTF8, 0, argv[i], -\/1, utf8Argv[i], bufSize, \textcolor{keyword}{nullptr}, \textcolor{keyword}{nullptr} );}
\DoxyCodeLine{13495         \}}
\DoxyCodeLine{13496 }
\DoxyCodeLine{13497         \textcolor{keywordtype}{int} returnCode = applyCommandLine( argc, utf8Argv );}
\DoxyCodeLine{13498 }
\DoxyCodeLine{13499         \textcolor{keywordflow}{for} ( \textcolor{keywordtype}{int} i = 0; i < argc; ++i )}
\DoxyCodeLine{13500             delete [] utf8Argv[ i ];}
\DoxyCodeLine{13501 }
\DoxyCodeLine{13502         \textcolor{keyword}{delete} [] utf8Argv;}
\DoxyCodeLine{13503 }
\DoxyCodeLine{13504         \textcolor{keywordflow}{return} returnCode;}
\DoxyCodeLine{13505     \}}
\DoxyCodeLine{13506 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{13507 }
\DoxyCodeLine{13508     \textcolor{keywordtype}{void} Session::useConfigData( ConfigData \textcolor{keyword}{const}\& configData ) \{}
\DoxyCodeLine{13509         m\_configData = configData;}
\DoxyCodeLine{13510         m\_config.reset();}
\DoxyCodeLine{13511     \}}
\DoxyCodeLine{13512 }
\DoxyCodeLine{13513     \textcolor{keywordtype}{int} Session::run() \{}
\DoxyCodeLine{13514         \textcolor{keywordflow}{if}( ( m\_configData.waitForKeypress \& WaitForKeypress::BeforeStart ) != 0 ) \{}
\DoxyCodeLine{13515             Catch::cout() << \textcolor{stringliteral}{"{}...waiting for enter/ return before starting"{}} << std::endl;}
\DoxyCodeLine{13516             \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{void}\textcolor{keyword}{>}(std::getchar());}
\DoxyCodeLine{13517         \}}
\DoxyCodeLine{13518         \textcolor{keywordtype}{int} exitCode = runInternal();}
\DoxyCodeLine{13519         \textcolor{keywordflow}{if}( ( m\_configData.waitForKeypress \& WaitForKeypress::BeforeExit ) != 0 ) \{}
\DoxyCodeLine{13520             Catch::cout() << \textcolor{stringliteral}{"{}...waiting for enter/ return before exiting, with code: "{}} << exitCode << std::endl;}
\DoxyCodeLine{13521             \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{void}\textcolor{keyword}{>}(std::getchar());}
\DoxyCodeLine{13522         \}}
\DoxyCodeLine{13523         \textcolor{keywordflow}{return} exitCode;}
\DoxyCodeLine{13524     \}}
\DoxyCodeLine{13525 }
\DoxyCodeLine{13526     clara::Parser \textcolor{keyword}{const}\& Session::cli()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{13527         \textcolor{keywordflow}{return} m\_cli;}
\DoxyCodeLine{13528     \}}
\DoxyCodeLine{13529     \textcolor{keywordtype}{void} Session::cli( clara::Parser \textcolor{keyword}{const}\& newParser ) \{}
\DoxyCodeLine{13530         m\_cli = newParser;}
\DoxyCodeLine{13531     \}}
\DoxyCodeLine{13532     ConfigData\& Session::configData() \{}
\DoxyCodeLine{13533         \textcolor{keywordflow}{return} m\_configData;}
\DoxyCodeLine{13534     \}}
\DoxyCodeLine{13535     Config\& Session::config() \{}
\DoxyCodeLine{13536         \textcolor{keywordflow}{if}( !m\_config )}
\DoxyCodeLine{13537             m\_config = std::make\_shared<Config>( m\_configData );}
\DoxyCodeLine{13538         \textcolor{keywordflow}{return} *m\_config;}
\DoxyCodeLine{13539     \}}
\DoxyCodeLine{13540 }
\DoxyCodeLine{13541     \textcolor{keywordtype}{int} Session::runInternal() \{}
\DoxyCodeLine{13542         \textcolor{keywordflow}{if}( m\_startupExceptions )}
\DoxyCodeLine{13543             \textcolor{keywordflow}{return} 1;}
\DoxyCodeLine{13544 }
\DoxyCodeLine{13545         \textcolor{keywordflow}{if} (m\_configData.showHelp || m\_configData.libIdentify) \{}
\DoxyCodeLine{13546             \textcolor{keywordflow}{return} 0;}
\DoxyCodeLine{13547         \}}
\DoxyCodeLine{13548 }
\DoxyCodeLine{13549         CATCH\_TRY \{}
\DoxyCodeLine{13550             config(); \textcolor{comment}{// Force config to be constructed}}
\DoxyCodeLine{13551 }
\DoxyCodeLine{13552             seedRng( *m\_config );}
\DoxyCodeLine{13553 }
\DoxyCodeLine{13554             \textcolor{keywordflow}{if}( m\_configData.filenamesAsTags )}
\DoxyCodeLine{13555                 applyFilenamesAsTags( *m\_config );}
\DoxyCodeLine{13556 }
\DoxyCodeLine{13557             \textcolor{comment}{// Handle list request}}
\DoxyCodeLine{13558             \textcolor{keywordflow}{if}( Option<std::size\_t> listed = list( m\_config ) )}
\DoxyCodeLine{13559                 \textcolor{keywordflow}{return} (std::min) (MaxExitCode, \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{int}\textcolor{keyword}{>}(*listed));}
\DoxyCodeLine{13560 }
\DoxyCodeLine{13561             TestGroup tests \{ m\_config \};}
\DoxyCodeLine{13562             \textcolor{keyword}{auto} \textcolor{keyword}{const} totals = tests.execute();}
\DoxyCodeLine{13563 }
\DoxyCodeLine{13564             \textcolor{keywordflow}{if}( m\_config-\/>warnAboutNoTests() \&\& totals.error == -\/1 )}
\DoxyCodeLine{13565                 return 2;}
\DoxyCodeLine{13566 }
\DoxyCodeLine{13567             \textcolor{comment}{// Note that on unices only the lower 8 bits are usually used, clamping}}
\DoxyCodeLine{13568             \textcolor{comment}{// the return value to 255 prevents false negative when some multiple}}
\DoxyCodeLine{13569             \textcolor{comment}{// of 256 tests has failed}}
\DoxyCodeLine{13570             \textcolor{keywordflow}{return} (std::min) (MaxExitCode, (std::max) (totals.error, \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{int}\textcolor{keyword}{>}(totals.assertions.failed)));}
\DoxyCodeLine{13571         \}}
\DoxyCodeLine{13572 \textcolor{preprocessor}{\#if !defined(CATCH\_CONFIG\_DISABLE\_EXCEPTIONS)}}
\DoxyCodeLine{13573         \textcolor{keywordflow}{catch}( std::exception\& ex ) \{}
\DoxyCodeLine{13574             Catch::cerr() << ex.what() << std::endl;}
\DoxyCodeLine{13575             \textcolor{keywordflow}{return} MaxExitCode;}
\DoxyCodeLine{13576         \}}
\DoxyCodeLine{13577 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{13578     \}}
\DoxyCodeLine{13579 }
\DoxyCodeLine{13580 \} \textcolor{comment}{// end namespace Catch}}
\DoxyCodeLine{13581 \textcolor{comment}{// end catch\_session.cpp}}
\DoxyCodeLine{13582 \textcolor{comment}{// start catch\_singletons.cpp}}
\DoxyCodeLine{13583 }
\DoxyCodeLine{13584 \textcolor{preprocessor}{\#include <vector>}}
\DoxyCodeLine{13585 }
\DoxyCodeLine{13586 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{13587 }
\DoxyCodeLine{13588     \textcolor{keyword}{namespace }\{}
\DoxyCodeLine{13589         \textcolor{keyword}{static} \textcolor{keyword}{auto} getSingletons() -\/> std::vector<ISingleton*>*\& \{}
\DoxyCodeLine{13590             \textcolor{keyword}{static} std::vector<ISingleton*>* g\_singletons = \textcolor{keyword}{nullptr};}
\DoxyCodeLine{13591             \textcolor{keywordflow}{if}( !g\_singletons )}
\DoxyCodeLine{13592                 g\_singletons = \textcolor{keyword}{new} std::vector<ISingleton*>();}
\DoxyCodeLine{13593             \textcolor{keywordflow}{return} g\_singletons;}
\DoxyCodeLine{13594         \}}
\DoxyCodeLine{13595     \}}
\DoxyCodeLine{13596 }
\DoxyCodeLine{13597     ISingleton::\string~ISingleton() \{\}}
\DoxyCodeLine{13598 }
\DoxyCodeLine{13599     \textcolor{keywordtype}{void} addSingleton(ISingleton* singleton ) \{}
\DoxyCodeLine{13600         getSingletons()-\/>push\_back( singleton );}
\DoxyCodeLine{13601     \}}
\DoxyCodeLine{13602     \textcolor{keywordtype}{void} cleanupSingletons() \{}
\DoxyCodeLine{13603         \textcolor{keyword}{auto}\& singletons = getSingletons();}
\DoxyCodeLine{13604         \textcolor{keywordflow}{for}( \textcolor{keyword}{auto} singleton : *singletons )}
\DoxyCodeLine{13605             \textcolor{keyword}{delete} singleton;}
\DoxyCodeLine{13606         \textcolor{keyword}{delete} singletons;}
\DoxyCodeLine{13607         singletons = \textcolor{keyword}{nullptr};}
\DoxyCodeLine{13608     \}}
\DoxyCodeLine{13609 }
\DoxyCodeLine{13610 \} \textcolor{comment}{// namespace Catch}}
\DoxyCodeLine{13611 \textcolor{comment}{// end catch\_singletons.cpp}}
\DoxyCodeLine{13612 \textcolor{comment}{// start catch\_startup\_exception\_registry.cpp}}
\DoxyCodeLine{13613 }
\DoxyCodeLine{13614 \textcolor{preprocessor}{\#if !defined(CATCH\_CONFIG\_DISABLE\_EXCEPTIONS)}}
\DoxyCodeLine{13615 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{13616 \textcolor{keywordtype}{void} StartupExceptionRegistry::add( std::exception\_ptr \textcolor{keyword}{const}\& exception ) \textcolor{keyword}{noexcept} \{}
\DoxyCodeLine{13617         CATCH\_TRY \{}
\DoxyCodeLine{13618             m\_exceptions.push\_back(exception);}
\DoxyCodeLine{13619         \} CATCH\_CATCH\_ALL \{}
\DoxyCodeLine{13620             \textcolor{comment}{// If we run out of memory during start-\/up there's really not a lot more we can do about it}}
\DoxyCodeLine{13621             std::terminate();}
\DoxyCodeLine{13622         \}}
\DoxyCodeLine{13623     \}}
\DoxyCodeLine{13624 }
\DoxyCodeLine{13625     std::vector<std::exception\_ptr> \textcolor{keyword}{const}\& StartupExceptionRegistry::getExceptions() const noexcept \{}
\DoxyCodeLine{13626         \textcolor{keywordflow}{return} m\_exceptions;}
\DoxyCodeLine{13627     \}}
\DoxyCodeLine{13628 }
\DoxyCodeLine{13629 \} \textcolor{comment}{// end namespace Catch}}
\DoxyCodeLine{13630 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{13631 \textcolor{comment}{// end catch\_startup\_exception\_registry.cpp}}
\DoxyCodeLine{13632 \textcolor{comment}{// start catch\_stream.cpp}}
\DoxyCodeLine{13633 }
\DoxyCodeLine{13634 \textcolor{preprocessor}{\#include <cstdio>}}
\DoxyCodeLine{13635 \textcolor{preprocessor}{\#include <iostream>}}
\DoxyCodeLine{13636 \textcolor{preprocessor}{\#include <fstream>}}
\DoxyCodeLine{13637 \textcolor{preprocessor}{\#include <sstream>}}
\DoxyCodeLine{13638 \textcolor{preprocessor}{\#include <vector>}}
\DoxyCodeLine{13639 \textcolor{preprocessor}{\#include <memory>}}
\DoxyCodeLine{13640 }
\DoxyCodeLine{13641 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{13642 }
\DoxyCodeLine{13643     Catch::IStream::\string~IStream() = \textcolor{keywordflow}{default};}
\DoxyCodeLine{13644 }
\DoxyCodeLine{13645     \textcolor{keyword}{namespace }Detail \{ \textcolor{keyword}{namespace }\{}
\DoxyCodeLine{13646         \textcolor{keyword}{template}<\textcolor{keyword}{typename} WriterF, std::\textcolor{keywordtype}{size\_t} bufferSize=256>}
\DoxyCodeLine{13647         \textcolor{keyword}{class }StreamBufImpl : \textcolor{keyword}{public} std::streambuf \{}
\DoxyCodeLine{13648             \textcolor{keywordtype}{char} data[bufferSize];}
\DoxyCodeLine{13649             WriterF m\_writer;}
\DoxyCodeLine{13650 }
\DoxyCodeLine{13651         \textcolor{keyword}{public}:}
\DoxyCodeLine{13652             StreamBufImpl() \{}
\DoxyCodeLine{13653                 setp( data, data + \textcolor{keyword}{sizeof}(data) );}
\DoxyCodeLine{13654             \}}
\DoxyCodeLine{13655 }
\DoxyCodeLine{13656             \string~StreamBufImpl() noexcept \{}
\DoxyCodeLine{13657                 StreamBufImpl::sync();}
\DoxyCodeLine{13658             \}}
\DoxyCodeLine{13659 }
\DoxyCodeLine{13660         \textcolor{keyword}{private}:}
\DoxyCodeLine{13661             \textcolor{keywordtype}{int} overflow( \textcolor{keywordtype}{int} c )\textcolor{keyword}{ override }\{}
\DoxyCodeLine{13662                 sync();}
\DoxyCodeLine{13663 }
\DoxyCodeLine{13664                 \textcolor{keywordflow}{if}( c != EOF ) \{}
\DoxyCodeLine{13665                     \textcolor{keywordflow}{if}( pbase() == epptr() )}
\DoxyCodeLine{13666                         m\_writer( std::string( 1, \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{char}\textcolor{keyword}{>}( c ) ) );}
\DoxyCodeLine{13667                     \textcolor{keywordflow}{else}}
\DoxyCodeLine{13668                         sputc( \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{char}\textcolor{keyword}{>}( c ) );}
\DoxyCodeLine{13669                 \}}
\DoxyCodeLine{13670                 \textcolor{keywordflow}{return} 0;}
\DoxyCodeLine{13671             \}}
\DoxyCodeLine{13672 }
\DoxyCodeLine{13673             \textcolor{keywordtype}{int} sync()\textcolor{keyword}{ override }\{}
\DoxyCodeLine{13674                 \textcolor{keywordflow}{if}( pbase() != pptr() ) \{}
\DoxyCodeLine{13675                     m\_writer( std::string( pbase(), \textcolor{keyword}{static\_cast<}std::string::size\_type\textcolor{keyword}{>}( pptr() -\/ pbase() ) ) );}
\DoxyCodeLine{13676                     setp( pbase(), epptr() );}
\DoxyCodeLine{13677                 \}}
\DoxyCodeLine{13678                 \textcolor{keywordflow}{return} 0;}
\DoxyCodeLine{13679             \}}
\DoxyCodeLine{13680         \};}
\DoxyCodeLine{13681 }
\DoxyCodeLine{13683 }
\DoxyCodeLine{13684         \textcolor{keyword}{struct }OutputDebugWriter \{}
\DoxyCodeLine{13685 }
\DoxyCodeLine{13686             \textcolor{keywordtype}{void} operator()( std::string \textcolor{keyword}{const}\&str ) \{}
\DoxyCodeLine{13687                 writeToDebugConsole( str );}
\DoxyCodeLine{13688             \}}
\DoxyCodeLine{13689         \};}
\DoxyCodeLine{13690 }
\DoxyCodeLine{13692 }
\DoxyCodeLine{13693         \textcolor{keyword}{class }FileStream : \textcolor{keyword}{public} IStream \{}
\DoxyCodeLine{13694             \textcolor{keyword}{mutable} std::ofstream m\_ofs;}
\DoxyCodeLine{13695         \textcolor{keyword}{public}:}
\DoxyCodeLine{13696             FileStream( StringRef filename ) \{}
\DoxyCodeLine{13697                 m\_ofs.open( filename.c\_str() );}
\DoxyCodeLine{13698                 CATCH\_ENFORCE( !m\_ofs.fail(), \textcolor{stringliteral}{"{}Unable to open file: '"{}} << filename << \textcolor{stringliteral}{"{}'"{}} );}
\DoxyCodeLine{13699             \}}
\DoxyCodeLine{13700             \string~FileStream() \textcolor{keyword}{override} = \textcolor{keywordflow}{default};}
\DoxyCodeLine{13701         \textcolor{keyword}{public}: \textcolor{comment}{// IStream}}
\DoxyCodeLine{13702             std::ostream\& stream()\textcolor{keyword}{ const override }\{}
\DoxyCodeLine{13703                 \textcolor{keywordflow}{return} m\_ofs;}
\DoxyCodeLine{13704             \}}
\DoxyCodeLine{13705         \};}
\DoxyCodeLine{13706 }
\DoxyCodeLine{13708 }
\DoxyCodeLine{13709         \textcolor{keyword}{class }CoutStream : \textcolor{keyword}{public} IStream \{}
\DoxyCodeLine{13710             \textcolor{keyword}{mutable} std::ostream m\_os;}
\DoxyCodeLine{13711         \textcolor{keyword}{public}:}
\DoxyCodeLine{13712             \textcolor{comment}{// Store the streambuf from cout up-\/front because}}
\DoxyCodeLine{13713             \textcolor{comment}{// cout may get redirected when running tests}}
\DoxyCodeLine{13714             CoutStream() : m\_os( Catch::cout().rdbuf() ) \{\}}
\DoxyCodeLine{13715             \string~CoutStream() \textcolor{keyword}{override} = \textcolor{keywordflow}{default};}
\DoxyCodeLine{13716 }
\DoxyCodeLine{13717         \textcolor{keyword}{public}: \textcolor{comment}{// IStream}}
\DoxyCodeLine{13718             std::ostream\& stream()\textcolor{keyword}{ const override }\{ \textcolor{keywordflow}{return} m\_os; \}}
\DoxyCodeLine{13719         \};}
\DoxyCodeLine{13720 }
\DoxyCodeLine{13722 }
\DoxyCodeLine{13723         \textcolor{keyword}{class }DebugOutStream : \textcolor{keyword}{public} IStream \{}
\DoxyCodeLine{13724             std::unique\_ptr<StreamBufImpl<OutputDebugWriter>> m\_streamBuf;}
\DoxyCodeLine{13725             \textcolor{keyword}{mutable} std::ostream m\_os;}
\DoxyCodeLine{13726         \textcolor{keyword}{public}:}
\DoxyCodeLine{13727             DebugOutStream()}
\DoxyCodeLine{13728             :   m\_streamBuf( new StreamBufImpl<OutputDebugWriter>() ),}
\DoxyCodeLine{13729                 m\_os( m\_streamBuf.get() )}
\DoxyCodeLine{13730             \{\}}
\DoxyCodeLine{13731 }
\DoxyCodeLine{13732             \string~DebugOutStream() \textcolor{keyword}{override} = \textcolor{keywordflow}{default};}
\DoxyCodeLine{13733 }
\DoxyCodeLine{13734         \textcolor{keyword}{public}: \textcolor{comment}{// IStream}}
\DoxyCodeLine{13735             std::ostream\& stream()\textcolor{keyword}{ const override }\{ \textcolor{keywordflow}{return} m\_os; \}}
\DoxyCodeLine{13736         \};}
\DoxyCodeLine{13737 }
\DoxyCodeLine{13738     \}\} \textcolor{comment}{// namespace anon::detail}}
\DoxyCodeLine{13739 }
\DoxyCodeLine{13741 }
\DoxyCodeLine{13742     \textcolor{keyword}{auto} makeStream( StringRef \textcolor{keyword}{const} \&filename ) -\/> IStream \textcolor{keyword}{const}* \{}
\DoxyCodeLine{13743         \textcolor{keywordflow}{if}( filename.empty() )}
\DoxyCodeLine{13744             \textcolor{keywordflow}{return} \textcolor{keyword}{new} Detail::CoutStream();}
\DoxyCodeLine{13745         \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}( filename[0] == \textcolor{charliteral}{'\%'} ) \{}
\DoxyCodeLine{13746             \textcolor{keywordflow}{if}( filename == \textcolor{stringliteral}{"{}\%debug"{}} )}
\DoxyCodeLine{13747                 \textcolor{keywordflow}{return} \textcolor{keyword}{new} Detail::DebugOutStream();}
\DoxyCodeLine{13748             \textcolor{keywordflow}{else}}
\DoxyCodeLine{13749                 CATCH\_ERROR( \textcolor{stringliteral}{"{}Unrecognised stream: '"{}} << filename << \textcolor{stringliteral}{"{}'"{}} );}
\DoxyCodeLine{13750         \}}
\DoxyCodeLine{13751         \textcolor{keywordflow}{else}}
\DoxyCodeLine{13752             \textcolor{keywordflow}{return} \textcolor{keyword}{new} Detail::FileStream( filename );}
\DoxyCodeLine{13753     \}}
\DoxyCodeLine{13754 }
\DoxyCodeLine{13755     \textcolor{comment}{// This class encapsulates the idea of a pool of ostringstreams that can be reused.}}
\DoxyCodeLine{13756     \textcolor{keyword}{struct }StringStreams \{}
\DoxyCodeLine{13757         std::vector<std::unique\_ptr<std::ostringstream>> m\_streams;}
\DoxyCodeLine{13758         std::vector<std::size\_t> m\_unused;}
\DoxyCodeLine{13759         std::ostringstream m\_referenceStream; \textcolor{comment}{// Used for copy state/ flags from}}
\DoxyCodeLine{13760 }
\DoxyCodeLine{13761         \textcolor{keyword}{auto} add() -\/> std::size\_t \{}
\DoxyCodeLine{13762             \textcolor{keywordflow}{if}( m\_unused.empty() ) \{}
\DoxyCodeLine{13763                 m\_streams.push\_back( std::unique\_ptr<std::ostringstream>( \textcolor{keyword}{new} std::ostringstream ) );}
\DoxyCodeLine{13764                 \textcolor{keywordflow}{return} m\_streams.size()-\/1;}
\DoxyCodeLine{13765             \}}
\DoxyCodeLine{13766             \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{13767                 \textcolor{keyword}{auto} index = m\_unused.back();}
\DoxyCodeLine{13768                 m\_unused.pop\_back();}
\DoxyCodeLine{13769                 \textcolor{keywordflow}{return} index;}
\DoxyCodeLine{13770             \}}
\DoxyCodeLine{13771         \}}
\DoxyCodeLine{13772 }
\DoxyCodeLine{13773         \textcolor{keywordtype}{void} release( std::size\_t index ) \{}
\DoxyCodeLine{13774             m\_streams[index]-\/>copyfmt( m\_referenceStream ); \textcolor{comment}{// Restore initial flags and other state}}
\DoxyCodeLine{13775             m\_unused.push\_back(index);}
\DoxyCodeLine{13776         \}}
\DoxyCodeLine{13777     \};}
\DoxyCodeLine{13778 }
\DoxyCodeLine{13779     ReusableStringStream::ReusableStringStream()}
\DoxyCodeLine{13780     :   m\_index( Singleton<StringStreams>::getMutable().add() ),}
\DoxyCodeLine{13781         m\_oss( Singleton<StringStreams>::getMutable().m\_streams[m\_index].get() )}
\DoxyCodeLine{13782     \{\}}
\DoxyCodeLine{13783 }
\DoxyCodeLine{13784     ReusableStringStream::\string~ReusableStringStream() \{}
\DoxyCodeLine{13785         \textcolor{keyword}{static\_cast<}std::ostringstream*\textcolor{keyword}{>}( m\_oss )-\/>str(\textcolor{stringliteral}{"{}"{}});}
\DoxyCodeLine{13786         m\_oss-\/>clear();}
\DoxyCodeLine{13787         Singleton<StringStreams>::getMutable().release( m\_index );}
\DoxyCodeLine{13788     \}}
\DoxyCodeLine{13789 }
\DoxyCodeLine{13790     \textcolor{keyword}{auto} ReusableStringStream::str() const -\/> std::\textcolor{keywordtype}{string} \{}
\DoxyCodeLine{13791         \textcolor{keywordflow}{return} \textcolor{keyword}{static\_cast<}std::ostringstream*\textcolor{keyword}{>}( m\_oss )-\/>str();}
\DoxyCodeLine{13792     \}}
\DoxyCodeLine{13793 }
\DoxyCodeLine{13795 }
\DoxyCodeLine{13796 \textcolor{preprocessor}{\#ifndef CATCH\_CONFIG\_NOSTDOUT }\textcolor{comment}{// If you \#define this you must implement these functions}}
\DoxyCodeLine{13797     std::ostream\& cout() \{ \textcolor{keywordflow}{return} std::cout; \}}
\DoxyCodeLine{13798     std::ostream\& cerr() \{ \textcolor{keywordflow}{return} std::cerr; \}}
\DoxyCodeLine{13799     std::ostream\& clog() \{ \textcolor{keywordflow}{return} std::clog; \}}
\DoxyCodeLine{13800 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{13801 \}}
\DoxyCodeLine{13802 \textcolor{comment}{// end catch\_stream.cpp}}
\DoxyCodeLine{13803 \textcolor{comment}{// start catch\_string\_manip.cpp}}
\DoxyCodeLine{13804 }
\DoxyCodeLine{13805 \textcolor{preprocessor}{\#include <algorithm>}}
\DoxyCodeLine{13806 \textcolor{preprocessor}{\#include <ostream>}}
\DoxyCodeLine{13807 \textcolor{preprocessor}{\#include <cstring>}}
\DoxyCodeLine{13808 \textcolor{preprocessor}{\#include <cctype>}}
\DoxyCodeLine{13809 \textcolor{preprocessor}{\#include <vector>}}
\DoxyCodeLine{13810 }
\DoxyCodeLine{13811 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{13812 }
\DoxyCodeLine{13813     \textcolor{keyword}{namespace }\{}
\DoxyCodeLine{13814         \textcolor{keywordtype}{char} toLowerCh(\textcolor{keywordtype}{char} c) \{}
\DoxyCodeLine{13815             \textcolor{keywordflow}{return} \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{char}\textcolor{keyword}{>}( std::tolower( \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char}\textcolor{keyword}{>}(c) ) );}
\DoxyCodeLine{13816         \}}
\DoxyCodeLine{13817     \}}
\DoxyCodeLine{13818 }
\DoxyCodeLine{13819     \textcolor{keywordtype}{bool} startsWith( std::string \textcolor{keyword}{const}\& s, std::string \textcolor{keyword}{const}\& prefix ) \{}
\DoxyCodeLine{13820         \textcolor{keywordflow}{return} s.size() >= prefix.size() \&\& std::equal(prefix.begin(), prefix.end(), s.begin());}
\DoxyCodeLine{13821     \}}
\DoxyCodeLine{13822     \textcolor{keywordtype}{bool} startsWith( std::string \textcolor{keyword}{const}\& s, \textcolor{keywordtype}{char} prefix ) \{}
\DoxyCodeLine{13823         \textcolor{keywordflow}{return} !s.empty() \&\& s[0] == prefix;}
\DoxyCodeLine{13824     \}}
\DoxyCodeLine{13825     \textcolor{keywordtype}{bool} endsWith( std::string \textcolor{keyword}{const}\& s, std::string \textcolor{keyword}{const}\& suffix ) \{}
\DoxyCodeLine{13826         \textcolor{keywordflow}{return} s.size() >= suffix.size() \&\& std::equal(suffix.rbegin(), suffix.rend(), s.rbegin());}
\DoxyCodeLine{13827     \}}
\DoxyCodeLine{13828     \textcolor{keywordtype}{bool} endsWith( std::string \textcolor{keyword}{const}\& s, \textcolor{keywordtype}{char} suffix ) \{}
\DoxyCodeLine{13829         \textcolor{keywordflow}{return} !s.empty() \&\& s[s.size()-\/1] == suffix;}
\DoxyCodeLine{13830     \}}
\DoxyCodeLine{13831     \textcolor{keywordtype}{bool} contains( std::string \textcolor{keyword}{const}\& s, std::string \textcolor{keyword}{const}\& infix ) \{}
\DoxyCodeLine{13832         \textcolor{keywordflow}{return} s.find( infix ) != std::string::npos;}
\DoxyCodeLine{13833     \}}
\DoxyCodeLine{13834     \textcolor{keywordtype}{void} toLowerInPlace( std::string\& s ) \{}
\DoxyCodeLine{13835         std::transform( s.begin(), s.end(), s.begin(), toLowerCh );}
\DoxyCodeLine{13836     \}}
\DoxyCodeLine{13837     std::string toLower( std::string \textcolor{keyword}{const}\& s ) \{}
\DoxyCodeLine{13838         std::string lc = s;}
\DoxyCodeLine{13839         toLowerInPlace( lc );}
\DoxyCodeLine{13840         \textcolor{keywordflow}{return} lc;}
\DoxyCodeLine{13841     \}}
\DoxyCodeLine{13842     std::string trim( std::string \textcolor{keyword}{const}\& str ) \{}
\DoxyCodeLine{13843         \textcolor{keyword}{static} \textcolor{keywordtype}{char} \textcolor{keyword}{const}* whitespaceChars = \textcolor{stringliteral}{"{}\(\backslash\)n\(\backslash\)r\(\backslash\)t "{}};}
\DoxyCodeLine{13844         std::string::size\_type start = str.find\_first\_not\_of( whitespaceChars );}
\DoxyCodeLine{13845         std::string::size\_type end = str.find\_last\_not\_of( whitespaceChars );}
\DoxyCodeLine{13846 }
\DoxyCodeLine{13847         \textcolor{keywordflow}{return} start != std::string::npos ? str.substr( start, 1+end-\/start ) : std::string();}
\DoxyCodeLine{13848     \}}
\DoxyCodeLine{13849 }
\DoxyCodeLine{13850     StringRef trim(StringRef ref) \{}
\DoxyCodeLine{13851         \textcolor{keyword}{const} \textcolor{keyword}{auto} is\_ws = [](\textcolor{keywordtype}{char} c) \{}
\DoxyCodeLine{13852             \textcolor{keywordflow}{return} c == \textcolor{charliteral}{' '} || c == \textcolor{charliteral}{'\(\backslash\)t'} || c == \textcolor{charliteral}{'\(\backslash\)n'} || c == \textcolor{charliteral}{'\(\backslash\)r'};}
\DoxyCodeLine{13853         \};}
\DoxyCodeLine{13854         \textcolor{keywordtype}{size\_t} real\_begin = 0;}
\DoxyCodeLine{13855         \textcolor{keywordflow}{while} (real\_begin < ref.size() \&\& is\_ws(ref[real\_begin])) \{ ++real\_begin; \}}
\DoxyCodeLine{13856         \textcolor{keywordtype}{size\_t} real\_end = ref.size();}
\DoxyCodeLine{13857         \textcolor{keywordflow}{while} (real\_end > real\_begin \&\& is\_ws(ref[real\_end -\/ 1])) \{ -\/-\/real\_end; \}}
\DoxyCodeLine{13858 }
\DoxyCodeLine{13859         \textcolor{keywordflow}{return} ref.substr(real\_begin, real\_end -\/ real\_begin);}
\DoxyCodeLine{13860     \}}
\DoxyCodeLine{13861 }
\DoxyCodeLine{13862     \textcolor{keywordtype}{bool} replaceInPlace( std::string\& str, std::string \textcolor{keyword}{const}\& replaceThis, std::string \textcolor{keyword}{const}\& withThis ) \{}
\DoxyCodeLine{13863         \textcolor{keywordtype}{bool} replaced = \textcolor{keyword}{false};}
\DoxyCodeLine{13864         std::size\_t i = str.find( replaceThis );}
\DoxyCodeLine{13865         \textcolor{keywordflow}{while}( i != std::string::npos ) \{}
\DoxyCodeLine{13866             replaced = \textcolor{keyword}{true};}
\DoxyCodeLine{13867             str = str.substr( 0, i ) + withThis + str.substr( i+replaceThis.size() );}
\DoxyCodeLine{13868             \textcolor{keywordflow}{if}( i < str.size()-\/withThis.size() )}
\DoxyCodeLine{13869                 i = str.find( replaceThis, i+withThis.size() );}
\DoxyCodeLine{13870             \textcolor{keywordflow}{else}}
\DoxyCodeLine{13871                 i = std::string::npos;}
\DoxyCodeLine{13872         \}}
\DoxyCodeLine{13873         \textcolor{keywordflow}{return} replaced;}
\DoxyCodeLine{13874     \}}
\DoxyCodeLine{13875 }
\DoxyCodeLine{13876     std::vector<StringRef> splitStringRef( StringRef str, \textcolor{keywordtype}{char} delimiter ) \{}
\DoxyCodeLine{13877         std::vector<StringRef> subStrings;}
\DoxyCodeLine{13878         std::size\_t start = 0;}
\DoxyCodeLine{13879         \textcolor{keywordflow}{for}(std::size\_t pos = 0; pos < str.size(); ++pos ) \{}
\DoxyCodeLine{13880             \textcolor{keywordflow}{if}( str[pos] == delimiter ) \{}
\DoxyCodeLine{13881                 \textcolor{keywordflow}{if}( pos -\/ start > 1 )}
\DoxyCodeLine{13882                     subStrings.push\_back( str.substr( start, pos-\/start ) );}
\DoxyCodeLine{13883                 start = pos+1;}
\DoxyCodeLine{13884             \}}
\DoxyCodeLine{13885         \}}
\DoxyCodeLine{13886         \textcolor{keywordflow}{if}( start < str.size() )}
\DoxyCodeLine{13887             subStrings.push\_back( str.substr( start, str.size()-\/start ) );}
\DoxyCodeLine{13888         \textcolor{keywordflow}{return} subStrings;}
\DoxyCodeLine{13889     \}}
\DoxyCodeLine{13890 }
\DoxyCodeLine{13891     pluralise::pluralise( std::size\_t count, std::string \textcolor{keyword}{const}\& label )}
\DoxyCodeLine{13892     :   m\_count( count ),}
\DoxyCodeLine{13893         m\_label( label )}
\DoxyCodeLine{13894     \{\}}
\DoxyCodeLine{13895 }
\DoxyCodeLine{13896     std::ostream\& operator << ( std::ostream\& os, pluralise \textcolor{keyword}{const}\& pluraliser ) \{}
\DoxyCodeLine{13897         os << pluraliser.m\_count << \textcolor{charliteral}{' '} << pluraliser.m\_label;}
\DoxyCodeLine{13898         \textcolor{keywordflow}{if}( pluraliser.m\_count != 1 )}
\DoxyCodeLine{13899             os << \textcolor{charliteral}{'s'};}
\DoxyCodeLine{13900         \textcolor{keywordflow}{return} os;}
\DoxyCodeLine{13901     \}}
\DoxyCodeLine{13902 }
\DoxyCodeLine{13903 \}}
\DoxyCodeLine{13904 \textcolor{comment}{// end catch\_string\_manip.cpp}}
\DoxyCodeLine{13905 \textcolor{comment}{// start catch\_stringref.cpp}}
\DoxyCodeLine{13906 }
\DoxyCodeLine{13907 \textcolor{preprocessor}{\#include <algorithm>}}
\DoxyCodeLine{13908 \textcolor{preprocessor}{\#include <ostream>}}
\DoxyCodeLine{13909 \textcolor{preprocessor}{\#include <cstring>}}
\DoxyCodeLine{13910 \textcolor{preprocessor}{\#include <cstdint>}}
\DoxyCodeLine{13911 }
\DoxyCodeLine{13912 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{13913     StringRef::StringRef( \textcolor{keywordtype}{char} \textcolor{keyword}{const}* rawChars ) noexcept}
\DoxyCodeLine{13914     : StringRef( rawChars, \textcolor{keyword}{static\_cast<}StringRef::size\_type\textcolor{keyword}{>}(std::strlen(rawChars) ) )}
\DoxyCodeLine{13915     \{\}}
\DoxyCodeLine{13916 }
\DoxyCodeLine{13917     \textcolor{keyword}{auto} StringRef::c\_str() const -\/> \textcolor{keywordtype}{char} const* \{}
\DoxyCodeLine{13918         CATCH\_ENFORCE(isNullTerminated(), \textcolor{stringliteral}{"{}Called StringRef::c\_str() on a non-\/null-\/terminated instance"{}});}
\DoxyCodeLine{13919         \textcolor{keywordflow}{return} m\_start;}
\DoxyCodeLine{13920     \}}
\DoxyCodeLine{13921     \textcolor{keyword}{auto} StringRef::data() const noexcept -\/> \textcolor{keywordtype}{char} const* \{}
\DoxyCodeLine{13922         \textcolor{keywordflow}{return} m\_start;}
\DoxyCodeLine{13923     \}}
\DoxyCodeLine{13924 }
\DoxyCodeLine{13925     \textcolor{keyword}{auto} StringRef::substr( size\_type start, size\_type size ) \textcolor{keyword}{const} \textcolor{keyword}{noexcept} -\/> StringRef \{}
\DoxyCodeLine{13926         \textcolor{keywordflow}{if} (start < m\_size) \{}
\DoxyCodeLine{13927             \textcolor{keywordflow}{return} StringRef(m\_start + start, (std::min)(m\_size -\/ start, size));}
\DoxyCodeLine{13928         \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{13929             \textcolor{keywordflow}{return} StringRef();}
\DoxyCodeLine{13930         \}}
\DoxyCodeLine{13931     \}}
\DoxyCodeLine{13932     \textcolor{keyword}{auto} StringRef::operator == ( StringRef \textcolor{keyword}{const}\& other ) \textcolor{keyword}{const} \textcolor{keyword}{noexcept} -\/> \textcolor{keywordtype}{bool} \{}
\DoxyCodeLine{13933         \textcolor{keywordflow}{return} m\_size == other.m\_size}
\DoxyCodeLine{13934             \&\& (std::memcmp( m\_start, other.m\_start, m\_size ) == 0);}
\DoxyCodeLine{13935     \}}
\DoxyCodeLine{13936 }
\DoxyCodeLine{13937     \textcolor{keyword}{auto} operator << ( std::ostream\& os, StringRef \textcolor{keyword}{const}\& str ) -\/> std::ostream\& \{}
\DoxyCodeLine{13938         \textcolor{keywordflow}{return} os.write(str.data(), str.size());}
\DoxyCodeLine{13939     \}}
\DoxyCodeLine{13940 }
\DoxyCodeLine{13941     \textcolor{keyword}{auto} operator+=( std::string\& lhs, StringRef \textcolor{keyword}{const}\& rhs ) -\/> std::string\& \{}
\DoxyCodeLine{13942         lhs.append(rhs.data(), rhs.size());}
\DoxyCodeLine{13943         \textcolor{keywordflow}{return} lhs;}
\DoxyCodeLine{13944     \}}
\DoxyCodeLine{13945 }
\DoxyCodeLine{13946 \} \textcolor{comment}{// namespace Catch}}
\DoxyCodeLine{13947 \textcolor{comment}{// end catch\_stringref.cpp}}
\DoxyCodeLine{13948 \textcolor{comment}{// start catch\_tag\_alias.cpp}}
\DoxyCodeLine{13949 }
\DoxyCodeLine{13950 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{13951     TagAlias::TagAlias(std::string \textcolor{keyword}{const} \& \_tag, SourceLineInfo \_lineInfo): tag(\_tag), lineInfo(\_lineInfo) \{\}}
\DoxyCodeLine{13952 \}}
\DoxyCodeLine{13953 \textcolor{comment}{// end catch\_tag\_alias.cpp}}
\DoxyCodeLine{13954 \textcolor{comment}{// start catch\_tag\_alias\_autoregistrar.cpp}}
\DoxyCodeLine{13955 }
\DoxyCodeLine{13956 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{13957 }
\DoxyCodeLine{13958     RegistrarForTagAliases::RegistrarForTagAliases(\textcolor{keywordtype}{char} \textcolor{keyword}{const}* alias, \textcolor{keywordtype}{char} \textcolor{keyword}{const}* tag, SourceLineInfo \textcolor{keyword}{const}\& lineInfo) \{}
\DoxyCodeLine{13959         CATCH\_TRY \{}
\DoxyCodeLine{13960             getMutableRegistryHub().registerTagAlias(alias, tag, lineInfo);}
\DoxyCodeLine{13961         \} CATCH\_CATCH\_ALL \{}
\DoxyCodeLine{13962             \textcolor{comment}{// Do not throw when constructing global objects, instead register the exception to be processed later}}
\DoxyCodeLine{13963             getMutableRegistryHub().registerStartupException();}
\DoxyCodeLine{13964         \}}
\DoxyCodeLine{13965     \}}
\DoxyCodeLine{13966 }
\DoxyCodeLine{13967 \}}
\DoxyCodeLine{13968 \textcolor{comment}{// end catch\_tag\_alias\_autoregistrar.cpp}}
\DoxyCodeLine{13969 \textcolor{comment}{// start catch\_tag\_alias\_registry.cpp}}
\DoxyCodeLine{13970 }
\DoxyCodeLine{13971 \textcolor{preprocessor}{\#include <sstream>}}
\DoxyCodeLine{13972 }
\DoxyCodeLine{13973 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{13974 }
\DoxyCodeLine{13975     TagAliasRegistry::\string~TagAliasRegistry() \{\}}
\DoxyCodeLine{13976 }
\DoxyCodeLine{13977     TagAlias \textcolor{keyword}{const}* TagAliasRegistry::find( std::string \textcolor{keyword}{const}\& alias )\textcolor{keyword}{ const }\{}
\DoxyCodeLine{13978         \textcolor{keyword}{auto} it = m\_registry.find( alias );}
\DoxyCodeLine{13979         \textcolor{keywordflow}{if}( it != m\_registry.end() )}
\DoxyCodeLine{13980             \textcolor{keywordflow}{return} \&(it-\/>second);}
\DoxyCodeLine{13981         \textcolor{keywordflow}{else}}
\DoxyCodeLine{13982             \textcolor{keywordflow}{return} \textcolor{keyword}{nullptr};}
\DoxyCodeLine{13983     \}}
\DoxyCodeLine{13984 }
\DoxyCodeLine{13985     std::string TagAliasRegistry::expandAliases( std::string \textcolor{keyword}{const}\& unexpandedTestSpec )\textcolor{keyword}{ const }\{}
\DoxyCodeLine{13986         std::string expandedTestSpec = unexpandedTestSpec;}
\DoxyCodeLine{13987         \textcolor{keywordflow}{for}( \textcolor{keyword}{auto} \textcolor{keyword}{const}\& registryKvp : m\_registry ) \{}
\DoxyCodeLine{13988             std::size\_t pos = expandedTestSpec.find( registryKvp.first );}
\DoxyCodeLine{13989             \textcolor{keywordflow}{if}( pos != std::string::npos ) \{}
\DoxyCodeLine{13990                 expandedTestSpec =  expandedTestSpec.substr( 0, pos ) +}
\DoxyCodeLine{13991                                     registryKvp.second.tag +}
\DoxyCodeLine{13992                                     expandedTestSpec.substr( pos + registryKvp.first.size() );}
\DoxyCodeLine{13993             \}}
\DoxyCodeLine{13994         \}}
\DoxyCodeLine{13995         \textcolor{keywordflow}{return} expandedTestSpec;}
\DoxyCodeLine{13996     \}}
\DoxyCodeLine{13997 }
\DoxyCodeLine{13998     \textcolor{keywordtype}{void} TagAliasRegistry::add( std::string \textcolor{keyword}{const}\& alias, std::string \textcolor{keyword}{const}\& tag, SourceLineInfo \textcolor{keyword}{const}\& lineInfo ) \{}
\DoxyCodeLine{13999         CATCH\_ENFORCE( startsWith(alias, \textcolor{stringliteral}{"{}[@"{}}) \&\& endsWith(alias, \textcolor{charliteral}{']'}),}
\DoxyCodeLine{14000                       \textcolor{stringliteral}{"{}error: tag alias, '"{}} << alias << \textcolor{stringliteral}{"{}' is not of the form [@alias name].\(\backslash\)n"{}} << lineInfo );}
\DoxyCodeLine{14001 }
\DoxyCodeLine{14002         CATCH\_ENFORCE( m\_registry.insert(std::make\_pair(alias, TagAlias(tag, lineInfo))).second,}
\DoxyCodeLine{14003                       \textcolor{stringliteral}{"{}error: tag alias, '"{}} << alias << \textcolor{stringliteral}{"{}' already registered.\(\backslash\)n"{}}}
\DoxyCodeLine{14004                       << \textcolor{stringliteral}{"{}\(\backslash\)tFirst seen at: "{}} << find(alias)-\/>lineInfo << \textcolor{stringliteral}{"{}\(\backslash\)n"{}}}
\DoxyCodeLine{14005                       << \textcolor{stringliteral}{"{}\(\backslash\)tRedefined at: "{}} << lineInfo );}
\DoxyCodeLine{14006     \}}
\DoxyCodeLine{14007 }
\DoxyCodeLine{14008     ITagAliasRegistry::\string~ITagAliasRegistry() \{\}}
\DoxyCodeLine{14009 }
\DoxyCodeLine{14010     ITagAliasRegistry \textcolor{keyword}{const}\& ITagAliasRegistry::get() \{}
\DoxyCodeLine{14011         \textcolor{keywordflow}{return} getRegistryHub().getTagAliasRegistry();}
\DoxyCodeLine{14012     \}}
\DoxyCodeLine{14013 }
\DoxyCodeLine{14014 \} \textcolor{comment}{// end namespace Catch}}
\DoxyCodeLine{14015 \textcolor{comment}{// end catch\_tag\_alias\_registry.cpp}}
\DoxyCodeLine{14016 \textcolor{comment}{// start catch\_test\_case\_info.cpp}}
\DoxyCodeLine{14017 }
\DoxyCodeLine{14018 \textcolor{preprocessor}{\#include <cctype>}}
\DoxyCodeLine{14019 \textcolor{preprocessor}{\#include <exception>}}
\DoxyCodeLine{14020 \textcolor{preprocessor}{\#include <algorithm>}}
\DoxyCodeLine{14021 \textcolor{preprocessor}{\#include <sstream>}}
\DoxyCodeLine{14022 }
\DoxyCodeLine{14023 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{14024 }
\DoxyCodeLine{14025     \textcolor{keyword}{namespace }\{}
\DoxyCodeLine{14026         TestCaseInfo::SpecialProperties parseSpecialTag( std::string \textcolor{keyword}{const}\& tag ) \{}
\DoxyCodeLine{14027             \textcolor{keywordflow}{if}( startsWith( tag, \textcolor{charliteral}{'.'} ) ||}
\DoxyCodeLine{14028                 tag == \textcolor{stringliteral}{"{}!hide"{}} )}
\DoxyCodeLine{14029                 \textcolor{keywordflow}{return} TestCaseInfo::IsHidden;}
\DoxyCodeLine{14030             \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}( tag == \textcolor{stringliteral}{"{}!throws"{}} )}
\DoxyCodeLine{14031                 \textcolor{keywordflow}{return} TestCaseInfo::Throws;}
\DoxyCodeLine{14032             \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}( tag == \textcolor{stringliteral}{"{}!shouldfail"{}} )}
\DoxyCodeLine{14033                 \textcolor{keywordflow}{return} TestCaseInfo::ShouldFail;}
\DoxyCodeLine{14034             \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}( tag == \textcolor{stringliteral}{"{}!mayfail"{}} )}
\DoxyCodeLine{14035                 \textcolor{keywordflow}{return} TestCaseInfo::MayFail;}
\DoxyCodeLine{14036             \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}( tag == \textcolor{stringliteral}{"{}!nonportable"{}} )}
\DoxyCodeLine{14037                 \textcolor{keywordflow}{return} TestCaseInfo::NonPortable;}
\DoxyCodeLine{14038             \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}( tag == \textcolor{stringliteral}{"{}!benchmark"{}} )}
\DoxyCodeLine{14039                 \textcolor{keywordflow}{return} \textcolor{keyword}{static\_cast<}TestCaseInfo::SpecialProperties\textcolor{keyword}{>}( TestCaseInfo::Benchmark | TestCaseInfo::IsHidden );}
\DoxyCodeLine{14040             \textcolor{keywordflow}{else}}
\DoxyCodeLine{14041                 \textcolor{keywordflow}{return} TestCaseInfo::None;}
\DoxyCodeLine{14042         \}}
\DoxyCodeLine{14043         \textcolor{keywordtype}{bool} isReservedTag( std::string \textcolor{keyword}{const}\& tag ) \{}
\DoxyCodeLine{14044             \textcolor{keywordflow}{return} parseSpecialTag( tag ) == TestCaseInfo::None \&\& tag.size() > 0 \&\& !std::isalnum( \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char}\textcolor{keyword}{>}(tag[0]) );}
\DoxyCodeLine{14045         \}}
\DoxyCodeLine{14046         \textcolor{keywordtype}{void} enforceNotReservedTag( std::string \textcolor{keyword}{const}\& tag, SourceLineInfo \textcolor{keyword}{const}\& \_lineInfo ) \{}
\DoxyCodeLine{14047             CATCH\_ENFORCE( !isReservedTag(tag),}
\DoxyCodeLine{14048                           \textcolor{stringliteral}{"{}Tag name: ["{}} << tag << \textcolor{stringliteral}{"{}] is not allowed.\(\backslash\)n"{}}}
\DoxyCodeLine{14049                           << \textcolor{stringliteral}{"{}Tag names starting with non alphanumeric characters are reserved\(\backslash\)n"{}}}
\DoxyCodeLine{14050                           << \_lineInfo );}
\DoxyCodeLine{14051         \}}
\DoxyCodeLine{14052     \}}
\DoxyCodeLine{14053 }
\DoxyCodeLine{14054     TestCase makeTestCase(  ITestInvoker* \_testCase,}
\DoxyCodeLine{14055                             std::string \textcolor{keyword}{const}\& \_className,}
\DoxyCodeLine{14056                             NameAndTags \textcolor{keyword}{const}\& nameAndTags,}
\DoxyCodeLine{14057                             SourceLineInfo \textcolor{keyword}{const}\& \_lineInfo )}
\DoxyCodeLine{14058     \{}
\DoxyCodeLine{14059         \textcolor{keywordtype}{bool} isHidden = \textcolor{keyword}{false};}
\DoxyCodeLine{14060 }
\DoxyCodeLine{14061         \textcolor{comment}{// Parse out tags}}
\DoxyCodeLine{14062         std::vector<std::string> tags;}
\DoxyCodeLine{14063         std::string desc, tag;}
\DoxyCodeLine{14064         \textcolor{keywordtype}{bool} inTag = \textcolor{keyword}{false};}
\DoxyCodeLine{14065         \textcolor{keywordflow}{for} (\textcolor{keywordtype}{char} c : nameAndTags.tags) \{}
\DoxyCodeLine{14066             \textcolor{keywordflow}{if}( !inTag ) \{}
\DoxyCodeLine{14067                 \textcolor{keywordflow}{if}( c == \textcolor{charliteral}{'['} )}
\DoxyCodeLine{14068                     inTag = \textcolor{keyword}{true};}
\DoxyCodeLine{14069                 \textcolor{keywordflow}{else}}
\DoxyCodeLine{14070                     desc += c;}
\DoxyCodeLine{14071             \}}
\DoxyCodeLine{14072             \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{14073                 \textcolor{keywordflow}{if}( c == \textcolor{charliteral}{']'} ) \{}
\DoxyCodeLine{14074                     TestCaseInfo::SpecialProperties prop = parseSpecialTag( tag );}
\DoxyCodeLine{14075                     \textcolor{keywordflow}{if}( ( prop \& TestCaseInfo::IsHidden ) != 0 )}
\DoxyCodeLine{14076                         isHidden = \textcolor{keyword}{true};}
\DoxyCodeLine{14077                     \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}( prop == TestCaseInfo::None )}
\DoxyCodeLine{14078                         enforceNotReservedTag( tag, \_lineInfo );}
\DoxyCodeLine{14079 }
\DoxyCodeLine{14080                     \textcolor{comment}{// Merged hide tags like `[.approvals]` should be added as}}
\DoxyCodeLine{14081                     \textcolor{comment}{// `[.][approvals]`. The `[.]` is added at later point, so}}
\DoxyCodeLine{14082                     \textcolor{comment}{// we only strip the prefix}}
\DoxyCodeLine{14083                     \textcolor{keywordflow}{if} (startsWith(tag, \textcolor{charliteral}{'.'}) \&\& tag.size() > 1) \{}
\DoxyCodeLine{14084                         tag.erase(0, 1);}
\DoxyCodeLine{14085                     \}}
\DoxyCodeLine{14086                     tags.push\_back( tag );}
\DoxyCodeLine{14087                     tag.clear();}
\DoxyCodeLine{14088                     inTag = \textcolor{keyword}{false};}
\DoxyCodeLine{14089                 \}}
\DoxyCodeLine{14090                 \textcolor{keywordflow}{else}}
\DoxyCodeLine{14091                     tag += c;}
\DoxyCodeLine{14092             \}}
\DoxyCodeLine{14093         \}}
\DoxyCodeLine{14094         \textcolor{keywordflow}{if}( isHidden ) \{}
\DoxyCodeLine{14095             \textcolor{comment}{// Add all "{}hidden"{} tags to make them behave identically}}
\DoxyCodeLine{14096             tags.insert( tags.end(), \{ \textcolor{stringliteral}{"{}."{}}, \textcolor{stringliteral}{"{}!hide"{}} \} );}
\DoxyCodeLine{14097         \}}
\DoxyCodeLine{14098 }
\DoxyCodeLine{14099         TestCaseInfo info( \textcolor{keyword}{static\_cast<}std::string\textcolor{keyword}{>}(nameAndTags.name), \_className, desc, tags, \_lineInfo );}
\DoxyCodeLine{14100         \textcolor{keywordflow}{return} TestCase( \_testCase, std::move(info) );}
\DoxyCodeLine{14101     \}}
\DoxyCodeLine{14102 }
\DoxyCodeLine{14103     \textcolor{keywordtype}{void} setTags( TestCaseInfo\& testCaseInfo, std::vector<std::string> tags ) \{}
\DoxyCodeLine{14104         std::sort(begin(tags), end(tags));}
\DoxyCodeLine{14105         tags.erase(std::unique(begin(tags), end(tags)), end(tags));}
\DoxyCodeLine{14106         testCaseInfo.lcaseTags.clear();}
\DoxyCodeLine{14107 }
\DoxyCodeLine{14108         \textcolor{keywordflow}{for}( \textcolor{keyword}{auto} \textcolor{keyword}{const}\& tag : tags ) \{}
\DoxyCodeLine{14109             std::string lcaseTag = toLower( tag );}
\DoxyCodeLine{14110             testCaseInfo.properties = \textcolor{keyword}{static\_cast<}TestCaseInfo::SpecialProperties\textcolor{keyword}{>}( testCaseInfo.properties | parseSpecialTag( lcaseTag ) );}
\DoxyCodeLine{14111             testCaseInfo.lcaseTags.push\_back( lcaseTag );}
\DoxyCodeLine{14112         \}}
\DoxyCodeLine{14113         testCaseInfo.tags = std::move(tags);}
\DoxyCodeLine{14114     \}}
\DoxyCodeLine{14115 }
\DoxyCodeLine{14116     TestCaseInfo::TestCaseInfo( std::string \textcolor{keyword}{const}\& \_name,}
\DoxyCodeLine{14117                                 std::string \textcolor{keyword}{const}\& \_className,}
\DoxyCodeLine{14118                                 std::string \textcolor{keyword}{const}\& \_description,}
\DoxyCodeLine{14119                                 std::vector<std::string> \textcolor{keyword}{const}\& \_tags,}
\DoxyCodeLine{14120                                 SourceLineInfo \textcolor{keyword}{const}\& \_lineInfo )}
\DoxyCodeLine{14121     :   name( \_name ),}
\DoxyCodeLine{14122         className( \_className ),}
\DoxyCodeLine{14123         description( \_description ),}
\DoxyCodeLine{14124         lineInfo( \_lineInfo ),}
\DoxyCodeLine{14125         properties( None )}
\DoxyCodeLine{14126     \{}
\DoxyCodeLine{14127         setTags( *\textcolor{keyword}{this}, \_tags );}
\DoxyCodeLine{14128     \}}
\DoxyCodeLine{14129 }
\DoxyCodeLine{14130     \textcolor{keywordtype}{bool} TestCaseInfo::isHidden()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{14131         \textcolor{keywordflow}{return} ( properties \& IsHidden ) != 0;}
\DoxyCodeLine{14132     \}}
\DoxyCodeLine{14133     \textcolor{keywordtype}{bool} TestCaseInfo::throws()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{14134         \textcolor{keywordflow}{return} ( properties \& Throws ) != 0;}
\DoxyCodeLine{14135     \}}
\DoxyCodeLine{14136     \textcolor{keywordtype}{bool} TestCaseInfo::okToFail()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{14137         \textcolor{keywordflow}{return} ( properties \& (ShouldFail | MayFail ) ) != 0;}
\DoxyCodeLine{14138     \}}
\DoxyCodeLine{14139     \textcolor{keywordtype}{bool} TestCaseInfo::expectedToFail()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{14140         \textcolor{keywordflow}{return} ( properties \& (ShouldFail ) ) != 0;}
\DoxyCodeLine{14141     \}}
\DoxyCodeLine{14142 }
\DoxyCodeLine{14143     std::string TestCaseInfo::tagsAsString()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{14144         std::string ret;}
\DoxyCodeLine{14145         \textcolor{comment}{// '[' and ']' per tag}}
\DoxyCodeLine{14146         std::size\_t full\_size = 2 * tags.size();}
\DoxyCodeLine{14147         \textcolor{keywordflow}{for} (\textcolor{keyword}{const} \textcolor{keyword}{auto}\& tag : tags) \{}
\DoxyCodeLine{14148             full\_size += tag.size();}
\DoxyCodeLine{14149         \}}
\DoxyCodeLine{14150         ret.reserve(full\_size);}
\DoxyCodeLine{14151         \textcolor{keywordflow}{for} (\textcolor{keyword}{const} \textcolor{keyword}{auto}\& tag : tags) \{}
\DoxyCodeLine{14152             ret.push\_back(\textcolor{charliteral}{'['});}
\DoxyCodeLine{14153             ret.append(tag);}
\DoxyCodeLine{14154             ret.push\_back(\textcolor{charliteral}{']'});}
\DoxyCodeLine{14155         \}}
\DoxyCodeLine{14156 }
\DoxyCodeLine{14157         \textcolor{keywordflow}{return} ret;}
\DoxyCodeLine{14158     \}}
\DoxyCodeLine{14159 }
\DoxyCodeLine{14160     TestCase::TestCase( ITestInvoker* testCase, TestCaseInfo\&\& info ) : TestCaseInfo( std::move(info) ), test( testCase ) \{\}}
\DoxyCodeLine{14161 }
\DoxyCodeLine{14162     TestCase TestCase::withName( std::string \textcolor{keyword}{const}\& \_newName )\textcolor{keyword}{ const }\{}
\DoxyCodeLine{14163         TestCase other( *\textcolor{keyword}{this} );}
\DoxyCodeLine{14164         other.name = \_newName;}
\DoxyCodeLine{14165         \textcolor{keywordflow}{return} other;}
\DoxyCodeLine{14166     \}}
\DoxyCodeLine{14167 }
\DoxyCodeLine{14168     \textcolor{keywordtype}{void} TestCase::invoke()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{14169         test-\/>invoke();}
\DoxyCodeLine{14170     \}}
\DoxyCodeLine{14171 }
\DoxyCodeLine{14172     \textcolor{keywordtype}{bool} TestCase::operator == ( TestCase \textcolor{keyword}{const}\& other )\textcolor{keyword}{ const }\{}
\DoxyCodeLine{14173         \textcolor{keywordflow}{return}  test.get() == other.test.get() \&\&}
\DoxyCodeLine{14174                 name == other.name \&\&}
\DoxyCodeLine{14175                 className == other.className;}
\DoxyCodeLine{14176     \}}
\DoxyCodeLine{14177 }
\DoxyCodeLine{14178     \textcolor{keywordtype}{bool} TestCase::operator < ( TestCase \textcolor{keyword}{const}\& other )\textcolor{keyword}{ const }\{}
\DoxyCodeLine{14179         \textcolor{keywordflow}{return} name < other.name;}
\DoxyCodeLine{14180     \}}
\DoxyCodeLine{14181 }
\DoxyCodeLine{14182     TestCaseInfo \textcolor{keyword}{const}\& TestCase::getTestCaseInfo()\textcolor{keyword}{ const}}
\DoxyCodeLine{14183 \textcolor{keyword}{    }\{}
\DoxyCodeLine{14184         \textcolor{keywordflow}{return} *\textcolor{keyword}{this};}
\DoxyCodeLine{14185     \}}
\DoxyCodeLine{14186 }
\DoxyCodeLine{14187 \} \textcolor{comment}{// end namespace Catch}}
\DoxyCodeLine{14188 \textcolor{comment}{// end catch\_test\_case\_info.cpp}}
\DoxyCodeLine{14189 \textcolor{comment}{// start catch\_test\_case\_registry\_impl.cpp}}
\DoxyCodeLine{14190 }
\DoxyCodeLine{14191 \textcolor{preprocessor}{\#include <algorithm>}}
\DoxyCodeLine{14192 \textcolor{preprocessor}{\#include <sstream>}}
\DoxyCodeLine{14193 }
\DoxyCodeLine{14194 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{14195 }
\DoxyCodeLine{14196     \textcolor{keyword}{namespace }\{}
\DoxyCodeLine{14197         \textcolor{keyword}{struct }TestHasher \{}
\DoxyCodeLine{14198             \textcolor{keyword}{using }hash\_t = uint64\_t;}
\DoxyCodeLine{14199 }
\DoxyCodeLine{14200             \textcolor{keyword}{explicit} TestHasher( hash\_t hashSuffix ):}
\DoxyCodeLine{14201                 m\_hashSuffix\{ hashSuffix \} \{\}}
\DoxyCodeLine{14202 }
\DoxyCodeLine{14203             uint32\_t operator()( TestCase \textcolor{keyword}{const}\& t )\textcolor{keyword}{ const }\{}
\DoxyCodeLine{14204                 \textcolor{comment}{// FNV-\/1a hash with multiplication fold.}}
\DoxyCodeLine{14205                 \textcolor{keyword}{const} hash\_t prime = 1099511628211u;}
\DoxyCodeLine{14206                 hash\_t hash = 14695981039346656037u;}
\DoxyCodeLine{14207                 \textcolor{keywordflow}{for} ( \textcolor{keyword}{const} \textcolor{keywordtype}{char} c : t.name ) \{}
\DoxyCodeLine{14208                     hash \string^= c;}
\DoxyCodeLine{14209                     hash *= prime;}
\DoxyCodeLine{14210                 \}}
\DoxyCodeLine{14211                 hash \string^= m\_hashSuffix;}
\DoxyCodeLine{14212                 hash *= prime;}
\DoxyCodeLine{14213                 \textcolor{keyword}{const} uint32\_t low\{ \textcolor{keyword}{static\_cast<}uint32\_t\textcolor{keyword}{>}( hash ) \};}
\DoxyCodeLine{14214                 \textcolor{keyword}{const} uint32\_t high\{ \textcolor{keyword}{static\_cast<}uint32\_t\textcolor{keyword}{>}( hash >> 32 ) \};}
\DoxyCodeLine{14215                 \textcolor{keywordflow}{return} low * high;}
\DoxyCodeLine{14216             \}}
\DoxyCodeLine{14217 }
\DoxyCodeLine{14218         \textcolor{keyword}{private}:}
\DoxyCodeLine{14219             hash\_t m\_hashSuffix;}
\DoxyCodeLine{14220         \};}
\DoxyCodeLine{14221     \} \textcolor{comment}{// end unnamed namespace}}
\DoxyCodeLine{14222 }
\DoxyCodeLine{14223     std::vector<TestCase> sortTests( IConfig \textcolor{keyword}{const}\& config, std::vector<TestCase> \textcolor{keyword}{const}\& unsortedTestCases ) \{}
\DoxyCodeLine{14224         \textcolor{keywordflow}{switch}( config.runOrder() ) \{}
\DoxyCodeLine{14225             \textcolor{keywordflow}{case} RunTests::InDeclarationOrder:}
\DoxyCodeLine{14226                 \textcolor{comment}{// already in declaration order}}
\DoxyCodeLine{14227                 \textcolor{keywordflow}{break};}
\DoxyCodeLine{14228 }
\DoxyCodeLine{14229             \textcolor{keywordflow}{case} RunTests::InLexicographicalOrder: \{}
\DoxyCodeLine{14230                 std::vector<TestCase> sorted = unsortedTestCases;}
\DoxyCodeLine{14231                 std::sort( sorted.begin(), sorted.end() );}
\DoxyCodeLine{14232                 \textcolor{keywordflow}{return} sorted;}
\DoxyCodeLine{14233             \}}
\DoxyCodeLine{14234 }
\DoxyCodeLine{14235             \textcolor{keywordflow}{case} RunTests::InRandomOrder: \{}
\DoxyCodeLine{14236                 seedRng( config );}
\DoxyCodeLine{14237                 TestHasher h\{ config.rngSeed() \};}
\DoxyCodeLine{14238 }
\DoxyCodeLine{14239                 \textcolor{keyword}{using }hashedTest = std::pair<TestHasher::hash\_t, TestCase const*>;}
\DoxyCodeLine{14240                 std::vector<hashedTest> indexed\_tests;}
\DoxyCodeLine{14241                 indexed\_tests.reserve( unsortedTestCases.size() );}
\DoxyCodeLine{14242 }
\DoxyCodeLine{14243                 \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} \textcolor{keyword}{const}\& testCase : unsortedTestCases) \{}
\DoxyCodeLine{14244                     indexed\_tests.emplace\_back(h(testCase), \&testCase);}
\DoxyCodeLine{14245                 \}}
\DoxyCodeLine{14246 }
\DoxyCodeLine{14247                 std::sort(indexed\_tests.begin(), indexed\_tests.end(),}
\DoxyCodeLine{14248                           [](hashedTest \textcolor{keyword}{const}\& lhs, hashedTest \textcolor{keyword}{const}\& rhs) \{}
\DoxyCodeLine{14249                           if (lhs.first == rhs.first) \{}
\DoxyCodeLine{14250                               return lhs.second-\/>name < rhs.second-\/>name;}
\DoxyCodeLine{14251                           \}}
\DoxyCodeLine{14252                           \textcolor{keywordflow}{return} lhs.first < rhs.first;}
\DoxyCodeLine{14253                 \});}
\DoxyCodeLine{14254 }
\DoxyCodeLine{14255                 std::vector<TestCase> sorted;}
\DoxyCodeLine{14256                 sorted.reserve( indexed\_tests.size() );}
\DoxyCodeLine{14257 }
\DoxyCodeLine{14258                 \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} \textcolor{keyword}{const}\& hashed : indexed\_tests) \{}
\DoxyCodeLine{14259                     sorted.emplace\_back(*hashed.second);}
\DoxyCodeLine{14260                 \}}
\DoxyCodeLine{14261 }
\DoxyCodeLine{14262                 \textcolor{keywordflow}{return} sorted;}
\DoxyCodeLine{14263             \}}
\DoxyCodeLine{14264         \}}
\DoxyCodeLine{14265         \textcolor{keywordflow}{return} unsortedTestCases;}
\DoxyCodeLine{14266     \}}
\DoxyCodeLine{14267 }
\DoxyCodeLine{14268     \textcolor{keywordtype}{bool} isThrowSafe( TestCase \textcolor{keyword}{const}\& testCase, IConfig \textcolor{keyword}{const}\& config ) \{}
\DoxyCodeLine{14269         \textcolor{keywordflow}{return} !testCase.throws() || config.allowThrows();}
\DoxyCodeLine{14270     \}}
\DoxyCodeLine{14271 }
\DoxyCodeLine{14272     \textcolor{keywordtype}{bool} matchTest( TestCase \textcolor{keyword}{const}\& testCase, TestSpec \textcolor{keyword}{const}\& testSpec, IConfig \textcolor{keyword}{const}\& config ) \{}
\DoxyCodeLine{14273         \textcolor{keywordflow}{return} testSpec.matches( testCase ) \&\& isThrowSafe( testCase, config );}
\DoxyCodeLine{14274     \}}
\DoxyCodeLine{14275 }
\DoxyCodeLine{14276     \textcolor{keywordtype}{void} enforceNoDuplicateTestCases( std::vector<TestCase> \textcolor{keyword}{const}\& functions ) \{}
\DoxyCodeLine{14277         std::set<TestCase> seenFunctions;}
\DoxyCodeLine{14278         \textcolor{keywordflow}{for}( \textcolor{keyword}{auto} \textcolor{keyword}{const}\& function : functions ) \{}
\DoxyCodeLine{14279             \textcolor{keyword}{auto} prev = seenFunctions.insert( function );}
\DoxyCodeLine{14280             CATCH\_ENFORCE( prev.second,}
\DoxyCodeLine{14281                     \textcolor{stringliteral}{"{}error: TEST\_CASE( \(\backslash\)"{}"{}} << function.name << \textcolor{stringliteral}{"{}\(\backslash\)"{} ) already defined.\(\backslash\)n"{}}}
\DoxyCodeLine{14282                     << \textcolor{stringliteral}{"{}\(\backslash\)tFirst seen at "{}} << prev.first-\/>getTestCaseInfo().lineInfo << \textcolor{stringliteral}{"{}\(\backslash\)n"{}}}
\DoxyCodeLine{14283                     << \textcolor{stringliteral}{"{}\(\backslash\)tRedefined at "{}} << function.getTestCaseInfo().lineInfo );}
\DoxyCodeLine{14284         \}}
\DoxyCodeLine{14285     \}}
\DoxyCodeLine{14286 }
\DoxyCodeLine{14287     std::vector<TestCase> filterTests( std::vector<TestCase> \textcolor{keyword}{const}\& testCases, TestSpec \textcolor{keyword}{const}\& testSpec, IConfig \textcolor{keyword}{const}\& config ) \{}
\DoxyCodeLine{14288         std::vector<TestCase> filtered;}
\DoxyCodeLine{14289         filtered.reserve( testCases.size() );}
\DoxyCodeLine{14290         \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} \textcolor{keyword}{const}\& testCase : testCases) \{}
\DoxyCodeLine{14291             \textcolor{keywordflow}{if} ((!testSpec.hasFilters() \&\& !testCase.isHidden()) ||}
\DoxyCodeLine{14292                 (testSpec.hasFilters() \&\& matchTest(testCase, testSpec, config))) \{}
\DoxyCodeLine{14293                 filtered.push\_back(testCase);}
\DoxyCodeLine{14294             \}}
\DoxyCodeLine{14295         \}}
\DoxyCodeLine{14296         \textcolor{keywordflow}{return} filtered;}
\DoxyCodeLine{14297     \}}
\DoxyCodeLine{14298     std::vector<TestCase> \textcolor{keyword}{const}\& getAllTestCasesSorted( IConfig \textcolor{keyword}{const}\& config ) \{}
\DoxyCodeLine{14299         \textcolor{keywordflow}{return} getRegistryHub().getTestCaseRegistry().getAllTestsSorted( config );}
\DoxyCodeLine{14300     \}}
\DoxyCodeLine{14301 }
\DoxyCodeLine{14302     \textcolor{keywordtype}{void} TestRegistry::registerTest( TestCase \textcolor{keyword}{const}\& testCase ) \{}
\DoxyCodeLine{14303         std::string name = testCase.getTestCaseInfo().name;}
\DoxyCodeLine{14304         \textcolor{keywordflow}{if}( name.empty() ) \{}
\DoxyCodeLine{14305             ReusableStringStream rss;}
\DoxyCodeLine{14306             rss << \textcolor{stringliteral}{"{}Anonymous test case "{}} << ++m\_unnamedCount;}
\DoxyCodeLine{14307             \textcolor{keywordflow}{return} registerTest( testCase.withName( rss.str() ) );}
\DoxyCodeLine{14308         \}}
\DoxyCodeLine{14309         m\_functions.push\_back( testCase );}
\DoxyCodeLine{14310     \}}
\DoxyCodeLine{14311 }
\DoxyCodeLine{14312     std::vector<TestCase> \textcolor{keyword}{const}\& TestRegistry::getAllTests()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{14313         \textcolor{keywordflow}{return} m\_functions;}
\DoxyCodeLine{14314     \}}
\DoxyCodeLine{14315     std::vector<TestCase> \textcolor{keyword}{const}\& TestRegistry::getAllTestsSorted( IConfig \textcolor{keyword}{const}\& config )\textcolor{keyword}{ const }\{}
\DoxyCodeLine{14316         \textcolor{keywordflow}{if}( m\_sortedFunctions.empty() )}
\DoxyCodeLine{14317             enforceNoDuplicateTestCases( m\_functions );}
\DoxyCodeLine{14318 }
\DoxyCodeLine{14319         \textcolor{keywordflow}{if}(  m\_currentSortOrder != config.runOrder() || m\_sortedFunctions.empty() ) \{}
\DoxyCodeLine{14320             m\_sortedFunctions = sortTests( config, m\_functions );}
\DoxyCodeLine{14321             m\_currentSortOrder = config.runOrder();}
\DoxyCodeLine{14322         \}}
\DoxyCodeLine{14323         \textcolor{keywordflow}{return} m\_sortedFunctions;}
\DoxyCodeLine{14324     \}}
\DoxyCodeLine{14325 }
\DoxyCodeLine{14327     TestInvokerAsFunction::TestInvokerAsFunction( \textcolor{keywordtype}{void}(*testAsFunction)() ) noexcept : m\_testAsFunction( testAsFunction ) \{\}}
\DoxyCodeLine{14328 }
\DoxyCodeLine{14329     \textcolor{keywordtype}{void} TestInvokerAsFunction::invoke()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{14330         m\_testAsFunction();}
\DoxyCodeLine{14331     \}}
\DoxyCodeLine{14332 }
\DoxyCodeLine{14333     std::string extractClassName( StringRef \textcolor{keyword}{const}\& classOrQualifiedMethodName ) \{}
\DoxyCodeLine{14334         std::string className(classOrQualifiedMethodName);}
\DoxyCodeLine{14335         \textcolor{keywordflow}{if}( startsWith( className, \textcolor{charliteral}{'\&'} ) )}
\DoxyCodeLine{14336         \{}
\DoxyCodeLine{14337             std::size\_t lastColons = className.rfind( \textcolor{stringliteral}{"{}::"{}} );}
\DoxyCodeLine{14338             std::size\_t penultimateColons = className.rfind( \textcolor{stringliteral}{"{}::"{}}, lastColons-\/1 );}
\DoxyCodeLine{14339             \textcolor{keywordflow}{if}( penultimateColons == std::string::npos )}
\DoxyCodeLine{14340                 penultimateColons = 1;}
\DoxyCodeLine{14341             className = className.substr( penultimateColons, lastColons-\/penultimateColons );}
\DoxyCodeLine{14342         \}}
\DoxyCodeLine{14343         \textcolor{keywordflow}{return} className;}
\DoxyCodeLine{14344     \}}
\DoxyCodeLine{14345 }
\DoxyCodeLine{14346 \} \textcolor{comment}{// end namespace Catch}}
\DoxyCodeLine{14347 \textcolor{comment}{// end catch\_test\_case\_registry\_impl.cpp}}
\DoxyCodeLine{14348 \textcolor{comment}{// start catch\_test\_case\_tracker.cpp}}
\DoxyCodeLine{14349 }
\DoxyCodeLine{14350 \textcolor{preprocessor}{\#include <algorithm>}}
\DoxyCodeLine{14351 \textcolor{preprocessor}{\#include <cassert>}}
\DoxyCodeLine{14352 \textcolor{preprocessor}{\#include <stdexcept>}}
\DoxyCodeLine{14353 \textcolor{preprocessor}{\#include <memory>}}
\DoxyCodeLine{14354 \textcolor{preprocessor}{\#include <sstream>}}
\DoxyCodeLine{14355 }
\DoxyCodeLine{14356 \textcolor{preprocessor}{\#if defined(\_\_clang\_\_)}}
\DoxyCodeLine{14357 \textcolor{preprocessor}{\#    pragma clang diagnostic push}}
\DoxyCodeLine{14358 \textcolor{preprocessor}{\#    pragma clang diagnostic ignored "{}-\/Wexit-\/time-\/destructors"{}}}
\DoxyCodeLine{14359 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{14360 }
\DoxyCodeLine{14361 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{14362 \textcolor{keyword}{namespace }TestCaseTracking \{}
\DoxyCodeLine{14363 }
\DoxyCodeLine{14364     NameAndLocation::NameAndLocation( std::string \textcolor{keyword}{const}\& \_name, SourceLineInfo \textcolor{keyword}{const}\& \_location )}
\DoxyCodeLine{14365     :   name( \_name ),}
\DoxyCodeLine{14366         location( \_location )}
\DoxyCodeLine{14367     \{\}}
\DoxyCodeLine{14368 }
\DoxyCodeLine{14369     ITracker::\string~ITracker() = \textcolor{keywordflow}{default};}
\DoxyCodeLine{14370 }
\DoxyCodeLine{14371     ITracker\& TrackerContext::startRun() \{}
\DoxyCodeLine{14372         m\_rootTracker = std::make\_shared<SectionTracker>( NameAndLocation( \textcolor{stringliteral}{"{}\{root\}"{}}, CATCH\_INTERNAL\_LINEINFO ), *\textcolor{keyword}{this}, \textcolor{keyword}{nullptr} );}
\DoxyCodeLine{14373         m\_currentTracker = \textcolor{keyword}{nullptr};}
\DoxyCodeLine{14374         m\_runState = Executing;}
\DoxyCodeLine{14375         \textcolor{keywordflow}{return} *m\_rootTracker;}
\DoxyCodeLine{14376     \}}
\DoxyCodeLine{14377 }
\DoxyCodeLine{14378     \textcolor{keywordtype}{void} TrackerContext::endRun() \{}
\DoxyCodeLine{14379         m\_rootTracker.reset();}
\DoxyCodeLine{14380         m\_currentTracker = \textcolor{keyword}{nullptr};}
\DoxyCodeLine{14381         m\_runState = NotStarted;}
\DoxyCodeLine{14382     \}}
\DoxyCodeLine{14383 }
\DoxyCodeLine{14384     \textcolor{keywordtype}{void} TrackerContext::startCycle() \{}
\DoxyCodeLine{14385         m\_currentTracker = m\_rootTracker.get();}
\DoxyCodeLine{14386         m\_runState = Executing;}
\DoxyCodeLine{14387     \}}
\DoxyCodeLine{14388     \textcolor{keywordtype}{void} TrackerContext::completeCycle() \{}
\DoxyCodeLine{14389         m\_runState = CompletedCycle;}
\DoxyCodeLine{14390     \}}
\DoxyCodeLine{14391 }
\DoxyCodeLine{14392     \textcolor{keywordtype}{bool} TrackerContext::completedCycle()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{14393         \textcolor{keywordflow}{return} m\_runState == CompletedCycle;}
\DoxyCodeLine{14394     \}}
\DoxyCodeLine{14395     ITracker\& TrackerContext::currentTracker() \{}
\DoxyCodeLine{14396         \textcolor{keywordflow}{return} *m\_currentTracker;}
\DoxyCodeLine{14397     \}}
\DoxyCodeLine{14398     \textcolor{keywordtype}{void} TrackerContext::setCurrentTracker( ITracker* tracker ) \{}
\DoxyCodeLine{14399         m\_currentTracker = tracker;}
\DoxyCodeLine{14400     \}}
\DoxyCodeLine{14401 }
\DoxyCodeLine{14402     TrackerBase::TrackerBase( NameAndLocation \textcolor{keyword}{const}\& nameAndLocation, TrackerContext\& ctx, ITracker* parent ):}
\DoxyCodeLine{14403         ITracker(nameAndLocation),}
\DoxyCodeLine{14404         m\_ctx( ctx ),}
\DoxyCodeLine{14405         m\_parent( parent )}
\DoxyCodeLine{14406     \{\}}
\DoxyCodeLine{14407 }
\DoxyCodeLine{14408     \textcolor{keywordtype}{bool} TrackerBase::isComplete()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{14409         \textcolor{keywordflow}{return} m\_runState == CompletedSuccessfully || m\_runState == Failed;}
\DoxyCodeLine{14410     \}}
\DoxyCodeLine{14411     \textcolor{keywordtype}{bool} TrackerBase::isSuccessfullyCompleted()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{14412         \textcolor{keywordflow}{return} m\_runState == CompletedSuccessfully;}
\DoxyCodeLine{14413     \}}
\DoxyCodeLine{14414     \textcolor{keywordtype}{bool} TrackerBase::isOpen()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{14415         \textcolor{keywordflow}{return} m\_runState != NotStarted \&\& !isComplete();}
\DoxyCodeLine{14416     \}}
\DoxyCodeLine{14417     \textcolor{keywordtype}{bool} TrackerBase::hasChildren()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{14418         \textcolor{keywordflow}{return} !m\_children.empty();}
\DoxyCodeLine{14419     \}}
\DoxyCodeLine{14420 }
\DoxyCodeLine{14421     \textcolor{keywordtype}{void} TrackerBase::addChild( ITrackerPtr \textcolor{keyword}{const}\& child ) \{}
\DoxyCodeLine{14422         m\_children.push\_back( child );}
\DoxyCodeLine{14423     \}}
\DoxyCodeLine{14424 }
\DoxyCodeLine{14425     ITrackerPtr TrackerBase::findChild( NameAndLocation \textcolor{keyword}{const}\& nameAndLocation ) \{}
\DoxyCodeLine{14426         \textcolor{keyword}{auto} it = std::find\_if( m\_children.begin(), m\_children.end(),}
\DoxyCodeLine{14427             [\&nameAndLocation]( ITrackerPtr \textcolor{keyword}{const}\& tracker )\{}
\DoxyCodeLine{14428                 return}
\DoxyCodeLine{14429                     tracker-\/>nameAndLocation().location == nameAndLocation.location \&\&}
\DoxyCodeLine{14430                     tracker-\/>nameAndLocation().name == nameAndLocation.name;}
\DoxyCodeLine{14431             \} );}
\DoxyCodeLine{14432         \textcolor{keywordflow}{return}( it != m\_children.end() )}
\DoxyCodeLine{14433             ? *it}
\DoxyCodeLine{14434             : \textcolor{keyword}{nullptr};}
\DoxyCodeLine{14435     \}}
\DoxyCodeLine{14436     ITracker\& TrackerBase::parent() \{}
\DoxyCodeLine{14437         assert( m\_parent ); \textcolor{comment}{// Should always be non-\/null except for root}}
\DoxyCodeLine{14438         \textcolor{keywordflow}{return} *m\_parent;}
\DoxyCodeLine{14439     \}}
\DoxyCodeLine{14440 }
\DoxyCodeLine{14441     \textcolor{keywordtype}{void} TrackerBase::openChild() \{}
\DoxyCodeLine{14442         \textcolor{keywordflow}{if}( m\_runState != ExecutingChildren ) \{}
\DoxyCodeLine{14443             m\_runState = ExecutingChildren;}
\DoxyCodeLine{14444             \textcolor{keywordflow}{if}( m\_parent )}
\DoxyCodeLine{14445                 m\_parent-\/>openChild();}
\DoxyCodeLine{14446         \}}
\DoxyCodeLine{14447     \}}
\DoxyCodeLine{14448 }
\DoxyCodeLine{14449     \textcolor{keywordtype}{bool} TrackerBase::isSectionTracker()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} \textcolor{keyword}{false}; \}}
\DoxyCodeLine{14450     \textcolor{keywordtype}{bool} TrackerBase::isGeneratorTracker()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} \textcolor{keyword}{false}; \}}
\DoxyCodeLine{14451 }
\DoxyCodeLine{14452     \textcolor{keywordtype}{void} TrackerBase::open() \{}
\DoxyCodeLine{14453         m\_runState = Executing;}
\DoxyCodeLine{14454         moveToThis();}
\DoxyCodeLine{14455         \textcolor{keywordflow}{if}( m\_parent )}
\DoxyCodeLine{14456             m\_parent-\/>openChild();}
\DoxyCodeLine{14457     \}}
\DoxyCodeLine{14458 }
\DoxyCodeLine{14459     \textcolor{keywordtype}{void} TrackerBase::close() \{}
\DoxyCodeLine{14460 }
\DoxyCodeLine{14461         \textcolor{comment}{// Close any still open children (e.g. generators)}}
\DoxyCodeLine{14462         \textcolor{keywordflow}{while}( \&m\_ctx.currentTracker() != \textcolor{keyword}{this} )}
\DoxyCodeLine{14463             m\_ctx.currentTracker().close();}
\DoxyCodeLine{14464 }
\DoxyCodeLine{14465         \textcolor{keywordflow}{switch}( m\_runState ) \{}
\DoxyCodeLine{14466             \textcolor{keywordflow}{case} NeedsAnotherRun:}
\DoxyCodeLine{14467                 \textcolor{keywordflow}{break};}
\DoxyCodeLine{14468 }
\DoxyCodeLine{14469             \textcolor{keywordflow}{case} Executing:}
\DoxyCodeLine{14470                 m\_runState = CompletedSuccessfully;}
\DoxyCodeLine{14471                 \textcolor{keywordflow}{break};}
\DoxyCodeLine{14472             \textcolor{keywordflow}{case} ExecutingChildren:}
\DoxyCodeLine{14473                 \textcolor{keywordflow}{if}( std::all\_of(m\_children.begin(), m\_children.end(), [](ITrackerPtr \textcolor{keyword}{const}\& t)\{ return t-\/>isComplete(); \}) )}
\DoxyCodeLine{14474                     m\_runState = CompletedSuccessfully;}
\DoxyCodeLine{14475                 \textcolor{keywordflow}{break};}
\DoxyCodeLine{14476 }
\DoxyCodeLine{14477             \textcolor{keywordflow}{case} NotStarted:}
\DoxyCodeLine{14478             \textcolor{keywordflow}{case} CompletedSuccessfully:}
\DoxyCodeLine{14479             \textcolor{keywordflow}{case} Failed:}
\DoxyCodeLine{14480                 CATCH\_INTERNAL\_ERROR( \textcolor{stringliteral}{"{}Illogical state: "{}} << m\_runState );}
\DoxyCodeLine{14481 }
\DoxyCodeLine{14482             \textcolor{keywordflow}{default}:}
\DoxyCodeLine{14483                 CATCH\_INTERNAL\_ERROR( \textcolor{stringliteral}{"{}Unknown state: "{}} << m\_runState );}
\DoxyCodeLine{14484         \}}
\DoxyCodeLine{14485         moveToParent();}
\DoxyCodeLine{14486         m\_ctx.completeCycle();}
\DoxyCodeLine{14487     \}}
\DoxyCodeLine{14488     \textcolor{keywordtype}{void} TrackerBase::fail() \{}
\DoxyCodeLine{14489         m\_runState = Failed;}
\DoxyCodeLine{14490         \textcolor{keywordflow}{if}( m\_parent )}
\DoxyCodeLine{14491             m\_parent-\/>markAsNeedingAnotherRun();}
\DoxyCodeLine{14492         moveToParent();}
\DoxyCodeLine{14493         m\_ctx.completeCycle();}
\DoxyCodeLine{14494     \}}
\DoxyCodeLine{14495     \textcolor{keywordtype}{void} TrackerBase::markAsNeedingAnotherRun() \{}
\DoxyCodeLine{14496         m\_runState = NeedsAnotherRun;}
\DoxyCodeLine{14497     \}}
\DoxyCodeLine{14498 }
\DoxyCodeLine{14499     \textcolor{keywordtype}{void} TrackerBase::moveToParent() \{}
\DoxyCodeLine{14500         assert( m\_parent );}
\DoxyCodeLine{14501         m\_ctx.setCurrentTracker( m\_parent );}
\DoxyCodeLine{14502     \}}
\DoxyCodeLine{14503     \textcolor{keywordtype}{void} TrackerBase::moveToThis() \{}
\DoxyCodeLine{14504         m\_ctx.setCurrentTracker( \textcolor{keyword}{this} );}
\DoxyCodeLine{14505     \}}
\DoxyCodeLine{14506 }
\DoxyCodeLine{14507     SectionTracker::SectionTracker( NameAndLocation \textcolor{keyword}{const}\& nameAndLocation, TrackerContext\& ctx, ITracker* parent )}
\DoxyCodeLine{14508     :   TrackerBase( nameAndLocation, ctx, parent ),}
\DoxyCodeLine{14509         m\_trimmed\_name(trim(nameAndLocation.name))}
\DoxyCodeLine{14510     \{}
\DoxyCodeLine{14511         \textcolor{keywordflow}{if}( parent ) \{}
\DoxyCodeLine{14512             \textcolor{keywordflow}{while}( !parent-\/>isSectionTracker() )}
\DoxyCodeLine{14513                 parent = \&parent-\/>parent();}
\DoxyCodeLine{14514 }
\DoxyCodeLine{14515             SectionTracker\& parentSection = \textcolor{keyword}{static\_cast<}SectionTracker\&\textcolor{keyword}{>}( *parent );}
\DoxyCodeLine{14516             addNextFilters( parentSection.m\_filters );}
\DoxyCodeLine{14517         \}}
\DoxyCodeLine{14518     \}}
\DoxyCodeLine{14519 }
\DoxyCodeLine{14520     \textcolor{keywordtype}{bool} SectionTracker::isComplete()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{14521         \textcolor{keywordtype}{bool} complete = \textcolor{keyword}{true};}
\DoxyCodeLine{14522 }
\DoxyCodeLine{14523         \textcolor{keywordflow}{if} (m\_filters.empty()}
\DoxyCodeLine{14524             || m\_filters[0] == \textcolor{stringliteral}{"{}"{}}}
\DoxyCodeLine{14525             || std::find(m\_filters.begin(), m\_filters.end(), m\_trimmed\_name) != m\_filters.end()) \{}
\DoxyCodeLine{14526             complete = TrackerBase::isComplete();}
\DoxyCodeLine{14527         \}}
\DoxyCodeLine{14528         \textcolor{keywordflow}{return} complete;}
\DoxyCodeLine{14529     \}}
\DoxyCodeLine{14530 }
\DoxyCodeLine{14531     \textcolor{keywordtype}{bool} SectionTracker::isSectionTracker()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} \textcolor{keyword}{true}; \}}
\DoxyCodeLine{14532 }
\DoxyCodeLine{14533     SectionTracker\& SectionTracker::acquire( TrackerContext\& ctx, NameAndLocation \textcolor{keyword}{const}\& nameAndLocation ) \{}
\DoxyCodeLine{14534         std::shared\_ptr<SectionTracker> section;}
\DoxyCodeLine{14535 }
\DoxyCodeLine{14536         ITracker\& currentTracker = ctx.currentTracker();}
\DoxyCodeLine{14537         \textcolor{keywordflow}{if}( ITrackerPtr childTracker = currentTracker.findChild( nameAndLocation ) ) \{}
\DoxyCodeLine{14538             assert( childTracker );}
\DoxyCodeLine{14539             assert( childTracker-\/>isSectionTracker() );}
\DoxyCodeLine{14540             section = std::static\_pointer\_cast<SectionTracker>( childTracker );}
\DoxyCodeLine{14541         \}}
\DoxyCodeLine{14542         \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{14543             section = std::make\_shared<SectionTracker>( nameAndLocation, ctx, \&currentTracker );}
\DoxyCodeLine{14544             currentTracker.addChild( section );}
\DoxyCodeLine{14545         \}}
\DoxyCodeLine{14546         \textcolor{keywordflow}{if}( !ctx.completedCycle() )}
\DoxyCodeLine{14547             section-\/>tryOpen();}
\DoxyCodeLine{14548         \textcolor{keywordflow}{return} *section;}
\DoxyCodeLine{14549     \}}
\DoxyCodeLine{14550 }
\DoxyCodeLine{14551     \textcolor{keywordtype}{void} SectionTracker::tryOpen() \{}
\DoxyCodeLine{14552         \textcolor{keywordflow}{if}( !isComplete() )}
\DoxyCodeLine{14553             open();}
\DoxyCodeLine{14554     \}}
\DoxyCodeLine{14555 }
\DoxyCodeLine{14556     \textcolor{keywordtype}{void} SectionTracker::addInitialFilters( std::vector<std::string> \textcolor{keyword}{const}\& filters ) \{}
\DoxyCodeLine{14557         \textcolor{keywordflow}{if}( !filters.empty() ) \{}
\DoxyCodeLine{14558             m\_filters.reserve( m\_filters.size() + filters.size() + 2 );}
\DoxyCodeLine{14559             m\_filters.emplace\_back(\textcolor{stringliteral}{"{}"{}}); \textcolor{comment}{// Root -\/ should never be consulted}}
\DoxyCodeLine{14560             m\_filters.emplace\_back(\textcolor{stringliteral}{"{}"{}}); \textcolor{comment}{// Test Case -\/ not a section filter}}
\DoxyCodeLine{14561             m\_filters.insert( m\_filters.end(), filters.begin(), filters.end() );}
\DoxyCodeLine{14562         \}}
\DoxyCodeLine{14563     \}}
\DoxyCodeLine{14564     \textcolor{keywordtype}{void} SectionTracker::addNextFilters( std::vector<std::string> \textcolor{keyword}{const}\& filters ) \{}
\DoxyCodeLine{14565         \textcolor{keywordflow}{if}( filters.size() > 1 )}
\DoxyCodeLine{14566             m\_filters.insert( m\_filters.end(), filters.begin()+1, filters.end() );}
\DoxyCodeLine{14567     \}}
\DoxyCodeLine{14568 }
\DoxyCodeLine{14569     std::vector<std::string> \textcolor{keyword}{const}\& SectionTracker::getFilters()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{14570         \textcolor{keywordflow}{return} m\_filters;}
\DoxyCodeLine{14571     \}}
\DoxyCodeLine{14572 }
\DoxyCodeLine{14573     std::string \textcolor{keyword}{const}\& SectionTracker::trimmedName()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{14574         \textcolor{keywordflow}{return} m\_trimmed\_name;}
\DoxyCodeLine{14575     \}}
\DoxyCodeLine{14576 }
\DoxyCodeLine{14577 \} \textcolor{comment}{// namespace TestCaseTracking}}
\DoxyCodeLine{14578 }
\DoxyCodeLine{14579 \textcolor{keyword}{using }TestCaseTracking::ITracker;}
\DoxyCodeLine{14580 \textcolor{keyword}{using }TestCaseTracking::TrackerContext;}
\DoxyCodeLine{14581 \textcolor{keyword}{using }TestCaseTracking::SectionTracker;}
\DoxyCodeLine{14582 }
\DoxyCodeLine{14583 \} \textcolor{comment}{// namespace Catch}}
\DoxyCodeLine{14584 }
\DoxyCodeLine{14585 \textcolor{preprocessor}{\#if defined(\_\_clang\_\_)}}
\DoxyCodeLine{14586 \textcolor{preprocessor}{\#    pragma clang diagnostic pop}}
\DoxyCodeLine{14587 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{14588 \textcolor{comment}{// end catch\_test\_case\_tracker.cpp}}
\DoxyCodeLine{14589 \textcolor{comment}{// start catch\_test\_registry.cpp}}
\DoxyCodeLine{14590 }
\DoxyCodeLine{14591 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{14592 }
\DoxyCodeLine{14593     \textcolor{keyword}{auto} makeTestInvoker( \textcolor{keywordtype}{void}(*testAsFunction)() ) noexcept -\/> ITestInvoker* \{}
\DoxyCodeLine{14594         \textcolor{keywordflow}{return} \textcolor{keyword}{new}(std::nothrow) TestInvokerAsFunction( testAsFunction );}
\DoxyCodeLine{14595     \}}
\DoxyCodeLine{14596 }
\DoxyCodeLine{14597     NameAndTags::NameAndTags( StringRef \textcolor{keyword}{const}\& name\_ , StringRef \textcolor{keyword}{const}\& tags\_ ) noexcept : name( name\_ ), tags( tags\_ ) \{\}}
\DoxyCodeLine{14598 }
\DoxyCodeLine{14599     AutoReg::AutoReg( ITestInvoker* invoker, SourceLineInfo \textcolor{keyword}{const}\& lineInfo, StringRef \textcolor{keyword}{const}\& classOrMethod, NameAndTags \textcolor{keyword}{const}\& nameAndTags ) \textcolor{keyword}{noexcept} \{}
\DoxyCodeLine{14600         CATCH\_TRY \{}
\DoxyCodeLine{14601             getMutableRegistryHub()}
\DoxyCodeLine{14602                     .registerTest(}
\DoxyCodeLine{14603                         makeTestCase(}
\DoxyCodeLine{14604                             invoker,}
\DoxyCodeLine{14605                             extractClassName( classOrMethod ),}
\DoxyCodeLine{14606                             nameAndTags,}
\DoxyCodeLine{14607                             lineInfo));}
\DoxyCodeLine{14608         \} CATCH\_CATCH\_ALL \{}
\DoxyCodeLine{14609             \textcolor{comment}{// Do not throw when constructing global objects, instead register the exception to be processed later}}
\DoxyCodeLine{14610             getMutableRegistryHub().registerStartupException();}
\DoxyCodeLine{14611         \}}
\DoxyCodeLine{14612     \}}
\DoxyCodeLine{14613 }
\DoxyCodeLine{14614     AutoReg::\string~AutoReg() = \textcolor{keywordflow}{default};}
\DoxyCodeLine{14615 \}}
\DoxyCodeLine{14616 \textcolor{comment}{// end catch\_test\_registry.cpp}}
\DoxyCodeLine{14617 \textcolor{comment}{// start catch\_test\_spec.cpp}}
\DoxyCodeLine{14618 }
\DoxyCodeLine{14619 \textcolor{preprocessor}{\#include <algorithm>}}
\DoxyCodeLine{14620 \textcolor{preprocessor}{\#include <string>}}
\DoxyCodeLine{14621 \textcolor{preprocessor}{\#include <vector>}}
\DoxyCodeLine{14622 \textcolor{preprocessor}{\#include <memory>}}
\DoxyCodeLine{14623 }
\DoxyCodeLine{14624 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{14625 }
\DoxyCodeLine{14626     TestSpec::Pattern::Pattern( std::string \textcolor{keyword}{const}\& name )}
\DoxyCodeLine{14627     : m\_name( name )}
\DoxyCodeLine{14628     \{\}}
\DoxyCodeLine{14629 }
\DoxyCodeLine{14630     TestSpec::Pattern::\string~Pattern() = \textcolor{keywordflow}{default};}
\DoxyCodeLine{14631 }
\DoxyCodeLine{14632     std::string \textcolor{keyword}{const}\& TestSpec::Pattern::name()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{14633         \textcolor{keywordflow}{return} m\_name;}
\DoxyCodeLine{14634     \}}
\DoxyCodeLine{14635 }
\DoxyCodeLine{14636     TestSpec::NamePattern::NamePattern( std::string \textcolor{keyword}{const}\& name, std::string \textcolor{keyword}{const}\& filterString )}
\DoxyCodeLine{14637     : Pattern( filterString )}
\DoxyCodeLine{14638     , m\_wildcardPattern( toLower( name ), CaseSensitive::No )}
\DoxyCodeLine{14639     \{\}}
\DoxyCodeLine{14640 }
\DoxyCodeLine{14641     \textcolor{keywordtype}{bool} TestSpec::NamePattern::matches( TestCaseInfo \textcolor{keyword}{const}\& testCase )\textcolor{keyword}{ const }\{}
\DoxyCodeLine{14642         \textcolor{keywordflow}{return} m\_wildcardPattern.matches( testCase.name );}
\DoxyCodeLine{14643     \}}
\DoxyCodeLine{14644 }
\DoxyCodeLine{14645     TestSpec::TagPattern::TagPattern( std::string \textcolor{keyword}{const}\& tag, std::string \textcolor{keyword}{const}\& filterString )}
\DoxyCodeLine{14646     : Pattern( filterString )}
\DoxyCodeLine{14647     , m\_tag( toLower( tag ) )}
\DoxyCodeLine{14648     \{\}}
\DoxyCodeLine{14649 }
\DoxyCodeLine{14650     \textcolor{keywordtype}{bool} TestSpec::TagPattern::matches( TestCaseInfo \textcolor{keyword}{const}\& testCase )\textcolor{keyword}{ const }\{}
\DoxyCodeLine{14651         \textcolor{keywordflow}{return} std::find(begin(testCase.lcaseTags),}
\DoxyCodeLine{14652                          end(testCase.lcaseTags),}
\DoxyCodeLine{14653                          m\_tag) != end(testCase.lcaseTags);}
\DoxyCodeLine{14654     \}}
\DoxyCodeLine{14655 }
\DoxyCodeLine{14656     TestSpec::ExcludedPattern::ExcludedPattern( PatternPtr \textcolor{keyword}{const}\& underlyingPattern )}
\DoxyCodeLine{14657     : Pattern( underlyingPattern-\/>name() )}
\DoxyCodeLine{14658     , m\_underlyingPattern( underlyingPattern )}
\DoxyCodeLine{14659     \{\}}
\DoxyCodeLine{14660 }
\DoxyCodeLine{14661     \textcolor{keywordtype}{bool} TestSpec::ExcludedPattern::matches( TestCaseInfo \textcolor{keyword}{const}\& testCase )\textcolor{keyword}{ const }\{}
\DoxyCodeLine{14662         \textcolor{keywordflow}{return} !m\_underlyingPattern-\/>matches( testCase );}
\DoxyCodeLine{14663     \}}
\DoxyCodeLine{14664 }
\DoxyCodeLine{14665     \textcolor{keywordtype}{bool} TestSpec::Filter::matches( TestCaseInfo \textcolor{keyword}{const}\& testCase )\textcolor{keyword}{ const }\{}
\DoxyCodeLine{14666         \textcolor{keywordflow}{return} std::all\_of( m\_patterns.begin(), m\_patterns.end(), [\&]( PatternPtr \textcolor{keyword}{const}\& p )\{ return p-\/>matches( testCase ); \} );}
\DoxyCodeLine{14667     \}}
\DoxyCodeLine{14668 }
\DoxyCodeLine{14669     std::string TestSpec::Filter::name()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{14670         std::string name;}
\DoxyCodeLine{14671         \textcolor{keywordflow}{for}( \textcolor{keyword}{auto} \textcolor{keyword}{const}\& p : m\_patterns )}
\DoxyCodeLine{14672             name += p-\/>name();}
\DoxyCodeLine{14673         \textcolor{keywordflow}{return} name;}
\DoxyCodeLine{14674     \}}
\DoxyCodeLine{14675 }
\DoxyCodeLine{14676     \textcolor{keywordtype}{bool} TestSpec::hasFilters()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{14677         \textcolor{keywordflow}{return} !m\_filters.empty();}
\DoxyCodeLine{14678     \}}
\DoxyCodeLine{14679 }
\DoxyCodeLine{14680     \textcolor{keywordtype}{bool} TestSpec::matches( TestCaseInfo \textcolor{keyword}{const}\& testCase )\textcolor{keyword}{ const }\{}
\DoxyCodeLine{14681         \textcolor{keywordflow}{return} std::any\_of( m\_filters.begin(), m\_filters.end(), [\&]( Filter \textcolor{keyword}{const}\& f )\{ return f.matches( testCase ); \} );}
\DoxyCodeLine{14682     \}}
\DoxyCodeLine{14683 }
\DoxyCodeLine{14684     TestSpec::Matches TestSpec::matchesByFilter( std::vector<TestCase> \textcolor{keyword}{const}\& testCases, IConfig \textcolor{keyword}{const}\& config )\textcolor{keyword}{ const}}
\DoxyCodeLine{14685 \textcolor{keyword}{    }\{}
\DoxyCodeLine{14686         Matches matches( m\_filters.size() );}
\DoxyCodeLine{14687         std::transform( m\_filters.begin(), m\_filters.end(), matches.begin(), [\&]( Filter \textcolor{keyword}{const}\& filter )\{}
\DoxyCodeLine{14688             std::vector<TestCase const*> currentMatches;}
\DoxyCodeLine{14689             for( auto const\& test : testCases )}
\DoxyCodeLine{14690                 if( isThrowSafe( test, config ) \&\& filter.matches( test ) )}
\DoxyCodeLine{14691                     currentMatches.emplace\_back( \&test );}
\DoxyCodeLine{14692             return FilterMatch\{ filter.name(), currentMatches \};}
\DoxyCodeLine{14693         \} );}
\DoxyCodeLine{14694         \textcolor{keywordflow}{return} matches;}
\DoxyCodeLine{14695     \}}
\DoxyCodeLine{14696 }
\DoxyCodeLine{14697     \textcolor{keyword}{const} TestSpec::vectorStrings\& TestSpec::getInvalidArgs()\textcolor{keyword}{ const}\{}
\DoxyCodeLine{14698         \textcolor{keywordflow}{return}  (m\_invalidArgs);}
\DoxyCodeLine{14699     \}}
\DoxyCodeLine{14700 }
\DoxyCodeLine{14701 \}}
\DoxyCodeLine{14702 \textcolor{comment}{// end catch\_test\_spec.cpp}}
\DoxyCodeLine{14703 \textcolor{comment}{// start catch\_test\_spec\_parser.cpp}}
\DoxyCodeLine{14704 }
\DoxyCodeLine{14705 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{14706 }
\DoxyCodeLine{14707     TestSpecParser::TestSpecParser( ITagAliasRegistry \textcolor{keyword}{const}\& tagAliases ) : m\_tagAliases( \&tagAliases ) \{\}}
\DoxyCodeLine{14708 }
\DoxyCodeLine{14709     TestSpecParser\& TestSpecParser::parse( std::string \textcolor{keyword}{const}\& arg ) \{}
\DoxyCodeLine{14710         m\_mode = None;}
\DoxyCodeLine{14711         m\_exclusion = \textcolor{keyword}{false};}
\DoxyCodeLine{14712         m\_arg = m\_tagAliases-\/>expandAliases( arg );}
\DoxyCodeLine{14713         m\_escapeChars.clear();}
\DoxyCodeLine{14714         m\_substring.reserve(m\_arg.size());}
\DoxyCodeLine{14715         m\_patternName.reserve(m\_arg.size());}
\DoxyCodeLine{14716         m\_realPatternPos = 0;}
\DoxyCodeLine{14717 }
\DoxyCodeLine{14718         \textcolor{keywordflow}{for}( m\_pos = 0; m\_pos < m\_arg.size(); ++m\_pos )}
\DoxyCodeLine{14719           \textcolor{comment}{//if visitChar fails}}
\DoxyCodeLine{14720            if( !visitChar( m\_arg[m\_pos] ) )\{}
\DoxyCodeLine{14721                m\_testSpec.m\_invalidArgs.push\_back(arg);}
\DoxyCodeLine{14722                \textcolor{keywordflow}{break};}
\DoxyCodeLine{14723            \}}
\DoxyCodeLine{14724         endMode();}
\DoxyCodeLine{14725         \textcolor{keywordflow}{return} *\textcolor{keyword}{this};}
\DoxyCodeLine{14726     \}}
\DoxyCodeLine{14727     TestSpec TestSpecParser::testSpec() \{}
\DoxyCodeLine{14728         addFilter();}
\DoxyCodeLine{14729         \textcolor{keywordflow}{return} m\_testSpec;}
\DoxyCodeLine{14730     \}}
\DoxyCodeLine{14731     \textcolor{keywordtype}{bool} TestSpecParser::visitChar( \textcolor{keywordtype}{char} c ) \{}
\DoxyCodeLine{14732         \textcolor{keywordflow}{if}( (m\_mode != EscapedName) \&\& (c == \textcolor{charliteral}{'\(\backslash\)\(\backslash\)'}) ) \{}
\DoxyCodeLine{14733             escape();}
\DoxyCodeLine{14734             addCharToPattern(c);}
\DoxyCodeLine{14735             \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{14736         \}\textcolor{keywordflow}{else} \textcolor{keywordflow}{if}((m\_mode != EscapedName) \&\& (c == \textcolor{charliteral}{','}) )  \{}
\DoxyCodeLine{14737             \textcolor{keywordflow}{return} separate();}
\DoxyCodeLine{14738         \}}
\DoxyCodeLine{14739 }
\DoxyCodeLine{14740         \textcolor{keywordflow}{switch}( m\_mode ) \{}
\DoxyCodeLine{14741         \textcolor{keywordflow}{case} None:}
\DoxyCodeLine{14742             \textcolor{keywordflow}{if}( processNoneChar( c ) )}
\DoxyCodeLine{14743                 \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{14744             \textcolor{keywordflow}{break};}
\DoxyCodeLine{14745         \textcolor{keywordflow}{case} Name:}
\DoxyCodeLine{14746             processNameChar( c );}
\DoxyCodeLine{14747             \textcolor{keywordflow}{break};}
\DoxyCodeLine{14748         \textcolor{keywordflow}{case} EscapedName:}
\DoxyCodeLine{14749             endMode();}
\DoxyCodeLine{14750             addCharToPattern(c);}
\DoxyCodeLine{14751             \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{14752         \textcolor{keywordflow}{default}:}
\DoxyCodeLine{14753         \textcolor{keywordflow}{case} Tag:}
\DoxyCodeLine{14754         \textcolor{keywordflow}{case} QuotedName:}
\DoxyCodeLine{14755             \textcolor{keywordflow}{if}( processOtherChar( c ) )}
\DoxyCodeLine{14756                 \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{14757             \textcolor{keywordflow}{break};}
\DoxyCodeLine{14758         \}}
\DoxyCodeLine{14759 }
\DoxyCodeLine{14760         m\_substring += c;}
\DoxyCodeLine{14761         \textcolor{keywordflow}{if}( !isControlChar( c ) ) \{}
\DoxyCodeLine{14762             m\_patternName += c;}
\DoxyCodeLine{14763             m\_realPatternPos++;}
\DoxyCodeLine{14764         \}}
\DoxyCodeLine{14765         \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{14766     \}}
\DoxyCodeLine{14767     \textcolor{comment}{// Two of the processing methods return true to signal the caller to return}}
\DoxyCodeLine{14768     \textcolor{comment}{// without adding the given character to the current pattern strings}}
\DoxyCodeLine{14769     \textcolor{keywordtype}{bool} TestSpecParser::processNoneChar( \textcolor{keywordtype}{char} c ) \{}
\DoxyCodeLine{14770         \textcolor{keywordflow}{switch}( c ) \{}
\DoxyCodeLine{14771         \textcolor{keywordflow}{case} \textcolor{charliteral}{' '}:}
\DoxyCodeLine{14772             \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{14773         \textcolor{keywordflow}{case} \textcolor{charliteral}{'\string~'}:}
\DoxyCodeLine{14774             m\_exclusion = \textcolor{keyword}{true};}
\DoxyCodeLine{14775             \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{14776         \textcolor{keywordflow}{case} \textcolor{charliteral}{'['}:}
\DoxyCodeLine{14777             startNewMode( Tag );}
\DoxyCodeLine{14778             \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{14779         \textcolor{keywordflow}{case} \textcolor{charliteral}{'"{}'}:}
\DoxyCodeLine{14780             startNewMode( QuotedName );}
\DoxyCodeLine{14781             \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{14782         \textcolor{keywordflow}{default}:}
\DoxyCodeLine{14783             startNewMode( Name );}
\DoxyCodeLine{14784             \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{14785         \}}
\DoxyCodeLine{14786     \}}
\DoxyCodeLine{14787     \textcolor{keywordtype}{void} TestSpecParser::processNameChar( \textcolor{keywordtype}{char} c ) \{}
\DoxyCodeLine{14788         \textcolor{keywordflow}{if}( c == \textcolor{charliteral}{'['} ) \{}
\DoxyCodeLine{14789             \textcolor{keywordflow}{if}( m\_substring == \textcolor{stringliteral}{"{}exclude:"{}} )}
\DoxyCodeLine{14790                 m\_exclusion = \textcolor{keyword}{true};}
\DoxyCodeLine{14791             \textcolor{keywordflow}{else}}
\DoxyCodeLine{14792                 endMode();}
\DoxyCodeLine{14793             startNewMode( Tag );}
\DoxyCodeLine{14794         \}}
\DoxyCodeLine{14795     \}}
\DoxyCodeLine{14796     \textcolor{keywordtype}{bool} TestSpecParser::processOtherChar( \textcolor{keywordtype}{char} c ) \{}
\DoxyCodeLine{14797         \textcolor{keywordflow}{if}( !isControlChar( c ) )}
\DoxyCodeLine{14798             \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{14799         m\_substring += c;}
\DoxyCodeLine{14800         endMode();}
\DoxyCodeLine{14801         \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{14802     \}}
\DoxyCodeLine{14803     \textcolor{keywordtype}{void} TestSpecParser::startNewMode( Mode mode ) \{}
\DoxyCodeLine{14804         m\_mode = mode;}
\DoxyCodeLine{14805     \}}
\DoxyCodeLine{14806     \textcolor{keywordtype}{void} TestSpecParser::endMode() \{}
\DoxyCodeLine{14807         \textcolor{keywordflow}{switch}( m\_mode ) \{}
\DoxyCodeLine{14808         \textcolor{keywordflow}{case} Name:}
\DoxyCodeLine{14809         \textcolor{keywordflow}{case} QuotedName:}
\DoxyCodeLine{14810             \textcolor{keywordflow}{return} addNamePattern();}
\DoxyCodeLine{14811         \textcolor{keywordflow}{case} Tag:}
\DoxyCodeLine{14812             \textcolor{keywordflow}{return} addTagPattern();}
\DoxyCodeLine{14813         \textcolor{keywordflow}{case} EscapedName:}
\DoxyCodeLine{14814             revertBackToLastMode();}
\DoxyCodeLine{14815             \textcolor{keywordflow}{return};}
\DoxyCodeLine{14816         \textcolor{keywordflow}{case} None:}
\DoxyCodeLine{14817         \textcolor{keywordflow}{default}:}
\DoxyCodeLine{14818             \textcolor{keywordflow}{return} startNewMode( None );}
\DoxyCodeLine{14819         \}}
\DoxyCodeLine{14820     \}}
\DoxyCodeLine{14821     \textcolor{keywordtype}{void} TestSpecParser::escape() \{}
\DoxyCodeLine{14822         saveLastMode();}
\DoxyCodeLine{14823         m\_mode = EscapedName;}
\DoxyCodeLine{14824         m\_escapeChars.push\_back(m\_realPatternPos);}
\DoxyCodeLine{14825     \}}
\DoxyCodeLine{14826     \textcolor{keywordtype}{bool} TestSpecParser::isControlChar( \textcolor{keywordtype}{char} c )\textcolor{keyword}{ const }\{}
\DoxyCodeLine{14827         \textcolor{keywordflow}{switch}( m\_mode ) \{}
\DoxyCodeLine{14828             \textcolor{keywordflow}{default}:}
\DoxyCodeLine{14829                 \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{14830             \textcolor{keywordflow}{case} None:}
\DoxyCodeLine{14831                 \textcolor{keywordflow}{return} c == \textcolor{charliteral}{'\string~'};}
\DoxyCodeLine{14832             \textcolor{keywordflow}{case} Name:}
\DoxyCodeLine{14833                 \textcolor{keywordflow}{return} c == \textcolor{charliteral}{'['};}
\DoxyCodeLine{14834             \textcolor{keywordflow}{case} EscapedName:}
\DoxyCodeLine{14835                 \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{14836             \textcolor{keywordflow}{case} QuotedName:}
\DoxyCodeLine{14837                 \textcolor{keywordflow}{return} c == \textcolor{charliteral}{'"{}'};}
\DoxyCodeLine{14838             \textcolor{keywordflow}{case} Tag:}
\DoxyCodeLine{14839                 \textcolor{keywordflow}{return} c == \textcolor{charliteral}{'['} || c == \textcolor{charliteral}{']'};}
\DoxyCodeLine{14840         \}}
\DoxyCodeLine{14841     \}}
\DoxyCodeLine{14842 }
\DoxyCodeLine{14843     \textcolor{keywordtype}{void} TestSpecParser::addFilter() \{}
\DoxyCodeLine{14844         \textcolor{keywordflow}{if}( !m\_currentFilter.m\_patterns.empty() ) \{}
\DoxyCodeLine{14845             m\_testSpec.m\_filters.push\_back( m\_currentFilter );}
\DoxyCodeLine{14846             m\_currentFilter = TestSpec::Filter();}
\DoxyCodeLine{14847         \}}
\DoxyCodeLine{14848     \}}
\DoxyCodeLine{14849 }
\DoxyCodeLine{14850     \textcolor{keywordtype}{void} TestSpecParser::saveLastMode() \{}
\DoxyCodeLine{14851       lastMode = m\_mode;}
\DoxyCodeLine{14852     \}}
\DoxyCodeLine{14853 }
\DoxyCodeLine{14854     \textcolor{keywordtype}{void} TestSpecParser::revertBackToLastMode() \{}
\DoxyCodeLine{14855       m\_mode = lastMode;}
\DoxyCodeLine{14856     \}}
\DoxyCodeLine{14857 }
\DoxyCodeLine{14858     \textcolor{keywordtype}{bool} TestSpecParser::separate() \{}
\DoxyCodeLine{14859       \textcolor{keywordflow}{if}( (m\_mode==QuotedName) || (m\_mode==Tag) )\{}
\DoxyCodeLine{14860          \textcolor{comment}{//invalid argument, signal failure to previous scope.}}
\DoxyCodeLine{14861          m\_mode = None;}
\DoxyCodeLine{14862          m\_pos = m\_arg.size();}
\DoxyCodeLine{14863          m\_substring.clear();}
\DoxyCodeLine{14864          m\_patternName.clear();}
\DoxyCodeLine{14865          m\_realPatternPos = 0;}
\DoxyCodeLine{14866          \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{14867       \}}
\DoxyCodeLine{14868       endMode();}
\DoxyCodeLine{14869       addFilter();}
\DoxyCodeLine{14870       \textcolor{keywordflow}{return} \textcolor{keyword}{true}; \textcolor{comment}{//success}}
\DoxyCodeLine{14871     \}}
\DoxyCodeLine{14872 }
\DoxyCodeLine{14873     std::string TestSpecParser::preprocessPattern() \{}
\DoxyCodeLine{14874         std::string token = m\_patternName;}
\DoxyCodeLine{14875         \textcolor{keywordflow}{for} (std::size\_t i = 0; i < m\_escapeChars.size(); ++i)}
\DoxyCodeLine{14876             token = token.substr(0, m\_escapeChars[i] -\/ i) + token.substr(m\_escapeChars[i] -\/ i + 1);}
\DoxyCodeLine{14877         m\_escapeChars.clear();}
\DoxyCodeLine{14878         \textcolor{keywordflow}{if} (startsWith(token, \textcolor{stringliteral}{"{}exclude:"{}})) \{}
\DoxyCodeLine{14879             m\_exclusion = \textcolor{keyword}{true};}
\DoxyCodeLine{14880             token = token.substr(8);}
\DoxyCodeLine{14881         \}}
\DoxyCodeLine{14882 }
\DoxyCodeLine{14883         m\_patternName.clear();}
\DoxyCodeLine{14884         m\_realPatternPos = 0;}
\DoxyCodeLine{14885 }
\DoxyCodeLine{14886         \textcolor{keywordflow}{return} token;}
\DoxyCodeLine{14887     \}}
\DoxyCodeLine{14888 }
\DoxyCodeLine{14889     \textcolor{keywordtype}{void} TestSpecParser::addNamePattern() \{}
\DoxyCodeLine{14890         \textcolor{keyword}{auto} token = preprocessPattern();}
\DoxyCodeLine{14891 }
\DoxyCodeLine{14892         \textcolor{keywordflow}{if} (!token.empty()) \{}
\DoxyCodeLine{14893             TestSpec::PatternPtr pattern = std::make\_shared<TestSpec::NamePattern>(token, m\_substring);}
\DoxyCodeLine{14894             \textcolor{keywordflow}{if} (m\_exclusion)}
\DoxyCodeLine{14895                 pattern = std::make\_shared<TestSpec::ExcludedPattern>(pattern);}
\DoxyCodeLine{14896             m\_currentFilter.m\_patterns.push\_back(pattern);}
\DoxyCodeLine{14897         \}}
\DoxyCodeLine{14898         m\_substring.clear();}
\DoxyCodeLine{14899         m\_exclusion = \textcolor{keyword}{false};}
\DoxyCodeLine{14900         m\_mode = None;}
\DoxyCodeLine{14901     \}}
\DoxyCodeLine{14902 }
\DoxyCodeLine{14903     \textcolor{keywordtype}{void} TestSpecParser::addTagPattern() \{}
\DoxyCodeLine{14904         \textcolor{keyword}{auto} token = preprocessPattern();}
\DoxyCodeLine{14905 }
\DoxyCodeLine{14906         \textcolor{keywordflow}{if} (!token.empty()) \{}
\DoxyCodeLine{14907             \textcolor{comment}{// If the tag pattern is the "{}hide and tag"{} shorthand (e.g. [.foo])}}
\DoxyCodeLine{14908             \textcolor{comment}{// we have to create a separate hide tag and shorten the real one}}
\DoxyCodeLine{14909             \textcolor{keywordflow}{if} (token.size() > 1 \&\& token[0] == \textcolor{charliteral}{'.'}) \{}
\DoxyCodeLine{14910                 token.erase(token.begin());}
\DoxyCodeLine{14911                 TestSpec::PatternPtr pattern = std::make\_shared<TestSpec::TagPattern>(\textcolor{stringliteral}{"{}."{}}, m\_substring);}
\DoxyCodeLine{14912                 \textcolor{keywordflow}{if} (m\_exclusion) \{}
\DoxyCodeLine{14913                     pattern = std::make\_shared<TestSpec::ExcludedPattern>(pattern);}
\DoxyCodeLine{14914                 \}}
\DoxyCodeLine{14915                 m\_currentFilter.m\_patterns.push\_back(pattern);}
\DoxyCodeLine{14916             \}}
\DoxyCodeLine{14917 }
\DoxyCodeLine{14918             TestSpec::PatternPtr pattern = std::make\_shared<TestSpec::TagPattern>(token, m\_substring);}
\DoxyCodeLine{14919 }
\DoxyCodeLine{14920             \textcolor{keywordflow}{if} (m\_exclusion) \{}
\DoxyCodeLine{14921                 pattern = std::make\_shared<TestSpec::ExcludedPattern>(pattern);}
\DoxyCodeLine{14922             \}}
\DoxyCodeLine{14923             m\_currentFilter.m\_patterns.push\_back(pattern);}
\DoxyCodeLine{14924         \}}
\DoxyCodeLine{14925         m\_substring.clear();}
\DoxyCodeLine{14926         m\_exclusion = \textcolor{keyword}{false};}
\DoxyCodeLine{14927         m\_mode = None;}
\DoxyCodeLine{14928     \}}
\DoxyCodeLine{14929 }
\DoxyCodeLine{14930     TestSpec parseTestSpec( std::string \textcolor{keyword}{const}\& arg ) \{}
\DoxyCodeLine{14931         \textcolor{keywordflow}{return} TestSpecParser( ITagAliasRegistry::get() ).parse( arg ).testSpec();}
\DoxyCodeLine{14932     \}}
\DoxyCodeLine{14933 }
\DoxyCodeLine{14934 \} \textcolor{comment}{// namespace Catch}}
\DoxyCodeLine{14935 \textcolor{comment}{// end catch\_test\_spec\_parser.cpp}}
\DoxyCodeLine{14936 \textcolor{comment}{// start catch\_timer.cpp}}
\DoxyCodeLine{14937 }
\DoxyCodeLine{14938 \textcolor{preprocessor}{\#include <chrono>}}
\DoxyCodeLine{14939 }
\DoxyCodeLine{14940 \textcolor{keyword}{static} \textcolor{keyword}{const} uint64\_t nanosecondsInSecond = 1000000000;}
\DoxyCodeLine{14941 }
\DoxyCodeLine{14942 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{14943 }
\DoxyCodeLine{14944     \textcolor{keyword}{auto} getCurrentNanosecondsSinceEpoch() -\/> uint64\_t \{}
\DoxyCodeLine{14945         \textcolor{keywordflow}{return} std::chrono::duration\_cast<std::chrono::nanoseconds>( std::chrono::high\_resolution\_clock::now().time\_since\_epoch() ).count();}
\DoxyCodeLine{14946     \}}
\DoxyCodeLine{14947 }
\DoxyCodeLine{14948     \textcolor{keyword}{namespace }\{}
\DoxyCodeLine{14949         \textcolor{keyword}{auto} estimateClockResolution() -\/> uint64\_t \{}
\DoxyCodeLine{14950             uint64\_t sum = 0;}
\DoxyCodeLine{14951             \textcolor{keyword}{static} \textcolor{keyword}{const} uint64\_t iterations = 1000000;}
\DoxyCodeLine{14952 }
\DoxyCodeLine{14953             \textcolor{keyword}{auto} startTime = getCurrentNanosecondsSinceEpoch();}
\DoxyCodeLine{14954 }
\DoxyCodeLine{14955             \textcolor{keywordflow}{for}( std::size\_t i = 0; i < iterations; ++i ) \{}
\DoxyCodeLine{14956 }
\DoxyCodeLine{14957                 uint64\_t ticks;}
\DoxyCodeLine{14958                 uint64\_t baseTicks = getCurrentNanosecondsSinceEpoch();}
\DoxyCodeLine{14959                 \textcolor{keywordflow}{do} \{}
\DoxyCodeLine{14960                     ticks = getCurrentNanosecondsSinceEpoch();}
\DoxyCodeLine{14961                 \} \textcolor{keywordflow}{while}( ticks == baseTicks );}
\DoxyCodeLine{14962 }
\DoxyCodeLine{14963                 \textcolor{keyword}{auto} delta = ticks -\/ baseTicks;}
\DoxyCodeLine{14964                 sum += delta;}
\DoxyCodeLine{14965 }
\DoxyCodeLine{14966                 \textcolor{comment}{// If we have been calibrating for over 3 seconds -\/-\/ the clock}}
\DoxyCodeLine{14967                 \textcolor{comment}{// is terrible and we should move on.}}
\DoxyCodeLine{14968                 \textcolor{comment}{// TBD: How to signal that the measured resolution is probably wrong?}}
\DoxyCodeLine{14969                 \textcolor{keywordflow}{if} (ticks > startTime + 3 * nanosecondsInSecond) \{}
\DoxyCodeLine{14970                     \textcolor{keywordflow}{return} sum / ( i + 1u );}
\DoxyCodeLine{14971                 \}}
\DoxyCodeLine{14972             \}}
\DoxyCodeLine{14973 }
\DoxyCodeLine{14974             \textcolor{comment}{// We're just taking the mean, here. To do better we could take the std. dev and exclude outliers}}
\DoxyCodeLine{14975             \textcolor{comment}{// -\/ and potentially do more iterations if there's a high variance.}}
\DoxyCodeLine{14976             \textcolor{keywordflow}{return} sum/iterations;}
\DoxyCodeLine{14977         \}}
\DoxyCodeLine{14978     \}}
\DoxyCodeLine{14979     \textcolor{keyword}{auto} getEstimatedClockResolution() -\/> uint64\_t \{}
\DoxyCodeLine{14980         \textcolor{keyword}{static} \textcolor{keyword}{auto} s\_resolution = estimateClockResolution();}
\DoxyCodeLine{14981         \textcolor{keywordflow}{return} s\_resolution;}
\DoxyCodeLine{14982     \}}
\DoxyCodeLine{14983 }
\DoxyCodeLine{14984     \textcolor{keywordtype}{void} Timer::start() \{}
\DoxyCodeLine{14985        m\_nanoseconds = getCurrentNanosecondsSinceEpoch();}
\DoxyCodeLine{14986     \}}
\DoxyCodeLine{14987     \textcolor{keyword}{auto} Timer::getElapsedNanoseconds() const -\/> uint64\_t \{}
\DoxyCodeLine{14988         \textcolor{keywordflow}{return} getCurrentNanosecondsSinceEpoch() -\/ m\_nanoseconds;}
\DoxyCodeLine{14989     \}}
\DoxyCodeLine{14990     \textcolor{keyword}{auto} Timer::getElapsedMicroseconds() const -\/> uint64\_t \{}
\DoxyCodeLine{14991         \textcolor{keywordflow}{return} getElapsedNanoseconds()/1000;}
\DoxyCodeLine{14992     \}}
\DoxyCodeLine{14993     \textcolor{keyword}{auto} Timer::getElapsedMilliseconds() const -\/> \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} \{}
\DoxyCodeLine{14994         \textcolor{keywordflow}{return} \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int}\textcolor{keyword}{>}(getElapsedMicroseconds()/1000);}
\DoxyCodeLine{14995     \}}
\DoxyCodeLine{14996     \textcolor{keyword}{auto} Timer::getElapsedSeconds() const -\/> \textcolor{keywordtype}{double} \{}
\DoxyCodeLine{14997         \textcolor{keywordflow}{return} getElapsedMicroseconds()/1000000.0;}
\DoxyCodeLine{14998     \}}
\DoxyCodeLine{14999 }
\DoxyCodeLine{15000 \} \textcolor{comment}{// namespace Catch}}
\DoxyCodeLine{15001 \textcolor{comment}{// end catch\_timer.cpp}}
\DoxyCodeLine{15002 \textcolor{comment}{// start catch\_tostring.cpp}}
\DoxyCodeLine{15003 }
\DoxyCodeLine{15004 \textcolor{preprocessor}{\#if defined(\_\_clang\_\_)}}
\DoxyCodeLine{15005 \textcolor{preprocessor}{\#    pragma clang diagnostic push}}
\DoxyCodeLine{15006 \textcolor{preprocessor}{\#    pragma clang diagnostic ignored "{}-\/Wexit-\/time-\/destructors"{}}}
\DoxyCodeLine{15007 \textcolor{preprocessor}{\#    pragma clang diagnostic ignored "{}-\/Wglobal-\/constructors"{}}}
\DoxyCodeLine{15008 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{15009 }
\DoxyCodeLine{15010 \textcolor{comment}{// Enable specific decls locally}}
\DoxyCodeLine{15011 \textcolor{preprocessor}{\#if !defined(CATCH\_CONFIG\_ENABLE\_CHRONO\_STRINGMAKER)}}
\DoxyCodeLine{15012 \textcolor{preprocessor}{\#define CATCH\_CONFIG\_ENABLE\_CHRONO\_STRINGMAKER}}
\DoxyCodeLine{15013 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{15014 }
\DoxyCodeLine{15015 \textcolor{preprocessor}{\#include <cmath>}}
\DoxyCodeLine{15016 \textcolor{preprocessor}{\#include <iomanip>}}
\DoxyCodeLine{15017 }
\DoxyCodeLine{15018 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{15019 }
\DoxyCodeLine{15020 \textcolor{keyword}{namespace }Detail \{}
\DoxyCodeLine{15021 }
\DoxyCodeLine{15022     \textcolor{keyword}{const} std::string unprintableString = \textcolor{stringliteral}{"{}\{?\}"{}};}
\DoxyCodeLine{15023 }
\DoxyCodeLine{15024     \textcolor{keyword}{namespace }\{}
\DoxyCodeLine{15025         \textcolor{keyword}{const} \textcolor{keywordtype}{int} hexThreshold = 255;}
\DoxyCodeLine{15026 }
\DoxyCodeLine{15027         \textcolor{keyword}{struct }Endianness \{}
\DoxyCodeLine{15028             \textcolor{keyword}{enum} Arch \{ Big, Little \};}
\DoxyCodeLine{15029 }
\DoxyCodeLine{15030             \textcolor{keyword}{static} Arch which() \{}
\DoxyCodeLine{15031                 \textcolor{keywordtype}{int} one = 1;}
\DoxyCodeLine{15032                 \textcolor{comment}{// If the lowest byte we read is non-\/zero, we can assume}}
\DoxyCodeLine{15033                 \textcolor{comment}{// that little endian format is used.}}
\DoxyCodeLine{15034                 \textcolor{keyword}{auto} value = *\textcolor{keyword}{reinterpret\_cast<}\textcolor{keywordtype}{char}*\textcolor{keyword}{>}(\&one);}
\DoxyCodeLine{15035                 \textcolor{keywordflow}{return} value ? Little : Big;}
\DoxyCodeLine{15036             \}}
\DoxyCodeLine{15037         \};}
\DoxyCodeLine{15038     \}}
\DoxyCodeLine{15039 }
\DoxyCodeLine{15040     std::string rawMemoryToString( \textcolor{keyword}{const} \textcolor{keywordtype}{void} *\textcolor{keywordtype}{object}, std::size\_t size ) \{}
\DoxyCodeLine{15041         \textcolor{comment}{// Reverse order for little endian architectures}}
\DoxyCodeLine{15042         \textcolor{keywordtype}{int} i = 0, end = \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{int}\textcolor{keyword}{>}( size ), inc = 1;}
\DoxyCodeLine{15043         \textcolor{keywordflow}{if}( Endianness::which() == Endianness::Little ) \{}
\DoxyCodeLine{15044             i = end-\/1;}
\DoxyCodeLine{15045             end = inc = -\/1;}
\DoxyCodeLine{15046         \}}
\DoxyCodeLine{15047 }
\DoxyCodeLine{15048         \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} \textcolor{keyword}{const} *bytes = \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} \textcolor{keyword}{const }*\textcolor{keyword}{>}(object);}
\DoxyCodeLine{15049         ReusableStringStream rss;}
\DoxyCodeLine{15050         rss << \textcolor{stringliteral}{"{}0x"{}} << std::setfill(\textcolor{charliteral}{'0'}) << std::hex;}
\DoxyCodeLine{15051         \textcolor{keywordflow}{for}( ; i != end; i += inc )}
\DoxyCodeLine{15052              rss << std::setw(2) << static\_cast<unsigned>(bytes[i]);}
\DoxyCodeLine{15053        \textcolor{keywordflow}{return} rss.str();}
\DoxyCodeLine{15054     \}}
\DoxyCodeLine{15055 \}}
\DoxyCodeLine{15056 }
\DoxyCodeLine{15057 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{15058 std::string fpToString( T value, \textcolor{keywordtype}{int} precision ) \{}
\DoxyCodeLine{15059     \textcolor{keywordflow}{if} (Catch::isnan(value)) \{}
\DoxyCodeLine{15060         \textcolor{keywordflow}{return} \textcolor{stringliteral}{"{}nan"{}};}
\DoxyCodeLine{15061     \}}
\DoxyCodeLine{15062 }
\DoxyCodeLine{15063     ReusableStringStream rss;}
\DoxyCodeLine{15064     rss << std::setprecision( precision )}
\DoxyCodeLine{15065         << std::fixed}
\DoxyCodeLine{15066         << value;}
\DoxyCodeLine{15067     std::string d = rss.str();}
\DoxyCodeLine{15068     std::size\_t i = d.find\_last\_not\_of( \textcolor{charliteral}{'0'} );}
\DoxyCodeLine{15069     \textcolor{keywordflow}{if}( i != std::string::npos \&\& i != d.size()-\/1 ) \{}
\DoxyCodeLine{15070         \textcolor{keywordflow}{if}( d[i] == \textcolor{charliteral}{'.'} )}
\DoxyCodeLine{15071             i++;}
\DoxyCodeLine{15072         d = d.substr( 0, i+1 );}
\DoxyCodeLine{15073     \}}
\DoxyCodeLine{15074     \textcolor{keywordflow}{return} d;}
\DoxyCodeLine{15075 \}}
\DoxyCodeLine{15076 }
\DoxyCodeLine{15078 \textcolor{comment}{//}}
\DoxyCodeLine{15079 \textcolor{comment}{//   Out-\/of-\/line defs for full specialization of StringMaker}}
\DoxyCodeLine{15080 \textcolor{comment}{//}}
\DoxyCodeLine{15082 \textcolor{comment}{}}
\DoxyCodeLine{15083 std::string StringMaker<std::string>::convert(\textcolor{keyword}{const} std::string\& str) \{}
\DoxyCodeLine{15084     \textcolor{keywordflow}{if} (!getCurrentContext().getConfig()-\/>showInvisibles()) \{}
\DoxyCodeLine{15085         \textcolor{keywordflow}{return} \textcolor{charliteral}{'"{}'} + str + '"{}';}
\DoxyCodeLine{15086     \}}
\DoxyCodeLine{15087 }
\DoxyCodeLine{15088     std::string s(\textcolor{stringliteral}{"{}\(\backslash\)"{}"{}});}
\DoxyCodeLine{15089     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{char} c : str) \{}
\DoxyCodeLine{15090         \textcolor{keywordflow}{switch} (c) \{}
\DoxyCodeLine{15091         \textcolor{keywordflow}{case} \textcolor{charliteral}{'\(\backslash\)n'}:}
\DoxyCodeLine{15092             s.append(\textcolor{stringliteral}{"{}\(\backslash\)\(\backslash\)n"{}});}
\DoxyCodeLine{15093             \textcolor{keywordflow}{break};}
\DoxyCodeLine{15094         \textcolor{keywordflow}{case} \textcolor{charliteral}{'\(\backslash\)t'}:}
\DoxyCodeLine{15095             s.append(\textcolor{stringliteral}{"{}\(\backslash\)\(\backslash\)t"{}});}
\DoxyCodeLine{15096             \textcolor{keywordflow}{break};}
\DoxyCodeLine{15097         \textcolor{keywordflow}{default}:}
\DoxyCodeLine{15098             s.push\_back(c);}
\DoxyCodeLine{15099             \textcolor{keywordflow}{break};}
\DoxyCodeLine{15100         \}}
\DoxyCodeLine{15101     \}}
\DoxyCodeLine{15102     s.append(\textcolor{stringliteral}{"{}\(\backslash\)"{}"{}});}
\DoxyCodeLine{15103     \textcolor{keywordflow}{return} s;}
\DoxyCodeLine{15104 \}}
\DoxyCodeLine{15105 }
\DoxyCodeLine{15106 \textcolor{preprocessor}{\#ifdef CATCH\_CONFIG\_CPP17\_STRING\_VIEW}}
\DoxyCodeLine{15107 std::string StringMaker<std::string\_view>::convert(std::string\_view str) \{}
\DoxyCodeLine{15108     return ::Catch::Detail::stringify(std::string\{ str \});}
\DoxyCodeLine{15109 \}}
\DoxyCodeLine{15110 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{15111 }
\DoxyCodeLine{15112 std::string StringMaker<char const*>::convert(\textcolor{keywordtype}{char} \textcolor{keyword}{const}* str) \{}
\DoxyCodeLine{15113     \textcolor{keywordflow}{if} (str) \{}
\DoxyCodeLine{15114         return ::Catch::Detail::stringify(std::string\{ str \});}
\DoxyCodeLine{15115     \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{15116         \textcolor{keywordflow}{return}\{ \textcolor{stringliteral}{"{}\{null string\}"{}} \};}
\DoxyCodeLine{15117     \}}
\DoxyCodeLine{15118 \}}
\DoxyCodeLine{15119 std::string StringMaker<char*>::convert(\textcolor{keywordtype}{char}* str) \{}
\DoxyCodeLine{15120     \textcolor{keywordflow}{if} (str) \{}
\DoxyCodeLine{15121         return ::Catch::Detail::stringify(std::string\{ str \});}
\DoxyCodeLine{15122     \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{15123         \textcolor{keywordflow}{return}\{ \textcolor{stringliteral}{"{}\{null string\}"{}} \};}
\DoxyCodeLine{15124     \}}
\DoxyCodeLine{15125 \}}
\DoxyCodeLine{15126 }
\DoxyCodeLine{15127 \textcolor{preprocessor}{\#ifdef CATCH\_CONFIG\_WCHAR}}
\DoxyCodeLine{15128 std::string StringMaker<std::wstring>::convert(\textcolor{keyword}{const} std::wstring\& wstr) \{}
\DoxyCodeLine{15129     std::string s;}
\DoxyCodeLine{15130     s.reserve(wstr.size());}
\DoxyCodeLine{15131     \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} c : wstr) \{}
\DoxyCodeLine{15132         s += (c <= 0xff) ? static\_cast<char>(c) : '?';}
\DoxyCodeLine{15133     \}}
\DoxyCodeLine{15134     return ::Catch::Detail::stringify(s);}
\DoxyCodeLine{15135 \}}
\DoxyCodeLine{15136 }
\DoxyCodeLine{15137 \textcolor{preprocessor}{\# ifdef CATCH\_CONFIG\_CPP17\_STRING\_VIEW}}
\DoxyCodeLine{15138 std::string StringMaker<std::wstring\_view>::convert(std::wstring\_view str) \{}
\DoxyCodeLine{15139     \textcolor{keywordflow}{return} StringMaker<std::wstring>::convert(std::wstring(str));}
\DoxyCodeLine{15140 \}}
\DoxyCodeLine{15141 \textcolor{preprocessor}{\# endif}}
\DoxyCodeLine{15142 }
\DoxyCodeLine{15143 std::string StringMaker<wchar\_t const*>::convert(\textcolor{keywordtype}{wchar\_t} \textcolor{keyword}{const} * str) \{}
\DoxyCodeLine{15144     \textcolor{keywordflow}{if} (str) \{}
\DoxyCodeLine{15145         return ::Catch::Detail::stringify(std::wstring\{ str \});}
\DoxyCodeLine{15146     \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{15147         \textcolor{keywordflow}{return}\{ \textcolor{stringliteral}{"{}\{null string\}"{}} \};}
\DoxyCodeLine{15148     \}}
\DoxyCodeLine{15149 \}}
\DoxyCodeLine{15150 std::string StringMaker<wchar\_t *>::convert(\textcolor{keywordtype}{wchar\_t} * str) \{}
\DoxyCodeLine{15151     \textcolor{keywordflow}{if} (str) \{}
\DoxyCodeLine{15152         return ::Catch::Detail::stringify(std::wstring\{ str \});}
\DoxyCodeLine{15153     \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{15154         \textcolor{keywordflow}{return}\{ \textcolor{stringliteral}{"{}\{null string\}"{}} \};}
\DoxyCodeLine{15155     \}}
\DoxyCodeLine{15156 \}}
\DoxyCodeLine{15157 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{15158 }
\DoxyCodeLine{15159 \textcolor{preprocessor}{\#if defined(CATCH\_CONFIG\_CPP17\_BYTE)}}
\DoxyCodeLine{15160 \textcolor{preprocessor}{\#include <cstddef>}}
\DoxyCodeLine{15161 std::string StringMaker<std::byte>::convert(std::byte value) \{}
\DoxyCodeLine{15162     return ::Catch::Detail::stringify(std::to\_integer<unsigned long long>(value));}
\DoxyCodeLine{15163 \}}
\DoxyCodeLine{15164 \textcolor{preprocessor}{\#endif }\textcolor{comment}{// defined(CATCH\_CONFIG\_CPP17\_BYTE)}}
\DoxyCodeLine{15165 }
\DoxyCodeLine{15166 std::string StringMaker<int>::convert(\textcolor{keywordtype}{int} value) \{}
\DoxyCodeLine{15167     return ::Catch::Detail::stringify(\textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{long} \textcolor{keywordtype}{long}\textcolor{keyword}{>}(value));}
\DoxyCodeLine{15168 \}}
\DoxyCodeLine{15169 std::string StringMaker<long>::convert(\textcolor{keywordtype}{long} value) \{}
\DoxyCodeLine{15170     return ::Catch::Detail::stringify(\textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{long} \textcolor{keywordtype}{long}\textcolor{keyword}{>}(value));}
\DoxyCodeLine{15171 \}}
\DoxyCodeLine{15172 std::string StringMaker<long long>::convert(\textcolor{keywordtype}{long} \textcolor{keywordtype}{long} value) \{}
\DoxyCodeLine{15173     ReusableStringStream rss;}
\DoxyCodeLine{15174     rss << value;}
\DoxyCodeLine{15175     \textcolor{keywordflow}{if} (value > Detail::hexThreshold) \{}
\DoxyCodeLine{15176         rss << \textcolor{stringliteral}{"{} (0x"{}} << std::hex << value << \textcolor{charliteral}{')'};}
\DoxyCodeLine{15177     \}}
\DoxyCodeLine{15178     \textcolor{keywordflow}{return} rss.str();}
\DoxyCodeLine{15179 \}}
\DoxyCodeLine{15180 }
\DoxyCodeLine{15181 std::string StringMaker<unsigned int>::convert(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} value) \{}
\DoxyCodeLine{15182     return ::Catch::Detail::stringify(\textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} \textcolor{keywordtype}{long}\textcolor{keyword}{>}(value));}
\DoxyCodeLine{15183 \}}
\DoxyCodeLine{15184 std::string StringMaker<unsigned long>::convert(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} value) \{}
\DoxyCodeLine{15185     return ::Catch::Detail::stringify(\textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} \textcolor{keywordtype}{long}\textcolor{keyword}{>}(value));}
\DoxyCodeLine{15186 \}}
\DoxyCodeLine{15187 std::string StringMaker<unsigned long long>::convert(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} value) \{}
\DoxyCodeLine{15188     ReusableStringStream rss;}
\DoxyCodeLine{15189     rss << value;}
\DoxyCodeLine{15190     \textcolor{keywordflow}{if} (value > Detail::hexThreshold) \{}
\DoxyCodeLine{15191         rss << \textcolor{stringliteral}{"{} (0x"{}} << std::hex << value << \textcolor{charliteral}{')'};}
\DoxyCodeLine{15192     \}}
\DoxyCodeLine{15193     \textcolor{keywordflow}{return} rss.str();}
\DoxyCodeLine{15194 \}}
\DoxyCodeLine{15195 }
\DoxyCodeLine{15196 std::string StringMaker<bool>::convert(\textcolor{keywordtype}{bool} b) \{}
\DoxyCodeLine{15197     \textcolor{keywordflow}{return} b ? \textcolor{stringliteral}{"{}true"{}} : \textcolor{stringliteral}{"{}false"{}};}
\DoxyCodeLine{15198 \}}
\DoxyCodeLine{15199 }
\DoxyCodeLine{15200 std::string StringMaker<signed char>::convert(\textcolor{keywordtype}{signed} \textcolor{keywordtype}{char} value) \{}
\DoxyCodeLine{15201     \textcolor{keywordflow}{if} (value == \textcolor{charliteral}{'\(\backslash\)r'}) \{}
\DoxyCodeLine{15202         \textcolor{keywordflow}{return} \textcolor{stringliteral}{"{}'\(\backslash\)\(\backslash\)r'"{}};}
\DoxyCodeLine{15203     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (value == \textcolor{charliteral}{'\(\backslash\)f'}) \{}
\DoxyCodeLine{15204         \textcolor{keywordflow}{return} \textcolor{stringliteral}{"{}'\(\backslash\)\(\backslash\)f'"{}};}
\DoxyCodeLine{15205     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (value == \textcolor{charliteral}{'\(\backslash\)n'}) \{}
\DoxyCodeLine{15206         \textcolor{keywordflow}{return} \textcolor{stringliteral}{"{}'\(\backslash\)\(\backslash\)n'"{}};}
\DoxyCodeLine{15207     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (value == \textcolor{charliteral}{'\(\backslash\)t'}) \{}
\DoxyCodeLine{15208         \textcolor{keywordflow}{return} \textcolor{stringliteral}{"{}'\(\backslash\)\(\backslash\)t'"{}};}
\DoxyCodeLine{15209     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (\textcolor{charliteral}{'\(\backslash\)0'} <= value \&\& value < \textcolor{charliteral}{' '}) \{}
\DoxyCodeLine{15210         return ::Catch::Detail::stringify(\textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int}\textcolor{keyword}{>}(value));}
\DoxyCodeLine{15211     \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{15212         \textcolor{keywordtype}{char} chstr[] = \textcolor{stringliteral}{"{}' '"{}};}
\DoxyCodeLine{15213         chstr[1] = value;}
\DoxyCodeLine{15214         \textcolor{keywordflow}{return} chstr;}
\DoxyCodeLine{15215     \}}
\DoxyCodeLine{15216 \}}
\DoxyCodeLine{15217 std::string StringMaker<char>::convert(\textcolor{keywordtype}{char} c) \{}
\DoxyCodeLine{15218     return ::Catch::Detail::stringify(\textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{signed} \textcolor{keywordtype}{char}\textcolor{keyword}{>}(c));}
\DoxyCodeLine{15219 \}}
\DoxyCodeLine{15220 std::string StringMaker<unsigned char>::convert(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} c) \{}
\DoxyCodeLine{15221     return ::Catch::Detail::stringify(\textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{char}\textcolor{keyword}{>}(c));}
\DoxyCodeLine{15222 \}}
\DoxyCodeLine{15223 }
\DoxyCodeLine{15224 std::string StringMaker<std::nullptr\_t>::convert(std::nullptr\_t) \{}
\DoxyCodeLine{15225     \textcolor{keywordflow}{return} \textcolor{stringliteral}{"{}nullptr"{}};}
\DoxyCodeLine{15226 \}}
\DoxyCodeLine{15227 }
\DoxyCodeLine{15228 \textcolor{keywordtype}{int} StringMaker<float>::precision = 5;}
\DoxyCodeLine{15229 }
\DoxyCodeLine{15230 std::string StringMaker<float>::convert(\textcolor{keywordtype}{float} value) \{}
\DoxyCodeLine{15231     \textcolor{keywordflow}{return} fpToString(value, precision) + 'f';}
\DoxyCodeLine{15232 \}}
\DoxyCodeLine{15233 }
\DoxyCodeLine{15234 \textcolor{keywordtype}{int} StringMaker<double>::precision = 10;}
\DoxyCodeLine{15235 }
\DoxyCodeLine{15236 std::string StringMaker<double>::convert(\textcolor{keywordtype}{double} value) \{}
\DoxyCodeLine{15237     \textcolor{keywordflow}{return} fpToString(value, precision);}
\DoxyCodeLine{15238 \}}
\DoxyCodeLine{15239 }
\DoxyCodeLine{15240 std::string ratio\_string<std::atto>::symbol() \{ \textcolor{keywordflow}{return} \textcolor{stringliteral}{"{}a"{}}; \}}
\DoxyCodeLine{15241 std::string ratio\_string<std::femto>::symbol() \{ \textcolor{keywordflow}{return} \textcolor{stringliteral}{"{}f"{}}; \}}
\DoxyCodeLine{15242 std::string ratio\_string<std::pico>::symbol() \{ \textcolor{keywordflow}{return} \textcolor{stringliteral}{"{}p"{}}; \}}
\DoxyCodeLine{15243 std::string ratio\_string<std::nano>::symbol() \{ \textcolor{keywordflow}{return} \textcolor{stringliteral}{"{}n"{}}; \}}
\DoxyCodeLine{15244 std::string ratio\_string<std::micro>::symbol() \{ \textcolor{keywordflow}{return} \textcolor{stringliteral}{"{}u"{}}; \}}
\DoxyCodeLine{15245 std::string ratio\_string<std::milli>::symbol() \{ \textcolor{keywordflow}{return} \textcolor{stringliteral}{"{}m"{}}; \}}
\DoxyCodeLine{15246 }
\DoxyCodeLine{15247 \} \textcolor{comment}{// end namespace Catch}}
\DoxyCodeLine{15248 }
\DoxyCodeLine{15249 \textcolor{preprocessor}{\#if defined(\_\_clang\_\_)}}
\DoxyCodeLine{15250 \textcolor{preprocessor}{\#    pragma clang diagnostic pop}}
\DoxyCodeLine{15251 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{15252 }
\DoxyCodeLine{15253 \textcolor{comment}{// end catch\_tostring.cpp}}
\DoxyCodeLine{15254 \textcolor{comment}{// start catch\_totals.cpp}}
\DoxyCodeLine{15255 }
\DoxyCodeLine{15256 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{15257 }
\DoxyCodeLine{15258     Counts Counts::operator -\/ ( Counts \textcolor{keyword}{const}\& other )\textcolor{keyword}{ const }\{}
\DoxyCodeLine{15259         Counts diff;}
\DoxyCodeLine{15260         diff.passed = passed -\/ other.passed;}
\DoxyCodeLine{15261         diff.failed = failed -\/ other.failed;}
\DoxyCodeLine{15262         diff.failedButOk = failedButOk -\/ other.failedButOk;}
\DoxyCodeLine{15263         \textcolor{keywordflow}{return} diff;}
\DoxyCodeLine{15264     \}}
\DoxyCodeLine{15265 }
\DoxyCodeLine{15266     Counts\& Counts::operator += ( Counts \textcolor{keyword}{const}\& other ) \{}
\DoxyCodeLine{15267         passed += other.passed;}
\DoxyCodeLine{15268         failed += other.failed;}
\DoxyCodeLine{15269         failedButOk += other.failedButOk;}
\DoxyCodeLine{15270         \textcolor{keywordflow}{return} *\textcolor{keyword}{this};}
\DoxyCodeLine{15271     \}}
\DoxyCodeLine{15272 }
\DoxyCodeLine{15273     std::size\_t Counts::total()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{15274         \textcolor{keywordflow}{return} passed + failed + failedButOk;}
\DoxyCodeLine{15275     \}}
\DoxyCodeLine{15276     \textcolor{keywordtype}{bool} Counts::allPassed()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{15277         \textcolor{keywordflow}{return} failed == 0 \&\& failedButOk == 0;}
\DoxyCodeLine{15278     \}}
\DoxyCodeLine{15279     \textcolor{keywordtype}{bool} Counts::allOk()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{15280         \textcolor{keywordflow}{return} failed == 0;}
\DoxyCodeLine{15281     \}}
\DoxyCodeLine{15282 }
\DoxyCodeLine{15283     Totals Totals::operator -\/ ( Totals \textcolor{keyword}{const}\& other )\textcolor{keyword}{ const }\{}
\DoxyCodeLine{15284         Totals diff;}
\DoxyCodeLine{15285         diff.assertions = assertions -\/ other.assertions;}
\DoxyCodeLine{15286         diff.testCases = testCases -\/ other.testCases;}
\DoxyCodeLine{15287         \textcolor{keywordflow}{return} diff;}
\DoxyCodeLine{15288     \}}
\DoxyCodeLine{15289 }
\DoxyCodeLine{15290     Totals\& Totals::operator += ( Totals \textcolor{keyword}{const}\& other ) \{}
\DoxyCodeLine{15291         assertions += other.assertions;}
\DoxyCodeLine{15292         testCases += other.testCases;}
\DoxyCodeLine{15293         \textcolor{keywordflow}{return} *\textcolor{keyword}{this};}
\DoxyCodeLine{15294     \}}
\DoxyCodeLine{15295 }
\DoxyCodeLine{15296     Totals Totals::delta( Totals \textcolor{keyword}{const}\& prevTotals )\textcolor{keyword}{ const }\{}
\DoxyCodeLine{15297         Totals diff = *\textcolor{keyword}{this} -\/ prevTotals;}
\DoxyCodeLine{15298         \textcolor{keywordflow}{if}( diff.assertions.failed > 0 )}
\DoxyCodeLine{15299             ++diff.testCases.failed;}
\DoxyCodeLine{15300         \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}( diff.assertions.failedButOk > 0 )}
\DoxyCodeLine{15301             ++diff.testCases.failedButOk;}
\DoxyCodeLine{15302         \textcolor{keywordflow}{else}}
\DoxyCodeLine{15303             ++diff.testCases.passed;}
\DoxyCodeLine{15304         \textcolor{keywordflow}{return} diff;}
\DoxyCodeLine{15305     \}}
\DoxyCodeLine{15306 }
\DoxyCodeLine{15307 \}}
\DoxyCodeLine{15308 \textcolor{comment}{// end catch\_totals.cpp}}
\DoxyCodeLine{15309 \textcolor{comment}{// start catch\_uncaught\_exceptions.cpp}}
\DoxyCodeLine{15310 }
\DoxyCodeLine{15311 \textcolor{comment}{// start catch\_config\_uncaught\_exceptions.hpp}}
\DoxyCodeLine{15312 }
\DoxyCodeLine{15313 \textcolor{comment}{//              Copyright Catch2 Authors}}
\DoxyCodeLine{15314 \textcolor{comment}{// Distributed under the Boost Software License, Version 1.0.}}
\DoxyCodeLine{15315 \textcolor{comment}{//   (See accompanying file LICENSE\_1\_0.txt or copy at}}
\DoxyCodeLine{15316 \textcolor{comment}{//        https://www.boost.org/LICENSE\_1\_0.txt)}}
\DoxyCodeLine{15317 }
\DoxyCodeLine{15318 \textcolor{comment}{// SPDX-\/License-\/Identifier: BSL-\/1.0}}
\DoxyCodeLine{15319 }
\DoxyCodeLine{15320 \textcolor{preprocessor}{\#ifndef CATCH\_CONFIG\_UNCAUGHT\_EXCEPTIONS\_HPP}}
\DoxyCodeLine{15321 \textcolor{preprocessor}{\#define CATCH\_CONFIG\_UNCAUGHT\_EXCEPTIONS\_HPP}}
\DoxyCodeLine{15322 }
\DoxyCodeLine{15323 \textcolor{preprocessor}{\#if defined(\_MSC\_VER)}}
\DoxyCodeLine{15324 \textcolor{preprocessor}{\#  if \_MSC\_VER >= 1900 }\textcolor{comment}{// Visual Studio 2015 or newer}}
\DoxyCodeLine{15325 \textcolor{preprocessor}{\#    define CATCH\_INTERNAL\_CONFIG\_CPP17\_UNCAUGHT\_EXCEPTIONS}}
\DoxyCodeLine{15326 \textcolor{preprocessor}{\#  endif}}
\DoxyCodeLine{15327 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{15328 }
\DoxyCodeLine{15329 \textcolor{preprocessor}{\#include <exception>}}
\DoxyCodeLine{15330 }
\DoxyCodeLine{15331 \textcolor{preprocessor}{\#if defined(\_\_cpp\_lib\_uncaught\_exceptions) \(\backslash\)}}
\DoxyCodeLine{15332 \textcolor{preprocessor}{    \&\& !defined(CATCH\_INTERNAL\_CONFIG\_CPP17\_UNCAUGHT\_EXCEPTIONS)}}
\DoxyCodeLine{15333 }
\DoxyCodeLine{15334 \textcolor{preprocessor}{\#  define CATCH\_INTERNAL\_CONFIG\_CPP17\_UNCAUGHT\_EXCEPTIONS}}
\DoxyCodeLine{15335 \textcolor{preprocessor}{\#endif }\textcolor{comment}{// \_\_cpp\_lib\_uncaught\_exceptions}}
\DoxyCodeLine{15336 }
\DoxyCodeLine{15337 \textcolor{preprocessor}{\#if defined(CATCH\_INTERNAL\_CONFIG\_CPP17\_UNCAUGHT\_EXCEPTIONS) \(\backslash\)}}
\DoxyCodeLine{15338 \textcolor{preprocessor}{    \&\& !defined(CATCH\_CONFIG\_NO\_CPP17\_UNCAUGHT\_EXCEPTIONS) \(\backslash\)}}
\DoxyCodeLine{15339 \textcolor{preprocessor}{    \&\& !defined(CATCH\_CONFIG\_CPP17\_UNCAUGHT\_EXCEPTIONS)}}
\DoxyCodeLine{15340 }
\DoxyCodeLine{15341 \textcolor{preprocessor}{\#  define CATCH\_CONFIG\_CPP17\_UNCAUGHT\_EXCEPTIONS}}
\DoxyCodeLine{15342 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{15343 }
\DoxyCodeLine{15344 \textcolor{preprocessor}{\#endif }\textcolor{comment}{// CATCH\_CONFIG\_UNCAUGHT\_EXCEPTIONS\_HPP}}
\DoxyCodeLine{15345 \textcolor{comment}{// end catch\_config\_uncaught\_exceptions.hpp}}
\DoxyCodeLine{15346 \textcolor{preprocessor}{\#include <exception>}}
\DoxyCodeLine{15347 }
\DoxyCodeLine{15348 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{15349     \textcolor{keywordtype}{bool} uncaught\_exceptions() \{}
\DoxyCodeLine{15350 \textcolor{preprocessor}{\#if defined(CATCH\_CONFIG\_DISABLE\_EXCEPTIONS)}}
\DoxyCodeLine{15351         \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{15352 \textcolor{preprocessor}{\#elif defined(CATCH\_CONFIG\_CPP17\_UNCAUGHT\_EXCEPTIONS)}}
\DoxyCodeLine{15353         \textcolor{keywordflow}{return} std::uncaught\_exceptions() > 0;}
\DoxyCodeLine{15354 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{15355         \textcolor{keywordflow}{return} std::uncaught\_exception();}
\DoxyCodeLine{15356 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{15357   \}}
\DoxyCodeLine{15358 \} \textcolor{comment}{// end namespace Catch}}
\DoxyCodeLine{15359 \textcolor{comment}{// end catch\_uncaught\_exceptions.cpp}}
\DoxyCodeLine{15360 \textcolor{comment}{// start catch\_version.cpp}}
\DoxyCodeLine{15361 }
\DoxyCodeLine{15362 \textcolor{preprocessor}{\#include <ostream>}}
\DoxyCodeLine{15363 }
\DoxyCodeLine{15364 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{15365 }
\DoxyCodeLine{15366     Version::Version}
\DoxyCodeLine{15367         (   \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} \_majorVersion,}
\DoxyCodeLine{15368             \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} \_minorVersion,}
\DoxyCodeLine{15369             \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} \_patchNumber,}
\DoxyCodeLine{15370             \textcolor{keywordtype}{char} \textcolor{keyword}{const} * \textcolor{keyword}{const} \_branchName,}
\DoxyCodeLine{15371             \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} \_buildNumber )}
\DoxyCodeLine{15372     :   majorVersion( \_majorVersion ),}
\DoxyCodeLine{15373         minorVersion( \_minorVersion ),}
\DoxyCodeLine{15374         patchNumber( \_patchNumber ),}
\DoxyCodeLine{15375         branchName( \_branchName ),}
\DoxyCodeLine{15376         buildNumber( \_buildNumber )}
\DoxyCodeLine{15377     \{\}}
\DoxyCodeLine{15378 }
\DoxyCodeLine{15379     std::ostream\& operator << ( std::ostream\& os, Version \textcolor{keyword}{const}\& version ) \{}
\DoxyCodeLine{15380         os  << version.majorVersion << \textcolor{charliteral}{'.'}}
\DoxyCodeLine{15381             << version.minorVersion << \textcolor{charliteral}{'.'}}
\DoxyCodeLine{15382             << version.patchNumber;}
\DoxyCodeLine{15383         \textcolor{comment}{// branchName is never null -\/> 0th char is \(\backslash\)0 if it is empty}}
\DoxyCodeLine{15384         \textcolor{keywordflow}{if} (version.branchName[0]) \{}
\DoxyCodeLine{15385             os << \textcolor{charliteral}{'-\/'} << version.branchName}
\DoxyCodeLine{15386                << \textcolor{charliteral}{'.'} << version.buildNumber;}
\DoxyCodeLine{15387         \}}
\DoxyCodeLine{15388         \textcolor{keywordflow}{return} os;}
\DoxyCodeLine{15389     \}}
\DoxyCodeLine{15390 }
\DoxyCodeLine{15391     Version \textcolor{keyword}{const}\& libraryVersion() \{}
\DoxyCodeLine{15392         \textcolor{keyword}{static} Version version( 2, 13, 10, \textcolor{stringliteral}{"{}"{}}, 0 );}
\DoxyCodeLine{15393         \textcolor{keywordflow}{return} version;}
\DoxyCodeLine{15394     \}}
\DoxyCodeLine{15395 }
\DoxyCodeLine{15396 \}}
\DoxyCodeLine{15397 \textcolor{comment}{// end catch\_version.cpp}}
\DoxyCodeLine{15398 \textcolor{comment}{// start catch\_wildcard\_pattern.cpp}}
\DoxyCodeLine{15399 }
\DoxyCodeLine{15400 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{15401 }
\DoxyCodeLine{15402     WildcardPattern::WildcardPattern( std::string \textcolor{keyword}{const}\& pattern,}
\DoxyCodeLine{15403                                       CaseSensitive::Choice caseSensitivity )}
\DoxyCodeLine{15404     :   m\_caseSensitivity( caseSensitivity ),}
\DoxyCodeLine{15405         m\_pattern( normaliseString( pattern ) )}
\DoxyCodeLine{15406     \{}
\DoxyCodeLine{15407         \textcolor{keywordflow}{if}( startsWith( m\_pattern, \textcolor{charliteral}{'*'} ) ) \{}
\DoxyCodeLine{15408             m\_pattern = m\_pattern.substr( 1 );}
\DoxyCodeLine{15409             m\_wildcard = WildcardAtStart;}
\DoxyCodeLine{15410         \}}
\DoxyCodeLine{15411         \textcolor{keywordflow}{if}( endsWith( m\_pattern, \textcolor{charliteral}{'*'} ) ) \{}
\DoxyCodeLine{15412             m\_pattern = m\_pattern.substr( 0, m\_pattern.size()-\/1 );}
\DoxyCodeLine{15413             m\_wildcard = \textcolor{keyword}{static\_cast<}WildcardPosition\textcolor{keyword}{>}( m\_wildcard | WildcardAtEnd );}
\DoxyCodeLine{15414         \}}
\DoxyCodeLine{15415     \}}
\DoxyCodeLine{15416 }
\DoxyCodeLine{15417     \textcolor{keywordtype}{bool} WildcardPattern::matches( std::string \textcolor{keyword}{const}\& str )\textcolor{keyword}{ const }\{}
\DoxyCodeLine{15418         \textcolor{keywordflow}{switch}( m\_wildcard ) \{}
\DoxyCodeLine{15419             \textcolor{keywordflow}{case} NoWildcard:}
\DoxyCodeLine{15420                 \textcolor{keywordflow}{return} m\_pattern == normaliseString( str );}
\DoxyCodeLine{15421             \textcolor{keywordflow}{case} WildcardAtStart:}
\DoxyCodeLine{15422                 \textcolor{keywordflow}{return} endsWith( normaliseString( str ), m\_pattern );}
\DoxyCodeLine{15423             \textcolor{keywordflow}{case} WildcardAtEnd:}
\DoxyCodeLine{15424                 \textcolor{keywordflow}{return} startsWith( normaliseString( str ), m\_pattern );}
\DoxyCodeLine{15425             \textcolor{keywordflow}{case} WildcardAtBothEnds:}
\DoxyCodeLine{15426                 \textcolor{keywordflow}{return} contains( normaliseString( str ), m\_pattern );}
\DoxyCodeLine{15427             \textcolor{keywordflow}{default}:}
\DoxyCodeLine{15428                 CATCH\_INTERNAL\_ERROR( \textcolor{stringliteral}{"{}Unknown enum"{}} );}
\DoxyCodeLine{15429         \}}
\DoxyCodeLine{15430     \}}
\DoxyCodeLine{15431 }
\DoxyCodeLine{15432     std::string WildcardPattern::normaliseString( std::string \textcolor{keyword}{const}\& str )\textcolor{keyword}{ const }\{}
\DoxyCodeLine{15433         \textcolor{keywordflow}{return} trim( m\_caseSensitivity == CaseSensitive::No ? toLower( str ) : str );}
\DoxyCodeLine{15434     \}}
\DoxyCodeLine{15435 \}}
\DoxyCodeLine{15436 \textcolor{comment}{// end catch\_wildcard\_pattern.cpp}}
\DoxyCodeLine{15437 \textcolor{comment}{// start catch\_xmlwriter.cpp}}
\DoxyCodeLine{15438 }
\DoxyCodeLine{15439 \textcolor{preprocessor}{\#include <iomanip>}}
\DoxyCodeLine{15440 \textcolor{preprocessor}{\#include <type\_traits>}}
\DoxyCodeLine{15441 }
\DoxyCodeLine{15442 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{15443 }
\DoxyCodeLine{15444 \textcolor{keyword}{namespace }\{}
\DoxyCodeLine{15445 }
\DoxyCodeLine{15446     \textcolor{keywordtype}{size\_t} trailingBytes(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} c) \{}
\DoxyCodeLine{15447         \textcolor{keywordflow}{if} ((c \& 0xE0) == 0xC0) \{}
\DoxyCodeLine{15448             \textcolor{keywordflow}{return} 2;}
\DoxyCodeLine{15449         \}}
\DoxyCodeLine{15450         \textcolor{keywordflow}{if} ((c \& 0xF0) == 0xE0) \{}
\DoxyCodeLine{15451             \textcolor{keywordflow}{return} 3;}
\DoxyCodeLine{15452         \}}
\DoxyCodeLine{15453         \textcolor{keywordflow}{if} ((c \& 0xF8) == 0xF0) \{}
\DoxyCodeLine{15454             \textcolor{keywordflow}{return} 4;}
\DoxyCodeLine{15455         \}}
\DoxyCodeLine{15456         CATCH\_INTERNAL\_ERROR(\textcolor{stringliteral}{"{}Invalid multibyte utf-\/8 start byte encountered"{}});}
\DoxyCodeLine{15457     \}}
\DoxyCodeLine{15458 }
\DoxyCodeLine{15459     uint32\_t headerValue(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} c) \{}
\DoxyCodeLine{15460         \textcolor{keywordflow}{if} ((c \& 0xE0) == 0xC0) \{}
\DoxyCodeLine{15461             \textcolor{keywordflow}{return} c \& 0x1F;}
\DoxyCodeLine{15462         \}}
\DoxyCodeLine{15463         \textcolor{keywordflow}{if} ((c \& 0xF0) == 0xE0) \{}
\DoxyCodeLine{15464             \textcolor{keywordflow}{return} c \& 0x0F;}
\DoxyCodeLine{15465         \}}
\DoxyCodeLine{15466         \textcolor{keywordflow}{if} ((c \& 0xF8) == 0xF0) \{}
\DoxyCodeLine{15467             \textcolor{keywordflow}{return} c \& 0x07;}
\DoxyCodeLine{15468         \}}
\DoxyCodeLine{15469         CATCH\_INTERNAL\_ERROR(\textcolor{stringliteral}{"{}Invalid multibyte utf-\/8 start byte encountered"{}});}
\DoxyCodeLine{15470     \}}
\DoxyCodeLine{15471 }
\DoxyCodeLine{15472     \textcolor{keywordtype}{void} hexEscapeChar(std::ostream\& os, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} c) \{}
\DoxyCodeLine{15473         std::ios\_base::fmtflags f(os.flags());}
\DoxyCodeLine{15474         os << \textcolor{stringliteral}{"{}\(\backslash\)\(\backslash\)x"{}}}
\DoxyCodeLine{15475             << std::uppercase << std::hex << std::setfill(\textcolor{charliteral}{'0'}) << std::setw(2)}
\DoxyCodeLine{15476             << \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{int}\textcolor{keyword}{>}(c);}
\DoxyCodeLine{15477         os.flags(f);}
\DoxyCodeLine{15478     \}}
\DoxyCodeLine{15479 }
\DoxyCodeLine{15480     \textcolor{keywordtype}{bool} shouldNewline(XmlFormatting fmt) \{}
\DoxyCodeLine{15481         \textcolor{keywordflow}{return} !!(\textcolor{keyword}{static\_cast<}std::underlying\_type<XmlFormatting>::type\textcolor{keyword}{>}(fmt \& XmlFormatting::Newline));}
\DoxyCodeLine{15482     \}}
\DoxyCodeLine{15483 }
\DoxyCodeLine{15484     \textcolor{keywordtype}{bool} shouldIndent(XmlFormatting fmt) \{}
\DoxyCodeLine{15485         \textcolor{keywordflow}{return} !!(\textcolor{keyword}{static\_cast<}std::underlying\_type<XmlFormatting>::type\textcolor{keyword}{>}(fmt \& XmlFormatting::Indent));}
\DoxyCodeLine{15486     \}}
\DoxyCodeLine{15487 }
\DoxyCodeLine{15488 \} \textcolor{comment}{// anonymous namespace}}
\DoxyCodeLine{15489 }
\DoxyCodeLine{15490     XmlFormatting operator | (XmlFormatting lhs, XmlFormatting rhs) \{}
\DoxyCodeLine{15491         \textcolor{keywordflow}{return} \textcolor{keyword}{static\_cast<}XmlFormatting\textcolor{keyword}{>}(}
\DoxyCodeLine{15492             \textcolor{keyword}{static\_cast<}std::underlying\_type<XmlFormatting>::type\textcolor{keyword}{>}(lhs) |}
\DoxyCodeLine{15493             \textcolor{keyword}{static\_cast<}std::underlying\_type<XmlFormatting>::type\textcolor{keyword}{>}(rhs)}
\DoxyCodeLine{15494         );}
\DoxyCodeLine{15495     \}}
\DoxyCodeLine{15496 }
\DoxyCodeLine{15497     XmlFormatting operator \& (XmlFormatting lhs, XmlFormatting rhs) \{}
\DoxyCodeLine{15498         \textcolor{keywordflow}{return} \textcolor{keyword}{static\_cast<}XmlFormatting\textcolor{keyword}{>}(}
\DoxyCodeLine{15499             \textcolor{keyword}{static\_cast<}std::underlying\_type<XmlFormatting>::type\textcolor{keyword}{>}(lhs) \&}
\DoxyCodeLine{15500             \textcolor{keyword}{static\_cast<}std::underlying\_type<XmlFormatting>::type\textcolor{keyword}{>}(rhs)}
\DoxyCodeLine{15501         );}
\DoxyCodeLine{15502     \}}
\DoxyCodeLine{15503 }
\DoxyCodeLine{15504     XmlEncode::XmlEncode( std::string \textcolor{keyword}{const}\& str, ForWhat forWhat )}
\DoxyCodeLine{15505     :   m\_str( str ),}
\DoxyCodeLine{15506         m\_forWhat( forWhat )}
\DoxyCodeLine{15507     \{\}}
\DoxyCodeLine{15508 }
\DoxyCodeLine{15509     \textcolor{keywordtype}{void} XmlEncode::encodeTo( std::ostream\& os )\textcolor{keyword}{ const }\{}
\DoxyCodeLine{15510         \textcolor{comment}{// Apostrophe escaping not necessary if we always use "{} to write attributes}}
\DoxyCodeLine{15511         \textcolor{comment}{// (see: http://www.w3.org/TR/xml/\#syntax)}}
\DoxyCodeLine{15512 }
\DoxyCodeLine{15513         \textcolor{keywordflow}{for}( std::size\_t idx = 0; idx < m\_str.size(); ++ idx ) \{}
\DoxyCodeLine{15514             \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} c = m\_str[idx];}
\DoxyCodeLine{15515             \textcolor{keywordflow}{switch} (c) \{}
\DoxyCodeLine{15516             \textcolor{keywordflow}{case} \textcolor{charliteral}{'<'}:   os << \textcolor{stringliteral}{"{}\&lt;"{}}; \textcolor{keywordflow}{break};}
\DoxyCodeLine{15517             \textcolor{keywordflow}{case} \textcolor{charliteral}{'\&'}:   os << \textcolor{stringliteral}{"{}\&amp;"{}}; \textcolor{keywordflow}{break};}
\DoxyCodeLine{15518 }
\DoxyCodeLine{15519             \textcolor{keywordflow}{case} \textcolor{charliteral}{'>'}:}
\DoxyCodeLine{15520                 \textcolor{comment}{// See: http://www.w3.org/TR/xml/\#syntax}}
\DoxyCodeLine{15521                 \textcolor{keywordflow}{if} (idx > 2 \&\& m\_str[idx -\/ 1] == \textcolor{charliteral}{']'} \&\& m\_str[idx -\/ 2] == \textcolor{charliteral}{']'})}
\DoxyCodeLine{15522                     os << \textcolor{stringliteral}{"{}\&gt;"{}};}
\DoxyCodeLine{15523                 \textcolor{keywordflow}{else}}
\DoxyCodeLine{15524                     os << c;}
\DoxyCodeLine{15525                 \textcolor{keywordflow}{break};}
\DoxyCodeLine{15526 }
\DoxyCodeLine{15527             \textcolor{keywordflow}{case} \textcolor{charliteral}{'\(\backslash\)"{}'}:}
\DoxyCodeLine{15528                 \textcolor{keywordflow}{if} (m\_forWhat == ForAttributes)}
\DoxyCodeLine{15529                     os << \textcolor{stringliteral}{"{}\&quot;"{}};}
\DoxyCodeLine{15530                 \textcolor{keywordflow}{else}}
\DoxyCodeLine{15531                     os << c;}
\DoxyCodeLine{15532                 \textcolor{keywordflow}{break};}
\DoxyCodeLine{15533 }
\DoxyCodeLine{15534             \textcolor{keywordflow}{default}:}
\DoxyCodeLine{15535                 \textcolor{comment}{// Check for control characters and invalid utf-\/8}}
\DoxyCodeLine{15536 }
\DoxyCodeLine{15537                 \textcolor{comment}{// Escape control characters in standard ascii}}
\DoxyCodeLine{15538                 \textcolor{comment}{// see http://stackoverflow.com/questions/404107/why-\/are-\/control-\/characters-\/illegal-\/in-\/xml-\/1-\/0}}
\DoxyCodeLine{15539                 \textcolor{keywordflow}{if} (c < 0x09 || (c > 0x0D \&\& c < 0x20) || c == 0x7F) \{}
\DoxyCodeLine{15540                     hexEscapeChar(os, c);}
\DoxyCodeLine{15541                     \textcolor{keywordflow}{break};}
\DoxyCodeLine{15542                 \}}
\DoxyCodeLine{15543 }
\DoxyCodeLine{15544                 \textcolor{comment}{// Plain ASCII: Write it to stream}}
\DoxyCodeLine{15545                 \textcolor{keywordflow}{if} (c < 0x7F) \{}
\DoxyCodeLine{15546                     os << c;}
\DoxyCodeLine{15547                     \textcolor{keywordflow}{break};}
\DoxyCodeLine{15548                 \}}
\DoxyCodeLine{15549 }
\DoxyCodeLine{15550                 \textcolor{comment}{// UTF-\/8 territory}}
\DoxyCodeLine{15551                 \textcolor{comment}{// Check if the encoding is valid and if it is not, hex escape bytes.}}
\DoxyCodeLine{15552                 \textcolor{comment}{// Important: We do not check the exact decoded values for validity, only the encoding format}}
\DoxyCodeLine{15553                 \textcolor{comment}{// First check that this bytes is a valid lead byte:}}
\DoxyCodeLine{15554                 \textcolor{comment}{// This means that it is not encoded as 1111 1XXX}}
\DoxyCodeLine{15555                 \textcolor{comment}{// Or as 10XX XXXX}}
\DoxyCodeLine{15556                 \textcolor{keywordflow}{if} (c <  0xC0 ||}
\DoxyCodeLine{15557                     c >= 0xF8) \{}
\DoxyCodeLine{15558                     hexEscapeChar(os, c);}
\DoxyCodeLine{15559                     \textcolor{keywordflow}{break};}
\DoxyCodeLine{15560                 \}}
\DoxyCodeLine{15561 }
\DoxyCodeLine{15562                 \textcolor{keyword}{auto} encBytes = trailingBytes(c);}
\DoxyCodeLine{15563                 \textcolor{comment}{// Are there enough bytes left to avoid accessing out-\/of-\/bounds memory?}}
\DoxyCodeLine{15564                 \textcolor{keywordflow}{if} (idx + encBytes -\/ 1 >= m\_str.size()) \{}
\DoxyCodeLine{15565                     hexEscapeChar(os, c);}
\DoxyCodeLine{15566                     \textcolor{keywordflow}{break};}
\DoxyCodeLine{15567                 \}}
\DoxyCodeLine{15568                 \textcolor{comment}{// The header is valid, check data}}
\DoxyCodeLine{15569                 \textcolor{comment}{// The next encBytes bytes must together be a valid utf-\/8}}
\DoxyCodeLine{15570                 \textcolor{comment}{// This means: bitpattern 10XX XXXX and the extracted value is sane (ish)}}
\DoxyCodeLine{15571                 \textcolor{keywordtype}{bool} valid = \textcolor{keyword}{true};}
\DoxyCodeLine{15572                 uint32\_t value = headerValue(c);}
\DoxyCodeLine{15573                 \textcolor{keywordflow}{for} (std::size\_t n = 1; n < encBytes; ++n) \{}
\DoxyCodeLine{15574                     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} nc = m\_str[idx + n];}
\DoxyCodeLine{15575                     valid \&= ((nc \& 0xC0) == 0x80);}
\DoxyCodeLine{15576                     value = (value << 6) | (nc \& 0x3F);}
\DoxyCodeLine{15577                 \}}
\DoxyCodeLine{15578 }
\DoxyCodeLine{15579                 \textcolor{keywordflow}{if} (}
\DoxyCodeLine{15580                     \textcolor{comment}{// Wrong bit pattern of following bytes}}
\DoxyCodeLine{15581                     (!valid) ||}
\DoxyCodeLine{15582                     \textcolor{comment}{// Overlong encodings}}
\DoxyCodeLine{15583                     (value < 0x80) ||}
\DoxyCodeLine{15584                     (0x80 <= value \&\& value < 0x800   \&\& encBytes > 2) ||}
\DoxyCodeLine{15585                     (0x800 < value \&\& value < 0x10000 \&\& encBytes > 3) ||}
\DoxyCodeLine{15586                     \textcolor{comment}{// Encoded value out of range}}
\DoxyCodeLine{15587                     (value >= 0x110000)}
\DoxyCodeLine{15588                     ) \{}
\DoxyCodeLine{15589                     hexEscapeChar(os, c);}
\DoxyCodeLine{15590                     \textcolor{keywordflow}{break};}
\DoxyCodeLine{15591                 \}}
\DoxyCodeLine{15592 }
\DoxyCodeLine{15593                 \textcolor{comment}{// If we got here, this is in fact a valid(ish) utf-\/8 sequence}}
\DoxyCodeLine{15594                 \textcolor{keywordflow}{for} (std::size\_t n = 0; n < encBytes; ++n) \{}
\DoxyCodeLine{15595                     os << m\_str[idx + n];}
\DoxyCodeLine{15596                 \}}
\DoxyCodeLine{15597                 idx += encBytes -\/ 1;}
\DoxyCodeLine{15598                 \textcolor{keywordflow}{break};}
\DoxyCodeLine{15599             \}}
\DoxyCodeLine{15600         \}}
\DoxyCodeLine{15601     \}}
\DoxyCodeLine{15602 }
\DoxyCodeLine{15603     std::ostream\& operator << ( std::ostream\& os, XmlEncode \textcolor{keyword}{const}\& xmlEncode ) \{}
\DoxyCodeLine{15604         xmlEncode.encodeTo( os );}
\DoxyCodeLine{15605         \textcolor{keywordflow}{return} os;}
\DoxyCodeLine{15606     \}}
\DoxyCodeLine{15607 }
\DoxyCodeLine{15608     XmlWriter::ScopedElement::ScopedElement( XmlWriter* writer, XmlFormatting fmt )}
\DoxyCodeLine{15609     :   m\_writer( writer ),}
\DoxyCodeLine{15610         m\_fmt(fmt)}
\DoxyCodeLine{15611     \{\}}
\DoxyCodeLine{15612 }
\DoxyCodeLine{15613     XmlWriter::ScopedElement::ScopedElement( ScopedElement\&\& other ) noexcept}
\DoxyCodeLine{15614     :   m\_writer( other.m\_writer ),}
\DoxyCodeLine{15615         m\_fmt(other.m\_fmt)}
\DoxyCodeLine{15616     \{}
\DoxyCodeLine{15617         other.m\_writer = \textcolor{keyword}{nullptr};}
\DoxyCodeLine{15618         other.m\_fmt = XmlFormatting::None;}
\DoxyCodeLine{15619     \}}
\DoxyCodeLine{15620     XmlWriter::ScopedElement\& XmlWriter::ScopedElement::operator=( ScopedElement\&\& other ) \textcolor{keyword}{noexcept} \{}
\DoxyCodeLine{15621         \textcolor{keywordflow}{if} ( m\_writer ) \{}
\DoxyCodeLine{15622             m\_writer-\/>endElement();}
\DoxyCodeLine{15623         \}}
\DoxyCodeLine{15624         m\_writer = other.m\_writer;}
\DoxyCodeLine{15625         other.m\_writer = \textcolor{keyword}{nullptr};}
\DoxyCodeLine{15626         m\_fmt = other.m\_fmt;}
\DoxyCodeLine{15627         other.m\_fmt = XmlFormatting::None;}
\DoxyCodeLine{15628         \textcolor{keywordflow}{return} *\textcolor{keyword}{this};}
\DoxyCodeLine{15629     \}}
\DoxyCodeLine{15630 }
\DoxyCodeLine{15631     XmlWriter::ScopedElement::\string~ScopedElement() \{}
\DoxyCodeLine{15632         \textcolor{keywordflow}{if} (m\_writer) \{}
\DoxyCodeLine{15633             m\_writer-\/>endElement(m\_fmt);}
\DoxyCodeLine{15634         \}}
\DoxyCodeLine{15635     \}}
\DoxyCodeLine{15636 }
\DoxyCodeLine{15637     XmlWriter::ScopedElement\& XmlWriter::ScopedElement::writeText( std::string \textcolor{keyword}{const}\& text, XmlFormatting fmt ) \{}
\DoxyCodeLine{15638         m\_writer-\/>writeText( text, fmt );}
\DoxyCodeLine{15639         \textcolor{keywordflow}{return} *\textcolor{keyword}{this};}
\DoxyCodeLine{15640     \}}
\DoxyCodeLine{15641 }
\DoxyCodeLine{15642     XmlWriter::XmlWriter( std::ostream\& os ) : m\_os( os )}
\DoxyCodeLine{15643     \{}
\DoxyCodeLine{15644         writeDeclaration();}
\DoxyCodeLine{15645     \}}
\DoxyCodeLine{15646 }
\DoxyCodeLine{15647     XmlWriter::\string~XmlWriter() \{}
\DoxyCodeLine{15648         \textcolor{keywordflow}{while} (!m\_tags.empty()) \{}
\DoxyCodeLine{15649             endElement();}
\DoxyCodeLine{15650         \}}
\DoxyCodeLine{15651         newlineIfNecessary();}
\DoxyCodeLine{15652     \}}
\DoxyCodeLine{15653 }
\DoxyCodeLine{15654     XmlWriter\& XmlWriter::startElement( std::string \textcolor{keyword}{const}\& name, XmlFormatting fmt ) \{}
\DoxyCodeLine{15655         ensureTagClosed();}
\DoxyCodeLine{15656         newlineIfNecessary();}
\DoxyCodeLine{15657         \textcolor{keywordflow}{if} (shouldIndent(fmt)) \{}
\DoxyCodeLine{15658             m\_os << m\_indent;}
\DoxyCodeLine{15659             m\_indent += "{}  "{};}
\DoxyCodeLine{15660         \}}
\DoxyCodeLine{15661         m\_os << \textcolor{charliteral}{'<'} << name;}
\DoxyCodeLine{15662         m\_tags.push\_back( name );}
\DoxyCodeLine{15663         m\_tagIsOpen = \textcolor{keyword}{true};}
\DoxyCodeLine{15664         applyFormatting(fmt);}
\DoxyCodeLine{15665         \textcolor{keywordflow}{return} *\textcolor{keyword}{this};}
\DoxyCodeLine{15666     \}}
\DoxyCodeLine{15667 }
\DoxyCodeLine{15668     XmlWriter::ScopedElement XmlWriter::scopedElement( std::string \textcolor{keyword}{const}\& name, XmlFormatting fmt ) \{}
\DoxyCodeLine{15669         ScopedElement scoped( \textcolor{keyword}{this}, fmt );}
\DoxyCodeLine{15670         startElement( name, fmt );}
\DoxyCodeLine{15671         \textcolor{keywordflow}{return} scoped;}
\DoxyCodeLine{15672     \}}
\DoxyCodeLine{15673 }
\DoxyCodeLine{15674     XmlWriter\& XmlWriter::endElement(XmlFormatting fmt) \{}
\DoxyCodeLine{15675         m\_indent = m\_indent.substr(0, m\_indent.size() -\/ 2);}
\DoxyCodeLine{15676 }
\DoxyCodeLine{15677         \textcolor{keywordflow}{if}( m\_tagIsOpen ) \{}
\DoxyCodeLine{15678             m\_os << \textcolor{stringliteral}{"{}/>"{}};}
\DoxyCodeLine{15679             m\_tagIsOpen = \textcolor{keyword}{false};}
\DoxyCodeLine{15680         \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{15681             newlineIfNecessary();}
\DoxyCodeLine{15682             \textcolor{keywordflow}{if} (shouldIndent(fmt)) \{}
\DoxyCodeLine{15683                 m\_os << m\_indent;}
\DoxyCodeLine{15684             \}}
\DoxyCodeLine{15685             m\_os << \textcolor{stringliteral}{"{}</"{}} << m\_tags.back() << \textcolor{stringliteral}{"{}>"{}};}
\DoxyCodeLine{15686         \}}
\DoxyCodeLine{15687         m\_os << std::flush;}
\DoxyCodeLine{15688         applyFormatting(fmt);}
\DoxyCodeLine{15689         m\_tags.pop\_back();}
\DoxyCodeLine{15690         \textcolor{keywordflow}{return} *\textcolor{keyword}{this};}
\DoxyCodeLine{15691     \}}
\DoxyCodeLine{15692 }
\DoxyCodeLine{15693     XmlWriter\& XmlWriter::writeAttribute( std::string \textcolor{keyword}{const}\& name, std::string \textcolor{keyword}{const}\& attribute ) \{}
\DoxyCodeLine{15694         \textcolor{keywordflow}{if}( !name.empty() \&\& !attribute.empty() )}
\DoxyCodeLine{15695             m\_os << \textcolor{charliteral}{' '} << name << \textcolor{stringliteral}{"{}=\(\backslash\)"{}"{}} << XmlEncode( attribute, XmlEncode::ForAttributes ) << \textcolor{charliteral}{'"{}'};}
\DoxyCodeLine{15696         \textcolor{keywordflow}{return} *\textcolor{keyword}{this};}
\DoxyCodeLine{15697     \}}
\DoxyCodeLine{15698 }
\DoxyCodeLine{15699     XmlWriter\& XmlWriter::writeAttribute( std::string \textcolor{keyword}{const}\& name, \textcolor{keywordtype}{bool} attribute ) \{}
\DoxyCodeLine{15700         m\_os << \textcolor{charliteral}{' '} << name << \textcolor{stringliteral}{"{}=\(\backslash\)"{}"{}} << ( attribute ? \textcolor{stringliteral}{"{}true"{}} : \textcolor{stringliteral}{"{}false"{}} ) << \textcolor{charliteral}{'"{}'};}
\DoxyCodeLine{15701         \textcolor{keywordflow}{return} *\textcolor{keyword}{this};}
\DoxyCodeLine{15702     \}}
\DoxyCodeLine{15703 }
\DoxyCodeLine{15704     XmlWriter\& XmlWriter::writeText( std::string \textcolor{keyword}{const}\& text, XmlFormatting fmt) \{}
\DoxyCodeLine{15705         \textcolor{keywordflow}{if}( !text.empty() )\{}
\DoxyCodeLine{15706             \textcolor{keywordtype}{bool} tagWasOpen = m\_tagIsOpen;}
\DoxyCodeLine{15707             ensureTagClosed();}
\DoxyCodeLine{15708             \textcolor{keywordflow}{if} (tagWasOpen \&\& shouldIndent(fmt)) \{}
\DoxyCodeLine{15709                 m\_os << m\_indent;}
\DoxyCodeLine{15710             \}}
\DoxyCodeLine{15711             m\_os << XmlEncode( text );}
\DoxyCodeLine{15712             applyFormatting(fmt);}
\DoxyCodeLine{15713         \}}
\DoxyCodeLine{15714         \textcolor{keywordflow}{return} *\textcolor{keyword}{this};}
\DoxyCodeLine{15715     \}}
\DoxyCodeLine{15716 }
\DoxyCodeLine{15717     XmlWriter\& XmlWriter::writeComment( std::string \textcolor{keyword}{const}\& text, XmlFormatting fmt) \{}
\DoxyCodeLine{15718         ensureTagClosed();}
\DoxyCodeLine{15719         \textcolor{keywordflow}{if} (shouldIndent(fmt)) \{}
\DoxyCodeLine{15720             m\_os << m\_indent;}
\DoxyCodeLine{15721         \}}
\DoxyCodeLine{15722         m\_os << \textcolor{stringliteral}{"{}<!-\/-\/"{}} << text << \textcolor{stringliteral}{"{}-\/-\/>"{}};}
\DoxyCodeLine{15723         applyFormatting(fmt);}
\DoxyCodeLine{15724         \textcolor{keywordflow}{return} *\textcolor{keyword}{this};}
\DoxyCodeLine{15725     \}}
\DoxyCodeLine{15726 }
\DoxyCodeLine{15727     \textcolor{keywordtype}{void} XmlWriter::writeStylesheetRef( std::string \textcolor{keyword}{const}\& url ) \{}
\DoxyCodeLine{15728         m\_os << \textcolor{stringliteral}{"{}<?xml-\/stylesheet type=\(\backslash\)"{}text/xsl\(\backslash\)"{} href=\(\backslash\)"{}"{}} << url << \textcolor{stringliteral}{"{}\(\backslash\)"{}?>\(\backslash\)n"{}};}
\DoxyCodeLine{15729     \}}
\DoxyCodeLine{15730 }
\DoxyCodeLine{15731     XmlWriter\& XmlWriter::writeBlankLine() \{}
\DoxyCodeLine{15732         ensureTagClosed();}
\DoxyCodeLine{15733         m\_os << \textcolor{charliteral}{'\(\backslash\)n'};}
\DoxyCodeLine{15734         \textcolor{keywordflow}{return} *\textcolor{keyword}{this};}
\DoxyCodeLine{15735     \}}
\DoxyCodeLine{15736 }
\DoxyCodeLine{15737     \textcolor{keywordtype}{void} XmlWriter::ensureTagClosed() \{}
\DoxyCodeLine{15738         \textcolor{keywordflow}{if}( m\_tagIsOpen ) \{}
\DoxyCodeLine{15739             m\_os << '>\textcolor{stringliteral}{' << std::flush;}}
\DoxyCodeLine{15740 \textcolor{stringliteral}{            newlineIfNecessary();}}
\DoxyCodeLine{15741 \textcolor{stringliteral}{            m\_tagIsOpen = false;}}
\DoxyCodeLine{15742 \textcolor{stringliteral}{        \}}}
\DoxyCodeLine{15743 \textcolor{stringliteral}{    \}}}
\DoxyCodeLine{15744 \textcolor{stringliteral}{}}
\DoxyCodeLine{15745 \textcolor{stringliteral}{    void XmlWriter::applyFormatting(XmlFormatting fmt) \{}}
\DoxyCodeLine{15746 \textcolor{stringliteral}{        m\_needsNewline = shouldNewline(fmt);}}
\DoxyCodeLine{15747 \textcolor{stringliteral}{    \}}}
\DoxyCodeLine{15748 \textcolor{stringliteral}{}}
\DoxyCodeLine{15749 \textcolor{stringliteral}{    void XmlWriter::writeDeclaration() \{}}
\DoxyCodeLine{15750 \textcolor{stringliteral}{        m\_os << "{}<?xml version=\(\backslash\)"{}1.0\(\backslash\)"{} encoding=\(\backslash\)"{}UTF-\/8\(\backslash\)"{}?>\(\backslash\)n"{};}}
\DoxyCodeLine{15751 \textcolor{stringliteral}{    \}}}
\DoxyCodeLine{15752 \textcolor{stringliteral}{}}
\DoxyCodeLine{15753 \textcolor{stringliteral}{    void XmlWriter::newlineIfNecessary() \{}}
\DoxyCodeLine{15754 \textcolor{stringliteral}{        if( m\_needsNewline ) \{}}
\DoxyCodeLine{15755 \textcolor{stringliteral}{            m\_os << std::endl;}}
\DoxyCodeLine{15756 \textcolor{stringliteral}{            m\_needsNewline = false;}}
\DoxyCodeLine{15757 \textcolor{stringliteral}{        \}}}
\DoxyCodeLine{15758 \textcolor{stringliteral}{    \}}}
\DoxyCodeLine{15759 \textcolor{stringliteral}{\}}}
\DoxyCodeLine{15760 \textcolor{stringliteral}{// end catch\_xmlwriter.cpp}}
\DoxyCodeLine{15761 \textcolor{stringliteral}{// start catch\_reporter\_bases.cpp}}
\DoxyCodeLine{15762 \textcolor{stringliteral}{}}
\DoxyCodeLine{15763 \textcolor{stringliteral}{\#include <cstring>}}
\DoxyCodeLine{15764 \textcolor{stringliteral}{\#include <cfloat>}}
\DoxyCodeLine{15765 \textcolor{stringliteral}{\#include <cstdio>}}
\DoxyCodeLine{15766 \textcolor{stringliteral}{\#include <cassert>}}
\DoxyCodeLine{15767 \textcolor{stringliteral}{\#include <memory>}}
\DoxyCodeLine{15768 \textcolor{stringliteral}{}}
\DoxyCodeLine{15769 \textcolor{stringliteral}{namespace Catch \{}}
\DoxyCodeLine{15770 \textcolor{stringliteral}{    void prepareExpandedExpression(AssertionResult\& result) \{}}
\DoxyCodeLine{15771 \textcolor{stringliteral}{        result.getExpandedExpression();}}
\DoxyCodeLine{15772 \textcolor{stringliteral}{    \}}}
\DoxyCodeLine{15773 \textcolor{stringliteral}{}}
\DoxyCodeLine{15774 \textcolor{stringliteral}{    // Because formatting using c++ streams is stateful, drop down to C is required}}
\DoxyCodeLine{15775 \textcolor{stringliteral}{    // Alternatively we could use stringstream, but its performance is... not good.}}
\DoxyCodeLine{15776 \textcolor{stringliteral}{    std::string getFormattedDuration( double duration ) \{}}
\DoxyCodeLine{15777 \textcolor{stringliteral}{        // Max exponent + 1 is required to represent the whole part}}
\DoxyCodeLine{15778 \textcolor{stringliteral}{        // + 1 for decimal point}}
\DoxyCodeLine{15779 \textcolor{stringliteral}{        // + 3 for the 3 decimal places}}
\DoxyCodeLine{15780 \textcolor{stringliteral}{        // + 1 for null terminator}}
\DoxyCodeLine{15781 \textcolor{stringliteral}{        const std::size\_t maxDoubleSize = DBL\_MAX\_10\_EXP + 1 + 1 + 3 + 1;}}
\DoxyCodeLine{15782 \textcolor{stringliteral}{        char buffer[maxDoubleSize];}}
\DoxyCodeLine{15783 \textcolor{stringliteral}{}}
\DoxyCodeLine{15784 \textcolor{stringliteral}{        // Save previous errno, to prevent sprintf from overwriting it}}
\DoxyCodeLine{15785 \textcolor{stringliteral}{        ErrnoGuard guard;}}
\DoxyCodeLine{15786 \textcolor{stringliteral}{\#ifdef \_MSC\_VER}}
\DoxyCodeLine{15787 \textcolor{stringliteral}{        sprintf\_s(buffer, "{}\%.3f"{}, duration);}}
\DoxyCodeLine{15788 \textcolor{stringliteral}{\#else}}
\DoxyCodeLine{15789 \textcolor{stringliteral}{        std::sprintf(buffer, "{}\%.3f"{}, duration);}}
\DoxyCodeLine{15790 \textcolor{stringliteral}{\#endif}}
\DoxyCodeLine{15791 \textcolor{stringliteral}{        return std::string(buffer);}}
\DoxyCodeLine{15792 \textcolor{stringliteral}{    \}}}
\DoxyCodeLine{15793 \textcolor{stringliteral}{}}
\DoxyCodeLine{15794 \textcolor{stringliteral}{    bool shouldShowDuration( IConfig const\& config, double duration ) \{}}
\DoxyCodeLine{15795 \textcolor{stringliteral}{        if ( config.showDurations() == ShowDurations::Always ) \{}}
\DoxyCodeLine{15796 \textcolor{stringliteral}{            return true;}}
\DoxyCodeLine{15797 \textcolor{stringliteral}{        \}}}
\DoxyCodeLine{15798 \textcolor{stringliteral}{        if ( config.showDurations() == ShowDurations::Never ) \{}}
\DoxyCodeLine{15799 \textcolor{stringliteral}{            return false;}}
\DoxyCodeLine{15800 \textcolor{stringliteral}{        \}}}
\DoxyCodeLine{15801 \textcolor{stringliteral}{        const double min = config.minDuration();}}
\DoxyCodeLine{15802 \textcolor{stringliteral}{        return min >= 0 \&\& duration >= min;}}
\DoxyCodeLine{15803 \textcolor{stringliteral}{    \}}}
\DoxyCodeLine{15804 \textcolor{stringliteral}{}}
\DoxyCodeLine{15805 \textcolor{stringliteral}{    std::string serializeFilters( std::vector<std::string> const\& container ) \{}}
\DoxyCodeLine{15806 \textcolor{stringliteral}{        ReusableStringStream oss;}}
\DoxyCodeLine{15807 \textcolor{stringliteral}{        bool first = true;}}
\DoxyCodeLine{15808 \textcolor{stringliteral}{        for (auto\&\& filter : container)}}
\DoxyCodeLine{15809 \textcolor{stringliteral}{        \{}}
\DoxyCodeLine{15810 \textcolor{stringliteral}{            if (!first)}}
\DoxyCodeLine{15811 \textcolor{stringliteral}{                oss << '} \textcolor{stringliteral}{';}}
\DoxyCodeLine{15812 \textcolor{stringliteral}{            else}}
\DoxyCodeLine{15813 \textcolor{stringliteral}{                first = false;}}
\DoxyCodeLine{15814 \textcolor{stringliteral}{}}
\DoxyCodeLine{15815 \textcolor{stringliteral}{            oss << filter;}}
\DoxyCodeLine{15816 \textcolor{stringliteral}{        \}}}
\DoxyCodeLine{15817 \textcolor{stringliteral}{        return oss.str();}}
\DoxyCodeLine{15818 \textcolor{stringliteral}{    \}}}
\DoxyCodeLine{15819 \textcolor{stringliteral}{}}
\DoxyCodeLine{15820 \textcolor{stringliteral}{    TestEventListenerBase::TestEventListenerBase(ReporterConfig const \& \_config)}}
\DoxyCodeLine{15821 \textcolor{stringliteral}{        :StreamingReporterBase(\_config) \{\}}}
\DoxyCodeLine{15822 \textcolor{stringliteral}{}}
\DoxyCodeLine{15823 \textcolor{stringliteral}{    std::set<Verbosity> TestEventListenerBase::getSupportedVerbosities() \{}}
\DoxyCodeLine{15824 \textcolor{stringliteral}{        return \{ Verbosity::Quiet, Verbosity::Normal, Verbosity::High \};}}
\DoxyCodeLine{15825 \textcolor{stringliteral}{    \}}}
\DoxyCodeLine{15826 \textcolor{stringliteral}{}}
\DoxyCodeLine{15827 \textcolor{stringliteral}{    void TestEventListenerBase::assertionStarting(AssertionInfo const \&) \{\}}}
\DoxyCodeLine{15828 \textcolor{stringliteral}{}}
\DoxyCodeLine{15829 \textcolor{stringliteral}{    bool TestEventListenerBase::assertionEnded(AssertionStats const \&) \{}}
\DoxyCodeLine{15830 \textcolor{stringliteral}{        return false;}}
\DoxyCodeLine{15831 \textcolor{stringliteral}{    \}}}
\DoxyCodeLine{15832 \textcolor{stringliteral}{}}
\DoxyCodeLine{15833 \textcolor{stringliteral}{\} // end namespace Catch}}
\DoxyCodeLine{15834 \textcolor{stringliteral}{// end catch\_reporter\_bases.cpp}}
\DoxyCodeLine{15835 \textcolor{stringliteral}{// start catch\_reporter\_compact.cpp}}
\DoxyCodeLine{15836 \textcolor{stringliteral}{}}
\DoxyCodeLine{15837 \textcolor{stringliteral}{namespace \{}}
\DoxyCodeLine{15838 \textcolor{stringliteral}{}}
\DoxyCodeLine{15839 \textcolor{stringliteral}{\#ifdef CATCH\_PLATFORM\_MAC}}
\DoxyCodeLine{15840 \textcolor{stringliteral}{    const char* failedString() \{ return "{}FAILED"{}; \}}}
\DoxyCodeLine{15841 \textcolor{stringliteral}{    const char* passedString() \{ return "{}PASSED"{}; \}}}
\DoxyCodeLine{15842 \textcolor{stringliteral}{\#else}}
\DoxyCodeLine{15843 \textcolor{stringliteral}{    const char* failedString() \{ return "{}failed"{}; \}}}
\DoxyCodeLine{15844 \textcolor{stringliteral}{    const char* passedString() \{ return "{}passed"{}; \}}}
\DoxyCodeLine{15845 \textcolor{stringliteral}{\#endif}}
\DoxyCodeLine{15846 \textcolor{stringliteral}{}}
\DoxyCodeLine{15847 \textcolor{stringliteral}{    // Colour::LightGrey}}
\DoxyCodeLine{15848 \textcolor{stringliteral}{    Catch::Colour::Code dimColour() \{ return Catch::Colour::FileName; \}}}
\DoxyCodeLine{15849 \textcolor{stringliteral}{}}
\DoxyCodeLine{15850 \textcolor{stringliteral}{    std::string bothOrAll( std::size\_t count ) \{}}
\DoxyCodeLine{15851 \textcolor{stringliteral}{        return count == 1 ? std::string() :}}
\DoxyCodeLine{15852 \textcolor{stringliteral}{               count == 2 ? "{}both "{} : "{}all "{} ;}}
\DoxyCodeLine{15853 \textcolor{stringliteral}{    \}}}
\DoxyCodeLine{15854 \textcolor{stringliteral}{}}
\DoxyCodeLine{15855 \textcolor{stringliteral}{\} // anon namespace}}
\DoxyCodeLine{15856 \textcolor{stringliteral}{}}
\DoxyCodeLine{15857 \textcolor{stringliteral}{namespace Catch \{}}
\DoxyCodeLine{15858 \textcolor{stringliteral}{namespace \{}}
\DoxyCodeLine{15859 \textcolor{stringliteral}{// Colour, message variants:}}
\DoxyCodeLine{15860 \textcolor{stringliteral}{// -\/ white: No tests ran.}}
\DoxyCodeLine{15861 \textcolor{stringliteral}{// -\/   red: Failed [both/all] N test cases, failed [both/all] M assertions.}}
\DoxyCodeLine{15862 \textcolor{stringliteral}{// -\/ white: Passed [both/all] N test cases (no assertions).}}
\DoxyCodeLine{15863 \textcolor{stringliteral}{// -\/   red: Failed N tests cases, failed M assertions.}}
\DoxyCodeLine{15864 \textcolor{stringliteral}{// -\/ green: Passed [both/all] N tests cases with M assertions.}}
\DoxyCodeLine{15865 \textcolor{stringliteral}{void printTotals(std::ostream\& out, const Totals\& totals) \{}}
\DoxyCodeLine{15866 \textcolor{stringliteral}{    if (totals.testCases.total() == 0) \{}}
\DoxyCodeLine{15867 \textcolor{stringliteral}{        out << "{}No tests ran."{};}}
\DoxyCodeLine{15868 \textcolor{stringliteral}{    \} else if (totals.testCases.failed == totals.testCases.total()) \{}}
\DoxyCodeLine{15869 \textcolor{stringliteral}{        Colour colour(Colour::ResultError);}}
\DoxyCodeLine{15870 \textcolor{stringliteral}{        const std::string qualify\_assertions\_failed =}}
\DoxyCodeLine{15871 \textcolor{stringliteral}{            totals.assertions.failed == totals.assertions.total() ?}}
\DoxyCodeLine{15872 \textcolor{stringliteral}{            bothOrAll(totals.assertions.failed) : std::string();}}
\DoxyCodeLine{15873 \textcolor{stringliteral}{        out <<}}
\DoxyCodeLine{15874 \textcolor{stringliteral}{            "{}Failed "{} << bothOrAll(totals.testCases.failed)}}
\DoxyCodeLine{15875 \textcolor{stringliteral}{            << pluralise(totals.testCases.failed, "{}test case"{}) << "{}, "{}}}
\DoxyCodeLine{15876 \textcolor{stringliteral}{            "{}failed "{} << qualify\_assertions\_failed <<}}
\DoxyCodeLine{15877 \textcolor{stringliteral}{            pluralise(totals.assertions.failed, "{}assertion"{}) << '}.\textcolor{stringliteral}{';}}
\DoxyCodeLine{15878 \textcolor{stringliteral}{    \} else if (totals.assertions.total() == 0) \{}}
\DoxyCodeLine{15879 \textcolor{stringliteral}{        out <<}}
\DoxyCodeLine{15880 \textcolor{stringliteral}{            "{}Passed "{} << bothOrAll(totals.testCases.total())}}
\DoxyCodeLine{15881 \textcolor{stringliteral}{            << pluralise(totals.testCases.total(), "{}test case"{})}}
\DoxyCodeLine{15882 \textcolor{stringliteral}{            << "{} (no assertions)."{};}}
\DoxyCodeLine{15883 \textcolor{stringliteral}{    \} else if (totals.assertions.failed) \{}}
\DoxyCodeLine{15884 \textcolor{stringliteral}{        Colour colour(Colour::ResultError);}}
\DoxyCodeLine{15885 \textcolor{stringliteral}{        out <<}}
\DoxyCodeLine{15886 \textcolor{stringliteral}{            "{}Failed "{} << pluralise(totals.testCases.failed, "{}test case"{}) << "{}, "{}}}
\DoxyCodeLine{15887 \textcolor{stringliteral}{            "{}failed "{} << pluralise(totals.assertions.failed, "{}assertion"{}) << '}.\textcolor{stringliteral}{';}}
\DoxyCodeLine{15888 \textcolor{stringliteral}{    \} else \{}}
\DoxyCodeLine{15889 \textcolor{stringliteral}{        Colour colour(Colour::ResultSuccess);}}
\DoxyCodeLine{15890 \textcolor{stringliteral}{        out <<}}
\DoxyCodeLine{15891 \textcolor{stringliteral}{            "{}Passed "{} << bothOrAll(totals.testCases.passed)}}
\DoxyCodeLine{15892 \textcolor{stringliteral}{            << pluralise(totals.testCases.passed, "{}test case"{}) <<}}
\DoxyCodeLine{15893 \textcolor{stringliteral}{            "{} with "{} << pluralise(totals.assertions.passed, "{}assertion"{}) << '}.\textcolor{stringliteral}{';}}
\DoxyCodeLine{15894 \textcolor{stringliteral}{    \}}}
\DoxyCodeLine{15895 \textcolor{stringliteral}{\}}}
\DoxyCodeLine{15896 \textcolor{stringliteral}{}}
\DoxyCodeLine{15897 \textcolor{stringliteral}{// Implementation of CompactReporter formatting}}
\DoxyCodeLine{15898 \textcolor{stringliteral}{class AssertionPrinter \{}}
\DoxyCodeLine{15899 \textcolor{stringliteral}{public:}}
\DoxyCodeLine{15900 \textcolor{stringliteral}{    AssertionPrinter\& operator= (AssertionPrinter const\&) = delete;}}
\DoxyCodeLine{15901 \textcolor{stringliteral}{    AssertionPrinter(AssertionPrinter const\&) = delete;}}
\DoxyCodeLine{15902 \textcolor{stringliteral}{    AssertionPrinter(std::ostream\& \_stream, AssertionStats const\& \_stats, bool \_printInfoMessages)}}
\DoxyCodeLine{15903 \textcolor{stringliteral}{        : stream(\_stream)}}
\DoxyCodeLine{15904 \textcolor{stringliteral}{        , result(\_stats.assertionResult)}}
\DoxyCodeLine{15905 \textcolor{stringliteral}{        , messages(\_stats.infoMessages)}}
\DoxyCodeLine{15906 \textcolor{stringliteral}{        , itMessage(\_stats.infoMessages.begin())}}
\DoxyCodeLine{15907 \textcolor{stringliteral}{        , printInfoMessages(\_printInfoMessages) \{\}}}
\DoxyCodeLine{15908 \textcolor{stringliteral}{}}
\DoxyCodeLine{15909 \textcolor{stringliteral}{    void print() \{}}
\DoxyCodeLine{15910 \textcolor{stringliteral}{        printSourceInfo();}}
\DoxyCodeLine{15911 \textcolor{stringliteral}{}}
\DoxyCodeLine{15912 \textcolor{stringliteral}{        itMessage = messages.begin();}}
\DoxyCodeLine{15913 \textcolor{stringliteral}{}}
\DoxyCodeLine{15914 \textcolor{stringliteral}{        switch (result.getResultType()) \{}}
\DoxyCodeLine{15915 \textcolor{stringliteral}{        case ResultWas::Ok:}}
\DoxyCodeLine{15916 \textcolor{stringliteral}{            printResultType(Colour::ResultSuccess, passedString());}}
\DoxyCodeLine{15917 \textcolor{stringliteral}{            printOriginalExpression();}}
\DoxyCodeLine{15918 \textcolor{stringliteral}{            printReconstructedExpression();}}
\DoxyCodeLine{15919 \textcolor{stringliteral}{            if (!result.hasExpression())}}
\DoxyCodeLine{15920 \textcolor{stringliteral}{                printRemainingMessages(Colour::None);}}
\DoxyCodeLine{15921 \textcolor{stringliteral}{            else}}
\DoxyCodeLine{15922 \textcolor{stringliteral}{                printRemainingMessages();}}
\DoxyCodeLine{15923 \textcolor{stringliteral}{            break;}}
\DoxyCodeLine{15924 \textcolor{stringliteral}{        case ResultWas::ExpressionFailed:}}
\DoxyCodeLine{15925 \textcolor{stringliteral}{            if (result.isOk())}}
\DoxyCodeLine{15926 \textcolor{stringliteral}{                printResultType(Colour::ResultSuccess, failedString() + std::string("{} -\/ but was ok"{}));}}
\DoxyCodeLine{15927 \textcolor{stringliteral}{            else}}
\DoxyCodeLine{15928 \textcolor{stringliteral}{                printResultType(Colour::Error, failedString());}}
\DoxyCodeLine{15929 \textcolor{stringliteral}{            printOriginalExpression();}}
\DoxyCodeLine{15930 \textcolor{stringliteral}{            printReconstructedExpression();}}
\DoxyCodeLine{15931 \textcolor{stringliteral}{            printRemainingMessages();}}
\DoxyCodeLine{15932 \textcolor{stringliteral}{            break;}}
\DoxyCodeLine{15933 \textcolor{stringliteral}{        case ResultWas::ThrewException:}}
\DoxyCodeLine{15934 \textcolor{stringliteral}{            printResultType(Colour::Error, failedString());}}
\DoxyCodeLine{15935 \textcolor{stringliteral}{            printIssue("{}unexpected exception with message:"{});}}
\DoxyCodeLine{15936 \textcolor{stringliteral}{            printMessage();}}
\DoxyCodeLine{15937 \textcolor{stringliteral}{            printExpressionWas();}}
\DoxyCodeLine{15938 \textcolor{stringliteral}{            printRemainingMessages();}}
\DoxyCodeLine{15939 \textcolor{stringliteral}{            break;}}
\DoxyCodeLine{15940 \textcolor{stringliteral}{        case ResultWas::FatalErrorCondition:}}
\DoxyCodeLine{15941 \textcolor{stringliteral}{            printResultType(Colour::Error, failedString());}}
\DoxyCodeLine{15942 \textcolor{stringliteral}{            printIssue("{}fatal error condition with message:"{});}}
\DoxyCodeLine{15943 \textcolor{stringliteral}{            printMessage();}}
\DoxyCodeLine{15944 \textcolor{stringliteral}{            printExpressionWas();}}
\DoxyCodeLine{15945 \textcolor{stringliteral}{            printRemainingMessages();}}
\DoxyCodeLine{15946 \textcolor{stringliteral}{            break;}}
\DoxyCodeLine{15947 \textcolor{stringliteral}{        case ResultWas::DidntThrowException:}}
\DoxyCodeLine{15948 \textcolor{stringliteral}{            printResultType(Colour::Error, failedString());}}
\DoxyCodeLine{15949 \textcolor{stringliteral}{            printIssue("{}expected exception, got none"{});}}
\DoxyCodeLine{15950 \textcolor{stringliteral}{            printExpressionWas();}}
\DoxyCodeLine{15951 \textcolor{stringliteral}{            printRemainingMessages();}}
\DoxyCodeLine{15952 \textcolor{stringliteral}{            break;}}
\DoxyCodeLine{15953 \textcolor{stringliteral}{        case ResultWas::Info:}}
\DoxyCodeLine{15954 \textcolor{stringliteral}{            printResultType(Colour::None, "{}info"{});}}
\DoxyCodeLine{15955 \textcolor{stringliteral}{            printMessage();}}
\DoxyCodeLine{15956 \textcolor{stringliteral}{            printRemainingMessages();}}
\DoxyCodeLine{15957 \textcolor{stringliteral}{            break;}}
\DoxyCodeLine{15958 \textcolor{stringliteral}{        case ResultWas::Warning:}}
\DoxyCodeLine{15959 \textcolor{stringliteral}{            printResultType(Colour::None, "{}warning"{});}}
\DoxyCodeLine{15960 \textcolor{stringliteral}{            printMessage();}}
\DoxyCodeLine{15961 \textcolor{stringliteral}{            printRemainingMessages();}}
\DoxyCodeLine{15962 \textcolor{stringliteral}{            break;}}
\DoxyCodeLine{15963 \textcolor{stringliteral}{        case ResultWas::ExplicitFailure:}}
\DoxyCodeLine{15964 \textcolor{stringliteral}{            printResultType(Colour::Error, failedString());}}
\DoxyCodeLine{15965 \textcolor{stringliteral}{            printIssue("{}explicitly"{});}}
\DoxyCodeLine{15966 \textcolor{stringliteral}{            printRemainingMessages(Colour::None);}}
\DoxyCodeLine{15967 \textcolor{stringliteral}{            break;}}
\DoxyCodeLine{15968 \textcolor{stringliteral}{            // These cases are here to prevent compiler warnings}}
\DoxyCodeLine{15969 \textcolor{stringliteral}{        case ResultWas::Unknown:}}
\DoxyCodeLine{15970 \textcolor{stringliteral}{        case ResultWas::FailureBit:}}
\DoxyCodeLine{15971 \textcolor{stringliteral}{        case ResultWas::Exception:}}
\DoxyCodeLine{15972 \textcolor{stringliteral}{            printResultType(Colour::Error, "{}** internal error **"{});}}
\DoxyCodeLine{15973 \textcolor{stringliteral}{            break;}}
\DoxyCodeLine{15974 \textcolor{stringliteral}{        \}}}
\DoxyCodeLine{15975 \textcolor{stringliteral}{    \}}}
\DoxyCodeLine{15976 \textcolor{stringliteral}{}}
\DoxyCodeLine{15977 \textcolor{stringliteral}{private:}}
\DoxyCodeLine{15978 \textcolor{stringliteral}{    void printSourceInfo() const \{}}
\DoxyCodeLine{15979 \textcolor{stringliteral}{        Colour colourGuard(Colour::FileName);}}
\DoxyCodeLine{15980 \textcolor{stringliteral}{        stream << result.getSourceInfo() << '}:\textcolor{stringliteral}{';}}
\DoxyCodeLine{15981 \textcolor{stringliteral}{    \}}}
\DoxyCodeLine{15982 \textcolor{stringliteral}{}}
\DoxyCodeLine{15983 \textcolor{stringliteral}{    void printResultType(Colour::Code colour, std::string const\& passOrFail) const \{}}
\DoxyCodeLine{15984 \textcolor{stringliteral}{        if (!passOrFail.empty()) \{}}
\DoxyCodeLine{15985 \textcolor{stringliteral}{            \{}}
\DoxyCodeLine{15986 \textcolor{stringliteral}{                Colour colourGuard(colour);}}
\DoxyCodeLine{15987 \textcolor{stringliteral}{                stream << '} \textcolor{stringliteral}{' << passOrFail;}}
\DoxyCodeLine{15988 \textcolor{stringliteral}{            \}}}
\DoxyCodeLine{15989 \textcolor{stringliteral}{            stream << '}:\textcolor{stringliteral}{';}}
\DoxyCodeLine{15990 \textcolor{stringliteral}{        \}}}
\DoxyCodeLine{15991 \textcolor{stringliteral}{    \}}}
\DoxyCodeLine{15992 \textcolor{stringliteral}{}}
\DoxyCodeLine{15993 \textcolor{stringliteral}{    void printIssue(std::string const\& issue) const \{}}
\DoxyCodeLine{15994 \textcolor{stringliteral}{        stream << '} \textcolor{stringliteral}{' << issue;}}
\DoxyCodeLine{15995 \textcolor{stringliteral}{    \}}}
\DoxyCodeLine{15996 \textcolor{stringliteral}{}}
\DoxyCodeLine{15997 \textcolor{stringliteral}{    void printExpressionWas() \{}}
\DoxyCodeLine{15998 \textcolor{stringliteral}{        if (result.hasExpression()) \{}}
\DoxyCodeLine{15999 \textcolor{stringliteral}{            stream << '};\textcolor{stringliteral}{';}}
\DoxyCodeLine{16000 \textcolor{stringliteral}{            \{}}
\DoxyCodeLine{16001 \textcolor{stringliteral}{                Colour colour(dimColour());}}
\DoxyCodeLine{16002 \textcolor{stringliteral}{                stream << "{} expression was:"{};}}
\DoxyCodeLine{16003 \textcolor{stringliteral}{            \}}}
\DoxyCodeLine{16004 \textcolor{stringliteral}{            printOriginalExpression();}}
\DoxyCodeLine{16005 \textcolor{stringliteral}{        \}}}
\DoxyCodeLine{16006 \textcolor{stringliteral}{    \}}}
\DoxyCodeLine{16007 \textcolor{stringliteral}{}}
\DoxyCodeLine{16008 \textcolor{stringliteral}{    void printOriginalExpression() const \{}}
\DoxyCodeLine{16009 \textcolor{stringliteral}{        if (result.hasExpression()) \{}}
\DoxyCodeLine{16010 \textcolor{stringliteral}{            stream << '} \textcolor{stringliteral}{' << result.getExpression();}}
\DoxyCodeLine{16011 \textcolor{stringliteral}{        \}}}
\DoxyCodeLine{16012 \textcolor{stringliteral}{    \}}}
\DoxyCodeLine{16013 \textcolor{stringliteral}{}}
\DoxyCodeLine{16014 \textcolor{stringliteral}{    void printReconstructedExpression() const \{}}
\DoxyCodeLine{16015 \textcolor{stringliteral}{        if (result.hasExpandedExpression()) \{}}
\DoxyCodeLine{16016 \textcolor{stringliteral}{            \{}}
\DoxyCodeLine{16017 \textcolor{stringliteral}{                Colour colour(dimColour());}}
\DoxyCodeLine{16018 \textcolor{stringliteral}{                stream << "{} for: "{};}}
\DoxyCodeLine{16019 \textcolor{stringliteral}{            \}}}
\DoxyCodeLine{16020 \textcolor{stringliteral}{            stream << result.getExpandedExpression();}}
\DoxyCodeLine{16021 \textcolor{stringliteral}{        \}}}
\DoxyCodeLine{16022 \textcolor{stringliteral}{    \}}}
\DoxyCodeLine{16023 \textcolor{stringliteral}{}}
\DoxyCodeLine{16024 \textcolor{stringliteral}{    void printMessage() \{}}
\DoxyCodeLine{16025 \textcolor{stringliteral}{        if (itMessage != messages.end()) \{}}
\DoxyCodeLine{16026 \textcolor{stringliteral}{            stream << "{} '}\textcolor{stringliteral}{"{} << itMessage-\/>message << '\(\backslash\)'';}}
\DoxyCodeLine{16027 \textcolor{stringliteral}{            ++itMessage;}}
\DoxyCodeLine{16028 \textcolor{stringliteral}{        \}}}
\DoxyCodeLine{16029 \textcolor{stringliteral}{    \}}}
\DoxyCodeLine{16030 \textcolor{stringliteral}{}}
\DoxyCodeLine{16031 \textcolor{stringliteral}{    void printRemainingMessages(Colour::Code colour = dimColour()) \{}}
\DoxyCodeLine{16032 \textcolor{stringliteral}{        if (itMessage == messages.end())}}
\DoxyCodeLine{16033 \textcolor{stringliteral}{            return;}}
\DoxyCodeLine{16034 \textcolor{stringliteral}{}}
\DoxyCodeLine{16035 \textcolor{stringliteral}{        const auto itEnd = messages.cend();}}
\DoxyCodeLine{16036 \textcolor{stringliteral}{        const auto N = static\_cast<std::size\_t>(std::distance(itMessage, itEnd));}}
\DoxyCodeLine{16037 \textcolor{stringliteral}{}}
\DoxyCodeLine{16038 \textcolor{stringliteral}{        \{}}
\DoxyCodeLine{16039 \textcolor{stringliteral}{            Colour colourGuard(colour);}}
\DoxyCodeLine{16040 \textcolor{stringliteral}{            stream << "{}} with \textcolor{stringliteral}{"{} << pluralise(N, "{}}message\textcolor{stringliteral}{"{}) << ':';}}
\DoxyCodeLine{16041 \textcolor{stringliteral}{        \}}}
\DoxyCodeLine{16042 \textcolor{stringliteral}{}}
\DoxyCodeLine{16043 \textcolor{stringliteral}{        while (itMessage != itEnd) \{}}
\DoxyCodeLine{16044 \textcolor{stringliteral}{            // If this assertion is a warning ignore any INFO messages}}
\DoxyCodeLine{16045 \textcolor{stringliteral}{            if (printInfoMessages || itMessage-\/>type != ResultWas::Info) \{}}
\DoxyCodeLine{16046 \textcolor{stringliteral}{                printMessage();}}
\DoxyCodeLine{16047 \textcolor{stringliteral}{                if (itMessage != itEnd) \{}}
\DoxyCodeLine{16048 \textcolor{stringliteral}{                    Colour colourGuard(dimColour());}}
\DoxyCodeLine{16049 \textcolor{stringliteral}{                    stream << "{}} and\textcolor{stringliteral}{"{};}}
\DoxyCodeLine{16050 \textcolor{stringliteral}{                \}}}
\DoxyCodeLine{16051 \textcolor{stringliteral}{                continue;}}
\DoxyCodeLine{16052 \textcolor{stringliteral}{            \}}}
\DoxyCodeLine{16053 \textcolor{stringliteral}{            ++itMessage;}}
\DoxyCodeLine{16054 \textcolor{stringliteral}{        \}}}
\DoxyCodeLine{16055 \textcolor{stringliteral}{    \}}}
\DoxyCodeLine{16056 \textcolor{stringliteral}{}}
\DoxyCodeLine{16057 \textcolor{stringliteral}{private:}}
\DoxyCodeLine{16058 \textcolor{stringliteral}{    std::ostream\& stream;}}
\DoxyCodeLine{16059 \textcolor{stringliteral}{    AssertionResult const\& result;}}
\DoxyCodeLine{16060 \textcolor{stringliteral}{    std::vector<MessageInfo> messages;}}
\DoxyCodeLine{16061 \textcolor{stringliteral}{    std::vector<MessageInfo>::const\_iterator itMessage;}}
\DoxyCodeLine{16062 \textcolor{stringliteral}{    bool printInfoMessages;}}
\DoxyCodeLine{16063 \textcolor{stringliteral}{\};}}
\DoxyCodeLine{16064 \textcolor{stringliteral}{}}
\DoxyCodeLine{16065 \textcolor{stringliteral}{\} // anon namespace}}
\DoxyCodeLine{16066 \textcolor{stringliteral}{}}
\DoxyCodeLine{16067 \textcolor{stringliteral}{        std::string CompactReporter::getDescription() \{}}
\DoxyCodeLine{16068 \textcolor{stringliteral}{            return "{}}Reports test results on a single line, suitable \textcolor{keywordflow}{for} IDEs\textcolor{stringliteral}{"{};}}
\DoxyCodeLine{16069 \textcolor{stringliteral}{        \}}}
\DoxyCodeLine{16070 \textcolor{stringliteral}{}}
\DoxyCodeLine{16071 \textcolor{stringliteral}{        void CompactReporter::noMatchingTestCases( std::string const\& spec ) \{}}
\DoxyCodeLine{16072 \textcolor{stringliteral}{            stream << "{}}No test cases matched \textcolor{stringliteral}{'"{} << spec << '}\(\backslash\)\textcolor{stringliteral}{''} << std::endl;}
\DoxyCodeLine{16073         \}}
\DoxyCodeLine{16074 }
\DoxyCodeLine{16075         \textcolor{keywordtype}{void} CompactReporter::assertionStarting( AssertionInfo \textcolor{keyword}{const}\& ) \{\}}
\DoxyCodeLine{16076 }
\DoxyCodeLine{16077         \textcolor{keywordtype}{bool} CompactReporter::assertionEnded( AssertionStats \textcolor{keyword}{const}\& \_assertionStats ) \{}
\DoxyCodeLine{16078             AssertionResult \textcolor{keyword}{const}\& result = \_assertionStats.assertionResult;}
\DoxyCodeLine{16079 }
\DoxyCodeLine{16080             \textcolor{keywordtype}{bool} printInfoMessages = \textcolor{keyword}{true};}
\DoxyCodeLine{16081 }
\DoxyCodeLine{16082             \textcolor{comment}{// Drop out if result was successful and we're not printing those}}
\DoxyCodeLine{16083             \textcolor{keywordflow}{if}( !m\_config-\/>includeSuccessfulResults() \&\& result.isOk() ) \{}
\DoxyCodeLine{16084                 \textcolor{keywordflow}{if}( result.getResultType() != ResultWas::Warning )}
\DoxyCodeLine{16085                     \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{16086                 printInfoMessages = \textcolor{keyword}{false};}
\DoxyCodeLine{16087             \}}
\DoxyCodeLine{16088 }
\DoxyCodeLine{16089             AssertionPrinter printer( stream, \_assertionStats, printInfoMessages );}
\DoxyCodeLine{16090             printer.print();}
\DoxyCodeLine{16091 }
\DoxyCodeLine{16092             stream << std::endl;}
\DoxyCodeLine{16093             \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{16094         \}}
\DoxyCodeLine{16095 }
\DoxyCodeLine{16096         \textcolor{keywordtype}{void} CompactReporter::sectionEnded(SectionStats \textcolor{keyword}{const}\& \_sectionStats) \{}
\DoxyCodeLine{16097             \textcolor{keywordtype}{double} dur = \_sectionStats.durationInSeconds;}
\DoxyCodeLine{16098             \textcolor{keywordflow}{if} ( shouldShowDuration( *m\_config, dur ) ) \{}
\DoxyCodeLine{16099                 stream << getFormattedDuration( dur ) << \textcolor{stringliteral}{"{} s: "{}} << \_sectionStats.sectionInfo.name << std::endl;}
\DoxyCodeLine{16100             \}}
\DoxyCodeLine{16101         \}}
\DoxyCodeLine{16102 }
\DoxyCodeLine{16103         \textcolor{keywordtype}{void} CompactReporter::testRunEnded( TestRunStats \textcolor{keyword}{const}\& \_testRunStats ) \{}
\DoxyCodeLine{16104             printTotals( stream, \_testRunStats.totals );}
\DoxyCodeLine{16105             stream << \textcolor{charliteral}{'\(\backslash\)n'} << std::endl;}
\DoxyCodeLine{16106             StreamingReporterBase::testRunEnded( \_testRunStats );}
\DoxyCodeLine{16107         \}}
\DoxyCodeLine{16108 }
\DoxyCodeLine{16109         CompactReporter::\string~CompactReporter() \{\}}
\DoxyCodeLine{16110 }
\DoxyCodeLine{16111     CATCH\_REGISTER\_REPORTER( \textcolor{stringliteral}{"{}compact"{}}, CompactReporter )}
\DoxyCodeLine{16112 }
\DoxyCodeLine{16113 \} \textcolor{comment}{// end namespace Catch}}
\DoxyCodeLine{16114 \textcolor{comment}{// end catch\_reporter\_compact.cpp}}
\DoxyCodeLine{16115 \textcolor{comment}{// start catch\_reporter\_console.cpp}}
\DoxyCodeLine{16116 }
\DoxyCodeLine{16117 \textcolor{preprocessor}{\#include <cfloat>}}
\DoxyCodeLine{16118 \textcolor{preprocessor}{\#include <cstdio>}}
\DoxyCodeLine{16119 }
\DoxyCodeLine{16120 \textcolor{preprocessor}{\#if defined(\_MSC\_VER)}}
\DoxyCodeLine{16121 \textcolor{preprocessor}{\#pragma warning(push)}}
\DoxyCodeLine{16122 \textcolor{preprocessor}{\#pragma warning(disable:4061) }\textcolor{comment}{// Not all labels are EXPLICITLY handled in switch}}
\DoxyCodeLine{16123  \textcolor{comment}{// Note that 4062 (not all labels are handled and default is missing) is enabled}}
\DoxyCodeLine{16124 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{16125 }
\DoxyCodeLine{16126 \textcolor{preprocessor}{\#if defined(\_\_clang\_\_)}}
\DoxyCodeLine{16127 \textcolor{preprocessor}{\#  pragma clang diagnostic push}}
\DoxyCodeLine{16128 \textcolor{comment}{// For simplicity, benchmarking-\/only helpers are always enabled}}
\DoxyCodeLine{16129 \textcolor{preprocessor}{\#  pragma clang diagnostic ignored "{}-\/Wunused-\/function"{}}}
\DoxyCodeLine{16130 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{16131 }
\DoxyCodeLine{16132 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{16133 }
\DoxyCodeLine{16134 \textcolor{keyword}{namespace }\{}
\DoxyCodeLine{16135 }
\DoxyCodeLine{16136 \textcolor{comment}{// Formatter impl for ConsoleReporter}}
\DoxyCodeLine{16137 \textcolor{keyword}{class }ConsoleAssertionPrinter \{}
\DoxyCodeLine{16138 \textcolor{keyword}{public}:}
\DoxyCodeLine{16139     ConsoleAssertionPrinter\& operator= (ConsoleAssertionPrinter \textcolor{keyword}{const}\&) = \textcolor{keyword}{delete};}
\DoxyCodeLine{16140     ConsoleAssertionPrinter(ConsoleAssertionPrinter \textcolor{keyword}{const}\&) = \textcolor{keyword}{delete};}
\DoxyCodeLine{16141     ConsoleAssertionPrinter(std::ostream\& \_stream, AssertionStats \textcolor{keyword}{const}\& \_stats, \textcolor{keywordtype}{bool} \_printInfoMessages)}
\DoxyCodeLine{16142         : stream(\_stream),}
\DoxyCodeLine{16143         stats(\_stats),}
\DoxyCodeLine{16144         result(\_stats.assertionResult),}
\DoxyCodeLine{16145         colour(Colour::None),}
\DoxyCodeLine{16146         message(result.getMessage()),}
\DoxyCodeLine{16147         messages(\_stats.infoMessages),}
\DoxyCodeLine{16148         printInfoMessages(\_printInfoMessages) \{}
\DoxyCodeLine{16149         \textcolor{keywordflow}{switch} (result.getResultType()) \{}
\DoxyCodeLine{16150         \textcolor{keywordflow}{case} ResultWas::Ok:}
\DoxyCodeLine{16151             colour = Colour::Success;}
\DoxyCodeLine{16152             passOrFail = \textcolor{stringliteral}{"{}PASSED"{}};}
\DoxyCodeLine{16153             \textcolor{comment}{//if( result.hasMessage() )}}
\DoxyCodeLine{16154             \textcolor{keywordflow}{if} (\_stats.infoMessages.size() == 1)}
\DoxyCodeLine{16155                 messageLabel = \textcolor{stringliteral}{"{}with message"{}};}
\DoxyCodeLine{16156             \textcolor{keywordflow}{if} (\_stats.infoMessages.size() > 1)}
\DoxyCodeLine{16157                 messageLabel = \textcolor{stringliteral}{"{}with messages"{}};}
\DoxyCodeLine{16158             \textcolor{keywordflow}{break};}
\DoxyCodeLine{16159         \textcolor{keywordflow}{case} ResultWas::ExpressionFailed:}
\DoxyCodeLine{16160             \textcolor{keywordflow}{if} (result.isOk()) \{}
\DoxyCodeLine{16161                 colour = Colour::Success;}
\DoxyCodeLine{16162                 passOrFail = \textcolor{stringliteral}{"{}FAILED -\/ but was ok"{}};}
\DoxyCodeLine{16163             \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{16164                 colour = Colour::Error;}
\DoxyCodeLine{16165                 passOrFail = \textcolor{stringliteral}{"{}FAILED"{}};}
\DoxyCodeLine{16166             \}}
\DoxyCodeLine{16167             \textcolor{keywordflow}{if} (\_stats.infoMessages.size() == 1)}
\DoxyCodeLine{16168                 messageLabel = \textcolor{stringliteral}{"{}with message"{}};}
\DoxyCodeLine{16169             \textcolor{keywordflow}{if} (\_stats.infoMessages.size() > 1)}
\DoxyCodeLine{16170                 messageLabel = \textcolor{stringliteral}{"{}with messages"{}};}
\DoxyCodeLine{16171             \textcolor{keywordflow}{break};}
\DoxyCodeLine{16172         \textcolor{keywordflow}{case} ResultWas::ThrewException:}
\DoxyCodeLine{16173             colour = Colour::Error;}
\DoxyCodeLine{16174             passOrFail = \textcolor{stringliteral}{"{}FAILED"{}};}
\DoxyCodeLine{16175             messageLabel = \textcolor{stringliteral}{"{}due to unexpected exception with "{}};}
\DoxyCodeLine{16176             \textcolor{keywordflow}{if} (\_stats.infoMessages.size() == 1)}
\DoxyCodeLine{16177                 messageLabel += "{}message"{};}
\DoxyCodeLine{16178             \textcolor{keywordflow}{if} (\_stats.infoMessages.size() > 1)}
\DoxyCodeLine{16179                 messageLabel += "{}messages"{};}
\DoxyCodeLine{16180             \textcolor{keywordflow}{break};}
\DoxyCodeLine{16181         \textcolor{keywordflow}{case} ResultWas::FatalErrorCondition:}
\DoxyCodeLine{16182             colour = Colour::Error;}
\DoxyCodeLine{16183             passOrFail = \textcolor{stringliteral}{"{}FAILED"{}};}
\DoxyCodeLine{16184             messageLabel = \textcolor{stringliteral}{"{}due to a fatal error condition"{}};}
\DoxyCodeLine{16185             \textcolor{keywordflow}{break};}
\DoxyCodeLine{16186         \textcolor{keywordflow}{case} ResultWas::DidntThrowException:}
\DoxyCodeLine{16187             colour = Colour::Error;}
\DoxyCodeLine{16188             passOrFail = \textcolor{stringliteral}{"{}FAILED"{}};}
\DoxyCodeLine{16189             messageLabel = \textcolor{stringliteral}{"{}because no exception was thrown where one was expected"{}};}
\DoxyCodeLine{16190             \textcolor{keywordflow}{break};}
\DoxyCodeLine{16191         \textcolor{keywordflow}{case} ResultWas::Info:}
\DoxyCodeLine{16192             messageLabel = \textcolor{stringliteral}{"{}info"{}};}
\DoxyCodeLine{16193             \textcolor{keywordflow}{break};}
\DoxyCodeLine{16194         \textcolor{keywordflow}{case} ResultWas::Warning:}
\DoxyCodeLine{16195             messageLabel = \textcolor{stringliteral}{"{}warning"{}};}
\DoxyCodeLine{16196             \textcolor{keywordflow}{break};}
\DoxyCodeLine{16197         \textcolor{keywordflow}{case} ResultWas::ExplicitFailure:}
\DoxyCodeLine{16198             passOrFail = \textcolor{stringliteral}{"{}FAILED"{}};}
\DoxyCodeLine{16199             colour = Colour::Error;}
\DoxyCodeLine{16200             \textcolor{keywordflow}{if} (\_stats.infoMessages.size() == 1)}
\DoxyCodeLine{16201                 messageLabel = \textcolor{stringliteral}{"{}explicitly with message"{}};}
\DoxyCodeLine{16202             \textcolor{keywordflow}{if} (\_stats.infoMessages.size() > 1)}
\DoxyCodeLine{16203                 messageLabel = \textcolor{stringliteral}{"{}explicitly with messages"{}};}
\DoxyCodeLine{16204             \textcolor{keywordflow}{break};}
\DoxyCodeLine{16205             \textcolor{comment}{// These cases are here to prevent compiler warnings}}
\DoxyCodeLine{16206         \textcolor{keywordflow}{case} ResultWas::Unknown:}
\DoxyCodeLine{16207         \textcolor{keywordflow}{case} ResultWas::FailureBit:}
\DoxyCodeLine{16208         \textcolor{keywordflow}{case} ResultWas::Exception:}
\DoxyCodeLine{16209             passOrFail = \textcolor{stringliteral}{"{}** internal error **"{}};}
\DoxyCodeLine{16210             colour = Colour::Error;}
\DoxyCodeLine{16211             \textcolor{keywordflow}{break};}
\DoxyCodeLine{16212         \}}
\DoxyCodeLine{16213     \}}
\DoxyCodeLine{16214 }
\DoxyCodeLine{16215     \textcolor{keywordtype}{void} print()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{16216         printSourceInfo();}
\DoxyCodeLine{16217         \textcolor{keywordflow}{if} (stats.totals.assertions.total() > 0) \{}
\DoxyCodeLine{16218             printResultType();}
\DoxyCodeLine{16219             printOriginalExpression();}
\DoxyCodeLine{16220             printReconstructedExpression();}
\DoxyCodeLine{16221         \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{16222             stream << \textcolor{charliteral}{'\(\backslash\)n'};}
\DoxyCodeLine{16223         \}}
\DoxyCodeLine{16224         printMessage();}
\DoxyCodeLine{16225     \}}
\DoxyCodeLine{16226 }
\DoxyCodeLine{16227 \textcolor{keyword}{private}:}
\DoxyCodeLine{16228     \textcolor{keywordtype}{void} printResultType()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{16229         \textcolor{keywordflow}{if} (!passOrFail.empty()) \{}
\DoxyCodeLine{16230             Colour colourGuard(colour);}
\DoxyCodeLine{16231             stream << passOrFail << \textcolor{stringliteral}{"{}:\(\backslash\)n"{}};}
\DoxyCodeLine{16232         \}}
\DoxyCodeLine{16233     \}}
\DoxyCodeLine{16234     \textcolor{keywordtype}{void} printOriginalExpression()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{16235         \textcolor{keywordflow}{if} (result.hasExpression()) \{}
\DoxyCodeLine{16236             Colour colourGuard(Colour::OriginalExpression);}
\DoxyCodeLine{16237             stream << \textcolor{stringliteral}{"{}  "{}};}
\DoxyCodeLine{16238             stream << result.getExpressionInMacro();}
\DoxyCodeLine{16239             stream << \textcolor{charliteral}{'\(\backslash\)n'};}
\DoxyCodeLine{16240         \}}
\DoxyCodeLine{16241     \}}
\DoxyCodeLine{16242     \textcolor{keywordtype}{void} printReconstructedExpression()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{16243         \textcolor{keywordflow}{if} (result.hasExpandedExpression()) \{}
\DoxyCodeLine{16244             stream << \textcolor{stringliteral}{"{}with expansion:\(\backslash\)n"{}};}
\DoxyCodeLine{16245             Colour colourGuard(Colour::ReconstructedExpression);}
\DoxyCodeLine{16246             stream << Column(result.getExpandedExpression()).indent(2) << \textcolor{charliteral}{'\(\backslash\)n'};}
\DoxyCodeLine{16247         \}}
\DoxyCodeLine{16248     \}}
\DoxyCodeLine{16249     \textcolor{keywordtype}{void} printMessage()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{16250         \textcolor{keywordflow}{if} (!messageLabel.empty())}
\DoxyCodeLine{16251             stream << messageLabel << \textcolor{charliteral}{':'} << \textcolor{charliteral}{'\(\backslash\)n'};}
\DoxyCodeLine{16252         \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} \textcolor{keyword}{const}\& msg : messages) \{}
\DoxyCodeLine{16253             \textcolor{comment}{// If this assertion is a warning ignore any INFO messages}}
\DoxyCodeLine{16254             \textcolor{keywordflow}{if} (printInfoMessages || msg.type != ResultWas::Info)}
\DoxyCodeLine{16255                 stream << Column(msg.message).indent(2) << \textcolor{charliteral}{'\(\backslash\)n'};}
\DoxyCodeLine{16256         \}}
\DoxyCodeLine{16257     \}}
\DoxyCodeLine{16258     \textcolor{keywordtype}{void} printSourceInfo()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{16259         Colour colourGuard(Colour::FileName);}
\DoxyCodeLine{16260         stream << result.getSourceInfo() << \textcolor{stringliteral}{"{}: "{}};}
\DoxyCodeLine{16261     \}}
\DoxyCodeLine{16262 }
\DoxyCodeLine{16263     std::ostream\& stream;}
\DoxyCodeLine{16264     AssertionStats \textcolor{keyword}{const}\& stats;}
\DoxyCodeLine{16265     AssertionResult \textcolor{keyword}{const}\& result;}
\DoxyCodeLine{16266     Colour::Code colour;}
\DoxyCodeLine{16267     std::string passOrFail;}
\DoxyCodeLine{16268     std::string messageLabel;}
\DoxyCodeLine{16269     std::string message;}
\DoxyCodeLine{16270     std::vector<MessageInfo> messages;}
\DoxyCodeLine{16271     \textcolor{keywordtype}{bool} printInfoMessages;}
\DoxyCodeLine{16272 \};}
\DoxyCodeLine{16273 }
\DoxyCodeLine{16274 std::size\_t makeRatio(std::size\_t number, std::size\_t total) \{}
\DoxyCodeLine{16275     std::size\_t ratio = total > 0 ? CATCH\_CONFIG\_CONSOLE\_WIDTH * number / total : 0;}
\DoxyCodeLine{16276     \textcolor{keywordflow}{return} (ratio == 0 \&\& number > 0) ? 1 : ratio;}
\DoxyCodeLine{16277 \}}
\DoxyCodeLine{16278 }
\DoxyCodeLine{16279 std::size\_t\& findMax(std::size\_t\& i, std::size\_t\& j, std::size\_t\& k) \{}
\DoxyCodeLine{16280     \textcolor{keywordflow}{if} (i > j \&\& i > k)}
\DoxyCodeLine{16281         \textcolor{keywordflow}{return} i;}
\DoxyCodeLine{16282     \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (j > k)}
\DoxyCodeLine{16283         \textcolor{keywordflow}{return} j;}
\DoxyCodeLine{16284     \textcolor{keywordflow}{else}}
\DoxyCodeLine{16285         \textcolor{keywordflow}{return} k;}
\DoxyCodeLine{16286 \}}
\DoxyCodeLine{16287 }
\DoxyCodeLine{16288 \textcolor{keyword}{struct }ColumnInfo \{}
\DoxyCodeLine{16289     \textcolor{keyword}{enum} Justification \{ Left, Right \};}
\DoxyCodeLine{16290     std::string name;}
\DoxyCodeLine{16291     \textcolor{keywordtype}{int} width;}
\DoxyCodeLine{16292     Justification justification;}
\DoxyCodeLine{16293 \};}
\DoxyCodeLine{16294 \textcolor{keyword}{struct }ColumnBreak \{\};}
\DoxyCodeLine{16295 \textcolor{keyword}{struct }RowBreak \{\};}
\DoxyCodeLine{16296 }
\DoxyCodeLine{16297 \textcolor{keyword}{class }Duration \{}
\DoxyCodeLine{16298     \textcolor{keyword}{enum class} Unit \{}
\DoxyCodeLine{16299         Auto,}
\DoxyCodeLine{16300         Nanoseconds,}
\DoxyCodeLine{16301         Microseconds,}
\DoxyCodeLine{16302         Milliseconds,}
\DoxyCodeLine{16303         Seconds,}
\DoxyCodeLine{16304         Minutes}
\DoxyCodeLine{16305     \};}
\DoxyCodeLine{16306     \textcolor{keyword}{static} \textcolor{keyword}{const} uint64\_t s\_nanosecondsInAMicrosecond = 1000;}
\DoxyCodeLine{16307     \textcolor{keyword}{static} \textcolor{keyword}{const} uint64\_t s\_nanosecondsInAMillisecond = 1000 * s\_nanosecondsInAMicrosecond;}
\DoxyCodeLine{16308     \textcolor{keyword}{static} \textcolor{keyword}{const} uint64\_t s\_nanosecondsInASecond = 1000 * s\_nanosecondsInAMillisecond;}
\DoxyCodeLine{16309     \textcolor{keyword}{static} \textcolor{keyword}{const} uint64\_t s\_nanosecondsInAMinute = 60 * s\_nanosecondsInASecond;}
\DoxyCodeLine{16310 }
\DoxyCodeLine{16311     \textcolor{keywordtype}{double} m\_inNanoseconds;}
\DoxyCodeLine{16312     Unit m\_units;}
\DoxyCodeLine{16313 }
\DoxyCodeLine{16314 \textcolor{keyword}{public}:}
\DoxyCodeLine{16315     \textcolor{keyword}{explicit} Duration(\textcolor{keywordtype}{double} inNanoseconds, Unit units = Unit::Auto)}
\DoxyCodeLine{16316         : m\_inNanoseconds(inNanoseconds),}
\DoxyCodeLine{16317         m\_units(units) \{}
\DoxyCodeLine{16318         \textcolor{keywordflow}{if} (m\_units == Unit::Auto) \{}
\DoxyCodeLine{16319             \textcolor{keywordflow}{if} (m\_inNanoseconds < s\_nanosecondsInAMicrosecond)}
\DoxyCodeLine{16320                 m\_units = Unit::Nanoseconds;}
\DoxyCodeLine{16321             \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (m\_inNanoseconds < s\_nanosecondsInAMillisecond)}
\DoxyCodeLine{16322                 m\_units = Unit::Microseconds;}
\DoxyCodeLine{16323             \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (m\_inNanoseconds < s\_nanosecondsInASecond)}
\DoxyCodeLine{16324                 m\_units = Unit::Milliseconds;}
\DoxyCodeLine{16325             \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (m\_inNanoseconds < s\_nanosecondsInAMinute)}
\DoxyCodeLine{16326                 m\_units = Unit::Seconds;}
\DoxyCodeLine{16327             \textcolor{keywordflow}{else}}
\DoxyCodeLine{16328                 m\_units = Unit::Minutes;}
\DoxyCodeLine{16329         \}}
\DoxyCodeLine{16330 }
\DoxyCodeLine{16331     \}}
\DoxyCodeLine{16332 }
\DoxyCodeLine{16333     \textcolor{keyword}{auto} value() const -\/> \textcolor{keywordtype}{double} \{}
\DoxyCodeLine{16334         \textcolor{keywordflow}{switch} (m\_units) \{}
\DoxyCodeLine{16335         \textcolor{keywordflow}{case} Unit::Microseconds:}
\DoxyCodeLine{16336             \textcolor{keywordflow}{return} m\_inNanoseconds / \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{double}\textcolor{keyword}{>}(s\_nanosecondsInAMicrosecond);}
\DoxyCodeLine{16337         \textcolor{keywordflow}{case} Unit::Milliseconds:}
\DoxyCodeLine{16338             \textcolor{keywordflow}{return} m\_inNanoseconds / \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{double}\textcolor{keyword}{>}(s\_nanosecondsInAMillisecond);}
\DoxyCodeLine{16339         \textcolor{keywordflow}{case} Unit::Seconds:}
\DoxyCodeLine{16340             \textcolor{keywordflow}{return} m\_inNanoseconds / \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{double}\textcolor{keyword}{>}(s\_nanosecondsInASecond);}
\DoxyCodeLine{16341         \textcolor{keywordflow}{case} Unit::Minutes:}
\DoxyCodeLine{16342             \textcolor{keywordflow}{return} m\_inNanoseconds / \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{double}\textcolor{keyword}{>}(s\_nanosecondsInAMinute);}
\DoxyCodeLine{16343         \textcolor{keywordflow}{default}:}
\DoxyCodeLine{16344             \textcolor{keywordflow}{return} m\_inNanoseconds;}
\DoxyCodeLine{16345         \}}
\DoxyCodeLine{16346     \}}
\DoxyCodeLine{16347     \textcolor{keyword}{auto} unitsAsString() const -\/> std::\textcolor{keywordtype}{string} \{}
\DoxyCodeLine{16348         \textcolor{keywordflow}{switch} (m\_units) \{}
\DoxyCodeLine{16349         \textcolor{keywordflow}{case} Unit::Nanoseconds:}
\DoxyCodeLine{16350             \textcolor{keywordflow}{return} \textcolor{stringliteral}{"{}ns"{}};}
\DoxyCodeLine{16351         \textcolor{keywordflow}{case} Unit::Microseconds:}
\DoxyCodeLine{16352             \textcolor{keywordflow}{return} \textcolor{stringliteral}{"{}us"{}};}
\DoxyCodeLine{16353         \textcolor{keywordflow}{case} Unit::Milliseconds:}
\DoxyCodeLine{16354             \textcolor{keywordflow}{return} \textcolor{stringliteral}{"{}ms"{}};}
\DoxyCodeLine{16355         \textcolor{keywordflow}{case} Unit::Seconds:}
\DoxyCodeLine{16356             \textcolor{keywordflow}{return} \textcolor{stringliteral}{"{}s"{}};}
\DoxyCodeLine{16357         \textcolor{keywordflow}{case} Unit::Minutes:}
\DoxyCodeLine{16358             \textcolor{keywordflow}{return} \textcolor{stringliteral}{"{}m"{}};}
\DoxyCodeLine{16359         \textcolor{keywordflow}{default}:}
\DoxyCodeLine{16360             \textcolor{keywordflow}{return} \textcolor{stringliteral}{"{}** internal error **"{}};}
\DoxyCodeLine{16361         \}}
\DoxyCodeLine{16362 }
\DoxyCodeLine{16363     \}}
\DoxyCodeLine{16364     \textcolor{keyword}{friend} \textcolor{keyword}{auto} operator << (std::ostream\& os, Duration \textcolor{keyword}{const}\& duration) -\/> std::ostream\& \{}
\DoxyCodeLine{16365         \textcolor{keywordflow}{return} os << duration.value() << \textcolor{charliteral}{' '} << duration.unitsAsString();}
\DoxyCodeLine{16366     \}}
\DoxyCodeLine{16367 \};}
\DoxyCodeLine{16368 \} \textcolor{comment}{// end anon namespace}}
\DoxyCodeLine{16369 }
\DoxyCodeLine{16370 \textcolor{keyword}{class }TablePrinter \{}
\DoxyCodeLine{16371     std::ostream\& m\_os;}
\DoxyCodeLine{16372     std::vector<ColumnInfo> m\_columnInfos;}
\DoxyCodeLine{16373     std::ostringstream m\_oss;}
\DoxyCodeLine{16374     \textcolor{keywordtype}{int} m\_currentColumn = -\/1;}
\DoxyCodeLine{16375     \textcolor{keywordtype}{bool} m\_isOpen = \textcolor{keyword}{false};}
\DoxyCodeLine{16376 }
\DoxyCodeLine{16377 \textcolor{keyword}{public}:}
\DoxyCodeLine{16378     TablePrinter( std::ostream\& os, std::vector<ColumnInfo> columnInfos )}
\DoxyCodeLine{16379     :   m\_os( os ),}
\DoxyCodeLine{16380         m\_columnInfos( std::move( columnInfos ) ) \{\}}
\DoxyCodeLine{16381 }
\DoxyCodeLine{16382     \textcolor{keyword}{auto} columnInfos() const -\/> std::vector<ColumnInfo> const\& \{}
\DoxyCodeLine{16383         \textcolor{keywordflow}{return} m\_columnInfos;}
\DoxyCodeLine{16384     \}}
\DoxyCodeLine{16385 }
\DoxyCodeLine{16386     \textcolor{keywordtype}{void} open() \{}
\DoxyCodeLine{16387         \textcolor{keywordflow}{if} (!m\_isOpen) \{}
\DoxyCodeLine{16388             m\_isOpen = \textcolor{keyword}{true};}
\DoxyCodeLine{16389             *\textcolor{keyword}{this} << RowBreak();}
\DoxyCodeLine{16390 }
\DoxyCodeLine{16391             Columns headerCols;}
\DoxyCodeLine{16392             Spacer spacer(2);}
\DoxyCodeLine{16393             \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} \textcolor{keyword}{const}\& info : m\_columnInfos) \{}
\DoxyCodeLine{16394                 headerCols += Column(info.name).width(static\_cast<std::size\_t>(info.width -\/ 2));}
\DoxyCodeLine{16395                 headerCols += spacer;}
\DoxyCodeLine{16396             \}}
\DoxyCodeLine{16397             m\_os << headerCols << \textcolor{charliteral}{'\(\backslash\)n'};}
\DoxyCodeLine{16398 }
\DoxyCodeLine{16399             m\_os << Catch::getLineOfChars<\textcolor{charliteral}{'-\/'}>() << \textcolor{charliteral}{'\(\backslash\)n'};}
\DoxyCodeLine{16400         \}}
\DoxyCodeLine{16401     \}}
\DoxyCodeLine{16402     \textcolor{keywordtype}{void} close() \{}
\DoxyCodeLine{16403         \textcolor{keywordflow}{if} (m\_isOpen) \{}
\DoxyCodeLine{16404             *\textcolor{keyword}{this} << RowBreak();}
\DoxyCodeLine{16405             m\_os << std::endl;}
\DoxyCodeLine{16406             m\_isOpen = \textcolor{keyword}{false};}
\DoxyCodeLine{16407         \}}
\DoxyCodeLine{16408     \}}
\DoxyCodeLine{16409 }
\DoxyCodeLine{16410     \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{16411     \textcolor{keyword}{friend} TablePrinter\& operator << (TablePrinter\& tp, T \textcolor{keyword}{const}\& value) \{}
\DoxyCodeLine{16412         tp.m\_oss << value;}
\DoxyCodeLine{16413         \textcolor{keywordflow}{return} tp;}
\DoxyCodeLine{16414     \}}
\DoxyCodeLine{16415 }
\DoxyCodeLine{16416     \textcolor{keyword}{friend} TablePrinter\& operator << (TablePrinter\& tp, ColumnBreak) \{}
\DoxyCodeLine{16417         \textcolor{keyword}{auto} colStr = tp.m\_oss.str();}
\DoxyCodeLine{16418         \textcolor{keyword}{const} \textcolor{keyword}{auto} strSize = colStr.size();}
\DoxyCodeLine{16419         tp.m\_oss.str(\textcolor{stringliteral}{"{}"{}});}
\DoxyCodeLine{16420         tp.open();}
\DoxyCodeLine{16421         \textcolor{keywordflow}{if} (tp.m\_currentColumn == \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{int}\textcolor{keyword}{>}(tp.m\_columnInfos.size() -\/ 1)) \{}
\DoxyCodeLine{16422             tp.m\_currentColumn = -\/1;}
\DoxyCodeLine{16423             tp.m\_os << \textcolor{charliteral}{'\(\backslash\)n'};}
\DoxyCodeLine{16424         \}}
\DoxyCodeLine{16425         tp.m\_currentColumn++;}
\DoxyCodeLine{16426 }
\DoxyCodeLine{16427         \textcolor{keyword}{auto} colInfo = tp.m\_columnInfos[tp.m\_currentColumn];}
\DoxyCodeLine{16428         \textcolor{keyword}{auto} padding = (strSize + 1 < static\_cast<std::size\_t>(colInfo.width))}
\DoxyCodeLine{16429             ? std::string(colInfo.width -\/ (strSize + 1), ' ')}
\DoxyCodeLine{16430             : std::string();}
\DoxyCodeLine{16431         \textcolor{keywordflow}{if} (colInfo.justification == ColumnInfo::Left)}
\DoxyCodeLine{16432             tp.m\_os << colStr << padding << \textcolor{charliteral}{' '};}
\DoxyCodeLine{16433         \textcolor{keywordflow}{else}}
\DoxyCodeLine{16434             tp.m\_os << padding << colStr << \textcolor{charliteral}{' '};}
\DoxyCodeLine{16435         \textcolor{keywordflow}{return} tp;}
\DoxyCodeLine{16436     \}}
\DoxyCodeLine{16437 }
\DoxyCodeLine{16438     \textcolor{keyword}{friend} TablePrinter\& operator << (TablePrinter\& tp, RowBreak) \{}
\DoxyCodeLine{16439         \textcolor{keywordflow}{if} (tp.m\_currentColumn > 0) \{}
\DoxyCodeLine{16440             tp.m\_os << \textcolor{charliteral}{'\(\backslash\)n'};}
\DoxyCodeLine{16441             tp.m\_currentColumn = -\/1;}
\DoxyCodeLine{16442         \}}
\DoxyCodeLine{16443         \textcolor{keywordflow}{return} tp;}
\DoxyCodeLine{16444     \}}
\DoxyCodeLine{16445 \};}
\DoxyCodeLine{16446 }
\DoxyCodeLine{16447 ConsoleReporter::ConsoleReporter(ReporterConfig \textcolor{keyword}{const}\& config)}
\DoxyCodeLine{16448     : StreamingReporterBase(config),}
\DoxyCodeLine{16449     m\_tablePrinter(new TablePrinter(config.stream(),}
\DoxyCodeLine{16450         [\&config]() -\/> std::vector<ColumnInfo> \{}
\DoxyCodeLine{16451         \textcolor{keywordflow}{if} (config.fullConfig()-\/>benchmarkNoAnalysis())}
\DoxyCodeLine{16452         \{}
\DoxyCodeLine{16453             \textcolor{keywordflow}{return}\{}
\DoxyCodeLine{16454                 \{ \textcolor{stringliteral}{"{}benchmark name"{}}, CATCH\_CONFIG\_CONSOLE\_WIDTH -\/ 43, ColumnInfo::Left \},}
\DoxyCodeLine{16455                 \{ \textcolor{stringliteral}{"{}     samples"{}}, 14, ColumnInfo::Right \},}
\DoxyCodeLine{16456                 \{ \textcolor{stringliteral}{"{}  iterations"{}}, 14, ColumnInfo::Right \},}
\DoxyCodeLine{16457                 \{ \textcolor{stringliteral}{"{}        mean"{}}, 14, ColumnInfo::Right \}}
\DoxyCodeLine{16458             \};}
\DoxyCodeLine{16459         \}}
\DoxyCodeLine{16460         \textcolor{keywordflow}{else}}
\DoxyCodeLine{16461         \{}
\DoxyCodeLine{16462             \textcolor{keywordflow}{return}\{}
\DoxyCodeLine{16463                 \{ \textcolor{stringliteral}{"{}benchmark name"{}}, CATCH\_CONFIG\_CONSOLE\_WIDTH -\/ 43, ColumnInfo::Left \},}
\DoxyCodeLine{16464                 \{ \textcolor{stringliteral}{"{}samples      mean       std dev"{}}, 14, ColumnInfo::Right \},}
\DoxyCodeLine{16465                 \{ \textcolor{stringliteral}{"{}iterations   low mean   low std dev"{}}, 14, ColumnInfo::Right \},}
\DoxyCodeLine{16466                 \{ \textcolor{stringliteral}{"{}estimated    high mean  high std dev"{}}, 14, ColumnInfo::Right \}}
\DoxyCodeLine{16467             \};}
\DoxyCodeLine{16468         \}}
\DoxyCodeLine{16469     \}())) \{\}}
\DoxyCodeLine{16470 ConsoleReporter::\string~ConsoleReporter() = \textcolor{keywordflow}{default};}
\DoxyCodeLine{16471 }
\DoxyCodeLine{16472 std::string ConsoleReporter::getDescription() \{}
\DoxyCodeLine{16473     \textcolor{keywordflow}{return} \textcolor{stringliteral}{"{}Reports test results as plain lines of text"{}};}
\DoxyCodeLine{16474 \}}
\DoxyCodeLine{16475 }
\DoxyCodeLine{16476 \textcolor{keywordtype}{void} ConsoleReporter::noMatchingTestCases(std::string \textcolor{keyword}{const}\& spec) \{}
\DoxyCodeLine{16477     stream << \textcolor{stringliteral}{"{}No test cases matched '"{}} << spec << \textcolor{charliteral}{'\(\backslash\)''} << std::endl;}
\DoxyCodeLine{16478 \}}
\DoxyCodeLine{16479 }
\DoxyCodeLine{16480 \textcolor{keywordtype}{void} ConsoleReporter::reportInvalidArguments(std::string \textcolor{keyword}{const}\&arg)\{}
\DoxyCodeLine{16481     stream << \textcolor{stringliteral}{"{}Invalid Filter: "{}} << arg << std::endl;}
\DoxyCodeLine{16482 \}}
\DoxyCodeLine{16483 }
\DoxyCodeLine{16484 \textcolor{keywordtype}{void} ConsoleReporter::assertionStarting(AssertionInfo \textcolor{keyword}{const}\&) \{\}}
\DoxyCodeLine{16485 }
\DoxyCodeLine{16486 \textcolor{keywordtype}{bool} ConsoleReporter::assertionEnded(AssertionStats \textcolor{keyword}{const}\& \_assertionStats) \{}
\DoxyCodeLine{16487     AssertionResult \textcolor{keyword}{const}\& result = \_assertionStats.assertionResult;}
\DoxyCodeLine{16488 }
\DoxyCodeLine{16489     \textcolor{keywordtype}{bool} includeResults = m\_config-\/>includeSuccessfulResults() || !result.isOk();}
\DoxyCodeLine{16490 }
\DoxyCodeLine{16491     \textcolor{comment}{// Drop out if result was successful but we're not printing them.}}
\DoxyCodeLine{16492     \textcolor{keywordflow}{if} (!includeResults \&\& result.getResultType() != ResultWas::Warning)}
\DoxyCodeLine{16493         \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{16494 }
\DoxyCodeLine{16495     lazyPrint();}
\DoxyCodeLine{16496 }
\DoxyCodeLine{16497     ConsoleAssertionPrinter printer(stream, \_assertionStats, includeResults);}
\DoxyCodeLine{16498     printer.print();}
\DoxyCodeLine{16499     stream << std::endl;}
\DoxyCodeLine{16500     \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{16501 \}}
\DoxyCodeLine{16502 }
\DoxyCodeLine{16503 \textcolor{keywordtype}{void} ConsoleReporter::sectionStarting(SectionInfo \textcolor{keyword}{const}\& \_sectionInfo) \{}
\DoxyCodeLine{16504     m\_tablePrinter-\/>close();}
\DoxyCodeLine{16505     m\_headerPrinted = \textcolor{keyword}{false};}
\DoxyCodeLine{16506     StreamingReporterBase::sectionStarting(\_sectionInfo);}
\DoxyCodeLine{16507 \}}
\DoxyCodeLine{16508 \textcolor{keywordtype}{void} ConsoleReporter::sectionEnded(SectionStats \textcolor{keyword}{const}\& \_sectionStats) \{}
\DoxyCodeLine{16509     m\_tablePrinter-\/>close();}
\DoxyCodeLine{16510     \textcolor{keywordflow}{if} (\_sectionStats.missingAssertions) \{}
\DoxyCodeLine{16511         lazyPrint();}
\DoxyCodeLine{16512         Colour colour(Colour::ResultError);}
\DoxyCodeLine{16513         \textcolor{keywordflow}{if} (m\_sectionStack.size() > 1)}
\DoxyCodeLine{16514             stream << \textcolor{stringliteral}{"{}\(\backslash\)nNo assertions in section"{}};}
\DoxyCodeLine{16515         \textcolor{keywordflow}{else}}
\DoxyCodeLine{16516             stream << \textcolor{stringliteral}{"{}\(\backslash\)nNo assertions in test case"{}};}
\DoxyCodeLine{16517         stream << \textcolor{stringliteral}{"{} '"{}} << \_sectionStats.sectionInfo.name << \textcolor{stringliteral}{"{}'\(\backslash\)n"{}} << std::endl;}
\DoxyCodeLine{16518     \}}
\DoxyCodeLine{16519     \textcolor{keywordtype}{double} dur = \_sectionStats.durationInSeconds;}
\DoxyCodeLine{16520     \textcolor{keywordflow}{if} (shouldShowDuration(*m\_config, dur)) \{}
\DoxyCodeLine{16521         stream << getFormattedDuration(dur) << \textcolor{stringliteral}{"{} s: "{}} << \_sectionStats.sectionInfo.name << std::endl;}
\DoxyCodeLine{16522     \}}
\DoxyCodeLine{16523     \textcolor{keywordflow}{if} (m\_headerPrinted) \{}
\DoxyCodeLine{16524         m\_headerPrinted = \textcolor{keyword}{false};}
\DoxyCodeLine{16525     \}}
\DoxyCodeLine{16526     StreamingReporterBase::sectionEnded(\_sectionStats);}
\DoxyCodeLine{16527 \}}
\DoxyCodeLine{16528 }
\DoxyCodeLine{16529 \textcolor{preprocessor}{\#if defined(CATCH\_CONFIG\_ENABLE\_BENCHMARKING)}}
\DoxyCodeLine{16530 \textcolor{keywordtype}{void} ConsoleReporter::benchmarkPreparing(std::string \textcolor{keyword}{const}\& name) \{}
\DoxyCodeLine{16531     lazyPrintWithoutClosingBenchmarkTable();}
\DoxyCodeLine{16532 }
\DoxyCodeLine{16533     \textcolor{keyword}{auto} nameCol = Column(name).width(\textcolor{keyword}{static\_cast<}std::size\_t\textcolor{keyword}{>}(m\_tablePrinter-\/>columnInfos()[0].width -\/ 2));}
\DoxyCodeLine{16534 }
\DoxyCodeLine{16535     \textcolor{keywordtype}{bool} firstLine = \textcolor{keyword}{true};}
\DoxyCodeLine{16536     \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} line : nameCol) \{}
\DoxyCodeLine{16537         \textcolor{keywordflow}{if} (!firstLine)}
\DoxyCodeLine{16538             (*m\_tablePrinter) << ColumnBreak() << ColumnBreak() << ColumnBreak();}
\DoxyCodeLine{16539         \textcolor{keywordflow}{else}}
\DoxyCodeLine{16540             firstLine = \textcolor{keyword}{false};}
\DoxyCodeLine{16541 }
\DoxyCodeLine{16542         (*m\_tablePrinter) << line << ColumnBreak();}
\DoxyCodeLine{16543     \}}
\DoxyCodeLine{16544 \}}
\DoxyCodeLine{16545 }
\DoxyCodeLine{16546 \textcolor{keywordtype}{void} ConsoleReporter::benchmarkStarting(BenchmarkInfo \textcolor{keyword}{const}\& info) \{}
\DoxyCodeLine{16547     (*m\_tablePrinter) << info.samples << ColumnBreak()}
\DoxyCodeLine{16548         << info.iterations << ColumnBreak();}
\DoxyCodeLine{16549     \textcolor{keywordflow}{if} (!m\_config-\/>benchmarkNoAnalysis())}
\DoxyCodeLine{16550         (*m\_tablePrinter) << Duration(info.estimatedDuration) << ColumnBreak();}
\DoxyCodeLine{16551 \}}
\DoxyCodeLine{16552 \textcolor{keywordtype}{void} ConsoleReporter::benchmarkEnded(BenchmarkStats<> \textcolor{keyword}{const}\& stats) \{}
\DoxyCodeLine{16553     \textcolor{keywordflow}{if} (m\_config-\/>benchmarkNoAnalysis())}
\DoxyCodeLine{16554     \{}
\DoxyCodeLine{16555         (*m\_tablePrinter) << Duration(stats.mean.point.count()) << ColumnBreak();}
\DoxyCodeLine{16556     \}}
\DoxyCodeLine{16557     \textcolor{keywordflow}{else}}
\DoxyCodeLine{16558     \{}
\DoxyCodeLine{16559         (*m\_tablePrinter) << ColumnBreak()}
\DoxyCodeLine{16560             << Duration(stats.mean.point.count()) << ColumnBreak()}
\DoxyCodeLine{16561             << Duration(stats.mean.lower\_bound.count()) << ColumnBreak()}
\DoxyCodeLine{16562             << Duration(stats.mean.upper\_bound.count()) << ColumnBreak() << ColumnBreak()}
\DoxyCodeLine{16563             << Duration(stats.standardDeviation.point.count()) << ColumnBreak()}
\DoxyCodeLine{16564             << Duration(stats.standardDeviation.lower\_bound.count()) << ColumnBreak()}
\DoxyCodeLine{16565             << Duration(stats.standardDeviation.upper\_bound.count()) << ColumnBreak() << ColumnBreak() << ColumnBreak() << ColumnBreak() << ColumnBreak();}
\DoxyCodeLine{16566     \}}
\DoxyCodeLine{16567 \}}
\DoxyCodeLine{16568 }
\DoxyCodeLine{16569 \textcolor{keywordtype}{void} ConsoleReporter::benchmarkFailed(std::string \textcolor{keyword}{const}\& error) \{}
\DoxyCodeLine{16570     Colour colour(Colour::Red);}
\DoxyCodeLine{16571     (*m\_tablePrinter)}
\DoxyCodeLine{16572         << \textcolor{stringliteral}{"{}Benchmark failed ("{}} << error << \textcolor{charliteral}{')'}}
\DoxyCodeLine{16573         << ColumnBreak() << RowBreak();}
\DoxyCodeLine{16574 \}}
\DoxyCodeLine{16575 \textcolor{preprocessor}{\#endif }\textcolor{comment}{// CATCH\_CONFIG\_ENABLE\_BENCHMARKING}}
\DoxyCodeLine{16576 }
\DoxyCodeLine{16577 \textcolor{keywordtype}{void} ConsoleReporter::testCaseEnded(TestCaseStats \textcolor{keyword}{const}\& \_testCaseStats) \{}
\DoxyCodeLine{16578     m\_tablePrinter-\/>close();}
\DoxyCodeLine{16579     StreamingReporterBase::testCaseEnded(\_testCaseStats);}
\DoxyCodeLine{16580     m\_headerPrinted = \textcolor{keyword}{false};}
\DoxyCodeLine{16581 \}}
\DoxyCodeLine{16582 \textcolor{keywordtype}{void} ConsoleReporter::testGroupEnded(TestGroupStats \textcolor{keyword}{const}\& \_testGroupStats) \{}
\DoxyCodeLine{16583     \textcolor{keywordflow}{if} (currentGroupInfo.used) \{}
\DoxyCodeLine{16584         printSummaryDivider();}
\DoxyCodeLine{16585         stream << \textcolor{stringliteral}{"{}Summary for group '"{}} << \_testGroupStats.groupInfo.name << \textcolor{stringliteral}{"{}':\(\backslash\)n"{}};}
\DoxyCodeLine{16586         printTotals(\_testGroupStats.totals);}
\DoxyCodeLine{16587         stream << \textcolor{charliteral}{'\(\backslash\)n'} << std::endl;}
\DoxyCodeLine{16588     \}}
\DoxyCodeLine{16589     StreamingReporterBase::testGroupEnded(\_testGroupStats);}
\DoxyCodeLine{16590 \}}
\DoxyCodeLine{16591 \textcolor{keywordtype}{void} ConsoleReporter::testRunEnded(TestRunStats \textcolor{keyword}{const}\& \_testRunStats) \{}
\DoxyCodeLine{16592     printTotalsDivider(\_testRunStats.totals);}
\DoxyCodeLine{16593     printTotals(\_testRunStats.totals);}
\DoxyCodeLine{16594     stream << std::endl;}
\DoxyCodeLine{16595     StreamingReporterBase::testRunEnded(\_testRunStats);}
\DoxyCodeLine{16596 \}}
\DoxyCodeLine{16597 \textcolor{keywordtype}{void} ConsoleReporter::testRunStarting(TestRunInfo \textcolor{keyword}{const}\& \_testInfo) \{}
\DoxyCodeLine{16598     StreamingReporterBase::testRunStarting(\_testInfo);}
\DoxyCodeLine{16599     printTestFilters();}
\DoxyCodeLine{16600 \}}
\DoxyCodeLine{16601 }
\DoxyCodeLine{16602 \textcolor{keywordtype}{void} ConsoleReporter::lazyPrint() \{}
\DoxyCodeLine{16603 }
\DoxyCodeLine{16604     m\_tablePrinter-\/>close();}
\DoxyCodeLine{16605     lazyPrintWithoutClosingBenchmarkTable();}
\DoxyCodeLine{16606 \}}
\DoxyCodeLine{16607 }
\DoxyCodeLine{16608 \textcolor{keywordtype}{void} ConsoleReporter::lazyPrintWithoutClosingBenchmarkTable() \{}
\DoxyCodeLine{16609 }
\DoxyCodeLine{16610     \textcolor{keywordflow}{if} (!currentTestRunInfo.used)}
\DoxyCodeLine{16611         lazyPrintRunInfo();}
\DoxyCodeLine{16612     \textcolor{keywordflow}{if} (!currentGroupInfo.used)}
\DoxyCodeLine{16613         lazyPrintGroupInfo();}
\DoxyCodeLine{16614 }
\DoxyCodeLine{16615     \textcolor{keywordflow}{if} (!m\_headerPrinted) \{}
\DoxyCodeLine{16616         printTestCaseAndSectionHeader();}
\DoxyCodeLine{16617         m\_headerPrinted = \textcolor{keyword}{true};}
\DoxyCodeLine{16618     \}}
\DoxyCodeLine{16619 \}}
\DoxyCodeLine{16620 \textcolor{keywordtype}{void} ConsoleReporter::lazyPrintRunInfo() \{}
\DoxyCodeLine{16621     stream << '\(\backslash\)n' << getLineOfChars<'\string~'>() << \textcolor{charliteral}{'\(\backslash\)n'};}
\DoxyCodeLine{16622     Colour colour(Colour::SecondaryText);}
\DoxyCodeLine{16623     stream << currentTestRunInfo-\/>name}
\DoxyCodeLine{16624         << \textcolor{stringliteral}{"{} is a Catch v"{}} << libraryVersion() << \textcolor{stringliteral}{"{} host application.\(\backslash\)n"{}}}
\DoxyCodeLine{16625         << \textcolor{stringliteral}{"{}Run with -\/? for options\(\backslash\)n\(\backslash\)n"{}};}
\DoxyCodeLine{16626 }
\DoxyCodeLine{16627     \textcolor{keywordflow}{if} (m\_config-\/>rngSeed() != 0)}
\DoxyCodeLine{16628         stream << \textcolor{stringliteral}{"{}Randomness seeded to: "{}} << m\_config-\/>rngSeed() << \textcolor{stringliteral}{"{}\(\backslash\)n\(\backslash\)n"{}};}
\DoxyCodeLine{16629 }
\DoxyCodeLine{16630     currentTestRunInfo.used = \textcolor{keyword}{true};}
\DoxyCodeLine{16631 \}}
\DoxyCodeLine{16632 \textcolor{keywordtype}{void} ConsoleReporter::lazyPrintGroupInfo() \{}
\DoxyCodeLine{16633     \textcolor{keywordflow}{if} (!currentGroupInfo-\/>name.empty() \&\& currentGroupInfo-\/>groupsCounts > 1) \{}
\DoxyCodeLine{16634         printClosedHeader(\textcolor{stringliteral}{"{}Group: "{}} + currentGroupInfo-\/>name);}
\DoxyCodeLine{16635         currentGroupInfo.used = \textcolor{keyword}{true};}
\DoxyCodeLine{16636     \}}
\DoxyCodeLine{16637 \}}
\DoxyCodeLine{16638 \textcolor{keywordtype}{void} ConsoleReporter::printTestCaseAndSectionHeader() \{}
\DoxyCodeLine{16639     assert(!m\_sectionStack.empty());}
\DoxyCodeLine{16640     printOpenHeader(currentTestCaseInfo-\/>name);}
\DoxyCodeLine{16641 }
\DoxyCodeLine{16642     \textcolor{keywordflow}{if} (m\_sectionStack.size() > 1) \{}
\DoxyCodeLine{16643         Colour colourGuard(Colour::Headers);}
\DoxyCodeLine{16644 }
\DoxyCodeLine{16645         \textcolor{keyword}{auto}}
\DoxyCodeLine{16646             it = m\_sectionStack.begin() + 1, \textcolor{comment}{// Skip first section (test case)}}
\DoxyCodeLine{16647             itEnd = m\_sectionStack.end();}
\DoxyCodeLine{16648         \textcolor{keywordflow}{for} (; it != itEnd; ++it)}
\DoxyCodeLine{16649             printHeaderString(it-\/>name, 2);}
\DoxyCodeLine{16650     \}}
\DoxyCodeLine{16651 }
\DoxyCodeLine{16652     SourceLineInfo lineInfo = m\_sectionStack.back().lineInfo;}
\DoxyCodeLine{16653 }
\DoxyCodeLine{16654     stream << getLineOfChars<\textcolor{charliteral}{'-\/'}>() << \textcolor{charliteral}{'\(\backslash\)n'};}
\DoxyCodeLine{16655     Colour colourGuard(Colour::FileName);}
\DoxyCodeLine{16656     stream << lineInfo << \textcolor{charliteral}{'\(\backslash\)n'};}
\DoxyCodeLine{16657     stream << getLineOfChars<\textcolor{charliteral}{'.'}>() << \textcolor{charliteral}{'\(\backslash\)n'} << std::endl;}
\DoxyCodeLine{16658 \}}
\DoxyCodeLine{16659 }
\DoxyCodeLine{16660 \textcolor{keywordtype}{void} ConsoleReporter::printClosedHeader(std::string \textcolor{keyword}{const}\& \_name) \{}
\DoxyCodeLine{16661     printOpenHeader(\_name);}
\DoxyCodeLine{16662     stream << getLineOfChars<\textcolor{charliteral}{'.'}>() << \textcolor{charliteral}{'\(\backslash\)n'};}
\DoxyCodeLine{16663 \}}
\DoxyCodeLine{16664 \textcolor{keywordtype}{void} ConsoleReporter::printOpenHeader(std::string \textcolor{keyword}{const}\& \_name) \{}
\DoxyCodeLine{16665     stream << getLineOfChars<\textcolor{charliteral}{'-\/'}>() << \textcolor{charliteral}{'\(\backslash\)n'};}
\DoxyCodeLine{16666     \{}
\DoxyCodeLine{16667         Colour colourGuard(Colour::Headers);}
\DoxyCodeLine{16668         printHeaderString(\_name);}
\DoxyCodeLine{16669     \}}
\DoxyCodeLine{16670 \}}
\DoxyCodeLine{16671 }
\DoxyCodeLine{16672 \textcolor{comment}{// if string has a : in first line will set indent to follow it on}}
\DoxyCodeLine{16673 \textcolor{comment}{// subsequent lines}}
\DoxyCodeLine{16674 \textcolor{keywordtype}{void} ConsoleReporter::printHeaderString(std::string \textcolor{keyword}{const}\& \_string, std::size\_t indent) \{}
\DoxyCodeLine{16675     std::size\_t i = \_string.find(\textcolor{stringliteral}{"{}: "{}});}
\DoxyCodeLine{16676     \textcolor{keywordflow}{if} (i != std::string::npos)}
\DoxyCodeLine{16677         i += 2;}
\DoxyCodeLine{16678     \textcolor{keywordflow}{else}}
\DoxyCodeLine{16679         i = 0;}
\DoxyCodeLine{16680     stream << Column(\_string).indent(indent + i).initialIndent(indent) << \textcolor{charliteral}{'\(\backslash\)n'};}
\DoxyCodeLine{16681 \}}
\DoxyCodeLine{16682 }
\DoxyCodeLine{16683 \textcolor{keyword}{struct }SummaryColumn \{}
\DoxyCodeLine{16684 }
\DoxyCodeLine{16685     SummaryColumn( std::string \_label, Colour::Code \_colour )}
\DoxyCodeLine{16686     :   label( std::move( \_label ) ),}
\DoxyCodeLine{16687         colour( \_colour ) \{\}}
\DoxyCodeLine{16688     SummaryColumn addRow( std::size\_t count ) \{}
\DoxyCodeLine{16689         ReusableStringStream rss;}
\DoxyCodeLine{16690         rss << count;}
\DoxyCodeLine{16691         std::string row = rss.str();}
\DoxyCodeLine{16692         \textcolor{keywordflow}{for} (\textcolor{keyword}{auto}\& oldRow : rows) \{}
\DoxyCodeLine{16693             \textcolor{keywordflow}{while} (oldRow.size() < row.size())}
\DoxyCodeLine{16694                 oldRow = \textcolor{charliteral}{' '} + oldRow;}
\DoxyCodeLine{16695             \textcolor{keywordflow}{while} (oldRow.size() > row.size())}
\DoxyCodeLine{16696                 row = \textcolor{charliteral}{' '} + row;}
\DoxyCodeLine{16697         \}}
\DoxyCodeLine{16698         rows.push\_back(row);}
\DoxyCodeLine{16699         \textcolor{keywordflow}{return} *\textcolor{keyword}{this};}
\DoxyCodeLine{16700     \}}
\DoxyCodeLine{16701 }
\DoxyCodeLine{16702     std::string label;}
\DoxyCodeLine{16703     Colour::Code colour;}
\DoxyCodeLine{16704     std::vector<std::string> rows;}
\DoxyCodeLine{16705 }
\DoxyCodeLine{16706 \};}
\DoxyCodeLine{16707 }
\DoxyCodeLine{16708 \textcolor{keywordtype}{void} ConsoleReporter::printTotals( Totals \textcolor{keyword}{const}\& totals ) \{}
\DoxyCodeLine{16709     \textcolor{keywordflow}{if} (totals.testCases.total() == 0) \{}
\DoxyCodeLine{16710         stream << Colour(Colour::Warning) << \textcolor{stringliteral}{"{}No tests ran\(\backslash\)n"{}};}
\DoxyCodeLine{16711     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (totals.assertions.total() > 0 \&\& totals.testCases.allPassed()) \{}
\DoxyCodeLine{16712         stream << Colour(Colour::ResultSuccess) << \textcolor{stringliteral}{"{}All tests passed"{}};}
\DoxyCodeLine{16713         stream << \textcolor{stringliteral}{"{} ("{}}}
\DoxyCodeLine{16714             << pluralise(totals.assertions.passed, \textcolor{stringliteral}{"{}assertion"{}}) << \textcolor{stringliteral}{"{} in "{}}}
\DoxyCodeLine{16715             << pluralise(totals.testCases.passed, \textcolor{stringliteral}{"{}test case"{}}) << \textcolor{charliteral}{')'}}
\DoxyCodeLine{16716             << \textcolor{charliteral}{'\(\backslash\)n'};}
\DoxyCodeLine{16717     \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{16718 }
\DoxyCodeLine{16719         std::vector<SummaryColumn> columns;}
\DoxyCodeLine{16720         columns.push\_back(SummaryColumn(\textcolor{stringliteral}{"{}"{}}, Colour::None)}
\DoxyCodeLine{16721                           .addRow(totals.testCases.total())}
\DoxyCodeLine{16722                           .addRow(totals.assertions.total()));}
\DoxyCodeLine{16723         columns.push\_back(SummaryColumn(\textcolor{stringliteral}{"{}passed"{}}, Colour::Success)}
\DoxyCodeLine{16724                           .addRow(totals.testCases.passed)}
\DoxyCodeLine{16725                           .addRow(totals.assertions.passed));}
\DoxyCodeLine{16726         columns.push\_back(SummaryColumn(\textcolor{stringliteral}{"{}failed"{}}, Colour::ResultError)}
\DoxyCodeLine{16727                           .addRow(totals.testCases.failed)}
\DoxyCodeLine{16728                           .addRow(totals.assertions.failed));}
\DoxyCodeLine{16729         columns.push\_back(SummaryColumn(\textcolor{stringliteral}{"{}failed as expected"{}}, Colour::ResultExpectedFailure)}
\DoxyCodeLine{16730                           .addRow(totals.testCases.failedButOk)}
\DoxyCodeLine{16731                           .addRow(totals.assertions.failedButOk));}
\DoxyCodeLine{16732 }
\DoxyCodeLine{16733         printSummaryRow(\textcolor{stringliteral}{"{}test cases"{}}, columns, 0);}
\DoxyCodeLine{16734         printSummaryRow(\textcolor{stringliteral}{"{}assertions"{}}, columns, 1);}
\DoxyCodeLine{16735     \}}
\DoxyCodeLine{16736 \}}
\DoxyCodeLine{16737 \textcolor{keywordtype}{void} ConsoleReporter::printSummaryRow(std::string \textcolor{keyword}{const}\& label, std::vector<SummaryColumn> \textcolor{keyword}{const}\& cols, std::size\_t row) \{}
\DoxyCodeLine{16738     \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} col : cols) \{}
\DoxyCodeLine{16739         std::string value = col.rows[row];}
\DoxyCodeLine{16740         \textcolor{keywordflow}{if} (col.label.empty()) \{}
\DoxyCodeLine{16741             stream << label << \textcolor{stringliteral}{"{}: "{}};}
\DoxyCodeLine{16742             \textcolor{keywordflow}{if} (value != \textcolor{stringliteral}{"{}0"{}})}
\DoxyCodeLine{16743                 stream << value;}
\DoxyCodeLine{16744             \textcolor{keywordflow}{else}}
\DoxyCodeLine{16745                 stream << Colour(Colour::Warning) << \textcolor{stringliteral}{"{}-\/ none -\/"{}};}
\DoxyCodeLine{16746         \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (value != \textcolor{stringliteral}{"{}0"{}}) \{}
\DoxyCodeLine{16747             stream << Colour(Colour::LightGrey) << \textcolor{stringliteral}{"{} | "{}};}
\DoxyCodeLine{16748             stream << Colour(col.colour)}
\DoxyCodeLine{16749                 << value << \textcolor{charliteral}{' '} << col.label;}
\DoxyCodeLine{16750         \}}
\DoxyCodeLine{16751     \}}
\DoxyCodeLine{16752     stream << \textcolor{charliteral}{'\(\backslash\)n'};}
\DoxyCodeLine{16753 \}}
\DoxyCodeLine{16754 }
\DoxyCodeLine{16755 \textcolor{keywordtype}{void} ConsoleReporter::printTotalsDivider(Totals \textcolor{keyword}{const}\& totals) \{}
\DoxyCodeLine{16756     \textcolor{keywordflow}{if} (totals.testCases.total() > 0) \{}
\DoxyCodeLine{16757         std::size\_t failedRatio = makeRatio(totals.testCases.failed, totals.testCases.total());}
\DoxyCodeLine{16758         std::size\_t failedButOkRatio = makeRatio(totals.testCases.failedButOk, totals.testCases.total());}
\DoxyCodeLine{16759         std::size\_t passedRatio = makeRatio(totals.testCases.passed, totals.testCases.total());}
\DoxyCodeLine{16760         \textcolor{keywordflow}{while} (failedRatio + failedButOkRatio + passedRatio < CATCH\_CONFIG\_CONSOLE\_WIDTH -\/ 1)}
\DoxyCodeLine{16761             findMax(failedRatio, failedButOkRatio, passedRatio)++;}
\DoxyCodeLine{16762         \textcolor{keywordflow}{while} (failedRatio + failedButOkRatio + passedRatio > CATCH\_CONFIG\_CONSOLE\_WIDTH -\/ 1)}
\DoxyCodeLine{16763             findMax(failedRatio, failedButOkRatio, passedRatio)-\/-\/;}
\DoxyCodeLine{16764 }
\DoxyCodeLine{16765         stream << Colour(Colour::Error) << std::string(failedRatio, \textcolor{charliteral}{'='});}
\DoxyCodeLine{16766         stream << Colour(Colour::ResultExpectedFailure) << std::string(failedButOkRatio, \textcolor{charliteral}{'='});}
\DoxyCodeLine{16767         \textcolor{keywordflow}{if} (totals.testCases.allPassed())}
\DoxyCodeLine{16768             stream << Colour(Colour::ResultSuccess) << std::string(passedRatio, \textcolor{charliteral}{'='});}
\DoxyCodeLine{16769         \textcolor{keywordflow}{else}}
\DoxyCodeLine{16770             stream << Colour(Colour::Success) << std::string(passedRatio, \textcolor{charliteral}{'='});}
\DoxyCodeLine{16771     \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{16772         stream << Colour(Colour::Warning) << std::string(CATCH\_CONFIG\_CONSOLE\_WIDTH -\/ 1, \textcolor{charliteral}{'='});}
\DoxyCodeLine{16773     \}}
\DoxyCodeLine{16774     stream << \textcolor{charliteral}{'\(\backslash\)n'};}
\DoxyCodeLine{16775 \}}
\DoxyCodeLine{16776 \textcolor{keywordtype}{void} ConsoleReporter::printSummaryDivider() \{}
\DoxyCodeLine{16777     stream << getLineOfChars<\textcolor{charliteral}{'-\/'}>() << \textcolor{charliteral}{'\(\backslash\)n'};}
\DoxyCodeLine{16778 \}}
\DoxyCodeLine{16779 }
\DoxyCodeLine{16780 \textcolor{keywordtype}{void} ConsoleReporter::printTestFilters() \{}
\DoxyCodeLine{16781     \textcolor{keywordflow}{if} (m\_config-\/>testSpec().hasFilters()) \{}
\DoxyCodeLine{16782         Colour guard(Colour::BrightYellow);}
\DoxyCodeLine{16783         stream << \textcolor{stringliteral}{"{}Filters: "{}} << serializeFilters(m\_config-\/>getTestsOrTags()) << \textcolor{charliteral}{'\(\backslash\)n'};}
\DoxyCodeLine{16784     \}}
\DoxyCodeLine{16785 \}}
\DoxyCodeLine{16786 }
\DoxyCodeLine{16787 CATCH\_REGISTER\_REPORTER(\textcolor{stringliteral}{"{}console"{}}, ConsoleReporter)}
\DoxyCodeLine{16788 }
\DoxyCodeLine{16789 \} \textcolor{comment}{// end namespace Catch}}
\DoxyCodeLine{16790 }
\DoxyCodeLine{16791 \textcolor{preprocessor}{\#if defined(\_MSC\_VER)}}
\DoxyCodeLine{16792 \textcolor{preprocessor}{\#pragma warning(pop)}}
\DoxyCodeLine{16793 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{16794 }
\DoxyCodeLine{16795 \textcolor{preprocessor}{\#if defined(\_\_clang\_\_)}}
\DoxyCodeLine{16796 \textcolor{preprocessor}{\#  pragma clang diagnostic pop}}
\DoxyCodeLine{16797 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{16798 \textcolor{comment}{// end catch\_reporter\_console.cpp}}
\DoxyCodeLine{16799 \textcolor{comment}{// start catch\_reporter\_junit.cpp}}
\DoxyCodeLine{16800 }
\DoxyCodeLine{16801 \textcolor{preprocessor}{\#include <cassert>}}
\DoxyCodeLine{16802 \textcolor{preprocessor}{\#include <sstream>}}
\DoxyCodeLine{16803 \textcolor{preprocessor}{\#include <ctime>}}
\DoxyCodeLine{16804 \textcolor{preprocessor}{\#include <algorithm>}}
\DoxyCodeLine{16805 \textcolor{preprocessor}{\#include <iomanip>}}
\DoxyCodeLine{16806 }
\DoxyCodeLine{16807 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{16808 }
\DoxyCodeLine{16809     \textcolor{keyword}{namespace }\{}
\DoxyCodeLine{16810         std::string getCurrentTimestamp() \{}
\DoxyCodeLine{16811             \textcolor{comment}{// Beware, this is not reentrant because of backward compatibility issues}}
\DoxyCodeLine{16812             \textcolor{comment}{// Also, UTC only, again because of backward compatibility (\%z is C++11)}}
\DoxyCodeLine{16813             time\_t rawtime;}
\DoxyCodeLine{16814             std::time(\&rawtime);}
\DoxyCodeLine{16815             \textcolor{keyword}{auto} \textcolor{keyword}{const} timeStampSize = \textcolor{keyword}{sizeof}(\textcolor{stringliteral}{"{}2017-\/01-\/16T17:06:45Z"{}});}
\DoxyCodeLine{16816 }
\DoxyCodeLine{16817 \textcolor{preprocessor}{\#ifdef \_MSC\_VER}}
\DoxyCodeLine{16818             std::tm timeInfo = \{\};}
\DoxyCodeLine{16819             gmtime\_s(\&timeInfo, \&rawtime);}
\DoxyCodeLine{16820 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{16821             std::tm* timeInfo;}
\DoxyCodeLine{16822             timeInfo = std::gmtime(\&rawtime);}
\DoxyCodeLine{16823 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{16824 }
\DoxyCodeLine{16825             \textcolor{keywordtype}{char} timeStamp[timeStampSize];}
\DoxyCodeLine{16826             \textcolor{keyword}{const} \textcolor{keywordtype}{char} * \textcolor{keyword}{const} fmt = \textcolor{stringliteral}{"{}\%Y-\/\%m-\/\%dT\%H:\%M:\%SZ"{}};}
\DoxyCodeLine{16827 }
\DoxyCodeLine{16828 \textcolor{preprocessor}{\#ifdef \_MSC\_VER}}
\DoxyCodeLine{16829             std::strftime(timeStamp, timeStampSize, fmt, \&timeInfo);}
\DoxyCodeLine{16830 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{16831             std::strftime(timeStamp, timeStampSize, fmt, timeInfo);}
\DoxyCodeLine{16832 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{16833             \textcolor{keywordflow}{return} std::string(timeStamp, timeStampSize-\/1);}
\DoxyCodeLine{16834         \}}
\DoxyCodeLine{16835 }
\DoxyCodeLine{16836         std::string fileNameTag(\textcolor{keyword}{const} std::vector<std::string> \&tags) \{}
\DoxyCodeLine{16837             \textcolor{keyword}{auto} it = std::find\_if(begin(tags),}
\DoxyCodeLine{16838                                    end(tags),}
\DoxyCodeLine{16839                                    [] (std::string \textcolor{keyword}{const}\& tag) \{\textcolor{keywordflow}{return} tag.front() == \textcolor{charliteral}{'\#'}; \});}
\DoxyCodeLine{16840             \textcolor{keywordflow}{if} (it != tags.end())}
\DoxyCodeLine{16841                 \textcolor{keywordflow}{return} it-\/>substr(1);}
\DoxyCodeLine{16842             \textcolor{keywordflow}{return} std::string();}
\DoxyCodeLine{16843         \}}
\DoxyCodeLine{16844 }
\DoxyCodeLine{16845         \textcolor{comment}{// Formats the duration in seconds to 3 decimal places.}}
\DoxyCodeLine{16846         \textcolor{comment}{// This is done because some genius defined Maven Surefire schema}}
\DoxyCodeLine{16847         \textcolor{comment}{// in a way that only accepts 3 decimal places, and tools like}}
\DoxyCodeLine{16848         \textcolor{comment}{// Jenkins use that schema for validation JUnit reporter output.}}
\DoxyCodeLine{16849         std::string formatDuration( \textcolor{keywordtype}{double} seconds ) \{}
\DoxyCodeLine{16850             ReusableStringStream rss;}
\DoxyCodeLine{16851             rss << std::fixed << std::setprecision( 3 ) << seconds;}
\DoxyCodeLine{16852             \textcolor{keywordflow}{return} rss.str();}
\DoxyCodeLine{16853         \}}
\DoxyCodeLine{16854 }
\DoxyCodeLine{16855     \} \textcolor{comment}{// anonymous namespace}}
\DoxyCodeLine{16856 }
\DoxyCodeLine{16857     JunitReporter::JunitReporter( ReporterConfig \textcolor{keyword}{const}\& \_config )}
\DoxyCodeLine{16858         :   CumulativeReporterBase( \_config ),}
\DoxyCodeLine{16859             xml( \_config.stream() )}
\DoxyCodeLine{16860         \{}
\DoxyCodeLine{16861             m\_reporterPrefs.shouldRedirectStdOut = \textcolor{keyword}{true};}
\DoxyCodeLine{16862             m\_reporterPrefs.shouldReportAllAssertions = \textcolor{keyword}{true};}
\DoxyCodeLine{16863         \}}
\DoxyCodeLine{16864 }
\DoxyCodeLine{16865     JunitReporter::\string~JunitReporter() \{\}}
\DoxyCodeLine{16866 }
\DoxyCodeLine{16867     std::string JunitReporter::getDescription() \{}
\DoxyCodeLine{16868         \textcolor{keywordflow}{return} \textcolor{stringliteral}{"{}Reports test results in an XML format that looks like Ant's junitreport target"{}};}
\DoxyCodeLine{16869     \}}
\DoxyCodeLine{16870 }
\DoxyCodeLine{16871     \textcolor{keywordtype}{void} JunitReporter::noMatchingTestCases( std::string \textcolor{keyword}{const}\& \textcolor{comment}{/*spec*/} ) \{\}}
\DoxyCodeLine{16872 }
\DoxyCodeLine{16873     \textcolor{keywordtype}{void} JunitReporter::testRunStarting( TestRunInfo \textcolor{keyword}{const}\& runInfo )  \{}
\DoxyCodeLine{16874         CumulativeReporterBase::testRunStarting( runInfo );}
\DoxyCodeLine{16875         xml.startElement( \textcolor{stringliteral}{"{}testsuites"{}} );}
\DoxyCodeLine{16876     \}}
\DoxyCodeLine{16877 }
\DoxyCodeLine{16878     \textcolor{keywordtype}{void} JunitReporter::testGroupStarting( GroupInfo \textcolor{keyword}{const}\& groupInfo ) \{}
\DoxyCodeLine{16879         suiteTimer.start();}
\DoxyCodeLine{16880         stdOutForSuite.clear();}
\DoxyCodeLine{16881         stdErrForSuite.clear();}
\DoxyCodeLine{16882         unexpectedExceptions = 0;}
\DoxyCodeLine{16883         CumulativeReporterBase::testGroupStarting( groupInfo );}
\DoxyCodeLine{16884     \}}
\DoxyCodeLine{16885 }
\DoxyCodeLine{16886     \textcolor{keywordtype}{void} JunitReporter::testCaseStarting( TestCaseInfo \textcolor{keyword}{const}\& testCaseInfo ) \{}
\DoxyCodeLine{16887         m\_okToFail = testCaseInfo.okToFail();}
\DoxyCodeLine{16888     \}}
\DoxyCodeLine{16889 }
\DoxyCodeLine{16890     \textcolor{keywordtype}{bool} JunitReporter::assertionEnded( AssertionStats \textcolor{keyword}{const}\& assertionStats ) \{}
\DoxyCodeLine{16891         \textcolor{keywordflow}{if}( assertionStats.assertionResult.getResultType() == ResultWas::ThrewException \&\& !m\_okToFail )}
\DoxyCodeLine{16892             unexpectedExceptions++;}
\DoxyCodeLine{16893         \textcolor{keywordflow}{return} CumulativeReporterBase::assertionEnded( assertionStats );}
\DoxyCodeLine{16894     \}}
\DoxyCodeLine{16895 }
\DoxyCodeLine{16896     \textcolor{keywordtype}{void} JunitReporter::testCaseEnded( TestCaseStats \textcolor{keyword}{const}\& testCaseStats ) \{}
\DoxyCodeLine{16897         stdOutForSuite += testCaseStats.stdOut;}
\DoxyCodeLine{16898         stdErrForSuite += testCaseStats.stdErr;}
\DoxyCodeLine{16899         CumulativeReporterBase::testCaseEnded( testCaseStats );}
\DoxyCodeLine{16900     \}}
\DoxyCodeLine{16901 }
\DoxyCodeLine{16902     \textcolor{keywordtype}{void} JunitReporter::testGroupEnded( TestGroupStats \textcolor{keyword}{const}\& testGroupStats ) \{}
\DoxyCodeLine{16903         \textcolor{keywordtype}{double} suiteTime = suiteTimer.getElapsedSeconds();}
\DoxyCodeLine{16904         CumulativeReporterBase::testGroupEnded( testGroupStats );}
\DoxyCodeLine{16905         writeGroup( *m\_testGroups.back(), suiteTime );}
\DoxyCodeLine{16906     \}}
\DoxyCodeLine{16907 }
\DoxyCodeLine{16908     \textcolor{keywordtype}{void} JunitReporter::testRunEndedCumulative() \{}
\DoxyCodeLine{16909         xml.endElement();}
\DoxyCodeLine{16910     \}}
\DoxyCodeLine{16911 }
\DoxyCodeLine{16912     \textcolor{keywordtype}{void} JunitReporter::writeGroup( TestGroupNode \textcolor{keyword}{const}\& groupNode, \textcolor{keywordtype}{double} suiteTime ) \{}
\DoxyCodeLine{16913         XmlWriter::ScopedElement e = xml.scopedElement( \textcolor{stringliteral}{"{}testsuite"{}} );}
\DoxyCodeLine{16914 }
\DoxyCodeLine{16915         TestGroupStats \textcolor{keyword}{const}\& stats = groupNode.value;}
\DoxyCodeLine{16916         xml.writeAttribute( \textcolor{stringliteral}{"{}name"{}}, stats.groupInfo.name );}
\DoxyCodeLine{16917         xml.writeAttribute( \textcolor{stringliteral}{"{}errors"{}}, unexpectedExceptions );}
\DoxyCodeLine{16918         xml.writeAttribute( \textcolor{stringliteral}{"{}failures"{}}, stats.totals.assertions.failed-\/unexpectedExceptions );}
\DoxyCodeLine{16919         xml.writeAttribute( \textcolor{stringliteral}{"{}tests"{}}, stats.totals.assertions.total() );}
\DoxyCodeLine{16920         xml.writeAttribute( \textcolor{stringliteral}{"{}hostname"{}}, \textcolor{stringliteral}{"{}tbd"{}} ); \textcolor{comment}{// !TBD}}
\DoxyCodeLine{16921         \textcolor{keywordflow}{if}( m\_config-\/>showDurations() == ShowDurations::Never )}
\DoxyCodeLine{16922             xml.writeAttribute( \textcolor{stringliteral}{"{}time"{}}, \textcolor{stringliteral}{"{}"{}} );}
\DoxyCodeLine{16923         \textcolor{keywordflow}{else}}
\DoxyCodeLine{16924             xml.writeAttribute( \textcolor{stringliteral}{"{}time"{}}, formatDuration( suiteTime ) );}
\DoxyCodeLine{16925         xml.writeAttribute( \textcolor{stringliteral}{"{}timestamp"{}}, getCurrentTimestamp() );}
\DoxyCodeLine{16926 }
\DoxyCodeLine{16927         \textcolor{comment}{// Write properties if there are any}}
\DoxyCodeLine{16928         \textcolor{keywordflow}{if} (m\_config-\/>hasTestFilters() || m\_config-\/>rngSeed() != 0) \{}
\DoxyCodeLine{16929             \textcolor{keyword}{auto} properties = xml.scopedElement(\textcolor{stringliteral}{"{}properties"{}});}
\DoxyCodeLine{16930             \textcolor{keywordflow}{if} (m\_config-\/>hasTestFilters()) \{}
\DoxyCodeLine{16931                 xml.scopedElement(\textcolor{stringliteral}{"{}property"{}})}
\DoxyCodeLine{16932                     .writeAttribute(\textcolor{stringliteral}{"{}name"{}}, \textcolor{stringliteral}{"{}filters"{}})}
\DoxyCodeLine{16933                     .writeAttribute(\textcolor{stringliteral}{"{}value"{}}, serializeFilters(m\_config-\/>getTestsOrTags()));}
\DoxyCodeLine{16934             \}}
\DoxyCodeLine{16935             \textcolor{keywordflow}{if} (m\_config-\/>rngSeed() != 0) \{}
\DoxyCodeLine{16936                 xml.scopedElement(\textcolor{stringliteral}{"{}property"{}})}
\DoxyCodeLine{16937                     .writeAttribute(\textcolor{stringliteral}{"{}name"{}}, \textcolor{stringliteral}{"{}random-\/seed"{}})}
\DoxyCodeLine{16938                     .writeAttribute(\textcolor{stringliteral}{"{}value"{}}, m\_config-\/>rngSeed());}
\DoxyCodeLine{16939             \}}
\DoxyCodeLine{16940         \}}
\DoxyCodeLine{16941 }
\DoxyCodeLine{16942         \textcolor{comment}{// Write test cases}}
\DoxyCodeLine{16943         \textcolor{keywordflow}{for}( \textcolor{keyword}{auto} \textcolor{keyword}{const}\& child : groupNode.children )}
\DoxyCodeLine{16944             writeTestCase( *child );}
\DoxyCodeLine{16945 }
\DoxyCodeLine{16946         xml.scopedElement( \textcolor{stringliteral}{"{}system-\/out"{}} ).writeText( trim( stdOutForSuite ), XmlFormatting::Newline );}
\DoxyCodeLine{16947         xml.scopedElement( \textcolor{stringliteral}{"{}system-\/err"{}} ).writeText( trim( stdErrForSuite ), XmlFormatting::Newline );}
\DoxyCodeLine{16948     \}}
\DoxyCodeLine{16949 }
\DoxyCodeLine{16950     \textcolor{keywordtype}{void} JunitReporter::writeTestCase( TestCaseNode \textcolor{keyword}{const}\& testCaseNode ) \{}
\DoxyCodeLine{16951         TestCaseStats \textcolor{keyword}{const}\& stats = testCaseNode.value;}
\DoxyCodeLine{16952 }
\DoxyCodeLine{16953         \textcolor{comment}{// All test cases have exactly one section -\/ which represents the}}
\DoxyCodeLine{16954         \textcolor{comment}{// test case itself. That section may have 0-\/n nested sections}}
\DoxyCodeLine{16955         assert( testCaseNode.children.size() == 1 );}
\DoxyCodeLine{16956         SectionNode \textcolor{keyword}{const}\& rootSection = *testCaseNode.children.front();}
\DoxyCodeLine{16957 }
\DoxyCodeLine{16958         std::string className = stats.testInfo.className;}
\DoxyCodeLine{16959 }
\DoxyCodeLine{16960         \textcolor{keywordflow}{if}( className.empty() ) \{}
\DoxyCodeLine{16961             className = fileNameTag(stats.testInfo.tags);}
\DoxyCodeLine{16962             \textcolor{keywordflow}{if} ( className.empty() )}
\DoxyCodeLine{16963                 className = \textcolor{stringliteral}{"{}global"{}};}
\DoxyCodeLine{16964         \}}
\DoxyCodeLine{16965 }
\DoxyCodeLine{16966         \textcolor{keywordflow}{if} ( !m\_config-\/>name().empty() )}
\DoxyCodeLine{16967             className = m\_config-\/>name() + "{}."{} + className;}
\DoxyCodeLine{16968 }
\DoxyCodeLine{16969         writeSection( className, \textcolor{stringliteral}{"{}"{}}, rootSection, stats.testInfo.okToFail() );}
\DoxyCodeLine{16970     \}}
\DoxyCodeLine{16971 }
\DoxyCodeLine{16972     \textcolor{keywordtype}{void} JunitReporter::writeSection( std::string \textcolor{keyword}{const}\& className,}
\DoxyCodeLine{16973                                       std::string \textcolor{keyword}{const}\& rootName,}
\DoxyCodeLine{16974                                       SectionNode \textcolor{keyword}{const}\& sectionNode,}
\DoxyCodeLine{16975                                       \textcolor{keywordtype}{bool} testOkToFail) \{}
\DoxyCodeLine{16976         std::string name = trim( sectionNode.stats.sectionInfo.name );}
\DoxyCodeLine{16977         \textcolor{keywordflow}{if}( !rootName.empty() )}
\DoxyCodeLine{16978             name = rootName + '/' + name;}
\DoxyCodeLine{16979 }
\DoxyCodeLine{16980         \textcolor{keywordflow}{if}( !sectionNode.assertions.empty() ||}
\DoxyCodeLine{16981             !sectionNode.stdOut.empty() ||}
\DoxyCodeLine{16982             !sectionNode.stdErr.empty() ) \{}
\DoxyCodeLine{16983             XmlWriter::ScopedElement e = xml.scopedElement( \textcolor{stringliteral}{"{}testcase"{}} );}
\DoxyCodeLine{16984             \textcolor{keywordflow}{if}( className.empty() ) \{}
\DoxyCodeLine{16985                 xml.writeAttribute( \textcolor{stringliteral}{"{}classname"{}}, name );}
\DoxyCodeLine{16986                 xml.writeAttribute( \textcolor{stringliteral}{"{}name"{}}, \textcolor{stringliteral}{"{}root"{}} );}
\DoxyCodeLine{16987             \}}
\DoxyCodeLine{16988             \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{16989                 xml.writeAttribute( \textcolor{stringliteral}{"{}classname"{}}, className );}
\DoxyCodeLine{16990                 xml.writeAttribute( \textcolor{stringliteral}{"{}name"{}}, name );}
\DoxyCodeLine{16991             \}}
\DoxyCodeLine{16992             xml.writeAttribute( \textcolor{stringliteral}{"{}time"{}}, formatDuration( sectionNode.stats.durationInSeconds ) );}
\DoxyCodeLine{16993             \textcolor{comment}{// This is not ideal, but it should be enough to mimic gtest's}}
\DoxyCodeLine{16994             \textcolor{comment}{// junit output.}}
\DoxyCodeLine{16995             \textcolor{comment}{// Ideally the JUnit reporter would also handle `skipTest`}}
\DoxyCodeLine{16996             \textcolor{comment}{// events and write those out appropriately.}}
\DoxyCodeLine{16997             xml.writeAttribute( \textcolor{stringliteral}{"{}status"{}}, \textcolor{stringliteral}{"{}run"{}} );}
\DoxyCodeLine{16998 }
\DoxyCodeLine{16999             \textcolor{keywordflow}{if} (sectionNode.stats.assertions.failedButOk) \{}
\DoxyCodeLine{17000                 xml.scopedElement(\textcolor{stringliteral}{"{}skipped"{}})}
\DoxyCodeLine{17001                     .writeAttribute(\textcolor{stringliteral}{"{}message"{}}, \textcolor{stringliteral}{"{}TEST\_CASE tagged with !mayfail"{}});}
\DoxyCodeLine{17002             \}}
\DoxyCodeLine{17003 }
\DoxyCodeLine{17004             writeAssertions( sectionNode );}
\DoxyCodeLine{17005 }
\DoxyCodeLine{17006             \textcolor{keywordflow}{if}( !sectionNode.stdOut.empty() )}
\DoxyCodeLine{17007                 xml.scopedElement( \textcolor{stringliteral}{"{}system-\/out"{}} ).writeText( trim( sectionNode.stdOut ), XmlFormatting::Newline );}
\DoxyCodeLine{17008             \textcolor{keywordflow}{if}( !sectionNode.stdErr.empty() )}
\DoxyCodeLine{17009                 xml.scopedElement( \textcolor{stringliteral}{"{}system-\/err"{}} ).writeText( trim( sectionNode.stdErr ), XmlFormatting::Newline );}
\DoxyCodeLine{17010         \}}
\DoxyCodeLine{17011         \textcolor{keywordflow}{for}( \textcolor{keyword}{auto} \textcolor{keyword}{const}\& childNode : sectionNode.childSections )}
\DoxyCodeLine{17012             \textcolor{keywordflow}{if}( className.empty() )}
\DoxyCodeLine{17013                 writeSection( name, \textcolor{stringliteral}{"{}"{}}, *childNode, testOkToFail );}
\DoxyCodeLine{17014             \textcolor{keywordflow}{else}}
\DoxyCodeLine{17015                 writeSection( className, name, *childNode, testOkToFail );}
\DoxyCodeLine{17016     \}}
\DoxyCodeLine{17017 }
\DoxyCodeLine{17018     \textcolor{keywordtype}{void} JunitReporter::writeAssertions( SectionNode \textcolor{keyword}{const}\& sectionNode ) \{}
\DoxyCodeLine{17019         \textcolor{keywordflow}{for}( \textcolor{keyword}{auto} \textcolor{keyword}{const}\& assertion : sectionNode.assertions )}
\DoxyCodeLine{17020             writeAssertion( assertion );}
\DoxyCodeLine{17021     \}}
\DoxyCodeLine{17022 }
\DoxyCodeLine{17023     \textcolor{keywordtype}{void} JunitReporter::writeAssertion( AssertionStats \textcolor{keyword}{const}\& stats ) \{}
\DoxyCodeLine{17024         AssertionResult \textcolor{keyword}{const}\& result = stats.assertionResult;}
\DoxyCodeLine{17025         \textcolor{keywordflow}{if}( !result.isOk() ) \{}
\DoxyCodeLine{17026             std::string elementName;}
\DoxyCodeLine{17027             \textcolor{keywordflow}{switch}( result.getResultType() ) \{}
\DoxyCodeLine{17028                 \textcolor{keywordflow}{case} ResultWas::ThrewException:}
\DoxyCodeLine{17029                 \textcolor{keywordflow}{case} ResultWas::FatalErrorCondition:}
\DoxyCodeLine{17030                     elementName = \textcolor{stringliteral}{"{}error"{}};}
\DoxyCodeLine{17031                     \textcolor{keywordflow}{break};}
\DoxyCodeLine{17032                 \textcolor{keywordflow}{case} ResultWas::ExplicitFailure:}
\DoxyCodeLine{17033                 \textcolor{keywordflow}{case} ResultWas::ExpressionFailed:}
\DoxyCodeLine{17034                 \textcolor{keywordflow}{case} ResultWas::DidntThrowException:}
\DoxyCodeLine{17035                     elementName = \textcolor{stringliteral}{"{}failure"{}};}
\DoxyCodeLine{17036                     \textcolor{keywordflow}{break};}
\DoxyCodeLine{17037 }
\DoxyCodeLine{17038                 \textcolor{comment}{// We should never see these here:}}
\DoxyCodeLine{17039                 \textcolor{keywordflow}{case} ResultWas::Info:}
\DoxyCodeLine{17040                 \textcolor{keywordflow}{case} ResultWas::Warning:}
\DoxyCodeLine{17041                 \textcolor{keywordflow}{case} ResultWas::Ok:}
\DoxyCodeLine{17042                 \textcolor{keywordflow}{case} ResultWas::Unknown:}
\DoxyCodeLine{17043                 \textcolor{keywordflow}{case} ResultWas::FailureBit:}
\DoxyCodeLine{17044                 \textcolor{keywordflow}{case} ResultWas::Exception:}
\DoxyCodeLine{17045                     elementName = \textcolor{stringliteral}{"{}internalError"{}};}
\DoxyCodeLine{17046                     \textcolor{keywordflow}{break};}
\DoxyCodeLine{17047             \}}
\DoxyCodeLine{17048 }
\DoxyCodeLine{17049             XmlWriter::ScopedElement e = xml.scopedElement( elementName );}
\DoxyCodeLine{17050 }
\DoxyCodeLine{17051             xml.writeAttribute( \textcolor{stringliteral}{"{}message"{}}, result.getExpression() );}
\DoxyCodeLine{17052             xml.writeAttribute( \textcolor{stringliteral}{"{}type"{}}, result.getTestMacroName() );}
\DoxyCodeLine{17053 }
\DoxyCodeLine{17054             ReusableStringStream rss;}
\DoxyCodeLine{17055             \textcolor{keywordflow}{if} (stats.totals.assertions.total() > 0) \{}
\DoxyCodeLine{17056                 rss << \textcolor{stringliteral}{"{}FAILED"{}} << \textcolor{stringliteral}{"{}:\(\backslash\)n"{}};}
\DoxyCodeLine{17057                 \textcolor{keywordflow}{if} (result.hasExpression()) \{}
\DoxyCodeLine{17058                     rss << \textcolor{stringliteral}{"{}  "{}};}
\DoxyCodeLine{17059                     rss << result.getExpressionInMacro();}
\DoxyCodeLine{17060                     rss << \textcolor{charliteral}{'\(\backslash\)n'};}
\DoxyCodeLine{17061                 \}}
\DoxyCodeLine{17062                 \textcolor{keywordflow}{if} (result.hasExpandedExpression()) \{}
\DoxyCodeLine{17063                     rss << \textcolor{stringliteral}{"{}with expansion:\(\backslash\)n"{}};}
\DoxyCodeLine{17064                     rss << Column(result.getExpandedExpression()).indent(2) << \textcolor{charliteral}{'\(\backslash\)n'};}
\DoxyCodeLine{17065                 \}}
\DoxyCodeLine{17066             \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{17067                 rss << \textcolor{charliteral}{'\(\backslash\)n'};}
\DoxyCodeLine{17068             \}}
\DoxyCodeLine{17069 }
\DoxyCodeLine{17070             \textcolor{keywordflow}{if}( !result.getMessage().empty() )}
\DoxyCodeLine{17071                 rss << result.getMessage() << \textcolor{charliteral}{'\(\backslash\)n'};}
\DoxyCodeLine{17072             \textcolor{keywordflow}{for}( \textcolor{keyword}{auto} \textcolor{keyword}{const}\& msg : stats.infoMessages )}
\DoxyCodeLine{17073                 \textcolor{keywordflow}{if}( msg.type == ResultWas::Info )}
\DoxyCodeLine{17074                     rss << msg.message << \textcolor{charliteral}{'\(\backslash\)n'};}
\DoxyCodeLine{17075 }
\DoxyCodeLine{17076             rss << \textcolor{stringliteral}{"{}at "{}} << result.getSourceInfo();}
\DoxyCodeLine{17077             xml.writeText( rss.str(), XmlFormatting::Newline );}
\DoxyCodeLine{17078         \}}
\DoxyCodeLine{17079     \}}
\DoxyCodeLine{17080 }
\DoxyCodeLine{17081     CATCH\_REGISTER\_REPORTER( \textcolor{stringliteral}{"{}junit"{}}, JunitReporter )}
\DoxyCodeLine{17082 }
\DoxyCodeLine{17083 \} \textcolor{comment}{// end namespace Catch}}
\DoxyCodeLine{17084 \textcolor{comment}{// end catch\_reporter\_junit.cpp}}
\DoxyCodeLine{17085 \textcolor{comment}{// start catch\_reporter\_listening.cpp}}
\DoxyCodeLine{17086 }
\DoxyCodeLine{17087 \textcolor{preprocessor}{\#include <cassert>}}
\DoxyCodeLine{17088 }
\DoxyCodeLine{17089 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{17090 }
\DoxyCodeLine{17091     ListeningReporter::ListeningReporter() \{}
\DoxyCodeLine{17092         \textcolor{comment}{// We will assume that listeners will always want all assertions}}
\DoxyCodeLine{17093         m\_preferences.shouldReportAllAssertions = \textcolor{keyword}{true};}
\DoxyCodeLine{17094     \}}
\DoxyCodeLine{17095 }
\DoxyCodeLine{17096     \textcolor{keywordtype}{void} ListeningReporter::addListener( IStreamingReporterPtr\&\& listener ) \{}
\DoxyCodeLine{17097         m\_listeners.push\_back( std::move( listener ) );}
\DoxyCodeLine{17098     \}}
\DoxyCodeLine{17099 }
\DoxyCodeLine{17100     \textcolor{keywordtype}{void} ListeningReporter::addReporter(IStreamingReporterPtr\&\& reporter) \{}
\DoxyCodeLine{17101         assert(!m\_reporter \&\& \textcolor{stringliteral}{"{}Listening reporter can wrap only 1 real reporter"{}});}
\DoxyCodeLine{17102         m\_reporter = std::move( reporter );}
\DoxyCodeLine{17103         m\_preferences.shouldRedirectStdOut = m\_reporter-\/>getPreferences().shouldRedirectStdOut;}
\DoxyCodeLine{17104     \}}
\DoxyCodeLine{17105 }
\DoxyCodeLine{17106     ReporterPreferences ListeningReporter::getPreferences()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{17107         \textcolor{keywordflow}{return} m\_preferences;}
\DoxyCodeLine{17108     \}}
\DoxyCodeLine{17109 }
\DoxyCodeLine{17110     std::set<Verbosity> ListeningReporter::getSupportedVerbosities() \{}
\DoxyCodeLine{17111         \textcolor{keywordflow}{return} std::set<Verbosity>\{ \};}
\DoxyCodeLine{17112     \}}
\DoxyCodeLine{17113 }
\DoxyCodeLine{17114     \textcolor{keywordtype}{void} ListeningReporter::noMatchingTestCases( std::string \textcolor{keyword}{const}\& spec ) \{}
\DoxyCodeLine{17115         \textcolor{keywordflow}{for} ( \textcolor{keyword}{auto} \textcolor{keyword}{const}\& listener : m\_listeners ) \{}
\DoxyCodeLine{17116             listener-\/>noMatchingTestCases( spec );}
\DoxyCodeLine{17117         \}}
\DoxyCodeLine{17118         m\_reporter-\/>noMatchingTestCases( spec );}
\DoxyCodeLine{17119     \}}
\DoxyCodeLine{17120 }
\DoxyCodeLine{17121     \textcolor{keywordtype}{void} ListeningReporter::reportInvalidArguments(std::string \textcolor{keyword}{const}\&arg)\{}
\DoxyCodeLine{17122         \textcolor{keywordflow}{for} ( \textcolor{keyword}{auto} \textcolor{keyword}{const}\& listener : m\_listeners ) \{}
\DoxyCodeLine{17123             listener-\/>reportInvalidArguments( arg );}
\DoxyCodeLine{17124         \}}
\DoxyCodeLine{17125         m\_reporter-\/>reportInvalidArguments( arg );}
\DoxyCodeLine{17126     \}}
\DoxyCodeLine{17127 }
\DoxyCodeLine{17128 \textcolor{preprocessor}{\#if defined(CATCH\_CONFIG\_ENABLE\_BENCHMARKING)}}
\DoxyCodeLine{17129     \textcolor{keywordtype}{void} ListeningReporter::benchmarkPreparing( std::string \textcolor{keyword}{const}\& name ) \{}
\DoxyCodeLine{17130         \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} \textcolor{keyword}{const}\& listener : m\_listeners) \{}
\DoxyCodeLine{17131             listener-\/>benchmarkPreparing(name);}
\DoxyCodeLine{17132         \}}
\DoxyCodeLine{17133         m\_reporter-\/>benchmarkPreparing(name);}
\DoxyCodeLine{17134     \}}
\DoxyCodeLine{17135     \textcolor{keywordtype}{void} ListeningReporter::benchmarkStarting( BenchmarkInfo \textcolor{keyword}{const}\& benchmarkInfo ) \{}
\DoxyCodeLine{17136         \textcolor{keywordflow}{for} ( \textcolor{keyword}{auto} \textcolor{keyword}{const}\& listener : m\_listeners ) \{}
\DoxyCodeLine{17137             listener-\/>benchmarkStarting( benchmarkInfo );}
\DoxyCodeLine{17138         \}}
\DoxyCodeLine{17139         m\_reporter-\/>benchmarkStarting( benchmarkInfo );}
\DoxyCodeLine{17140     \}}
\DoxyCodeLine{17141     \textcolor{keywordtype}{void} ListeningReporter::benchmarkEnded( BenchmarkStats<> \textcolor{keyword}{const}\& benchmarkStats ) \{}
\DoxyCodeLine{17142         \textcolor{keywordflow}{for} ( \textcolor{keyword}{auto} \textcolor{keyword}{const}\& listener : m\_listeners ) \{}
\DoxyCodeLine{17143             listener-\/>benchmarkEnded( benchmarkStats );}
\DoxyCodeLine{17144         \}}
\DoxyCodeLine{17145         m\_reporter-\/>benchmarkEnded( benchmarkStats );}
\DoxyCodeLine{17146     \}}
\DoxyCodeLine{17147 }
\DoxyCodeLine{17148     \textcolor{keywordtype}{void} ListeningReporter::benchmarkFailed( std::string \textcolor{keyword}{const}\& error ) \{}
\DoxyCodeLine{17149         \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} \textcolor{keyword}{const}\& listener : m\_listeners) \{}
\DoxyCodeLine{17150             listener-\/>benchmarkFailed(error);}
\DoxyCodeLine{17151         \}}
\DoxyCodeLine{17152         m\_reporter-\/>benchmarkFailed(error);}
\DoxyCodeLine{17153     \}}
\DoxyCodeLine{17154 \textcolor{preprocessor}{\#endif }\textcolor{comment}{// CATCH\_CONFIG\_ENABLE\_BENCHMARKING}}
\DoxyCodeLine{17155 }
\DoxyCodeLine{17156     \textcolor{keywordtype}{void} ListeningReporter::testRunStarting( TestRunInfo \textcolor{keyword}{const}\& testRunInfo ) \{}
\DoxyCodeLine{17157         \textcolor{keywordflow}{for} ( \textcolor{keyword}{auto} \textcolor{keyword}{const}\& listener : m\_listeners ) \{}
\DoxyCodeLine{17158             listener-\/>testRunStarting( testRunInfo );}
\DoxyCodeLine{17159         \}}
\DoxyCodeLine{17160         m\_reporter-\/>testRunStarting( testRunInfo );}
\DoxyCodeLine{17161     \}}
\DoxyCodeLine{17162 }
\DoxyCodeLine{17163     \textcolor{keywordtype}{void} ListeningReporter::testGroupStarting( GroupInfo \textcolor{keyword}{const}\& groupInfo ) \{}
\DoxyCodeLine{17164         \textcolor{keywordflow}{for} ( \textcolor{keyword}{auto} \textcolor{keyword}{const}\& listener : m\_listeners ) \{}
\DoxyCodeLine{17165             listener-\/>testGroupStarting( groupInfo );}
\DoxyCodeLine{17166         \}}
\DoxyCodeLine{17167         m\_reporter-\/>testGroupStarting( groupInfo );}
\DoxyCodeLine{17168     \}}
\DoxyCodeLine{17169 }
\DoxyCodeLine{17170     \textcolor{keywordtype}{void} ListeningReporter::testCaseStarting( TestCaseInfo \textcolor{keyword}{const}\& testInfo ) \{}
\DoxyCodeLine{17171         \textcolor{keywordflow}{for} ( \textcolor{keyword}{auto} \textcolor{keyword}{const}\& listener : m\_listeners ) \{}
\DoxyCodeLine{17172             listener-\/>testCaseStarting( testInfo );}
\DoxyCodeLine{17173         \}}
\DoxyCodeLine{17174         m\_reporter-\/>testCaseStarting( testInfo );}
\DoxyCodeLine{17175     \}}
\DoxyCodeLine{17176 }
\DoxyCodeLine{17177     \textcolor{keywordtype}{void} ListeningReporter::sectionStarting( SectionInfo \textcolor{keyword}{const}\& sectionInfo ) \{}
\DoxyCodeLine{17178         \textcolor{keywordflow}{for} ( \textcolor{keyword}{auto} \textcolor{keyword}{const}\& listener : m\_listeners ) \{}
\DoxyCodeLine{17179             listener-\/>sectionStarting( sectionInfo );}
\DoxyCodeLine{17180         \}}
\DoxyCodeLine{17181         m\_reporter-\/>sectionStarting( sectionInfo );}
\DoxyCodeLine{17182     \}}
\DoxyCodeLine{17183 }
\DoxyCodeLine{17184     \textcolor{keywordtype}{void} ListeningReporter::assertionStarting( AssertionInfo \textcolor{keyword}{const}\& assertionInfo ) \{}
\DoxyCodeLine{17185         \textcolor{keywordflow}{for} ( \textcolor{keyword}{auto} \textcolor{keyword}{const}\& listener : m\_listeners ) \{}
\DoxyCodeLine{17186             listener-\/>assertionStarting( assertionInfo );}
\DoxyCodeLine{17187         \}}
\DoxyCodeLine{17188         m\_reporter-\/>assertionStarting( assertionInfo );}
\DoxyCodeLine{17189     \}}
\DoxyCodeLine{17190 }
\DoxyCodeLine{17191     \textcolor{comment}{// The return value indicates if the messages buffer should be cleared:}}
\DoxyCodeLine{17192     \textcolor{keywordtype}{bool} ListeningReporter::assertionEnded( AssertionStats \textcolor{keyword}{const}\& assertionStats ) \{}
\DoxyCodeLine{17193         \textcolor{keywordflow}{for}( \textcolor{keyword}{auto} \textcolor{keyword}{const}\& listener : m\_listeners ) \{}
\DoxyCodeLine{17194             \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{void}\textcolor{keyword}{>}( listener-\/>assertionEnded( assertionStats ) );}
\DoxyCodeLine{17195         \}}
\DoxyCodeLine{17196         \textcolor{keywordflow}{return} m\_reporter-\/>assertionEnded( assertionStats );}
\DoxyCodeLine{17197     \}}
\DoxyCodeLine{17198 }
\DoxyCodeLine{17199     \textcolor{keywordtype}{void} ListeningReporter::sectionEnded( SectionStats \textcolor{keyword}{const}\& sectionStats ) \{}
\DoxyCodeLine{17200         \textcolor{keywordflow}{for} ( \textcolor{keyword}{auto} \textcolor{keyword}{const}\& listener : m\_listeners ) \{}
\DoxyCodeLine{17201             listener-\/>sectionEnded( sectionStats );}
\DoxyCodeLine{17202         \}}
\DoxyCodeLine{17203         m\_reporter-\/>sectionEnded( sectionStats );}
\DoxyCodeLine{17204     \}}
\DoxyCodeLine{17205 }
\DoxyCodeLine{17206     \textcolor{keywordtype}{void} ListeningReporter::testCaseEnded( TestCaseStats \textcolor{keyword}{const}\& testCaseStats ) \{}
\DoxyCodeLine{17207         \textcolor{keywordflow}{for} ( \textcolor{keyword}{auto} \textcolor{keyword}{const}\& listener : m\_listeners ) \{}
\DoxyCodeLine{17208             listener-\/>testCaseEnded( testCaseStats );}
\DoxyCodeLine{17209         \}}
\DoxyCodeLine{17210         m\_reporter-\/>testCaseEnded( testCaseStats );}
\DoxyCodeLine{17211     \}}
\DoxyCodeLine{17212 }
\DoxyCodeLine{17213     \textcolor{keywordtype}{void} ListeningReporter::testGroupEnded( TestGroupStats \textcolor{keyword}{const}\& testGroupStats ) \{}
\DoxyCodeLine{17214         \textcolor{keywordflow}{for} ( \textcolor{keyword}{auto} \textcolor{keyword}{const}\& listener : m\_listeners ) \{}
\DoxyCodeLine{17215             listener-\/>testGroupEnded( testGroupStats );}
\DoxyCodeLine{17216         \}}
\DoxyCodeLine{17217         m\_reporter-\/>testGroupEnded( testGroupStats );}
\DoxyCodeLine{17218     \}}
\DoxyCodeLine{17219 }
\DoxyCodeLine{17220     \textcolor{keywordtype}{void} ListeningReporter::testRunEnded( TestRunStats \textcolor{keyword}{const}\& testRunStats ) \{}
\DoxyCodeLine{17221         \textcolor{keywordflow}{for} ( \textcolor{keyword}{auto} \textcolor{keyword}{const}\& listener : m\_listeners ) \{}
\DoxyCodeLine{17222             listener-\/>testRunEnded( testRunStats );}
\DoxyCodeLine{17223         \}}
\DoxyCodeLine{17224         m\_reporter-\/>testRunEnded( testRunStats );}
\DoxyCodeLine{17225     \}}
\DoxyCodeLine{17226 }
\DoxyCodeLine{17227     \textcolor{keywordtype}{void} ListeningReporter::skipTest( TestCaseInfo \textcolor{keyword}{const}\& testInfo ) \{}
\DoxyCodeLine{17228         \textcolor{keywordflow}{for} ( \textcolor{keyword}{auto} \textcolor{keyword}{const}\& listener : m\_listeners ) \{}
\DoxyCodeLine{17229             listener-\/>skipTest( testInfo );}
\DoxyCodeLine{17230         \}}
\DoxyCodeLine{17231         m\_reporter-\/>skipTest( testInfo );}
\DoxyCodeLine{17232     \}}
\DoxyCodeLine{17233 }
\DoxyCodeLine{17234     \textcolor{keywordtype}{bool} ListeningReporter::isMulti()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{17235         \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{17236     \}}
\DoxyCodeLine{17237 }
\DoxyCodeLine{17238 \} \textcolor{comment}{// end namespace Catch}}
\DoxyCodeLine{17239 \textcolor{comment}{// end catch\_reporter\_listening.cpp}}
\DoxyCodeLine{17240 \textcolor{comment}{// start catch\_reporter\_xml.cpp}}
\DoxyCodeLine{17241 }
\DoxyCodeLine{17242 \textcolor{preprocessor}{\#if defined(\_MSC\_VER)}}
\DoxyCodeLine{17243 \textcolor{preprocessor}{\#pragma warning(push)}}
\DoxyCodeLine{17244 \textcolor{preprocessor}{\#pragma warning(disable:4061) }\textcolor{comment}{// Not all labels are EXPLICITLY handled in switch}}
\DoxyCodeLine{17245                               \textcolor{comment}{// Note that 4062 (not all labels are handled}}
\DoxyCodeLine{17246                               \textcolor{comment}{// and default is missing) is enabled}}
\DoxyCodeLine{17247 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{17248 }
\DoxyCodeLine{17249 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{17250     XmlReporter::XmlReporter( ReporterConfig \textcolor{keyword}{const}\& \_config )}
\DoxyCodeLine{17251     :   StreamingReporterBase( \_config ),}
\DoxyCodeLine{17252         m\_xml(\_config.stream())}
\DoxyCodeLine{17253     \{}
\DoxyCodeLine{17254         m\_reporterPrefs.shouldRedirectStdOut = \textcolor{keyword}{true};}
\DoxyCodeLine{17255         m\_reporterPrefs.shouldReportAllAssertions = \textcolor{keyword}{true};}
\DoxyCodeLine{17256     \}}
\DoxyCodeLine{17257 }
\DoxyCodeLine{17258     XmlReporter::\string~XmlReporter() = \textcolor{keywordflow}{default};}
\DoxyCodeLine{17259 }
\DoxyCodeLine{17260     std::string XmlReporter::getDescription() \{}
\DoxyCodeLine{17261         \textcolor{keywordflow}{return} \textcolor{stringliteral}{"{}Reports test results as an XML document"{}};}
\DoxyCodeLine{17262     \}}
\DoxyCodeLine{17263 }
\DoxyCodeLine{17264     std::string XmlReporter::getStylesheetRef()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{17265         \textcolor{keywordflow}{return} std::string();}
\DoxyCodeLine{17266     \}}
\DoxyCodeLine{17267 }
\DoxyCodeLine{17268     \textcolor{keywordtype}{void} XmlReporter::writeSourceInfo( SourceLineInfo \textcolor{keyword}{const}\& sourceInfo ) \{}
\DoxyCodeLine{17269         m\_xml}
\DoxyCodeLine{17270             .writeAttribute( \textcolor{stringliteral}{"{}filename"{}}, sourceInfo.file )}
\DoxyCodeLine{17271             .writeAttribute( \textcolor{stringliteral}{"{}line"{}}, sourceInfo.line );}
\DoxyCodeLine{17272     \}}
\DoxyCodeLine{17273 }
\DoxyCodeLine{17274     \textcolor{keywordtype}{void} XmlReporter::noMatchingTestCases( std::string \textcolor{keyword}{const}\& s ) \{}
\DoxyCodeLine{17275         StreamingReporterBase::noMatchingTestCases( s );}
\DoxyCodeLine{17276     \}}
\DoxyCodeLine{17277 }
\DoxyCodeLine{17278     \textcolor{keywordtype}{void} XmlReporter::testRunStarting( TestRunInfo \textcolor{keyword}{const}\& testInfo ) \{}
\DoxyCodeLine{17279         StreamingReporterBase::testRunStarting( testInfo );}
\DoxyCodeLine{17280         std::string stylesheetRef = getStylesheetRef();}
\DoxyCodeLine{17281         \textcolor{keywordflow}{if}( !stylesheetRef.empty() )}
\DoxyCodeLine{17282             m\_xml.writeStylesheetRef( stylesheetRef );}
\DoxyCodeLine{17283         m\_xml.startElement( \textcolor{stringliteral}{"{}Catch"{}} );}
\DoxyCodeLine{17284         \textcolor{keywordflow}{if}( !m\_config-\/>name().empty() )}
\DoxyCodeLine{17285             m\_xml.writeAttribute( \textcolor{stringliteral}{"{}name"{}}, m\_config-\/>name() );}
\DoxyCodeLine{17286         \textcolor{keywordflow}{if} (m\_config-\/>testSpec().hasFilters())}
\DoxyCodeLine{17287             m\_xml.writeAttribute( \textcolor{stringliteral}{"{}filters"{}}, serializeFilters( m\_config-\/>getTestsOrTags() ) );}
\DoxyCodeLine{17288         \textcolor{keywordflow}{if}( m\_config-\/>rngSeed() != 0 )}
\DoxyCodeLine{17289             m\_xml.scopedElement( \textcolor{stringliteral}{"{}Randomness"{}} )}
\DoxyCodeLine{17290                 .writeAttribute( \textcolor{stringliteral}{"{}seed"{}}, m\_config-\/>rngSeed() );}
\DoxyCodeLine{17291     \}}
\DoxyCodeLine{17292 }
\DoxyCodeLine{17293     \textcolor{keywordtype}{void} XmlReporter::testGroupStarting( GroupInfo \textcolor{keyword}{const}\& groupInfo ) \{}
\DoxyCodeLine{17294         StreamingReporterBase::testGroupStarting( groupInfo );}
\DoxyCodeLine{17295         m\_xml.startElement( \textcolor{stringliteral}{"{}Group"{}} )}
\DoxyCodeLine{17296             .writeAttribute( \textcolor{stringliteral}{"{}name"{}}, groupInfo.name );}
\DoxyCodeLine{17297     \}}
\DoxyCodeLine{17298 }
\DoxyCodeLine{17299     \textcolor{keywordtype}{void} XmlReporter::testCaseStarting( TestCaseInfo \textcolor{keyword}{const}\& testInfo ) \{}
\DoxyCodeLine{17300         StreamingReporterBase::testCaseStarting(testInfo);}
\DoxyCodeLine{17301         m\_xml.startElement( \textcolor{stringliteral}{"{}TestCase"{}} )}
\DoxyCodeLine{17302             .writeAttribute( \textcolor{stringliteral}{"{}name"{}}, trim( testInfo.name ) )}
\DoxyCodeLine{17303             .writeAttribute( \textcolor{stringliteral}{"{}description"{}}, testInfo.description )}
\DoxyCodeLine{17304             .writeAttribute( \textcolor{stringliteral}{"{}tags"{}}, testInfo.tagsAsString() );}
\DoxyCodeLine{17305 }
\DoxyCodeLine{17306         writeSourceInfo( testInfo.lineInfo );}
\DoxyCodeLine{17307 }
\DoxyCodeLine{17308         \textcolor{keywordflow}{if} ( m\_config-\/>showDurations() == ShowDurations::Always )}
\DoxyCodeLine{17309             m\_testCaseTimer.start();}
\DoxyCodeLine{17310         m\_xml.ensureTagClosed();}
\DoxyCodeLine{17311     \}}
\DoxyCodeLine{17312 }
\DoxyCodeLine{17313     \textcolor{keywordtype}{void} XmlReporter::sectionStarting( SectionInfo \textcolor{keyword}{const}\& sectionInfo ) \{}
\DoxyCodeLine{17314         StreamingReporterBase::sectionStarting( sectionInfo );}
\DoxyCodeLine{17315         \textcolor{keywordflow}{if}( m\_sectionDepth++ > 0 ) \{}
\DoxyCodeLine{17316             m\_xml.startElement( \textcolor{stringliteral}{"{}Section"{}} )}
\DoxyCodeLine{17317                 .writeAttribute( \textcolor{stringliteral}{"{}name"{}}, trim( sectionInfo.name ) );}
\DoxyCodeLine{17318             writeSourceInfo( sectionInfo.lineInfo );}
\DoxyCodeLine{17319             m\_xml.ensureTagClosed();}
\DoxyCodeLine{17320         \}}
\DoxyCodeLine{17321     \}}
\DoxyCodeLine{17322 }
\DoxyCodeLine{17323     \textcolor{keywordtype}{void} XmlReporter::assertionStarting( AssertionInfo \textcolor{keyword}{const}\& ) \{ \}}
\DoxyCodeLine{17324 }
\DoxyCodeLine{17325     \textcolor{keywordtype}{bool} XmlReporter::assertionEnded( AssertionStats \textcolor{keyword}{const}\& assertionStats ) \{}
\DoxyCodeLine{17326 }
\DoxyCodeLine{17327         AssertionResult \textcolor{keyword}{const}\& result = assertionStats.assertionResult;}
\DoxyCodeLine{17328 }
\DoxyCodeLine{17329         \textcolor{keywordtype}{bool} includeResults = m\_config-\/>includeSuccessfulResults() || !result.isOk();}
\DoxyCodeLine{17330 }
\DoxyCodeLine{17331         \textcolor{keywordflow}{if}( includeResults || result.getResultType() == ResultWas::Warning ) \{}
\DoxyCodeLine{17332             \textcolor{comment}{// Print any info messages in <Info> tags.}}
\DoxyCodeLine{17333             \textcolor{keywordflow}{for}( \textcolor{keyword}{auto} \textcolor{keyword}{const}\& msg : assertionStats.infoMessages ) \{}
\DoxyCodeLine{17334                 \textcolor{keywordflow}{if}( msg.type == ResultWas::Info \&\& includeResults ) \{}
\DoxyCodeLine{17335                     m\_xml.scopedElement( \textcolor{stringliteral}{"{}Info"{}} )}
\DoxyCodeLine{17336                             .writeText( msg.message );}
\DoxyCodeLine{17337                 \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} ( msg.type == ResultWas::Warning ) \{}
\DoxyCodeLine{17338                     m\_xml.scopedElement( \textcolor{stringliteral}{"{}Warning"{}} )}
\DoxyCodeLine{17339                             .writeText( msg.message );}
\DoxyCodeLine{17340                 \}}
\DoxyCodeLine{17341             \}}
\DoxyCodeLine{17342         \}}
\DoxyCodeLine{17343 }
\DoxyCodeLine{17344         \textcolor{comment}{// Drop out if result was successful but we're not printing them.}}
\DoxyCodeLine{17345         \textcolor{keywordflow}{if}( !includeResults \&\& result.getResultType() != ResultWas::Warning )}
\DoxyCodeLine{17346             \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{17347 }
\DoxyCodeLine{17348         \textcolor{comment}{// Print the expression if there is one.}}
\DoxyCodeLine{17349         \textcolor{keywordflow}{if}( result.hasExpression() ) \{}
\DoxyCodeLine{17350             m\_xml.startElement( \textcolor{stringliteral}{"{}Expression"{}} )}
\DoxyCodeLine{17351                 .writeAttribute( \textcolor{stringliteral}{"{}success"{}}, result.succeeded() )}
\DoxyCodeLine{17352                 .writeAttribute( \textcolor{stringliteral}{"{}type"{}}, result.getTestMacroName() );}
\DoxyCodeLine{17353 }
\DoxyCodeLine{17354             writeSourceInfo( result.getSourceInfo() );}
\DoxyCodeLine{17355 }
\DoxyCodeLine{17356             m\_xml.scopedElement( \textcolor{stringliteral}{"{}Original"{}} )}
\DoxyCodeLine{17357                 .writeText( result.getExpression() );}
\DoxyCodeLine{17358             m\_xml.scopedElement( \textcolor{stringliteral}{"{}Expanded"{}} )}
\DoxyCodeLine{17359                 .writeText( result.getExpandedExpression() );}
\DoxyCodeLine{17360         \}}
\DoxyCodeLine{17361 }
\DoxyCodeLine{17362         \textcolor{comment}{// And... Print a result applicable to each result type.}}
\DoxyCodeLine{17363         \textcolor{keywordflow}{switch}( result.getResultType() ) \{}
\DoxyCodeLine{17364             \textcolor{keywordflow}{case} ResultWas::ThrewException:}
\DoxyCodeLine{17365                 m\_xml.startElement( \textcolor{stringliteral}{"{}Exception"{}} );}
\DoxyCodeLine{17366                 writeSourceInfo( result.getSourceInfo() );}
\DoxyCodeLine{17367                 m\_xml.writeText( result.getMessage() );}
\DoxyCodeLine{17368                 m\_xml.endElement();}
\DoxyCodeLine{17369                 \textcolor{keywordflow}{break};}
\DoxyCodeLine{17370             \textcolor{keywordflow}{case} ResultWas::FatalErrorCondition:}
\DoxyCodeLine{17371                 m\_xml.startElement( \textcolor{stringliteral}{"{}FatalErrorCondition"{}} );}
\DoxyCodeLine{17372                 writeSourceInfo( result.getSourceInfo() );}
\DoxyCodeLine{17373                 m\_xml.writeText( result.getMessage() );}
\DoxyCodeLine{17374                 m\_xml.endElement();}
\DoxyCodeLine{17375                 \textcolor{keywordflow}{break};}
\DoxyCodeLine{17376             \textcolor{keywordflow}{case} ResultWas::Info:}
\DoxyCodeLine{17377                 m\_xml.scopedElement( \textcolor{stringliteral}{"{}Info"{}} )}
\DoxyCodeLine{17378                     .writeText( result.getMessage() );}
\DoxyCodeLine{17379                 \textcolor{keywordflow}{break};}
\DoxyCodeLine{17380             \textcolor{keywordflow}{case} ResultWas::Warning:}
\DoxyCodeLine{17381                 \textcolor{comment}{// Warning will already have been written}}
\DoxyCodeLine{17382                 \textcolor{keywordflow}{break};}
\DoxyCodeLine{17383             \textcolor{keywordflow}{case} ResultWas::ExplicitFailure:}
\DoxyCodeLine{17384                 m\_xml.startElement( \textcolor{stringliteral}{"{}Failure"{}} );}
\DoxyCodeLine{17385                 writeSourceInfo( result.getSourceInfo() );}
\DoxyCodeLine{17386                 m\_xml.writeText( result.getMessage() );}
\DoxyCodeLine{17387                 m\_xml.endElement();}
\DoxyCodeLine{17388                 \textcolor{keywordflow}{break};}
\DoxyCodeLine{17389             \textcolor{keywordflow}{default}:}
\DoxyCodeLine{17390                 \textcolor{keywordflow}{break};}
\DoxyCodeLine{17391         \}}
\DoxyCodeLine{17392 }
\DoxyCodeLine{17393         \textcolor{keywordflow}{if}( result.hasExpression() )}
\DoxyCodeLine{17394             m\_xml.endElement();}
\DoxyCodeLine{17395 }
\DoxyCodeLine{17396         \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{17397     \}}
\DoxyCodeLine{17398 }
\DoxyCodeLine{17399     \textcolor{keywordtype}{void} XmlReporter::sectionEnded( SectionStats \textcolor{keyword}{const}\& sectionStats ) \{}
\DoxyCodeLine{17400         StreamingReporterBase::sectionEnded( sectionStats );}
\DoxyCodeLine{17401         \textcolor{keywordflow}{if}( -\/-\/m\_sectionDepth > 0 ) \{}
\DoxyCodeLine{17402             XmlWriter::ScopedElement e = m\_xml.scopedElement( \textcolor{stringliteral}{"{}OverallResults"{}} );}
\DoxyCodeLine{17403             e.writeAttribute( \textcolor{stringliteral}{"{}successes"{}}, sectionStats.assertions.passed );}
\DoxyCodeLine{17404             e.writeAttribute( \textcolor{stringliteral}{"{}failures"{}}, sectionStats.assertions.failed );}
\DoxyCodeLine{17405             e.writeAttribute( \textcolor{stringliteral}{"{}expectedFailures"{}}, sectionStats.assertions.failedButOk );}
\DoxyCodeLine{17406 }
\DoxyCodeLine{17407             \textcolor{keywordflow}{if} ( m\_config-\/>showDurations() == ShowDurations::Always )}
\DoxyCodeLine{17408                 e.writeAttribute( \textcolor{stringliteral}{"{}durationInSeconds"{}}, sectionStats.durationInSeconds );}
\DoxyCodeLine{17409 }
\DoxyCodeLine{17410             m\_xml.endElement();}
\DoxyCodeLine{17411         \}}
\DoxyCodeLine{17412     \}}
\DoxyCodeLine{17413 }
\DoxyCodeLine{17414     \textcolor{keywordtype}{void} XmlReporter::testCaseEnded( TestCaseStats \textcolor{keyword}{const}\& testCaseStats ) \{}
\DoxyCodeLine{17415         StreamingReporterBase::testCaseEnded( testCaseStats );}
\DoxyCodeLine{17416         XmlWriter::ScopedElement e = m\_xml.scopedElement( \textcolor{stringliteral}{"{}OverallResult"{}} );}
\DoxyCodeLine{17417         e.writeAttribute( \textcolor{stringliteral}{"{}success"{}}, testCaseStats.totals.assertions.allOk() );}
\DoxyCodeLine{17418 }
\DoxyCodeLine{17419         \textcolor{keywordflow}{if} ( m\_config-\/>showDurations() == ShowDurations::Always )}
\DoxyCodeLine{17420             e.writeAttribute( \textcolor{stringliteral}{"{}durationInSeconds"{}}, m\_testCaseTimer.getElapsedSeconds() );}
\DoxyCodeLine{17421 }
\DoxyCodeLine{17422         \textcolor{keywordflow}{if}( !testCaseStats.stdOut.empty() )}
\DoxyCodeLine{17423             m\_xml.scopedElement( \textcolor{stringliteral}{"{}StdOut"{}} ).writeText( trim( testCaseStats.stdOut ), XmlFormatting::Newline );}
\DoxyCodeLine{17424         \textcolor{keywordflow}{if}( !testCaseStats.stdErr.empty() )}
\DoxyCodeLine{17425             m\_xml.scopedElement( \textcolor{stringliteral}{"{}StdErr"{}} ).writeText( trim( testCaseStats.stdErr ), XmlFormatting::Newline );}
\DoxyCodeLine{17426 }
\DoxyCodeLine{17427         m\_xml.endElement();}
\DoxyCodeLine{17428     \}}
\DoxyCodeLine{17429 }
\DoxyCodeLine{17430     \textcolor{keywordtype}{void} XmlReporter::testGroupEnded( TestGroupStats \textcolor{keyword}{const}\& testGroupStats ) \{}
\DoxyCodeLine{17431         StreamingReporterBase::testGroupEnded( testGroupStats );}
\DoxyCodeLine{17432         \textcolor{comment}{// TODO: Check testGroupStats.aborting and act accordingly.}}
\DoxyCodeLine{17433         m\_xml.scopedElement( \textcolor{stringliteral}{"{}OverallResults"{}} )}
\DoxyCodeLine{17434             .writeAttribute( \textcolor{stringliteral}{"{}successes"{}}, testGroupStats.totals.assertions.passed )}
\DoxyCodeLine{17435             .writeAttribute( \textcolor{stringliteral}{"{}failures"{}}, testGroupStats.totals.assertions.failed )}
\DoxyCodeLine{17436             .writeAttribute( \textcolor{stringliteral}{"{}expectedFailures"{}}, testGroupStats.totals.assertions.failedButOk );}
\DoxyCodeLine{17437         m\_xml.scopedElement( \textcolor{stringliteral}{"{}OverallResultsCases"{}})}
\DoxyCodeLine{17438             .writeAttribute( \textcolor{stringliteral}{"{}successes"{}}, testGroupStats.totals.testCases.passed )}
\DoxyCodeLine{17439             .writeAttribute( \textcolor{stringliteral}{"{}failures"{}}, testGroupStats.totals.testCases.failed )}
\DoxyCodeLine{17440             .writeAttribute( \textcolor{stringliteral}{"{}expectedFailures"{}}, testGroupStats.totals.testCases.failedButOk );}
\DoxyCodeLine{17441         m\_xml.endElement();}
\DoxyCodeLine{17442     \}}
\DoxyCodeLine{17443 }
\DoxyCodeLine{17444     \textcolor{keywordtype}{void} XmlReporter::testRunEnded( TestRunStats \textcolor{keyword}{const}\& testRunStats ) \{}
\DoxyCodeLine{17445         StreamingReporterBase::testRunEnded( testRunStats );}
\DoxyCodeLine{17446         m\_xml.scopedElement( \textcolor{stringliteral}{"{}OverallResults"{}} )}
\DoxyCodeLine{17447             .writeAttribute( \textcolor{stringliteral}{"{}successes"{}}, testRunStats.totals.assertions.passed )}
\DoxyCodeLine{17448             .writeAttribute( \textcolor{stringliteral}{"{}failures"{}}, testRunStats.totals.assertions.failed )}
\DoxyCodeLine{17449             .writeAttribute( \textcolor{stringliteral}{"{}expectedFailures"{}}, testRunStats.totals.assertions.failedButOk );}
\DoxyCodeLine{17450         m\_xml.scopedElement( \textcolor{stringliteral}{"{}OverallResultsCases"{}})}
\DoxyCodeLine{17451             .writeAttribute( \textcolor{stringliteral}{"{}successes"{}}, testRunStats.totals.testCases.passed )}
\DoxyCodeLine{17452             .writeAttribute( \textcolor{stringliteral}{"{}failures"{}}, testRunStats.totals.testCases.failed )}
\DoxyCodeLine{17453             .writeAttribute( \textcolor{stringliteral}{"{}expectedFailures"{}}, testRunStats.totals.testCases.failedButOk );}
\DoxyCodeLine{17454         m\_xml.endElement();}
\DoxyCodeLine{17455     \}}
\DoxyCodeLine{17456 }
\DoxyCodeLine{17457 \textcolor{preprocessor}{\#if defined(CATCH\_CONFIG\_ENABLE\_BENCHMARKING)}}
\DoxyCodeLine{17458     \textcolor{keywordtype}{void} XmlReporter::benchmarkPreparing(std::string \textcolor{keyword}{const}\& name) \{}
\DoxyCodeLine{17459         m\_xml.startElement(\textcolor{stringliteral}{"{}BenchmarkResults"{}})}
\DoxyCodeLine{17460             .writeAttribute(\textcolor{stringliteral}{"{}name"{}}, name);}
\DoxyCodeLine{17461     \}}
\DoxyCodeLine{17462 }
\DoxyCodeLine{17463     \textcolor{keywordtype}{void} XmlReporter::benchmarkStarting(BenchmarkInfo \textcolor{keyword}{const} \&info) \{}
\DoxyCodeLine{17464         m\_xml.writeAttribute(\textcolor{stringliteral}{"{}samples"{}}, info.samples)}
\DoxyCodeLine{17465             .writeAttribute(\textcolor{stringliteral}{"{}resamples"{}}, info.resamples)}
\DoxyCodeLine{17466             .writeAttribute(\textcolor{stringliteral}{"{}iterations"{}}, info.iterations)}
\DoxyCodeLine{17467             .writeAttribute(\textcolor{stringliteral}{"{}clockResolution"{}}, info.clockResolution)}
\DoxyCodeLine{17468             .writeAttribute(\textcolor{stringliteral}{"{}estimatedDuration"{}}, info.estimatedDuration)}
\DoxyCodeLine{17469             .writeComment(\textcolor{stringliteral}{"{}All values in nano seconds"{}});}
\DoxyCodeLine{17470     \}}
\DoxyCodeLine{17471 }
\DoxyCodeLine{17472     \textcolor{keywordtype}{void} XmlReporter::benchmarkEnded(BenchmarkStats<> \textcolor{keyword}{const}\& benchmarkStats) \{}
\DoxyCodeLine{17473         m\_xml.startElement(\textcolor{stringliteral}{"{}mean"{}})}
\DoxyCodeLine{17474             .writeAttribute(\textcolor{stringliteral}{"{}value"{}}, benchmarkStats.mean.point.count())}
\DoxyCodeLine{17475             .writeAttribute(\textcolor{stringliteral}{"{}lowerBound"{}}, benchmarkStats.mean.lower\_bound.count())}
\DoxyCodeLine{17476             .writeAttribute(\textcolor{stringliteral}{"{}upperBound"{}}, benchmarkStats.mean.upper\_bound.count())}
\DoxyCodeLine{17477             .writeAttribute(\textcolor{stringliteral}{"{}ci"{}}, benchmarkStats.mean.confidence\_interval);}
\DoxyCodeLine{17478         m\_xml.endElement();}
\DoxyCodeLine{17479         m\_xml.startElement(\textcolor{stringliteral}{"{}standardDeviation"{}})}
\DoxyCodeLine{17480             .writeAttribute(\textcolor{stringliteral}{"{}value"{}}, benchmarkStats.standardDeviation.point.count())}
\DoxyCodeLine{17481             .writeAttribute(\textcolor{stringliteral}{"{}lowerBound"{}}, benchmarkStats.standardDeviation.lower\_bound.count())}
\DoxyCodeLine{17482             .writeAttribute(\textcolor{stringliteral}{"{}upperBound"{}}, benchmarkStats.standardDeviation.upper\_bound.count())}
\DoxyCodeLine{17483             .writeAttribute(\textcolor{stringliteral}{"{}ci"{}}, benchmarkStats.standardDeviation.confidence\_interval);}
\DoxyCodeLine{17484         m\_xml.endElement();}
\DoxyCodeLine{17485         m\_xml.startElement(\textcolor{stringliteral}{"{}outliers"{}})}
\DoxyCodeLine{17486             .writeAttribute(\textcolor{stringliteral}{"{}variance"{}}, benchmarkStats.outlierVariance)}
\DoxyCodeLine{17487             .writeAttribute(\textcolor{stringliteral}{"{}lowMild"{}}, benchmarkStats.outliers.low\_mild)}
\DoxyCodeLine{17488             .writeAttribute(\textcolor{stringliteral}{"{}lowSevere"{}}, benchmarkStats.outliers.low\_severe)}
\DoxyCodeLine{17489             .writeAttribute(\textcolor{stringliteral}{"{}highMild"{}}, benchmarkStats.outliers.high\_mild)}
\DoxyCodeLine{17490             .writeAttribute(\textcolor{stringliteral}{"{}highSevere"{}}, benchmarkStats.outliers.high\_severe);}
\DoxyCodeLine{17491         m\_xml.endElement();}
\DoxyCodeLine{17492         m\_xml.endElement();}
\DoxyCodeLine{17493     \}}
\DoxyCodeLine{17494 }
\DoxyCodeLine{17495     \textcolor{keywordtype}{void} XmlReporter::benchmarkFailed(std::string \textcolor{keyword}{const} \&error) \{}
\DoxyCodeLine{17496         m\_xml.scopedElement(\textcolor{stringliteral}{"{}failed"{}}).}
\DoxyCodeLine{17497             writeAttribute(\textcolor{stringliteral}{"{}message"{}}, error);}
\DoxyCodeLine{17498         m\_xml.endElement();}
\DoxyCodeLine{17499     \}}
\DoxyCodeLine{17500 \textcolor{preprocessor}{\#endif }\textcolor{comment}{// CATCH\_CONFIG\_ENABLE\_BENCHMARKING}}
\DoxyCodeLine{17501 }
\DoxyCodeLine{17502     CATCH\_REGISTER\_REPORTER( \textcolor{stringliteral}{"{}xml"{}}, XmlReporter )}
\DoxyCodeLine{17503 }
\DoxyCodeLine{17504 \} \textcolor{comment}{// end namespace Catch}}
\DoxyCodeLine{17505 }
\DoxyCodeLine{17506 \textcolor{preprocessor}{\#if defined(\_MSC\_VER)}}
\DoxyCodeLine{17507 \textcolor{preprocessor}{\#pragma warning(pop)}}
\DoxyCodeLine{17508 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{17509 \textcolor{comment}{// end catch\_reporter\_xml.cpp}}
\DoxyCodeLine{17510 }
\DoxyCodeLine{17511 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{17512     LeakDetector leakDetector;}
\DoxyCodeLine{17513 \}}
\DoxyCodeLine{17514 }
\DoxyCodeLine{17515 \textcolor{preprocessor}{\#ifdef \_\_clang\_\_}}
\DoxyCodeLine{17516 \textcolor{preprocessor}{\#pragma clang diagnostic pop}}
\DoxyCodeLine{17517 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{17518 }
\DoxyCodeLine{17519 \textcolor{comment}{// end catch\_impl.hpp}}
\DoxyCodeLine{17520 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{17521 }
\DoxyCodeLine{17522 \textcolor{preprocessor}{\#ifdef CATCH\_CONFIG\_MAIN}}
\DoxyCodeLine{17523 \textcolor{comment}{// start catch\_default\_main.hpp}}
\DoxyCodeLine{17524 }
\DoxyCodeLine{17525 \textcolor{preprocessor}{\#ifndef \_\_OBJC\_\_}}
\DoxyCodeLine{17526 }
\DoxyCodeLine{17527 \textcolor{preprocessor}{\#ifndef CATCH\_INTERNAL\_CDECL}}
\DoxyCodeLine{17528 \textcolor{preprocessor}{\#ifdef \_MSC\_VER}}
\DoxyCodeLine{17529 \textcolor{preprocessor}{\#define CATCH\_INTERNAL\_CDECL \_\_cdecl}}
\DoxyCodeLine{17530 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{17531 \textcolor{preprocessor}{\#define CATCH\_INTERNAL\_CDECL}}
\DoxyCodeLine{17532 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{17533 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{17534 }
\DoxyCodeLine{17535 \textcolor{preprocessor}{\#if defined(CATCH\_CONFIG\_WCHAR) \&\& defined(CATCH\_PLATFORM\_WINDOWS) \&\& defined(\_UNICODE) \&\& !defined(DO\_NOT\_USE\_WMAIN)}}
\DoxyCodeLine{17536 \textcolor{comment}{// Standard C/C++ Win32 Unicode wmain entry point}}
\DoxyCodeLine{17537 \textcolor{keyword}{extern} \textcolor{stringliteral}{"{}C"{}} \textcolor{keywordtype}{int} CATCH\_INTERNAL\_CDECL wmain (\textcolor{keywordtype}{int} argc, \textcolor{keywordtype}{wchar\_t} * argv[], \textcolor{keywordtype}{wchar\_t} * []) \{}
\DoxyCodeLine{17538 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{17539 \textcolor{comment}{// Standard C/C++ main entry point}}
\DoxyCodeLine{17540 \textcolor{keywordtype}{int} CATCH\_INTERNAL\_CDECL main (\textcolor{keywordtype}{int} argc, \textcolor{keywordtype}{char} * argv[]) \{}
\DoxyCodeLine{17541 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{17542 }
\DoxyCodeLine{17543     \textcolor{keywordflow}{return} Catch::Session().run( argc, argv );}
\DoxyCodeLine{17544 \}}
\DoxyCodeLine{17545 }
\DoxyCodeLine{17546 \textcolor{preprocessor}{\#else }\textcolor{comment}{// \_\_OBJC\_\_}}
\DoxyCodeLine{17547 }
\DoxyCodeLine{17548 \textcolor{comment}{// Objective-\/C entry point}}
\DoxyCodeLine{17549 \textcolor{keywordtype}{int} main (\textcolor{keywordtype}{int} argc, \textcolor{keywordtype}{char} * \textcolor{keyword}{const} argv[]) \{}
\DoxyCodeLine{17550 \textcolor{preprocessor}{\#if !CATCH\_ARC\_ENABLED}}
\DoxyCodeLine{17551     NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];}
\DoxyCodeLine{17552 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{17553 }
\DoxyCodeLine{17554     Catch::registerTestMethods();}
\DoxyCodeLine{17555     \textcolor{keywordtype}{int} result = Catch::Session().run( argc, (\textcolor{keywordtype}{char}**)argv );}
\DoxyCodeLine{17556 }
\DoxyCodeLine{17557 \textcolor{preprocessor}{\#if !CATCH\_ARC\_ENABLED}}
\DoxyCodeLine{17558     [pool drain];}
\DoxyCodeLine{17559 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{17560 }
\DoxyCodeLine{17561     \textcolor{keywordflow}{return} result;}
\DoxyCodeLine{17562 \}}
\DoxyCodeLine{17563 }
\DoxyCodeLine{17564 \textcolor{preprocessor}{\#endif }\textcolor{comment}{// \_\_OBJC\_\_}}
\DoxyCodeLine{17565 }
\DoxyCodeLine{17566 \textcolor{comment}{// end catch\_default\_main.hpp}}
\DoxyCodeLine{17567 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{17568 }
\DoxyCodeLine{17569 \textcolor{preprocessor}{\#if !defined(CATCH\_CONFIG\_IMPL\_ONLY)}}
\DoxyCodeLine{17570 }
\DoxyCodeLine{17571 \textcolor{preprocessor}{\#ifdef CLARA\_CONFIG\_MAIN\_NOT\_DEFINED}}
\DoxyCodeLine{17572 \textcolor{preprocessor}{\#  undef CLARA\_CONFIG\_MAIN}}
\DoxyCodeLine{17573 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{17574 }
\DoxyCodeLine{17575 \textcolor{preprocessor}{\#if !defined(CATCH\_CONFIG\_DISABLE)}}
\DoxyCodeLine{17577 \textcolor{comment}{// If this config identifier is defined then all CATCH macros are prefixed with CATCH\_}}
\DoxyCodeLine{17578 \textcolor{preprocessor}{\#ifdef CATCH\_CONFIG\_PREFIX\_ALL}}
\DoxyCodeLine{17579 }
\DoxyCodeLine{17580 \textcolor{preprocessor}{\#define CATCH\_REQUIRE( ... ) INTERNAL\_CATCH\_TEST( "{}CATCH\_REQUIRE"{}}, Catch::ResultDisposition::Normal, \_\_VA\_ARGS\_\_ )}
\DoxyCodeLine{17581 \textcolor{preprocessor}{\#define CATCH\_REQUIRE\_FALSE( ... ) INTERNAL\_CATCH\_TEST( "{}CATCH\_REQUIRE\_FALSE"{}}, Catch::ResultDisposition::Normal | Catch::ResultDisposition::FalseTest, \_\_VA\_ARGS\_\_ )}
\DoxyCodeLine{17582 }
\DoxyCodeLine{17583 \textcolor{preprocessor}{\#define CATCH\_REQUIRE\_THROWS( ... ) INTERNAL\_CATCH\_THROWS( "{}CATCH\_REQUIRE\_THROWS"{}}, Catch::ResultDisposition::Normal, \_\_VA\_ARGS\_\_ )}
\DoxyCodeLine{17584 \textcolor{preprocessor}{\#define CATCH\_REQUIRE\_THROWS\_AS( expr, exceptionType ) INTERNAL\_CATCH\_THROWS\_AS( "{}CATCH\_REQUIRE\_THROWS\_AS"{}}, exceptionType, Catch::ResultDisposition::Normal, expr )}
\DoxyCodeLine{17585 \textcolor{preprocessor}{\#define CATCH\_REQUIRE\_THROWS\_WITH( expr, matcher ) INTERNAL\_CATCH\_THROWS\_STR\_MATCHES( "{}CATCH\_REQUIRE\_THROWS\_WITH"{}}, Catch::ResultDisposition::Normal, matcher, expr )}
\DoxyCodeLine{17586 \textcolor{preprocessor}{\#if !defined(CATCH\_CONFIG\_DISABLE\_MATCHERS)}}
\DoxyCodeLine{17587 \textcolor{preprocessor}{\#define CATCH\_REQUIRE\_THROWS\_MATCHES( expr, exceptionType, matcher ) INTERNAL\_CATCH\_THROWS\_MATCHES( "{}CATCH\_REQUIRE\_THROWS\_MATCHES"{}}, exceptionType, Catch::ResultDisposition::Normal, matcher, expr )}
\DoxyCodeLine{17588 \textcolor{preprocessor}{\#endif}\textcolor{comment}{// CATCH\_CONFIG\_DISABLE\_MATCHERS}}
\DoxyCodeLine{17589 \textcolor{preprocessor}{\#define CATCH\_REQUIRE\_NOTHROW( ... ) INTERNAL\_CATCH\_NO\_THROW( "{}CATCH\_REQUIRE\_NOTHROW"{}}, Catch::ResultDisposition::Normal, \_\_VA\_ARGS\_\_ )}
\DoxyCodeLine{17590 }
\DoxyCodeLine{17591 \textcolor{preprocessor}{\#define CATCH\_CHECK( ... ) INTERNAL\_CATCH\_TEST( "{}CATCH\_CHECK"{}}, Catch::ResultDisposition::ContinueOnFailure, \_\_VA\_ARGS\_\_ )}
\DoxyCodeLine{17592 \textcolor{preprocessor}{\#define CATCH\_CHECK\_FALSE( ... ) INTERNAL\_CATCH\_TEST( "{}CATCH\_CHECK\_FALSE"{}}, Catch::ResultDisposition::ContinueOnFailure | Catch::ResultDisposition::FalseTest, \_\_VA\_ARGS\_\_ )}
\DoxyCodeLine{17593 \textcolor{preprocessor}{\#define CATCH\_CHECKED\_IF( ... ) INTERNAL\_CATCH\_IF( "{}CATCH\_CHECKED\_IF"{}}, Catch::ResultDisposition::ContinueOnFailure, \_\_VA\_ARGS\_\_ )}
\DoxyCodeLine{17594 \textcolor{preprocessor}{\#define CATCH\_CHECKED\_ELSE( ... ) INTERNAL\_CATCH\_ELSE( "{}CATCH\_CHECKED\_ELSE"{}}, Catch::ResultDisposition::ContinueOnFailure, \_\_VA\_ARGS\_\_ )}
\DoxyCodeLine{17595 \textcolor{preprocessor}{\#define CATCH\_CHECK\_NOFAIL( ... ) INTERNAL\_CATCH\_TEST( "{}CATCH\_CHECK\_NOFAIL"{}}, Catch::ResultDisposition::ContinueOnFailure | Catch::ResultDisposition::SuppressFail, \_\_VA\_ARGS\_\_ )}
\DoxyCodeLine{17596 }
\DoxyCodeLine{17597 \textcolor{preprocessor}{\#define CATCH\_CHECK\_THROWS( ... )  INTERNAL\_CATCH\_THROWS( "{}CATCH\_CHECK\_THROWS"{}}, Catch::ResultDisposition::ContinueOnFailure, \_\_VA\_ARGS\_\_ )}
\DoxyCodeLine{17598 \textcolor{preprocessor}{\#define CATCH\_CHECK\_THROWS\_AS( expr, exceptionType ) INTERNAL\_CATCH\_THROWS\_AS( "{}CATCH\_CHECK\_THROWS\_AS"{}}, exceptionType, Catch::ResultDisposition::ContinueOnFailure, expr )}
\DoxyCodeLine{17599 \textcolor{preprocessor}{\#define CATCH\_CHECK\_THROWS\_WITH( expr, matcher ) INTERNAL\_CATCH\_THROWS\_STR\_MATCHES( "{}CATCH\_CHECK\_THROWS\_WITH"{}}, Catch::ResultDisposition::ContinueOnFailure, matcher, expr )}
\DoxyCodeLine{17600 \textcolor{preprocessor}{\#if !defined(CATCH\_CONFIG\_DISABLE\_MATCHERS)}}
\DoxyCodeLine{17601 \textcolor{preprocessor}{\#define CATCH\_CHECK\_THROWS\_MATCHES( expr, exceptionType, matcher ) INTERNAL\_CATCH\_THROWS\_MATCHES( "{}CATCH\_CHECK\_THROWS\_MATCHES"{}}, exceptionType, Catch::ResultDisposition::ContinueOnFailure, matcher, expr )}
\DoxyCodeLine{17602 \textcolor{preprocessor}{\#endif }\textcolor{comment}{// CATCH\_CONFIG\_DISABLE\_MATCHERS}}
\DoxyCodeLine{17603 \textcolor{preprocessor}{\#define CATCH\_CHECK\_NOTHROW( ... ) INTERNAL\_CATCH\_NO\_THROW( "{}CATCH\_CHECK\_NOTHROW"{}}, Catch::ResultDisposition::ContinueOnFailure, \_\_VA\_ARGS\_\_ )}
\DoxyCodeLine{17604 }
\DoxyCodeLine{17605 \textcolor{preprocessor}{\#if !defined(CATCH\_CONFIG\_DISABLE\_MATCHERS)}}
\DoxyCodeLine{17606 \textcolor{preprocessor}{\#define CATCH\_CHECK\_THAT( arg, matcher ) INTERNAL\_CHECK\_THAT( "{}CATCH\_CHECK\_THAT"{}}, matcher, Catch::ResultDisposition::ContinueOnFailure, arg )}
\DoxyCodeLine{17607 }
\DoxyCodeLine{17608 \textcolor{preprocessor}{\#define CATCH\_REQUIRE\_THAT( arg, matcher ) INTERNAL\_CHECK\_THAT( "{}CATCH\_REQUIRE\_THAT"{}}, matcher, Catch::ResultDisposition::Normal, arg )}
\DoxyCodeLine{17609 \textcolor{preprocessor}{\#endif }\textcolor{comment}{// CATCH\_CONFIG\_DISABLE\_MATCHERS}}
\DoxyCodeLine{17610 }
\DoxyCodeLine{17611 \textcolor{preprocessor}{\#define CATCH\_INFO( msg ) INTERNAL\_CATCH\_INFO( "{}CATCH\_INFO"{}}, msg )}
\DoxyCodeLine{17612 \textcolor{preprocessor}{\#define CATCH\_UNSCOPED\_INFO( msg ) INTERNAL\_CATCH\_UNSCOPED\_INFO( "{}CATCH\_UNSCOPED\_INFO"{}}, msg )}
\DoxyCodeLine{17613 \textcolor{preprocessor}{\#define CATCH\_WARN( msg ) INTERNAL\_CATCH\_MSG( "{}CATCH\_WARN"{}}, Catch::ResultWas::Warning, Catch::ResultDisposition::ContinueOnFailure, msg )}
\DoxyCodeLine{17614 \textcolor{preprocessor}{\#define CATCH\_CAPTURE( ... ) INTERNAL\_CATCH\_CAPTURE( INTERNAL\_CATCH\_UNIQUE\_NAME(capturer), "{}CATCH\_CAPTURE"{}},\_\_VA\_ARGS\_\_ )}
\DoxyCodeLine{17615 }
\DoxyCodeLine{17616 \textcolor{preprocessor}{\#define CATCH\_TEST\_CASE( ... ) INTERNAL\_CATCH\_TESTCASE( \_\_VA\_ARGS\_\_ )}}
\DoxyCodeLine{17617 \textcolor{preprocessor}{\#define CATCH\_TEST\_CASE\_METHOD( className, ... ) INTERNAL\_CATCH\_TEST\_CASE\_METHOD( className, \_\_VA\_ARGS\_\_ )}}
\DoxyCodeLine{17618 \textcolor{preprocessor}{\#define CATCH\_METHOD\_AS\_TEST\_CASE( method, ... ) INTERNAL\_CATCH\_METHOD\_AS\_TEST\_CASE( method, \_\_VA\_ARGS\_\_ )}}
\DoxyCodeLine{17619 \textcolor{preprocessor}{\#define CATCH\_REGISTER\_TEST\_CASE( Function, ... ) INTERNAL\_CATCH\_REGISTER\_TESTCASE( Function, \_\_VA\_ARGS\_\_ )}}
\DoxyCodeLine{17620 \textcolor{preprocessor}{\#define CATCH\_SECTION( ... ) INTERNAL\_CATCH\_SECTION( \_\_VA\_ARGS\_\_ )}}
\DoxyCodeLine{17621 \textcolor{preprocessor}{\#define CATCH\_DYNAMIC\_SECTION( ... ) INTERNAL\_CATCH\_DYNAMIC\_SECTION( \_\_VA\_ARGS\_\_ )}}
\DoxyCodeLine{17622 \textcolor{preprocessor}{\#define CATCH\_FAIL( ... ) INTERNAL\_CATCH\_MSG( "{}CATCH\_FAIL"{}}, Catch::ResultWas::ExplicitFailure, Catch::ResultDisposition::Normal, \_\_VA\_ARGS\_\_ )}
\DoxyCodeLine{17623 \textcolor{preprocessor}{\#define CATCH\_FAIL\_CHECK( ... ) INTERNAL\_CATCH\_MSG( "{}CATCH\_FAIL\_CHECK"{}}, Catch::ResultWas::ExplicitFailure, Catch::ResultDisposition::ContinueOnFailure, \_\_VA\_ARGS\_\_ )}
\DoxyCodeLine{17624 \textcolor{preprocessor}{\#define CATCH\_SUCCEED( ... ) INTERNAL\_CATCH\_MSG( "{}CATCH\_SUCCEED"{}}, Catch::ResultWas::Ok, Catch::ResultDisposition::ContinueOnFailure, \_\_VA\_ARGS\_\_ )}
\DoxyCodeLine{17625 }
\DoxyCodeLine{17626 \textcolor{preprocessor}{\#define CATCH\_ANON\_TEST\_CASE() INTERNAL\_CATCH\_TESTCASE()}}
\DoxyCodeLine{17627 }
\DoxyCodeLine{17628 \textcolor{preprocessor}{\#ifndef CATCH\_CONFIG\_TRADITIONAL\_MSVC\_PREPROCESSOR}}
\DoxyCodeLine{17629 \textcolor{preprocessor}{\#define CATCH\_TEMPLATE\_TEST\_CASE( ... ) INTERNAL\_CATCH\_TEMPLATE\_TEST\_CASE( \_\_VA\_ARGS\_\_ )}}
\DoxyCodeLine{17630 \textcolor{preprocessor}{\#define CATCH\_TEMPLATE\_TEST\_CASE\_SIG( ... ) INTERNAL\_CATCH\_TEMPLATE\_TEST\_CASE\_SIG( \_\_VA\_ARGS\_\_ )}}
\DoxyCodeLine{17631 \textcolor{preprocessor}{\#define CATCH\_TEMPLATE\_TEST\_CASE\_METHOD( className, ... ) INTERNAL\_CATCH\_TEMPLATE\_TEST\_CASE\_METHOD( className, \_\_VA\_ARGS\_\_ )}}
\DoxyCodeLine{17632 \textcolor{preprocessor}{\#define CATCH\_TEMPLATE\_TEST\_CASE\_METHOD\_SIG( className, ... ) INTERNAL\_CATCH\_TEMPLATE\_TEST\_CASE\_METHOD\_SIG( className, \_\_VA\_ARGS\_\_ )}}
\DoxyCodeLine{17633 \textcolor{preprocessor}{\#define CATCH\_TEMPLATE\_PRODUCT\_TEST\_CASE( ... ) INTERNAL\_CATCH\_TEMPLATE\_PRODUCT\_TEST\_CASE( \_\_VA\_ARGS\_\_ )}}
\DoxyCodeLine{17634 \textcolor{preprocessor}{\#define CATCH\_TEMPLATE\_PRODUCT\_TEST\_CASE\_SIG( ... ) INTERNAL\_CATCH\_TEMPLATE\_PRODUCT\_TEST\_CASE\_SIG( \_\_VA\_ARGS\_\_ )}}
\DoxyCodeLine{17635 \textcolor{preprocessor}{\#define CATCH\_TEMPLATE\_PRODUCT\_TEST\_CASE\_METHOD( className, ... ) INTERNAL\_CATCH\_TEMPLATE\_PRODUCT\_TEST\_CASE\_METHOD( className, \_\_VA\_ARGS\_\_ )}}
\DoxyCodeLine{17636 \textcolor{preprocessor}{\#define CATCH\_TEMPLATE\_PRODUCT\_TEST\_CASE\_METHOD\_SIG( className, ... ) INTERNAL\_CATCH\_TEMPLATE\_PRODUCT\_TEST\_CASE\_METHOD\_SIG( className, \_\_VA\_ARGS\_\_ )}}
\DoxyCodeLine{17637 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{17638 \textcolor{preprocessor}{\#define CATCH\_TEMPLATE\_TEST\_CASE( ... ) INTERNAL\_CATCH\_EXPAND\_VARGS( INTERNAL\_CATCH\_TEMPLATE\_TEST\_CASE( \_\_VA\_ARGS\_\_ ) )}}
\DoxyCodeLine{17639 \textcolor{preprocessor}{\#define CATCH\_TEMPLATE\_TEST\_CASE\_SIG( ... ) INTERNAL\_CATCH\_EXPAND\_VARGS( INTERNAL\_CATCH\_TEMPLATE\_TEST\_CASE\_SIG( \_\_VA\_ARGS\_\_ ) )}}
\DoxyCodeLine{17640 \textcolor{preprocessor}{\#define CATCH\_TEMPLATE\_TEST\_CASE\_METHOD( className, ... ) INTERNAL\_CATCH\_EXPAND\_VARGS( INTERNAL\_CATCH\_TEMPLATE\_TEST\_CASE\_METHOD( className, \_\_VA\_ARGS\_\_ ) )}}
\DoxyCodeLine{17641 \textcolor{preprocessor}{\#define CATCH\_TEMPLATE\_TEST\_CASE\_METHOD\_SIG( className, ... ) INTERNAL\_CATCH\_EXPAND\_VARGS( INTERNAL\_CATCH\_TEMPLATE\_TEST\_CASE\_METHOD\_SIG( className, \_\_VA\_ARGS\_\_ ) )}}
\DoxyCodeLine{17642 \textcolor{preprocessor}{\#define CATCH\_TEMPLATE\_PRODUCT\_TEST\_CASE( ... ) INTERNAL\_CATCH\_EXPAND\_VARGS( INTERNAL\_CATCH\_TEMPLATE\_PRODUCT\_TEST\_CASE( \_\_VA\_ARGS\_\_ ) )}}
\DoxyCodeLine{17643 \textcolor{preprocessor}{\#define CATCH\_TEMPLATE\_PRODUCT\_TEST\_CASE\_SIG( ... ) INTERNAL\_CATCH\_EXPAND\_VARGS( INTERNAL\_CATCH\_TEMPLATE\_PRODUCT\_TEST\_CASE\_SIG( \_\_VA\_ARGS\_\_ ) )}}
\DoxyCodeLine{17644 \textcolor{preprocessor}{\#define CATCH\_TEMPLATE\_PRODUCT\_TEST\_CASE\_METHOD( className, ... ) INTERNAL\_CATCH\_EXPAND\_VARGS( INTERNAL\_CATCH\_TEMPLATE\_PRODUCT\_TEST\_CASE\_METHOD( className, \_\_VA\_ARGS\_\_ ) )}}
\DoxyCodeLine{17645 \textcolor{preprocessor}{\#define CATCH\_TEMPLATE\_PRODUCT\_TEST\_CASE\_METHOD\_SIG( className, ... ) INTERNAL\_CATCH\_EXPAND\_VARGS( INTERNAL\_CATCH\_TEMPLATE\_PRODUCT\_TEST\_CASE\_METHOD\_SIG( className, \_\_VA\_ARGS\_\_ ) )}}
\DoxyCodeLine{17646 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{17647 }
\DoxyCodeLine{17648 \textcolor{preprocessor}{\#if !defined(CATCH\_CONFIG\_RUNTIME\_STATIC\_REQUIRE)}}
\DoxyCodeLine{17649 \textcolor{preprocessor}{\#define CATCH\_STATIC\_REQUIRE( ... )       static\_assert(   \_\_VA\_ARGS\_\_ ,      \#\_\_VA\_ARGS\_\_ );     CATCH\_SUCCEED( \#\_\_VA\_ARGS\_\_ )}}
\DoxyCodeLine{17650 \textcolor{preprocessor}{\#define CATCH\_STATIC\_REQUIRE\_FALSE( ... ) static\_assert( !(\_\_VA\_ARGS\_\_), "{}!("{}} \#\_\_VA\_ARGS\_\_ "{})"{} ); CATCH\_SUCCEED( \#\_\_VA\_ARGS\_\_ )}
\DoxyCodeLine{17651 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{17652 \textcolor{preprocessor}{\#define CATCH\_STATIC\_REQUIRE( ... )       CATCH\_REQUIRE( \_\_VA\_ARGS\_\_ )}}
\DoxyCodeLine{17653 \textcolor{preprocessor}{\#define CATCH\_STATIC\_REQUIRE\_FALSE( ... ) CATCH\_REQUIRE\_FALSE( \_\_VA\_ARGS\_\_ )}}
\DoxyCodeLine{17654 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{17655 }
\DoxyCodeLine{17656 \textcolor{comment}{// "{}BDD-\/style"{} convenience wrappers}}
\DoxyCodeLine{17657 \textcolor{preprocessor}{\#define CATCH\_SCENARIO( ... ) CATCH\_TEST\_CASE( "{}Scenario: "{}} \_\_VA\_ARGS\_\_ )}
\DoxyCodeLine{17658 \textcolor{preprocessor}{\#define CATCH\_SCENARIO\_METHOD( className, ... ) INTERNAL\_CATCH\_TEST\_CASE\_METHOD( className, "{}Scenario: "{}} \_\_VA\_ARGS\_\_ )}
\DoxyCodeLine{17659 \textcolor{preprocessor}{\#define CATCH\_GIVEN( desc )     INTERNAL\_CATCH\_DYNAMIC\_SECTION( "{}    Given: "{}} << desc )}
\DoxyCodeLine{17660 \textcolor{preprocessor}{\#define CATCH\_AND\_GIVEN( desc ) INTERNAL\_CATCH\_DYNAMIC\_SECTION( "{}And given: "{}} << desc )}
\DoxyCodeLine{17661 \textcolor{preprocessor}{\#define CATCH\_WHEN( desc )      INTERNAL\_CATCH\_DYNAMIC\_SECTION( "{}     When: "{}} << desc )}
\DoxyCodeLine{17662 \textcolor{preprocessor}{\#define CATCH\_AND\_WHEN( desc )  INTERNAL\_CATCH\_DYNAMIC\_SECTION( "{} And when: "{}} << desc )}
\DoxyCodeLine{17663 \textcolor{preprocessor}{\#define CATCH\_THEN( desc )      INTERNAL\_CATCH\_DYNAMIC\_SECTION( "{}     Then: "{}} << desc )}
\DoxyCodeLine{17664 \textcolor{preprocessor}{\#define CATCH\_AND\_THEN( desc )  INTERNAL\_CATCH\_DYNAMIC\_SECTION( "{}      And: "{}} << desc )}
\DoxyCodeLine{17665 }
\DoxyCodeLine{17666 \textcolor{preprocessor}{\#if defined(CATCH\_CONFIG\_ENABLE\_BENCHMARKING)}}
\DoxyCodeLine{17667 \textcolor{preprocessor}{\#define CATCH\_BENCHMARK(...) \(\backslash\)}}
\DoxyCodeLine{17668 \textcolor{preprocessor}{    INTERNAL\_CATCH\_BENCHMARK(INTERNAL\_CATCH\_UNIQUE\_NAME(C\_A\_T\_C\_H\_B\_E\_N\_C\_H\_), INTERNAL\_CATCH\_GET\_1\_ARG(\_\_VA\_ARGS\_\_,,), INTERNAL\_CATCH\_GET\_2\_ARG(\_\_VA\_ARGS\_\_,,))}}
\DoxyCodeLine{17669 \textcolor{preprocessor}{\#define CATCH\_BENCHMARK\_ADVANCED(name) \(\backslash\)}}
\DoxyCodeLine{17670 \textcolor{preprocessor}{    INTERNAL\_CATCH\_BENCHMARK\_ADVANCED(INTERNAL\_CATCH\_UNIQUE\_NAME(C\_A\_T\_C\_H\_B\_E\_N\_C\_H\_), name)}}
\DoxyCodeLine{17671 \textcolor{preprocessor}{\#endif }\textcolor{comment}{// CATCH\_CONFIG\_ENABLE\_BENCHMARKING}}
\DoxyCodeLine{17672 }
\DoxyCodeLine{17673 \textcolor{comment}{// If CATCH\_CONFIG\_PREFIX\_ALL is not defined then the CATCH\_ prefix is not required}}
\DoxyCodeLine{17674 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{17675 }
\DoxyCodeLine{17676 \textcolor{preprocessor}{\#define REQUIRE( ... ) INTERNAL\_CATCH\_TEST( "{}REQUIRE"{}}, Catch::ResultDisposition::Normal, \_\_VA\_ARGS\_\_  )}
\DoxyCodeLine{17677 \textcolor{preprocessor}{\#define REQUIRE\_FALSE( ... ) INTERNAL\_CATCH\_TEST( "{}REQUIRE\_FALSE"{}}, Catch::ResultDisposition::Normal | Catch::ResultDisposition::FalseTest, \_\_VA\_ARGS\_\_ )}
\DoxyCodeLine{17678 }
\DoxyCodeLine{17679 \textcolor{preprocessor}{\#define REQUIRE\_THROWS( ... ) INTERNAL\_CATCH\_THROWS( "{}REQUIRE\_THROWS"{}}, Catch::ResultDisposition::Normal, \_\_VA\_ARGS\_\_ )}
\DoxyCodeLine{17680 \textcolor{preprocessor}{\#define REQUIRE\_THROWS\_AS( expr, exceptionType ) INTERNAL\_CATCH\_THROWS\_AS( "{}REQUIRE\_THROWS\_AS"{}}, exceptionType, Catch::ResultDisposition::Normal, expr )}
\DoxyCodeLine{17681 \textcolor{preprocessor}{\#define REQUIRE\_THROWS\_WITH( expr, matcher ) INTERNAL\_CATCH\_THROWS\_STR\_MATCHES( "{}REQUIRE\_THROWS\_WITH"{}}, Catch::ResultDisposition::Normal, matcher, expr )}
\DoxyCodeLine{17682 \textcolor{preprocessor}{\#if !defined(CATCH\_CONFIG\_DISABLE\_MATCHERS)}}
\DoxyCodeLine{17683 \textcolor{preprocessor}{\#define REQUIRE\_THROWS\_MATCHES( expr, exceptionType, matcher ) INTERNAL\_CATCH\_THROWS\_MATCHES( "{}REQUIRE\_THROWS\_MATCHES"{}}, exceptionType, Catch::ResultDisposition::Normal, matcher, expr )}
\DoxyCodeLine{17684 \textcolor{preprocessor}{\#endif }\textcolor{comment}{// CATCH\_CONFIG\_DISABLE\_MATCHERS}}
\DoxyCodeLine{17685 \textcolor{preprocessor}{\#define REQUIRE\_NOTHROW( ... ) INTERNAL\_CATCH\_NO\_THROW( "{}REQUIRE\_NOTHROW"{}}, Catch::ResultDisposition::Normal, \_\_VA\_ARGS\_\_ )}
\DoxyCodeLine{17686 }
\DoxyCodeLine{17687 \textcolor{preprocessor}{\#define CHECK( ... ) INTERNAL\_CATCH\_TEST( "{}CHECK"{}}, Catch::ResultDisposition::ContinueOnFailure, \_\_VA\_ARGS\_\_ )}
\DoxyCodeLine{17688 \textcolor{preprocessor}{\#define CHECK\_FALSE( ... ) INTERNAL\_CATCH\_TEST( "{}CHECK\_FALSE"{}}, Catch::ResultDisposition::ContinueOnFailure | Catch::ResultDisposition::FalseTest, \_\_VA\_ARGS\_\_ )}
\DoxyCodeLine{17689 \textcolor{preprocessor}{\#define CHECKED\_IF( ... ) INTERNAL\_CATCH\_IF( "{}CHECKED\_IF"{}}, Catch::ResultDisposition::ContinueOnFailure, \_\_VA\_ARGS\_\_ )}
\DoxyCodeLine{17690 \textcolor{preprocessor}{\#define CHECKED\_ELSE( ... ) INTERNAL\_CATCH\_ELSE( "{}CHECKED\_ELSE"{}}, Catch::ResultDisposition::ContinueOnFailure, \_\_VA\_ARGS\_\_ )}
\DoxyCodeLine{17691 \textcolor{preprocessor}{\#define CHECK\_NOFAIL( ... ) INTERNAL\_CATCH\_TEST( "{}CHECK\_NOFAIL"{}}, Catch::ResultDisposition::ContinueOnFailure | Catch::ResultDisposition::SuppressFail, \_\_VA\_ARGS\_\_ )}
\DoxyCodeLine{17692 }
\DoxyCodeLine{17693 \textcolor{preprocessor}{\#define CHECK\_THROWS( ... )  INTERNAL\_CATCH\_THROWS( "{}CHECK\_THROWS"{}}, Catch::ResultDisposition::ContinueOnFailure, \_\_VA\_ARGS\_\_ )}
\DoxyCodeLine{17694 \textcolor{preprocessor}{\#define CHECK\_THROWS\_AS( expr, exceptionType ) INTERNAL\_CATCH\_THROWS\_AS( "{}CHECK\_THROWS\_AS"{}}, exceptionType, Catch::ResultDisposition::ContinueOnFailure, expr )}
\DoxyCodeLine{17695 \textcolor{preprocessor}{\#define CHECK\_THROWS\_WITH( expr, matcher ) INTERNAL\_CATCH\_THROWS\_STR\_MATCHES( "{}CHECK\_THROWS\_WITH"{}}, Catch::ResultDisposition::ContinueOnFailure, matcher, expr )}
\DoxyCodeLine{17696 \textcolor{preprocessor}{\#if !defined(CATCH\_CONFIG\_DISABLE\_MATCHERS)}}
\DoxyCodeLine{17697 \textcolor{preprocessor}{\#define CHECK\_THROWS\_MATCHES( expr, exceptionType, matcher ) INTERNAL\_CATCH\_THROWS\_MATCHES( "{}CHECK\_THROWS\_MATCHES"{}}, exceptionType, Catch::ResultDisposition::ContinueOnFailure, matcher, expr )}
\DoxyCodeLine{17698 \textcolor{preprocessor}{\#endif }\textcolor{comment}{// CATCH\_CONFIG\_DISABLE\_MATCHERS}}
\DoxyCodeLine{17699 \textcolor{preprocessor}{\#define CHECK\_NOTHROW( ... ) INTERNAL\_CATCH\_NO\_THROW( "{}CHECK\_NOTHROW"{}}, Catch::ResultDisposition::ContinueOnFailure, \_\_VA\_ARGS\_\_ )}
\DoxyCodeLine{17700 }
\DoxyCodeLine{17701 \textcolor{preprocessor}{\#if !defined(CATCH\_CONFIG\_DISABLE\_MATCHERS)}}
\DoxyCodeLine{17702 \textcolor{preprocessor}{\#define CHECK\_THAT( arg, matcher ) INTERNAL\_CHECK\_THAT( "{}CHECK\_THAT"{}}, matcher, Catch::ResultDisposition::ContinueOnFailure, arg )}
\DoxyCodeLine{17703 }
\DoxyCodeLine{17704 \textcolor{preprocessor}{\#define REQUIRE\_THAT( arg, matcher ) INTERNAL\_CHECK\_THAT( "{}REQUIRE\_THAT"{}}, matcher, Catch::ResultDisposition::Normal, arg )}
\DoxyCodeLine{17705 \textcolor{preprocessor}{\#endif }\textcolor{comment}{// CATCH\_CONFIG\_DISABLE\_MATCHERS}}
\DoxyCodeLine{17706 }
\DoxyCodeLine{17707 \textcolor{preprocessor}{\#define INFO( msg ) INTERNAL\_CATCH\_INFO( "{}INFO"{}}, msg )}
\DoxyCodeLine{17708 \textcolor{preprocessor}{\#define UNSCOPED\_INFO( msg ) INTERNAL\_CATCH\_UNSCOPED\_INFO( "{}UNSCOPED\_INFO"{}}, msg )}
\DoxyCodeLine{17709 \textcolor{preprocessor}{\#define WARN( msg ) INTERNAL\_CATCH\_MSG( "{}WARN"{}}, Catch::ResultWas::Warning, Catch::ResultDisposition::ContinueOnFailure, msg )}
\DoxyCodeLine{17710 \textcolor{preprocessor}{\#define CAPTURE( ... ) INTERNAL\_CATCH\_CAPTURE( INTERNAL\_CATCH\_UNIQUE\_NAME(capturer), "{}CAPTURE"{}},\_\_VA\_ARGS\_\_ )}
\DoxyCodeLine{17711 }
\DoxyCodeLine{17712 \textcolor{preprocessor}{\#define TEST\_CASE( ... ) INTERNAL\_CATCH\_TESTCASE( \_\_VA\_ARGS\_\_ )}}
\DoxyCodeLine{17713 \textcolor{preprocessor}{\#define TEST\_CASE\_METHOD( className, ... ) INTERNAL\_CATCH\_TEST\_CASE\_METHOD( className, \_\_VA\_ARGS\_\_ )}}
\DoxyCodeLine{17714 \textcolor{preprocessor}{\#define METHOD\_AS\_TEST\_CASE( method, ... ) INTERNAL\_CATCH\_METHOD\_AS\_TEST\_CASE( method, \_\_VA\_ARGS\_\_ )}}
\DoxyCodeLine{17715 \textcolor{preprocessor}{\#define REGISTER\_TEST\_CASE( Function, ... ) INTERNAL\_CATCH\_REGISTER\_TESTCASE( Function, \_\_VA\_ARGS\_\_ )}}
\DoxyCodeLine{17716 \textcolor{preprocessor}{\#define SECTION( ... ) INTERNAL\_CATCH\_SECTION( \_\_VA\_ARGS\_\_ )}}
\DoxyCodeLine{17717 \textcolor{preprocessor}{\#define DYNAMIC\_SECTION( ... ) INTERNAL\_CATCH\_DYNAMIC\_SECTION( \_\_VA\_ARGS\_\_ )}}
\DoxyCodeLine{17718 \textcolor{preprocessor}{\#define FAIL( ... ) INTERNAL\_CATCH\_MSG( "{}FAIL"{}}, Catch::ResultWas::ExplicitFailure, Catch::ResultDisposition::Normal, \_\_VA\_ARGS\_\_ )}
\DoxyCodeLine{17719 \textcolor{preprocessor}{\#define FAIL\_CHECK( ... ) INTERNAL\_CATCH\_MSG( "{}FAIL\_CHECK"{}}, Catch::ResultWas::ExplicitFailure, Catch::ResultDisposition::ContinueOnFailure, \_\_VA\_ARGS\_\_ )}
\DoxyCodeLine{17720 \textcolor{preprocessor}{\#define SUCCEED( ... ) INTERNAL\_CATCH\_MSG( "{}SUCCEED"{}}, Catch::ResultWas::Ok, Catch::ResultDisposition::ContinueOnFailure, \_\_VA\_ARGS\_\_ )}
\DoxyCodeLine{17721 \textcolor{preprocessor}{\#define ANON\_TEST\_CASE() INTERNAL\_CATCH\_TESTCASE()}}
\DoxyCodeLine{17722 }
\DoxyCodeLine{17723 \textcolor{preprocessor}{\#ifndef CATCH\_CONFIG\_TRADITIONAL\_MSVC\_PREPROCESSOR}}
\DoxyCodeLine{17724 \textcolor{preprocessor}{\#define TEMPLATE\_TEST\_CASE( ... ) INTERNAL\_CATCH\_TEMPLATE\_TEST\_CASE( \_\_VA\_ARGS\_\_ )}}
\DoxyCodeLine{17725 \textcolor{preprocessor}{\#define TEMPLATE\_TEST\_CASE\_SIG( ... ) INTERNAL\_CATCH\_TEMPLATE\_TEST\_CASE\_SIG( \_\_VA\_ARGS\_\_ )}}
\DoxyCodeLine{17726 \textcolor{preprocessor}{\#define TEMPLATE\_TEST\_CASE\_METHOD( className, ... ) INTERNAL\_CATCH\_TEMPLATE\_TEST\_CASE\_METHOD( className, \_\_VA\_ARGS\_\_ )}}
\DoxyCodeLine{17727 \textcolor{preprocessor}{\#define TEMPLATE\_TEST\_CASE\_METHOD\_SIG( className, ... ) INTERNAL\_CATCH\_TEMPLATE\_TEST\_CASE\_METHOD\_SIG( className, \_\_VA\_ARGS\_\_ )}}
\DoxyCodeLine{17728 \textcolor{preprocessor}{\#define TEMPLATE\_PRODUCT\_TEST\_CASE( ... ) INTERNAL\_CATCH\_TEMPLATE\_PRODUCT\_TEST\_CASE( \_\_VA\_ARGS\_\_ )}}
\DoxyCodeLine{17729 \textcolor{preprocessor}{\#define TEMPLATE\_PRODUCT\_TEST\_CASE\_SIG( ... ) INTERNAL\_CATCH\_TEMPLATE\_PRODUCT\_TEST\_CASE\_SIG( \_\_VA\_ARGS\_\_ )}}
\DoxyCodeLine{17730 \textcolor{preprocessor}{\#define TEMPLATE\_PRODUCT\_TEST\_CASE\_METHOD( className, ... ) INTERNAL\_CATCH\_TEMPLATE\_PRODUCT\_TEST\_CASE\_METHOD( className, \_\_VA\_ARGS\_\_ )}}
\DoxyCodeLine{17731 \textcolor{preprocessor}{\#define TEMPLATE\_PRODUCT\_TEST\_CASE\_METHOD\_SIG( className, ... ) INTERNAL\_CATCH\_TEMPLATE\_PRODUCT\_TEST\_CASE\_METHOD\_SIG( className, \_\_VA\_ARGS\_\_ )}}
\DoxyCodeLine{17732 \textcolor{preprocessor}{\#define TEMPLATE\_LIST\_TEST\_CASE( ... ) INTERNAL\_CATCH\_TEMPLATE\_LIST\_TEST\_CASE(\_\_VA\_ARGS\_\_)}}
\DoxyCodeLine{17733 \textcolor{preprocessor}{\#define TEMPLATE\_LIST\_TEST\_CASE\_METHOD( className, ... ) INTERNAL\_CATCH\_TEMPLATE\_LIST\_TEST\_CASE\_METHOD( className, \_\_VA\_ARGS\_\_ )}}
\DoxyCodeLine{17734 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{17735 \textcolor{preprocessor}{\#define TEMPLATE\_TEST\_CASE( ... ) INTERNAL\_CATCH\_EXPAND\_VARGS( INTERNAL\_CATCH\_TEMPLATE\_TEST\_CASE( \_\_VA\_ARGS\_\_ ) )}}
\DoxyCodeLine{17736 \textcolor{preprocessor}{\#define TEMPLATE\_TEST\_CASE\_SIG( ... ) INTERNAL\_CATCH\_EXPAND\_VARGS( INTERNAL\_CATCH\_TEMPLATE\_TEST\_CASE\_SIG( \_\_VA\_ARGS\_\_ ) )}}
\DoxyCodeLine{17737 \textcolor{preprocessor}{\#define TEMPLATE\_TEST\_CASE\_METHOD( className, ... ) INTERNAL\_CATCH\_EXPAND\_VARGS( INTERNAL\_CATCH\_TEMPLATE\_TEST\_CASE\_METHOD( className, \_\_VA\_ARGS\_\_ ) )}}
\DoxyCodeLine{17738 \textcolor{preprocessor}{\#define TEMPLATE\_TEST\_CASE\_METHOD\_SIG( className, ... ) INTERNAL\_CATCH\_EXPAND\_VARGS( INTERNAL\_CATCH\_TEMPLATE\_TEST\_CASE\_METHOD\_SIG( className, \_\_VA\_ARGS\_\_ ) )}}
\DoxyCodeLine{17739 \textcolor{preprocessor}{\#define TEMPLATE\_PRODUCT\_TEST\_CASE( ... ) INTERNAL\_CATCH\_EXPAND\_VARGS( INTERNAL\_CATCH\_TEMPLATE\_PRODUCT\_TEST\_CASE( \_\_VA\_ARGS\_\_ ) )}}
\DoxyCodeLine{17740 \textcolor{preprocessor}{\#define TEMPLATE\_PRODUCT\_TEST\_CASE\_SIG( ... ) INTERNAL\_CATCH\_EXPAND\_VARGS( INTERNAL\_CATCH\_TEMPLATE\_PRODUCT\_TEST\_CASE\_SIG( \_\_VA\_ARGS\_\_ ) )}}
\DoxyCodeLine{17741 \textcolor{preprocessor}{\#define TEMPLATE\_PRODUCT\_TEST\_CASE\_METHOD( className, ... ) INTERNAL\_CATCH\_EXPAND\_VARGS( INTERNAL\_CATCH\_TEMPLATE\_PRODUCT\_TEST\_CASE\_METHOD( className, \_\_VA\_ARGS\_\_ ) )}}
\DoxyCodeLine{17742 \textcolor{preprocessor}{\#define TEMPLATE\_PRODUCT\_TEST\_CASE\_METHOD\_SIG( className, ... ) INTERNAL\_CATCH\_EXPAND\_VARGS( INTERNAL\_CATCH\_TEMPLATE\_PRODUCT\_TEST\_CASE\_METHOD\_SIG( className, \_\_VA\_ARGS\_\_ ) )}}
\DoxyCodeLine{17743 \textcolor{preprocessor}{\#define TEMPLATE\_LIST\_TEST\_CASE( ... ) INTERNAL\_CATCH\_EXPAND\_VARGS( INTERNAL\_CATCH\_TEMPLATE\_LIST\_TEST\_CASE( \_\_VA\_ARGS\_\_ ) )}}
\DoxyCodeLine{17744 \textcolor{preprocessor}{\#define TEMPLATE\_LIST\_TEST\_CASE\_METHOD( className, ... ) INTERNAL\_CATCH\_EXPAND\_VARGS( INTERNAL\_CATCH\_TEMPLATE\_LIST\_TEST\_CASE\_METHOD( className, \_\_VA\_ARGS\_\_ ) )}}
\DoxyCodeLine{17745 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{17746 }
\DoxyCodeLine{17747 \textcolor{preprocessor}{\#if !defined(CATCH\_CONFIG\_RUNTIME\_STATIC\_REQUIRE)}}
\DoxyCodeLine{17748 \textcolor{preprocessor}{\#define STATIC\_REQUIRE( ... )       static\_assert(   \_\_VA\_ARGS\_\_,  \#\_\_VA\_ARGS\_\_ ); SUCCEED( \#\_\_VA\_ARGS\_\_ )}}
\DoxyCodeLine{17749 \textcolor{preprocessor}{\#define STATIC\_REQUIRE\_FALSE( ... ) static\_assert( !(\_\_VA\_ARGS\_\_), "{}!("{}} \#\_\_VA\_ARGS\_\_ "{})"{} ); SUCCEED( "{}!("{} \#\_\_VA\_ARGS\_\_ "{})"{} )}
\DoxyCodeLine{17750 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{17751 \textcolor{preprocessor}{\#define STATIC\_REQUIRE( ... )       REQUIRE( \_\_VA\_ARGS\_\_ )}}
\DoxyCodeLine{17752 \textcolor{preprocessor}{\#define STATIC\_REQUIRE\_FALSE( ... ) REQUIRE\_FALSE( \_\_VA\_ARGS\_\_ )}}
\DoxyCodeLine{17753 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{17754 }
\DoxyCodeLine{17755 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{17756 }
\DoxyCodeLine{17757 \textcolor{preprocessor}{\#define CATCH\_TRANSLATE\_EXCEPTION( signature ) INTERNAL\_CATCH\_TRANSLATE\_EXCEPTION( signature )}}
\DoxyCodeLine{17758 }
\DoxyCodeLine{17759 \textcolor{comment}{// "{}BDD-\/style"{} convenience wrappers}}
\DoxyCodeLine{17760 \textcolor{preprocessor}{\#define SCENARIO( ... ) TEST\_CASE( "{}Scenario: "{}} \_\_VA\_ARGS\_\_ )}
\DoxyCodeLine{17761 \textcolor{preprocessor}{\#define SCENARIO\_METHOD( className, ... ) INTERNAL\_CATCH\_TEST\_CASE\_METHOD( className, "{}Scenario: "{}} \_\_VA\_ARGS\_\_ )}
\DoxyCodeLine{17762 }
\DoxyCodeLine{17763 \textcolor{preprocessor}{\#define GIVEN( desc )     INTERNAL\_CATCH\_DYNAMIC\_SECTION( "{}    Given: "{}} << desc )}
\DoxyCodeLine{17764 \textcolor{preprocessor}{\#define AND\_GIVEN( desc ) INTERNAL\_CATCH\_DYNAMIC\_SECTION( "{}And given: "{}} << desc )}
\DoxyCodeLine{17765 \textcolor{preprocessor}{\#define WHEN( desc )      INTERNAL\_CATCH\_DYNAMIC\_SECTION( "{}     When: "{}} << desc )}
\DoxyCodeLine{17766 \textcolor{preprocessor}{\#define AND\_WHEN( desc )  INTERNAL\_CATCH\_DYNAMIC\_SECTION( "{} And when: "{}} << desc )}
\DoxyCodeLine{17767 \textcolor{preprocessor}{\#define THEN( desc )      INTERNAL\_CATCH\_DYNAMIC\_SECTION( "{}     Then: "{}} << desc )}
\DoxyCodeLine{17768 \textcolor{preprocessor}{\#define AND\_THEN( desc )  INTERNAL\_CATCH\_DYNAMIC\_SECTION( "{}      And: "{}} << desc )}
\DoxyCodeLine{17769 }
\DoxyCodeLine{17770 \textcolor{preprocessor}{\#if defined(CATCH\_CONFIG\_ENABLE\_BENCHMARKING)}}
\DoxyCodeLine{17771 \textcolor{preprocessor}{\#define BENCHMARK(...) \(\backslash\)}}
\DoxyCodeLine{17772 \textcolor{preprocessor}{    INTERNAL\_CATCH\_BENCHMARK(INTERNAL\_CATCH\_UNIQUE\_NAME(C\_A\_T\_C\_H\_B\_E\_N\_C\_H\_), INTERNAL\_CATCH\_GET\_1\_ARG(\_\_VA\_ARGS\_\_,,), INTERNAL\_CATCH\_GET\_2\_ARG(\_\_VA\_ARGS\_\_,,))}}
\DoxyCodeLine{17773 \textcolor{preprocessor}{\#define BENCHMARK\_ADVANCED(name) \(\backslash\)}}
\DoxyCodeLine{17774 \textcolor{preprocessor}{    INTERNAL\_CATCH\_BENCHMARK\_ADVANCED(INTERNAL\_CATCH\_UNIQUE\_NAME(C\_A\_T\_C\_H\_B\_E\_N\_C\_H\_), name)}}
\DoxyCodeLine{17775 \textcolor{preprocessor}{\#endif }\textcolor{comment}{// CATCH\_CONFIG\_ENABLE\_BENCHMARKING}}
\DoxyCodeLine{17776 }
\DoxyCodeLine{17777 \textcolor{keyword}{using }\mbox{\hyperlink{classCatch_1_1Detail_1_1Approx}{Catch::Detail::Approx}};}
\DoxyCodeLine{17778 }
\DoxyCodeLine{17779 \textcolor{preprocessor}{\#else }\textcolor{comment}{// CATCH\_CONFIG\_DISABLE}}
\DoxyCodeLine{17780 }
\DoxyCodeLine{17782 \textcolor{comment}{// If this config identifier is defined then all CATCH macros are prefixed with CATCH\_}}
\DoxyCodeLine{17783 \textcolor{preprocessor}{\#ifdef CATCH\_CONFIG\_PREFIX\_ALL}}
\DoxyCodeLine{17784 }
\DoxyCodeLine{17785 \textcolor{preprocessor}{\#define CATCH\_REQUIRE( ... )        (void)(0)}}
\DoxyCodeLine{17786 \textcolor{preprocessor}{\#define CATCH\_REQUIRE\_FALSE( ... )  (void)(0)}}
\DoxyCodeLine{17787 }
\DoxyCodeLine{17788 \textcolor{preprocessor}{\#define CATCH\_REQUIRE\_THROWS( ... ) (void)(0)}}
\DoxyCodeLine{17789 \textcolor{preprocessor}{\#define CATCH\_REQUIRE\_THROWS\_AS( expr, exceptionType ) (void)(0)}}
\DoxyCodeLine{17790 \textcolor{preprocessor}{\#define CATCH\_REQUIRE\_THROWS\_WITH( expr, matcher )     (void)(0)}}
\DoxyCodeLine{17791 \textcolor{preprocessor}{\#if !defined(CATCH\_CONFIG\_DISABLE\_MATCHERS)}}
\DoxyCodeLine{17792 \textcolor{preprocessor}{\#define CATCH\_REQUIRE\_THROWS\_MATCHES( expr, exceptionType, matcher ) (void)(0)}}
\DoxyCodeLine{17793 \textcolor{preprocessor}{\#endif}\textcolor{comment}{// CATCH\_CONFIG\_DISABLE\_MATCHERS}}
\DoxyCodeLine{17794 \textcolor{preprocessor}{\#define CATCH\_REQUIRE\_NOTHROW( ... ) (void)(0)}}
\DoxyCodeLine{17795 }
\DoxyCodeLine{17796 \textcolor{preprocessor}{\#define CATCH\_CHECK( ... )         (void)(0)}}
\DoxyCodeLine{17797 \textcolor{preprocessor}{\#define CATCH\_CHECK\_FALSE( ... )   (void)(0)}}
\DoxyCodeLine{17798 \textcolor{preprocessor}{\#define CATCH\_CHECKED\_IF( ... )    if (\_\_VA\_ARGS\_\_)}}
\DoxyCodeLine{17799 \textcolor{preprocessor}{\#define CATCH\_CHECKED\_ELSE( ... )  if (!(\_\_VA\_ARGS\_\_))}}
\DoxyCodeLine{17800 \textcolor{preprocessor}{\#define CATCH\_CHECK\_NOFAIL( ... )  (void)(0)}}
\DoxyCodeLine{17801 }
\DoxyCodeLine{17802 \textcolor{preprocessor}{\#define CATCH\_CHECK\_THROWS( ... )  (void)(0)}}
\DoxyCodeLine{17803 \textcolor{preprocessor}{\#define CATCH\_CHECK\_THROWS\_AS( expr, exceptionType ) (void)(0)}}
\DoxyCodeLine{17804 \textcolor{preprocessor}{\#define CATCH\_CHECK\_THROWS\_WITH( expr, matcher )     (void)(0)}}
\DoxyCodeLine{17805 \textcolor{preprocessor}{\#if !defined(CATCH\_CONFIG\_DISABLE\_MATCHERS)}}
\DoxyCodeLine{17806 \textcolor{preprocessor}{\#define CATCH\_CHECK\_THROWS\_MATCHES( expr, exceptionType, matcher ) (void)(0)}}
\DoxyCodeLine{17807 \textcolor{preprocessor}{\#endif }\textcolor{comment}{// CATCH\_CONFIG\_DISABLE\_MATCHERS}}
\DoxyCodeLine{17808 \textcolor{preprocessor}{\#define CATCH\_CHECK\_NOTHROW( ... ) (void)(0)}}
\DoxyCodeLine{17809 }
\DoxyCodeLine{17810 \textcolor{preprocessor}{\#if !defined(CATCH\_CONFIG\_DISABLE\_MATCHERS)}}
\DoxyCodeLine{17811 \textcolor{preprocessor}{\#define CATCH\_CHECK\_THAT( arg, matcher )   (void)(0)}}
\DoxyCodeLine{17812 }
\DoxyCodeLine{17813 \textcolor{preprocessor}{\#define CATCH\_REQUIRE\_THAT( arg, matcher ) (void)(0)}}
\DoxyCodeLine{17814 \textcolor{preprocessor}{\#endif }\textcolor{comment}{// CATCH\_CONFIG\_DISABLE\_MATCHERS}}
\DoxyCodeLine{17815 }
\DoxyCodeLine{17816 \textcolor{preprocessor}{\#define CATCH\_INFO( msg )          (void)(0)}}
\DoxyCodeLine{17817 \textcolor{preprocessor}{\#define CATCH\_UNSCOPED\_INFO( msg ) (void)(0)}}
\DoxyCodeLine{17818 \textcolor{preprocessor}{\#define CATCH\_WARN( msg )          (void)(0)}}
\DoxyCodeLine{17819 \textcolor{preprocessor}{\#define CATCH\_CAPTURE( msg )       (void)(0)}}
\DoxyCodeLine{17820 }
\DoxyCodeLine{17821 \textcolor{preprocessor}{\#define CATCH\_TEST\_CASE( ... ) INTERNAL\_CATCH\_TESTCASE\_NO\_REGISTRATION(INTERNAL\_CATCH\_UNIQUE\_NAME( C\_A\_T\_C\_H\_T\_E\_S\_T\_ ))}}
\DoxyCodeLine{17822 \textcolor{preprocessor}{\#define CATCH\_TEST\_CASE\_METHOD( className, ... ) INTERNAL\_CATCH\_TESTCASE\_NO\_REGISTRATION(INTERNAL\_CATCH\_UNIQUE\_NAME( C\_A\_T\_C\_H\_T\_E\_S\_T\_ ))}}
\DoxyCodeLine{17823 \textcolor{preprocessor}{\#define CATCH\_METHOD\_AS\_TEST\_CASE( method, ... )}}
\DoxyCodeLine{17824 \textcolor{preprocessor}{\#define CATCH\_REGISTER\_TEST\_CASE( Function, ... ) (void)(0)}}
\DoxyCodeLine{17825 \textcolor{preprocessor}{\#define CATCH\_SECTION( ... )}}
\DoxyCodeLine{17826 \textcolor{preprocessor}{\#define CATCH\_DYNAMIC\_SECTION( ... )}}
\DoxyCodeLine{17827 \textcolor{preprocessor}{\#define CATCH\_FAIL( ... ) (void)(0)}}
\DoxyCodeLine{17828 \textcolor{preprocessor}{\#define CATCH\_FAIL\_CHECK( ... ) (void)(0)}}
\DoxyCodeLine{17829 \textcolor{preprocessor}{\#define CATCH\_SUCCEED( ... ) (void)(0)}}
\DoxyCodeLine{17830 }
\DoxyCodeLine{17831 \textcolor{preprocessor}{\#define CATCH\_ANON\_TEST\_CASE() INTERNAL\_CATCH\_TESTCASE\_NO\_REGISTRATION(INTERNAL\_CATCH\_UNIQUE\_NAME( C\_A\_T\_C\_H\_T\_E\_S\_T\_ ))}}
\DoxyCodeLine{17832 }
\DoxyCodeLine{17833 \textcolor{preprocessor}{\#ifndef CATCH\_CONFIG\_TRADITIONAL\_MSVC\_PREPROCESSOR}}
\DoxyCodeLine{17834 \textcolor{preprocessor}{\#define CATCH\_TEMPLATE\_TEST\_CASE( ... ) INTERNAL\_CATCH\_TEMPLATE\_TEST\_CASE\_NO\_REGISTRATION(\_\_VA\_ARGS\_\_)}}
\DoxyCodeLine{17835 \textcolor{preprocessor}{\#define CATCH\_TEMPLATE\_TEST\_CASE\_SIG( ... ) INTERNAL\_CATCH\_TEMPLATE\_TEST\_CASE\_SIG\_NO\_REGISTRATION(\_\_VA\_ARGS\_\_)}}
\DoxyCodeLine{17836 \textcolor{preprocessor}{\#define CATCH\_TEMPLATE\_TEST\_CASE\_METHOD( className, ... ) INTERNAL\_CATCH\_TEMPLATE\_TEST\_CASE\_METHOD\_NO\_REGISTRATION(className, \_\_VA\_ARGS\_\_)}}
\DoxyCodeLine{17837 \textcolor{preprocessor}{\#define CATCH\_TEMPLATE\_TEST\_CASE\_METHOD\_SIG( className, ... ) INTERNAL\_CATCH\_TEMPLATE\_TEST\_CASE\_METHOD\_SIG\_NO\_REGISTRATION(className, \_\_VA\_ARGS\_\_ )}}
\DoxyCodeLine{17838 \textcolor{preprocessor}{\#define CATCH\_TEMPLATE\_PRODUCT\_TEST\_CASE( ... ) CATCH\_TEMPLATE\_TEST\_CASE( \_\_VA\_ARGS\_\_ )}}
\DoxyCodeLine{17839 \textcolor{preprocessor}{\#define CATCH\_TEMPLATE\_PRODUCT\_TEST\_CASE\_SIG( ... ) CATCH\_TEMPLATE\_TEST\_CASE( \_\_VA\_ARGS\_\_ )}}
\DoxyCodeLine{17840 \textcolor{preprocessor}{\#define CATCH\_TEMPLATE\_PRODUCT\_TEST\_CASE\_METHOD( className, ... ) CATCH\_TEMPLATE\_TEST\_CASE\_METHOD( className, \_\_VA\_ARGS\_\_ )}}
\DoxyCodeLine{17841 \textcolor{preprocessor}{\#define CATCH\_TEMPLATE\_PRODUCT\_TEST\_CASE\_METHOD\_SIG( className, ... ) CATCH\_TEMPLATE\_TEST\_CASE\_METHOD( className, \_\_VA\_ARGS\_\_ )}}
\DoxyCodeLine{17842 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{17843 \textcolor{preprocessor}{\#define CATCH\_TEMPLATE\_TEST\_CASE( ... ) INTERNAL\_CATCH\_EXPAND\_VARGS( INTERNAL\_CATCH\_TEMPLATE\_TEST\_CASE\_NO\_REGISTRATION(\_\_VA\_ARGS\_\_) )}}
\DoxyCodeLine{17844 \textcolor{preprocessor}{\#define CATCH\_TEMPLATE\_TEST\_CASE\_SIG( ... ) INTERNAL\_CATCH\_EXPAND\_VARGS( INTERNAL\_CATCH\_TEMPLATE\_TEST\_CASE\_SIG\_NO\_REGISTRATION(\_\_VA\_ARGS\_\_) )}}
\DoxyCodeLine{17845 \textcolor{preprocessor}{\#define CATCH\_TEMPLATE\_TEST\_CASE\_METHOD( className, ... ) INTERNAL\_CATCH\_EXPAND\_VARGS( INTERNAL\_CATCH\_TEMPLATE\_TEST\_CASE\_METHOD\_NO\_REGISTRATION(className, \_\_VA\_ARGS\_\_ ) )}}
\DoxyCodeLine{17846 \textcolor{preprocessor}{\#define CATCH\_TEMPLATE\_TEST\_CASE\_METHOD\_SIG( className, ... ) INTERNAL\_CATCH\_EXPAND\_VARGS( INTERNAL\_CATCH\_TEMPLATE\_TEST\_CASE\_METHOD\_SIG\_NO\_REGISTRATION(className, \_\_VA\_ARGS\_\_ ) )}}
\DoxyCodeLine{17847 \textcolor{preprocessor}{\#define CATCH\_TEMPLATE\_PRODUCT\_TEST\_CASE( ... ) CATCH\_TEMPLATE\_TEST\_CASE( \_\_VA\_ARGS\_\_ )}}
\DoxyCodeLine{17848 \textcolor{preprocessor}{\#define CATCH\_TEMPLATE\_PRODUCT\_TEST\_CASE\_SIG( ... ) CATCH\_TEMPLATE\_TEST\_CASE( \_\_VA\_ARGS\_\_ )}}
\DoxyCodeLine{17849 \textcolor{preprocessor}{\#define CATCH\_TEMPLATE\_PRODUCT\_TEST\_CASE\_METHOD( className, ... ) CATCH\_TEMPLATE\_TEST\_CASE\_METHOD( className, \_\_VA\_ARGS\_\_ )}}
\DoxyCodeLine{17850 \textcolor{preprocessor}{\#define CATCH\_TEMPLATE\_PRODUCT\_TEST\_CASE\_METHOD\_SIG( className, ... ) CATCH\_TEMPLATE\_TEST\_CASE\_METHOD( className, \_\_VA\_ARGS\_\_ )}}
\DoxyCodeLine{17851 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{17852 }
\DoxyCodeLine{17853 \textcolor{comment}{// "{}BDD-\/style"{} convenience wrappers}}
\DoxyCodeLine{17854 \textcolor{preprocessor}{\#define CATCH\_SCENARIO( ... ) INTERNAL\_CATCH\_TESTCASE\_NO\_REGISTRATION(INTERNAL\_CATCH\_UNIQUE\_NAME( C\_A\_T\_C\_H\_T\_E\_S\_T\_ ))}}
\DoxyCodeLine{17855 \textcolor{preprocessor}{\#define CATCH\_SCENARIO\_METHOD( className, ... ) INTERNAL\_CATCH\_TESTCASE\_METHOD\_NO\_REGISTRATION(INTERNAL\_CATCH\_UNIQUE\_NAME( C\_A\_T\_C\_H\_T\_E\_S\_T\_ ), className )}}
\DoxyCodeLine{17856 \textcolor{preprocessor}{\#define CATCH\_GIVEN( desc )}}
\DoxyCodeLine{17857 \textcolor{preprocessor}{\#define CATCH\_AND\_GIVEN( desc )}}
\DoxyCodeLine{17858 \textcolor{preprocessor}{\#define CATCH\_WHEN( desc )}}
\DoxyCodeLine{17859 \textcolor{preprocessor}{\#define CATCH\_AND\_WHEN( desc )}}
\DoxyCodeLine{17860 \textcolor{preprocessor}{\#define CATCH\_THEN( desc )}}
\DoxyCodeLine{17861 \textcolor{preprocessor}{\#define CATCH\_AND\_THEN( desc )}}
\DoxyCodeLine{17862 }
\DoxyCodeLine{17863 \textcolor{preprocessor}{\#define CATCH\_STATIC\_REQUIRE( ... )       (void)(0)}}
\DoxyCodeLine{17864 \textcolor{preprocessor}{\#define CATCH\_STATIC\_REQUIRE\_FALSE( ... ) (void)(0)}}
\DoxyCodeLine{17865 }
\DoxyCodeLine{17866 \textcolor{comment}{// If CATCH\_CONFIG\_PREFIX\_ALL is not defined then the CATCH\_ prefix is not required}}
\DoxyCodeLine{17867 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{17868 }
\DoxyCodeLine{17869 \textcolor{preprocessor}{\#define REQUIRE( ... )       (void)(0)}}
\DoxyCodeLine{17870 \textcolor{preprocessor}{\#define REQUIRE\_FALSE( ... ) (void)(0)}}
\DoxyCodeLine{17871 }
\DoxyCodeLine{17872 \textcolor{preprocessor}{\#define REQUIRE\_THROWS( ... ) (void)(0)}}
\DoxyCodeLine{17873 \textcolor{preprocessor}{\#define REQUIRE\_THROWS\_AS( expr, exceptionType ) (void)(0)}}
\DoxyCodeLine{17874 \textcolor{preprocessor}{\#define REQUIRE\_THROWS\_WITH( expr, matcher ) (void)(0)}}
\DoxyCodeLine{17875 \textcolor{preprocessor}{\#if !defined(CATCH\_CONFIG\_DISABLE\_MATCHERS)}}
\DoxyCodeLine{17876 \textcolor{preprocessor}{\#define REQUIRE\_THROWS\_MATCHES( expr, exceptionType, matcher ) (void)(0)}}
\DoxyCodeLine{17877 \textcolor{preprocessor}{\#endif }\textcolor{comment}{// CATCH\_CONFIG\_DISABLE\_MATCHERS}}
\DoxyCodeLine{17878 \textcolor{preprocessor}{\#define REQUIRE\_NOTHROW( ... ) (void)(0)}}
\DoxyCodeLine{17879 }
\DoxyCodeLine{17880 \textcolor{preprocessor}{\#define CHECK( ... ) (void)(0)}}
\DoxyCodeLine{17881 \textcolor{preprocessor}{\#define CHECK\_FALSE( ... ) (void)(0)}}
\DoxyCodeLine{17882 \textcolor{preprocessor}{\#define CHECKED\_IF( ... ) if (\_\_VA\_ARGS\_\_)}}
\DoxyCodeLine{17883 \textcolor{preprocessor}{\#define CHECKED\_ELSE( ... ) if (!(\_\_VA\_ARGS\_\_))}}
\DoxyCodeLine{17884 \textcolor{preprocessor}{\#define CHECK\_NOFAIL( ... ) (void)(0)}}
\DoxyCodeLine{17885 }
\DoxyCodeLine{17886 \textcolor{preprocessor}{\#define CHECK\_THROWS( ... )  (void)(0)}}
\DoxyCodeLine{17887 \textcolor{preprocessor}{\#define CHECK\_THROWS\_AS( expr, exceptionType ) (void)(0)}}
\DoxyCodeLine{17888 \textcolor{preprocessor}{\#define CHECK\_THROWS\_WITH( expr, matcher ) (void)(0)}}
\DoxyCodeLine{17889 \textcolor{preprocessor}{\#if !defined(CATCH\_CONFIG\_DISABLE\_MATCHERS)}}
\DoxyCodeLine{17890 \textcolor{preprocessor}{\#define CHECK\_THROWS\_MATCHES( expr, exceptionType, matcher ) (void)(0)}}
\DoxyCodeLine{17891 \textcolor{preprocessor}{\#endif }\textcolor{comment}{// CATCH\_CONFIG\_DISABLE\_MATCHERS}}
\DoxyCodeLine{17892 \textcolor{preprocessor}{\#define CHECK\_NOTHROW( ... ) (void)(0)}}
\DoxyCodeLine{17893 }
\DoxyCodeLine{17894 \textcolor{preprocessor}{\#if !defined(CATCH\_CONFIG\_DISABLE\_MATCHERS)}}
\DoxyCodeLine{17895 \textcolor{preprocessor}{\#define CHECK\_THAT( arg, matcher ) (void)(0)}}
\DoxyCodeLine{17896 }
\DoxyCodeLine{17897 \textcolor{preprocessor}{\#define REQUIRE\_THAT( arg, matcher ) (void)(0)}}
\DoxyCodeLine{17898 \textcolor{preprocessor}{\#endif }\textcolor{comment}{// CATCH\_CONFIG\_DISABLE\_MATCHERS}}
\DoxyCodeLine{17899 }
\DoxyCodeLine{17900 \textcolor{preprocessor}{\#define INFO( msg ) (void)(0)}}
\DoxyCodeLine{17901 \textcolor{preprocessor}{\#define UNSCOPED\_INFO( msg ) (void)(0)}}
\DoxyCodeLine{17902 \textcolor{preprocessor}{\#define WARN( msg ) (void)(0)}}
\DoxyCodeLine{17903 \textcolor{preprocessor}{\#define CAPTURE( ... ) (void)(0)}}
\DoxyCodeLine{17904 }
\DoxyCodeLine{17905 \textcolor{preprocessor}{\#define TEST\_CASE( ... )  INTERNAL\_CATCH\_TESTCASE\_NO\_REGISTRATION(INTERNAL\_CATCH\_UNIQUE\_NAME( C\_A\_T\_C\_H\_T\_E\_S\_T\_ ))}}
\DoxyCodeLine{17906 \textcolor{preprocessor}{\#define TEST\_CASE\_METHOD( className, ... ) INTERNAL\_CATCH\_TESTCASE\_NO\_REGISTRATION(INTERNAL\_CATCH\_UNIQUE\_NAME( C\_A\_T\_C\_H\_T\_E\_S\_T\_ ))}}
\DoxyCodeLine{17907 \textcolor{preprocessor}{\#define METHOD\_AS\_TEST\_CASE( method, ... )}}
\DoxyCodeLine{17908 \textcolor{preprocessor}{\#define REGISTER\_TEST\_CASE( Function, ... ) (void)(0)}}
\DoxyCodeLine{17909 \textcolor{preprocessor}{\#define SECTION( ... )}}
\DoxyCodeLine{17910 \textcolor{preprocessor}{\#define DYNAMIC\_SECTION( ... )}}
\DoxyCodeLine{17911 \textcolor{preprocessor}{\#define FAIL( ... ) (void)(0)}}
\DoxyCodeLine{17912 \textcolor{preprocessor}{\#define FAIL\_CHECK( ... ) (void)(0)}}
\DoxyCodeLine{17913 \textcolor{preprocessor}{\#define SUCCEED( ... ) (void)(0)}}
\DoxyCodeLine{17914 \textcolor{preprocessor}{\#define ANON\_TEST\_CASE() INTERNAL\_CATCH\_TESTCASE\_NO\_REGISTRATION(INTERNAL\_CATCH\_UNIQUE\_NAME( C\_A\_T\_C\_H\_T\_E\_S\_T\_ ))}}
\DoxyCodeLine{17915 }
\DoxyCodeLine{17916 \textcolor{preprocessor}{\#ifndef CATCH\_CONFIG\_TRADITIONAL\_MSVC\_PREPROCESSOR}}
\DoxyCodeLine{17917 \textcolor{preprocessor}{\#define TEMPLATE\_TEST\_CASE( ... ) INTERNAL\_CATCH\_TEMPLATE\_TEST\_CASE\_NO\_REGISTRATION(\_\_VA\_ARGS\_\_)}}
\DoxyCodeLine{17918 \textcolor{preprocessor}{\#define TEMPLATE\_TEST\_CASE\_SIG( ... ) INTERNAL\_CATCH\_TEMPLATE\_TEST\_CASE\_SIG\_NO\_REGISTRATION(\_\_VA\_ARGS\_\_)}}
\DoxyCodeLine{17919 \textcolor{preprocessor}{\#define TEMPLATE\_TEST\_CASE\_METHOD( className, ... ) INTERNAL\_CATCH\_TEMPLATE\_TEST\_CASE\_METHOD\_NO\_REGISTRATION(className, \_\_VA\_ARGS\_\_)}}
\DoxyCodeLine{17920 \textcolor{preprocessor}{\#define TEMPLATE\_TEST\_CASE\_METHOD\_SIG( className, ... ) INTERNAL\_CATCH\_TEMPLATE\_TEST\_CASE\_METHOD\_SIG\_NO\_REGISTRATION(className, \_\_VA\_ARGS\_\_ )}}
\DoxyCodeLine{17921 \textcolor{preprocessor}{\#define TEMPLATE\_PRODUCT\_TEST\_CASE( ... ) TEMPLATE\_TEST\_CASE( \_\_VA\_ARGS\_\_ )}}
\DoxyCodeLine{17922 \textcolor{preprocessor}{\#define TEMPLATE\_PRODUCT\_TEST\_CASE\_SIG( ... ) TEMPLATE\_TEST\_CASE( \_\_VA\_ARGS\_\_ )}}
\DoxyCodeLine{17923 \textcolor{preprocessor}{\#define TEMPLATE\_PRODUCT\_TEST\_CASE\_METHOD( className, ... ) TEMPLATE\_TEST\_CASE\_METHOD( className, \_\_VA\_ARGS\_\_ )}}
\DoxyCodeLine{17924 \textcolor{preprocessor}{\#define TEMPLATE\_PRODUCT\_TEST\_CASE\_METHOD\_SIG( className, ... ) TEMPLATE\_TEST\_CASE\_METHOD( className, \_\_VA\_ARGS\_\_ )}}
\DoxyCodeLine{17925 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{17926 \textcolor{preprocessor}{\#define TEMPLATE\_TEST\_CASE( ... ) INTERNAL\_CATCH\_EXPAND\_VARGS( INTERNAL\_CATCH\_TEMPLATE\_TEST\_CASE\_NO\_REGISTRATION(\_\_VA\_ARGS\_\_) )}}
\DoxyCodeLine{17927 \textcolor{preprocessor}{\#define TEMPLATE\_TEST\_CASE\_SIG( ... ) INTERNAL\_CATCH\_EXPAND\_VARGS( INTERNAL\_CATCH\_TEMPLATE\_TEST\_CASE\_SIG\_NO\_REGISTRATION(\_\_VA\_ARGS\_\_) )}}
\DoxyCodeLine{17928 \textcolor{preprocessor}{\#define TEMPLATE\_TEST\_CASE\_METHOD( className, ... ) INTERNAL\_CATCH\_EXPAND\_VARGS( INTERNAL\_CATCH\_TEMPLATE\_TEST\_CASE\_METHOD\_NO\_REGISTRATION(className, \_\_VA\_ARGS\_\_ ) )}}
\DoxyCodeLine{17929 \textcolor{preprocessor}{\#define TEMPLATE\_TEST\_CASE\_METHOD\_SIG( className, ... ) INTERNAL\_CATCH\_EXPAND\_VARGS( INTERNAL\_CATCH\_TEMPLATE\_TEST\_CASE\_METHOD\_SIG\_NO\_REGISTRATION(className, \_\_VA\_ARGS\_\_ ) )}}
\DoxyCodeLine{17930 \textcolor{preprocessor}{\#define TEMPLATE\_PRODUCT\_TEST\_CASE( ... ) TEMPLATE\_TEST\_CASE( \_\_VA\_ARGS\_\_ )}}
\DoxyCodeLine{17931 \textcolor{preprocessor}{\#define TEMPLATE\_PRODUCT\_TEST\_CASE\_SIG( ... ) TEMPLATE\_TEST\_CASE( \_\_VA\_ARGS\_\_ )}}
\DoxyCodeLine{17932 \textcolor{preprocessor}{\#define TEMPLATE\_PRODUCT\_TEST\_CASE\_METHOD( className, ... ) TEMPLATE\_TEST\_CASE\_METHOD( className, \_\_VA\_ARGS\_\_ )}}
\DoxyCodeLine{17933 \textcolor{preprocessor}{\#define TEMPLATE\_PRODUCT\_TEST\_CASE\_METHOD\_SIG( className, ... ) TEMPLATE\_TEST\_CASE\_METHOD( className, \_\_VA\_ARGS\_\_ )}}
\DoxyCodeLine{17934 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{17935 }
\DoxyCodeLine{17936 \textcolor{preprocessor}{\#define STATIC\_REQUIRE( ... )       (void)(0)}}
\DoxyCodeLine{17937 \textcolor{preprocessor}{\#define STATIC\_REQUIRE\_FALSE( ... ) (void)(0)}}
\DoxyCodeLine{17938 }
\DoxyCodeLine{17939 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{17940 }
\DoxyCodeLine{17941 \textcolor{preprocessor}{\#define CATCH\_TRANSLATE\_EXCEPTION( signature ) INTERNAL\_CATCH\_TRANSLATE\_EXCEPTION\_NO\_REG( INTERNAL\_CATCH\_UNIQUE\_NAME( catch\_internal\_ExceptionTranslator ), signature )}}
\DoxyCodeLine{17942 }
\DoxyCodeLine{17943 \textcolor{comment}{// "{}BDD-\/style"{} convenience wrappers}}
\DoxyCodeLine{17944 \textcolor{preprocessor}{\#define SCENARIO( ... ) INTERNAL\_CATCH\_TESTCASE\_NO\_REGISTRATION(INTERNAL\_CATCH\_UNIQUE\_NAME( C\_A\_T\_C\_H\_T\_E\_S\_T\_ ) )}}
\DoxyCodeLine{17945 \textcolor{preprocessor}{\#define SCENARIO\_METHOD( className, ... ) INTERNAL\_CATCH\_TESTCASE\_METHOD\_NO\_REGISTRATION(INTERNAL\_CATCH\_UNIQUE\_NAME( C\_A\_T\_C\_H\_T\_E\_S\_T\_ ), className )}}
\DoxyCodeLine{17946 }
\DoxyCodeLine{17947 \textcolor{preprocessor}{\#define GIVEN( desc )}}
\DoxyCodeLine{17948 \textcolor{preprocessor}{\#define AND\_GIVEN( desc )}}
\DoxyCodeLine{17949 \textcolor{preprocessor}{\#define WHEN( desc )}}
\DoxyCodeLine{17950 \textcolor{preprocessor}{\#define AND\_WHEN( desc )}}
\DoxyCodeLine{17951 \textcolor{preprocessor}{\#define THEN( desc )}}
\DoxyCodeLine{17952 \textcolor{preprocessor}{\#define AND\_THEN( desc )}}
\DoxyCodeLine{17953 }
\DoxyCodeLine{17954 \textcolor{keyword}{using }\mbox{\hyperlink{classCatch_1_1Detail_1_1Approx}{Catch::Detail::Approx}};}
\DoxyCodeLine{17955 }
\DoxyCodeLine{17956 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{17957 }
\DoxyCodeLine{17958 \textcolor{preprocessor}{\#endif }\textcolor{comment}{// ! CATCH\_CONFIG\_IMPL\_ONLY}}
\DoxyCodeLine{17959 }
\DoxyCodeLine{17960 \textcolor{comment}{// start catch\_reenable\_warnings.h}}
\DoxyCodeLine{17961 }
\DoxyCodeLine{17962 }
\DoxyCodeLine{17963 \textcolor{preprocessor}{\#ifdef \_\_clang\_\_}}
\DoxyCodeLine{17964 \textcolor{preprocessor}{\#    ifdef \_\_ICC }\textcolor{comment}{// icpc defines the \_\_clang\_\_ macro}}
\DoxyCodeLine{17965 \textcolor{preprocessor}{\#        pragma warning(pop)}}
\DoxyCodeLine{17966 \textcolor{preprocessor}{\#    else}}
\DoxyCodeLine{17967 \textcolor{preprocessor}{\#        pragma clang diagnostic pop}}
\DoxyCodeLine{17968 \textcolor{preprocessor}{\#    endif}}
\DoxyCodeLine{17969 \textcolor{preprocessor}{\#elif defined \_\_GNUC\_\_}}
\DoxyCodeLine{17970 \textcolor{preprocessor}{\#    pragma GCC diagnostic pop}}
\DoxyCodeLine{17971 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{17972 }
\DoxyCodeLine{17973 \textcolor{comment}{// end catch\_reenable\_warnings.h}}
\DoxyCodeLine{17974 \textcolor{comment}{// end catch.hpp}}
\DoxyCodeLine{17975 \textcolor{preprocessor}{\#endif }\textcolor{comment}{// TWOBLUECUBES\_SINGLE\_INCLUDE\_CATCH\_HPP\_INCLUDED}}
\DoxyCodeLine{17976 }

\end{DoxyCode}
